var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var feng3d;
(function (feng3d) {
    /**
     * 观察装饰器，观察被装饰属性的变化
     *
     * @param onChange 属性变化回调  例如参数为“onChange”时，回调将会调用this.onChange(property, oldValue, newValue)
     *
     * 使用@watch后会自动生成一个带"_"的属性，例如 属性"a"会生成"_a"
     *
     * 通过使用 eval 函数 生成出 与自己手动写的set get 一样的函数，性能已经接近 手动写的get set函数。
     *
     */
    function watch(onChange) {
        return function (target, property) {
            var key = "_" + property;
            var get = eval("(function (){return this." + key + "})");
            var set = eval("(function (value){\n                if (this." + key + " == value)\n                    return;\n                var oldValue = this." + key + ";\n                this." + key + " = value;\n                this." + onChange + "(\"" + property + "\", oldValue, value);\n            })");
            Object.defineProperty(target, property, {
                get: get,
                set: set,
                enumerable: true,
                configurable: true
            });
        };
    }
    feng3d.watch = watch;
    var Watcher = /** @class */ (function () {
        function Watcher() {
        }
        /**
         * 监听对象属性的变化
         *
         * 注意：使用watch后获取该属性值的性能将会是原来的1/60，避免在运算密集处使用该函数。
         *
         * @param object 被监听对象
         * @param property 被监听属性
         * @param handler 变化回调函数 (object: T, property: string, oldvalue: V) => void
         * @param thisObject 变化回调函数 this值
         */
        Watcher.prototype.watch = function (object, property, handler, thisObject) {
            if (!Object.getOwnPropertyDescriptor(object, feng3d.__watchs__)) {
                Object.defineProperty(object, feng3d.__watchs__, {
                    value: {},
                    enumerable: false,
                    configurable: true,
                    writable: false,
                });
            }
            var watchs = object[feng3d.__watchs__];
            if (!watchs[property]) {
                var oldPropertyDescriptor = Object.getOwnPropertyDescriptor(object, property);
                watchs[property] = { value: object[property], oldPropertyDescriptor: oldPropertyDescriptor, handlers: [] };
                //
                var data = Object.getPropertyDescriptor(object, property);
                if (data && data.set && data.get) {
                    data = { enumerable: data.enumerable, configurable: true, get: data.get, set: data.set };
                    var orgSet = data.set;
                    data.set = function (value) {
                        var oldvalue = this[property];
                        if (oldvalue != value) {
                            orgSet && orgSet.call(this, value);
                            notifyListener(this, property, oldvalue);
                        }
                    };
                }
                else if (!data || (!data.get && !data.set)) {
                    data = { enumerable: true, configurable: true };
                    data.get = function () {
                        return this[feng3d.__watchs__][property].value;
                    };
                    data.set = function (value) {
                        var oldvalue = this[feng3d.__watchs__][property].value;
                        if (oldvalue != value) {
                            this[feng3d.__watchs__][property].value = value;
                            notifyListener(this, property, oldvalue);
                        }
                    };
                }
                else {
                    console.warn("watch " + object + " . " + property + " \u5931\u8D25\uFF01");
                    return;
                }
                Object.defineProperty(object, property, data);
            }
            var propertywatchs = watchs[property];
            var has = propertywatchs.handlers.reduce(function (v, item) { return v || (item.handler == handler && item.thisObject == thisObject); }, false);
            if (!has)
                propertywatchs.handlers.push({ handler: handler, thisObject: thisObject });
        };
        /**
         * 取消监听对象属性的变化
         *
         * @param object 被监听对象
         * @param property 被监听属性
         * @param handler 变化回调函数 (object: T, property: string, oldvalue: V) => void
         * @param thisObject 变化回调函数 this值
         */
        Watcher.prototype.unwatch = function (object, property, handler, thisObject) {
            var watchs = object[feng3d.__watchs__];
            if (!watchs)
                return;
            if (watchs[property]) {
                var handlers = watchs[property].handlers;
                if (handler === undefined)
                    handlers.length = 0;
                for (var i = handlers.length - 1; i >= 0; i--) {
                    if (handlers[i].handler == handler && (handlers[i].thisObject == thisObject || thisObject === undefined))
                        handlers.splice(i, 1);
                }
                if (handlers.length == 0) {
                    var value = object[property];
                    delete object[property];
                    if (watchs[property].oldPropertyDescriptor)
                        Object.defineProperty(object, property, watchs[property].oldPropertyDescriptor);
                    object[property] = value;
                    delete watchs[property];
                }
                if (Object.keys(watchs).length == 0) {
                    delete object[feng3d.__watchs__];
                }
            }
        };
        /**
         * 监听对象属性链值变化
         *
         * @param object 被监听对象
         * @param property 被监听属性 例如："a.b"
         * @param handler 变化回调函数 (object: T, property: string, oldvalue: V) => void
         * @param thisObject 变化回调函数 this值
         */
        Watcher.prototype.watchchain = function (object, property, handler, thisObject) {
            var _this = this;
            var notIndex = property.indexOf(".");
            if (notIndex == -1) {
                this.watch(object, property, handler, thisObject);
                return;
            }
            if (!Object.getOwnPropertyDescriptor(object, feng3d.__watchchains__))
                Object.defineProperty(object, feng3d.__watchchains__, { value: {}, enumerable: false, writable: false, configurable: true });
            var watchchains = object[feng3d.__watchchains__];
            if (!watchchains[property]) {
                watchchains[property] = [];
            }
            var propertywatchs = watchchains[property];
            var has = propertywatchs.reduce(function (v, item) { return v || (item.handler == handler && item.thisObject == thisObject); }, false);
            if (!has) {
                // 添加下级监听链
                var currentp = property.substr(0, notIndex);
                var nextp = property.substr(notIndex + 1);
                if (object[currentp]) {
                    this.watchchain(object[currentp], nextp, handler, thisObject);
                }
                // 添加链监听
                var watchchainFun = function (h, p, oldvalue) {
                    var newvalue = h[p];
                    if (oldvalue)
                        _this.unwatchchain(oldvalue, nextp, handler, thisObject);
                    if (newvalue)
                        _this.watchchain(newvalue, nextp, handler, thisObject);
                    // 当更换对象且监听值发生改变时触发处理函数
                    var ov = Object.getPropertyValue(oldvalue, nextp);
                    var nv = Object.getPropertyValue(newvalue, nextp);
                    if (ov != nv) {
                        handler.call(thisObject, newvalue, nextp, ov);
                    }
                };
                this.watch(object, currentp, watchchainFun);
                // 记录链监听函数
                propertywatchs.push({ handler: handler, thisObject: thisObject, watchchainFun: watchchainFun });
            }
        };
        /**
         * 取消监听对象属性链值变化
         *
         * @param object 被监听对象
         * @param property 被监听属性 例如："a.b"
         * @param handler 变化回调函数 (object: T, property: string, oldvalue: V) => void
         * @param thisObject 变化回调函数 this值
         */
        Watcher.prototype.unwatchchain = function (object, property, handler, thisObject) {
            var notIndex = property.indexOf(".");
            if (notIndex == -1) {
                this.unwatch(object, property, handler, thisObject);
                return;
            }
            var currentp = property.substr(0, notIndex);
            var nextp = property.substr(notIndex + 1);
            //
            var watchchains = object[feng3d.__watchchains__];
            if (!watchchains || !watchchains[property])
                return;
            // 
            var propertywatchs = watchchains[property];
            for (var i = propertywatchs.length - 1; i >= 0; i--) {
                var element = propertywatchs[i];
                if (handler == null || (handler == element.handler && thisObject == element.thisObject)) {
                    // 删除下级监听链
                    if (object[currentp]) {
                        this.unwatchchain(object[currentp], nextp, element.handler, element.thisObject);
                    }
                    // 删除链监听
                    this.unwatch(object, currentp, element.watchchainFun);
                    // 清理记录链监听函数
                    propertywatchs.splice(i, 1);
                }
            }
            // 清理空列表
            if (propertywatchs.length == 0)
                delete watchchains[property];
            if (Object.keys(watchchains).length == 0) {
                delete object[feng3d.__watchchains__];
            }
        };
        /**
         * 监听对象属性链值变化
         *
         * @param object 被监听对象
         * @param property 被监听属性 例如：{a:{b:null,d:null}} 表示监听 object.a.b 与 object.a.d 值得变化，如果property == object时表示监听对象中所有叶子属性变化。
         * @param handler 变化回调函数 (object: T, property: string, oldvalue: V) => void
         * @param thisObject 变化回调函数 this值
         */
        Watcher.prototype.watchobject = function (object, property, handler, thisObject) {
            var _this = this;
            var chains = Object.getPropertyChains(object);
            chains.forEach(function (v) {
                _this.watchchain(object, v, handler, thisObject);
            });
        };
        /**
         * 取消监听对象属性链值变化
         *
         * @param object 被监听对象
         * @param property 被监听属性 例如：{a:{b:null,d:null}} 表示监听 object.a.b 与 object.a.d 值得变化，如果property == object时表示监听对象中所有叶子属性变化。
         * @param handler 变化回调函数 (object: T, property: string, oldvalue: V) => void
         * @param thisObject 变化回调函数 this值
         */
        Watcher.prototype.unwatchobject = function (object, property, handler, thisObject) {
            var _this = this;
            var chains = Object.getPropertyChains(property);
            chains.forEach(function (v) {
                _this.unwatchchain(object, v, handler, thisObject);
            });
        };
        return Watcher;
    }());
    feng3d.Watcher = Watcher;
    feng3d.watcher = new Watcher();
    feng3d.__watchs__ = "__watchs__";
    feng3d.__watchchains__ = "__watchchains__";
    function notifyListener(host, property, oldview) {
        var watchs = host[feng3d.__watchs__];
        var handlers = watchs[property].handlers;
        handlers.forEach(function (element) {
            element.handler.call(element.thisObject, host, property, oldview);
        });
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    feng3d.shaderConfig = {
        "shaders": {
            "color": {
                "fragment": "precision mediump float;\r\n\r\nuniform vec4 u_diffuseInput;\r\n\r\nvoid main() \r\n{\r\n    gl_FragColor = u_diffuseInput;\r\n}\r\n",
                "vertex": "attribute vec3 a_position;\r\n\r\nuniform mat4 u_modelMatrix;\r\nuniform mat4 u_viewProjection;\r\n\r\nvoid main()\r\n{\r\n    vec4 worldPosition = u_modelMatrix * vec4(a_position, 1.0);\r\n    gl_Position = u_viewProjection * worldPosition;\r\n}"
            },
            "mouse": {
                "fragment": "precision highp float;\r\n\r\nuniform int u_objectID;\r\n\r\nvoid main()\r\n{\r\n    //支持 255*255*255*255 个索引\r\n    const float invColor = 1.0/255.0;\r\n    float temp = float(u_objectID);\r\n    temp = floor(temp) * invColor;\r\n    gl_FragColor.x = fract(temp);\r\n    temp = floor(temp) * invColor;\r\n    gl_FragColor.y = fract(temp);\r\n    temp = floor(temp) * invColor;\r\n    gl_FragColor.z = fract(temp);\r\n    temp = floor(temp) * invColor;\r\n    gl_FragColor.w = fract(temp);\r\n}",
                "vertex": "attribute vec3 a_position;\r\n\r\nuniform mat4 u_modelMatrix;\r\nuniform mat4 u_viewProjection;\r\n\r\nvoid main()\r\n{\r\n    vec4 worldPosition = u_modelMatrix * vec4(a_position, 1.0);\r\n    gl_Position = u_viewProjection * worldPosition;\r\n}"
            },
            "outline": {
                "fragment": "precision mediump float;\r\n\r\nuniform vec4 u_outlineColor;\r\n\r\nvoid main() \r\n{\r\n    gl_FragColor = u_outlineColor;\r\n}",
                "vertex": "precision mediump float;  \r\n\r\n//坐标属性\r\nattribute vec3 a_position;\r\nattribute vec3 a_normal;\r\n\r\nuniform mat4 u_modelMatrix;\r\nuniform mat4 u_ITModelMatrix;\r\nuniform vec3 u_cameraPos;\r\nuniform mat4 u_viewProjection;\r\nuniform float u_scaleByDepth;\r\nuniform float u_outlineMorphFactor;\r\n\r\n#include<skeleton_pars_vert>\r\n#include<particle_pars_vert>\r\n\r\nuniform float u_outlineSize;\r\n\r\nvoid main() \r\n{\r\n    vec4 position = vec4(a_position, 1.0);\r\n\r\n    #include<skeleton_vert>\r\n    #include<particle_vert>\r\n    \r\n    vec3 normal = a_normal;\r\n\r\n    //全局坐标\r\n    vec4 worldPosition = u_modelMatrix * position;\r\n    //全局法线\r\n    vec3 globalNormal = normalize((u_ITModelMatrix * vec4(normal, 0.0)).xyz);\r\n\r\n    float depth = distance(worldPosition.xyz , u_cameraPos.xyz);\r\n    \r\n    vec3 offsetDir = mix(globalNormal, normalize(worldPosition.xyz), u_outlineMorphFactor);\r\n    //摄像机远近保持粗细一致\r\n    offsetDir = offsetDir * depth * u_scaleByDepth;\r\n    //描边宽度\r\n    offsetDir = offsetDir * u_outlineSize;\r\n\r\n    worldPosition.xyz = worldPosition.xyz + offsetDir;//\r\n\r\n    //计算投影坐标\r\n    gl_Position = u_viewProjection * worldPosition;\r\n}"
            },
            "particle": {
                "fragment": "precision mediump float;\r\n\r\nvarying vec2 v_uv;\r\n\r\nuniform float u_alphaThreshold;\r\n//漫反射\r\nuniform vec4 u_diffuse;\r\nuniform sampler2D s_diffuse;\r\n\r\n#include<particle_pars_frag>\r\n\r\nvoid main()\r\n{\r\n    vec4 finalColor = vec4(1.0, 1.0, 1.0, 1.0);\r\n\r\n    //获取漫反射基本颜色\r\n    vec4 diffuseColor = u_diffuse * texture2D(s_diffuse, v_uv);\r\n\r\n    if(diffuseColor.w < u_alphaThreshold)\r\n    {\r\n        discard;\r\n    }\r\n\r\n    finalColor = diffuseColor;\r\n\r\n    #include<particle_frag>\r\n\r\n    gl_FragColor = finalColor;\r\n}",
                "vertex": "precision mediump float;  \r\n\r\n//坐标属性\r\nattribute vec3 a_position;\r\nattribute vec2 a_uv;\r\nattribute vec3 a_normal;\r\n\r\nuniform mat4 u_modelMatrix;\r\nuniform mat4 u_ITModelMatrix;\r\nuniform mat4 u_viewProjection;\r\n\r\nvarying vec2 v_uv;\r\n\r\nuniform float u_PointSize;\r\n\r\n#include<particle_pars_vert>\r\n\r\nvoid main() \r\n{\r\n    vec4 position = vec4(a_position, 1.0);\r\n    \r\n    #include<particle_vert>\r\n\r\n    vec3 normal = a_normal;\r\n\r\n    //获取全局坐标\r\n    vec4 worldPosition = u_modelMatrix * position;\r\n    //计算投影坐标\r\n    gl_Position = u_viewProjection * worldPosition;\r\n    //输出uv\r\n    v_uv = a_uv;\r\n\r\n    gl_PointSize = u_PointSize;\r\n}"
            },
            "point": {
                "fragment": "precision mediump float;\r\n\r\nvarying vec4 v_color;\r\nuniform vec4 u_color;\r\n\r\nvoid main() \r\n{\r\n    gl_FragColor = v_color * u_color;\r\n}\r\n",
                "vertex": "attribute vec3 a_position;\r\nattribute vec4 a_color;\r\n\r\nuniform float u_PointSize;\r\n\r\nuniform mat4 u_modelMatrix;\r\nuniform mat4 u_viewProjection;\r\n\r\nvarying vec4 v_color;\r\n\r\nvoid main() \r\n{\r\n    vec4 worldPosition = u_modelMatrix * vec4(a_position, 1.0);\r\n    gl_Position = u_viewProjection * worldPosition;\r\n    gl_PointSize = u_PointSize;\r\n\r\n    v_color = a_color;\r\n}"
            },
            "segment": {
                "fragment": "precision mediump float;\r\n\r\nvarying vec4 v_color;\r\n\r\nuniform vec4 u_segmentColor;\r\n\r\nvoid main() \r\n{\r\n    gl_FragColor = v_color * u_segmentColor;\r\n}",
                "vertex": "attribute vec3 a_position;\r\nattribute vec4 a_color;\r\n\r\nuniform mat4 u_modelMatrix;\r\nuniform mat4 u_viewProjection;\r\n\r\nvarying vec4 v_color;\r\n\r\nvoid main() \r\n{\r\n    gl_Position = u_viewProjection * u_modelMatrix * vec4(a_position, 1.0);\r\n    v_color = a_color;\r\n}"
            },
            "shadow": {
                "fragment": "precision mediump float;\r\n\r\nvarying vec3 v_worldPosition;\r\n\r\nuniform int u_lightType;\r\nuniform vec3 u_lightPosition;\r\nuniform float u_shadowCameraNear;\r\nuniform float u_shadowCameraFar;\r\n\r\n// @see https://github.com/mrdoob/three.js/blob/dev/src/renderers/shaders/ShaderChunk/packing.glsl\r\nconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\nconst float ShiftRight8 = 1. / 256.;\r\nvec4 packDepthToRGBA( const in float v ) \r\n{\r\n\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\treturn r * PackUpscale;\r\n}\r\n\r\nvoid main() \r\n{\r\n    vec3 lightToPosition = (v_worldPosition - u_lightPosition);\r\n    float dp = ( length( lightToPosition ) - u_shadowCameraNear ) / ( u_shadowCameraFar - u_shadowCameraNear ); // need to clamp?\r\n    gl_FragColor = packDepthToRGBA( dp );\r\n}",
                "vertex": "precision mediump float;  \r\n\r\nattribute vec3 a_position;\r\n\r\nuniform mat4 u_modelMatrix;\r\nuniform mat4 u_viewProjection;\r\n\r\n#include<skeleton_pars_vert>\r\n#include<particle_pars_vert>\r\n\r\nvarying vec3 v_worldPosition;\r\n\r\nvoid main() \r\n{\r\n    vec4 position = vec4(a_position, 1.0);\r\n\r\n    #include<skeleton_vert>\r\n    #include<particle_vert>\r\n\r\n    vec4 worldPosition = u_modelMatrix * position;\r\n    gl_Position = u_viewProjection * worldPosition;\r\n    v_worldPosition = worldPosition.xyz;\r\n}"
            },
            "skybox": {
                "fragment": "precision highp float;\r\n\r\nuniform samplerCube s_skyboxTexture;\r\nuniform vec3 u_cameraPos;\r\n\r\nvarying vec3 v_worldPos;\r\n\r\nvoid main()\r\n{\r\n    vec3 cameraDir = normalize(u_cameraPos.xyz - v_worldPos);\r\n    gl_FragColor = textureCube(s_skyboxTexture, -cameraDir);\r\n}",
                "vertex": "attribute vec3 a_position;\r\n\r\nuniform vec3 u_cameraPos;\r\nuniform mat4 u_viewProjection;\r\n\r\nuniform float u_skyBoxSize;\r\n\r\nvarying vec3 v_worldPos;\r\n\r\nvoid main()\r\n{\r\n    vec3 worldPos = a_position.xyz * u_skyBoxSize + u_cameraPos.xyz;\r\n    gl_Position = u_viewProjection * vec4(worldPos.xyz, 1.0);\r\n    v_worldPos = worldPos;\r\n}"
            },
            "standard": {
                "fragment": "precision mediump float;\r\n\r\nvarying vec2 v_uv;\r\nvarying vec3 v_worldPosition;\r\nuniform vec3 u_cameraPos;\r\n\r\n#include<normal_pars_frag>\r\n#include<diffuse_pars_frag>\r\n#include<alphatest_pars_frag>\r\n\r\n#include<ambient_pars_frag>\r\n#include<specular_pars_frag>\r\n#include<lights_pars_frag>\r\n\r\n#include<envmap_pars_frag>\r\n#include<particle_pars_frag>\r\n#include<fog_pars_frag>\r\n\r\nvoid main()\r\n{\r\n    vec4 finalColor = vec4(1.0,1.0,1.0,1.0);\r\n\r\n    #include<normal_frag>\r\n    #include<diffuse_frag>\r\n    #include<alphatest_frag>\r\n\r\n    #include<ambient_frag>\r\n    #include<specular_frag>\r\n    #include<lights_frag>\r\n\r\n    #include<envmap_frag>\r\n    #include<particle_frag>\r\n    #include<fog_frag>\r\n\r\n    gl_FragColor = finalColor;\r\n}",
                "vertex": "precision mediump float;  \r\n\r\n#include<position_pars_vert>\r\n#include<normal_pars_vert>\r\n#include<tangent_pars_vert>\r\n//\r\n#include<skeleton_pars_vert>\r\n#include<particle_pars_vert>\r\n//\r\n#include<worldposition_pars_vert>\r\n#include<project_pars_vert>\r\n//\r\n#include<uv_pars_vert>\r\n#include<normalmap_pars_vert>\r\n//\r\n#include<lights_pars_vert>\r\n#include<pointsize_pars_vert>\r\n\r\nvoid main()\r\n{\r\n    // 初始化\r\n    #include<position_vert>\r\n    #include<normal_vert>\r\n    #include<tangent_vert>\r\n    // 动画\r\n    #include<skeleton_vert>\r\n    #include<particle_vert>\r\n    // 投影\r\n    #include<worldposition_vert>\r\n    #include<project_vert>\r\n    // \r\n    #include<uv_vert>\r\n    #include<normalmap_vert>\r\n    //\r\n    #include<lights_vert>\r\n    #include<pointsize_vert>\r\n}"
            },
            "terrain": {
                "fragment": "precision mediump float;\r\n\r\nvarying vec2 v_uv;\r\nvarying vec3 v_worldPosition;\r\nuniform vec3 u_cameraPos;\r\n\r\n#include<normal_pars_frag>\r\n#include<diffuse_pars_frag>\r\n#include<alphatest_pars_frag>\r\n\r\n#include<terrain_pars_frag>\r\n\r\n#include<ambient_pars_frag>\r\n#include<specular_pars_frag>\r\n#include<lights_pars_frag>\r\n\r\n#include<envmap_pars_frag>\r\n#include<fog_pars_frag>\r\n\r\nvoid main()\r\n{\r\n    vec4 finalColor = vec4(1.0, 1.0, 1.0, 1.0);\r\n\r\n    #include<normal_frag>\r\n    #include<diffuse_frag>\r\n    #include<alphatest_frag>\r\n\r\n    #include<terrain_frag>\r\n\r\n    #include<ambient_frag>\r\n    #include<specular_frag>\r\n    #include<lights_frag>\r\n\r\n    #include<envmap_frag>\r\n    #include<fog_frag>\r\n\r\n    gl_FragColor = finalColor;\r\n}",
                "vertex": "precision mediump float;  \r\n\r\n#include<position_pars_vert>\r\n#include<normal_pars_vert>\r\n#include<tangent_pars_vert>\r\n//\r\n#include<worldposition_pars_vert>\r\n#include<project_pars_vert>\r\n//\r\n#include<uv_pars_vert>\r\n#include<normalmap_pars_vert>\r\n//\r\n#include<lights_pars_vert>\r\n#include<pointsize_pars_vert>\r\n\r\nvoid main() \r\n{\r\n    // 初始化\r\n    #include<position_vert>\r\n    #include<normal_vert>\r\n    #include<tangent_vert>\r\n    // 投影\r\n    #include<worldposition_vert>\r\n    #include<project_vert>\r\n    // \r\n    #include<uv_vert>\r\n    #include<normalmap_vert>\r\n    //\r\n    #include<lights_vert>\r\n    #include<pointsize_vert>\r\n}"
            },
            "texture": {
                "fragment": "precision mediump float;\r\n\r\nuniform sampler2D s_texture;\r\nvarying vec2 v_uv;\r\n\r\nuniform vec4 u_color;\r\n\r\nvoid main() {\r\n\r\n    vec4 color = texture2D(s_texture, v_uv);\r\n    gl_FragColor = color * u_color;\r\n}\r\n",
                "vertex": "attribute vec3 a_position;\r\nattribute vec2 a_uv;\r\n\r\nvarying vec2 v_uv;\r\nuniform mat4 u_modelMatrix;\r\nuniform mat4 u_viewProjection;\r\n\r\nvoid main() \r\n{\r\n    gl_Position = u_viewProjection * u_modelMatrix * vec4(a_position, 1.0);\r\n    v_uv = a_uv;\r\n}"
            },
            "water": {
                "fragment": "precision mediump float;  \r\n\r\nuniform vec3 u_cameraPos;\r\n\r\nvarying vec4 v_mirrorCoord;\r\nvarying vec4 v_worldPosition;\r\n\r\nuniform sampler2D s_mirrorSampler;\r\nuniform sampler2D s_normalSampler;\r\n\r\nuniform float u_alpha;\r\nuniform float u_time;\r\nuniform float u_size;\r\nuniform float u_distortionScale;\r\nuniform vec3 u_sunColor;\r\nuniform vec3 u_sunDirection;\r\nuniform vec3 u_waterColor;\r\n\r\nvec4 getNoise( vec2 uv ) \r\n{\r\n\tvec2 uv0 = ( uv / 103.0 ) + vec2(u_time / 17.0, u_time / 29.0);\r\n\tvec2 uv1 = uv / 107.0-vec2( u_time / -19.0, u_time / 31.0 );\r\n\tvec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( u_time / 101.0, u_time / 97.0 );\r\n\tvec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( u_time / 109.0, u_time / -113.0 );\r\n\tvec4 noise = texture2D( s_normalSampler, uv0 ) +\r\n\t\ttexture2D( s_normalSampler, uv1 ) +\r\n\t\ttexture2D( s_normalSampler, uv2 ) +\r\n\t\ttexture2D( s_normalSampler, uv3 );\r\n\treturn noise * 0.5 - 1.0;\r\n}\r\n\r\nvoid sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) \r\n{\r\n\tvec3 reflection = normalize( reflect( -u_sunDirection, surfaceNormal ) );\r\n\tfloat direction = max( 0.0, dot( eyeDirection, reflection ) );\r\n\tspecularColor += pow( direction, shiny ) * u_sunColor * spec;\r\n\tdiffuseColor += max( dot( u_sunDirection, surfaceNormal ), 0.0 ) * u_sunColor * diffuse;\r\n}\r\n\r\nvoid main() \r\n{\r\n\tvec4 noise = getNoise( v_worldPosition.xz * u_size );\r\n\tvec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );\r\n\tvec3 diffuseLight = vec3(0.0);\r\n\tvec3 specularLight = vec3(0.0);\r\n\tvec3 worldToEye = u_cameraPos-v_worldPosition.xyz;\r\n\tvec3 eyeDirection = normalize( worldToEye );\r\n\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\r\n\tfloat distance = length(worldToEye);\r\n\tvec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * u_distortionScale;\r\n\tvec3 reflectionSample = vec3( texture2D( s_mirrorSampler, v_mirrorCoord.xy / v_mirrorCoord.z + distortion ) );\r\n\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );\r\n\tfloat rf0 = 0.3;\r\n\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );\r\n\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * u_waterColor;\r\n\r\n\tfloat shadowMask = 1.0;\r\n\t// float shadowMask = getShadowMask();\r\n\r\n\tvec3 albedo = mix( ( u_sunColor * diffuseLight * 0.3 + scatter ) * shadowMask, ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);\r\n\tvec3 outgoingLight = albedo;\r\n\tgl_FragColor = vec4( outgoingLight, u_alpha );\r\n\r\n\t// debug\r\n\t// gl_FragColor = texture2D( s_mirrorSampler, (v_mirrorCoord.xy / v_mirrorCoord.z + 1.0) / 2.0 );\r\n\t// gl_FragColor = vec4( reflectionSample, 1.0 );\r\n\t// gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\r\n}",
                "vertex": "attribute vec3 a_position;\r\n\r\nuniform mat4 u_modelMatrix;\r\nuniform mat4 u_viewProjection;\r\n\r\nuniform mat4 u_textureMatrix;\r\n\r\nvarying vec4 v_mirrorCoord;\r\nvarying vec4 v_worldPosition;\r\n\r\nvoid main() \r\n{\r\n\tvec4 position = vec4(a_position, 1.0);\r\n\t//获取全局坐标\r\n    vec4 worldPosition = u_modelMatrix * position;\r\n    //计算投影坐标\r\n    gl_Position = u_viewProjection * worldPosition;\r\n\t\r\n\tv_worldPosition = worldPosition;\r\n\tv_mirrorCoord = u_textureMatrix * worldPosition;\r\n}"
            },
            "wireframe": {
                "fragment": "precision mediump float;\r\n\r\nuniform vec4 u_wireframeColor;\r\n\r\nvoid main() \r\n{\r\n    gl_FragColor = u_wireframeColor;\r\n}",
                "vertex": "precision mediump float;  \r\n\r\nattribute vec3 a_position;\r\nattribute vec4 a_color;\r\n\r\nuniform mat4 u_modelMatrix;\r\nuniform mat4 u_viewProjection;\r\n\r\n#include<skeleton_pars_vert>\r\n#include<particle_pars_vert>\r\n\r\nvoid main() \r\n{\r\n    vec4 position = vec4(a_position, 1.0);\r\n\r\n    #include<skeleton_vert>\r\n    #include<particle_vert>\r\n\r\n    gl_Position = u_viewProjection * u_modelMatrix * position;\r\n}"
            }
        },
        "modules": {
            "alphatest_frag": "if(diffuseColor.w < u_alphaThreshold) discard;",
            "alphatest_pars_frag": "uniform float u_alphaThreshold;",
            "ambient_frag": "//环境光\r\nvec3 ambientColor = u_ambient.w * u_ambient.xyz * u_sceneAmbientColor.xyz * u_sceneAmbientColor.w;\r\nambientColor = ambientColor * texture2D(s_ambient, v_uv).xyz;",
            "ambient_pars_frag": "uniform vec4 u_sceneAmbientColor;\r\n\r\n//环境\r\nuniform vec4 u_ambient;\r\nuniform sampler2D s_ambient;",
            "cartoon_pars_frag": "#ifdef IS_CARTOON\r\n    #ifdef cartoon_Anti_aliasing\r\n        #extension GL_OES_standard_derivatives : enable\r\n    #endif\r\n\r\n    uniform vec4 u_diffuseSegment;\r\n    uniform vec4 u_diffuseSegmentValue;\r\n    uniform float u_specularSegment;\r\n\r\n    //漫反射\r\n    float cartoonLightDiffuse(vec3 normal,vec3 lightDir)\r\n    {\r\n        float diff = dot(normal, lightDir);\r\n        diff = diff * 0.5 + 0.5;\r\n\r\n        #ifdef cartoon_Anti_aliasing\r\n            float w = fwidth(diff) * 2.0;\r\n            if (diff < u_diffuseSegment.x + w) \r\n            {\r\n                diff = mix(u_diffuseSegment.x, u_diffuseSegment.y, smoothstep(u_diffuseSegment.x - w, u_diffuseSegment.x + w, diff));\r\n            //  diff = mix(u_diffuseSegment.x, u_diffuseSegment.y, clamp(0.5 * (diff - u_diffuseSegment.x) / w, 0, 1));\r\n            } else if (diff < u_diffuseSegment.y + w) \r\n            {\r\n                diff = mix(u_diffuseSegment.y, u_diffuseSegment.z, smoothstep(u_diffuseSegment.y - w, u_diffuseSegment.y + w, diff));\r\n            //  diff = mix(u_diffuseSegment.y, u_diffuseSegment.z, clamp(0.5 * (diff - u_diffuseSegment.y) / w, 0, 1));\r\n            } else if (diff < u_diffuseSegment.z + w) \r\n            {\r\n                diff = mix(u_diffuseSegment.z, u_diffuseSegment.w, smoothstep(u_diffuseSegment.z - w, u_diffuseSegment.z + w, diff));\r\n            //  diff = mix(u_diffuseSegment.z, u_diffuseSegment.w, clamp(0.5 * (diff - u_diffuseSegment.z) / w, 0, 1));\r\n            } else \r\n            {\r\n                diff = u_diffuseSegment.w;\r\n            }\r\n        #else\r\n            if (diff < u_diffuseSegment.x) \r\n            {\r\n                diff = u_diffuseSegmentValue.x;\r\n            } else if (diff < u_diffuseSegment.y) \r\n            {\r\n                diff = u_diffuseSegmentValue.y;\r\n            } else if (diff < u_diffuseSegment.z) \r\n            {\r\n                diff = u_diffuseSegmentValue.z;\r\n            } else \r\n            {\r\n                diff = u_diffuseSegmentValue.w;\r\n            }\r\n        #endif\r\n\r\n        return diff;\r\n    }\r\n\r\n    //镜面反射漫反射\r\n    float cartoonLightSpecular(vec3 normal,vec3 lightDir,vec3 cameraDir,float glossiness)\r\n    {\r\n        vec3 halfVec = normalize(lightDir + cameraDir);\r\n        float specComp = max(dot(normal,halfVec),0.0);\r\n        specComp = pow(specComp, glossiness);\r\n\r\n        #ifdef cartoon_Anti_aliasing\r\n            float w = fwidth(specComp);\r\n            if (specComp < u_specularSegment + w) \r\n            {\r\n                specComp = mix(0.0, 1.0, smoothstep(u_specularSegment - w, u_specularSegment + w, specComp));\r\n                // specComp = smoothstep(u_specularSegment - w, u_specularSegment + w, specComp);\r\n            } else \r\n            {\r\n                specComp = 1.0;\r\n            }\r\n        #else\r\n            if(specComp < u_specularSegment)\r\n            {\r\n                specComp = 0.0;\r\n            }else\r\n            {\r\n                specComp = 1.0;\r\n            }\r\n        #endif\r\n\r\n        return specComp;\r\n    }\r\n#endif",
            "diffuse_frag": "//获取漫反射基本颜色\r\nvec4 diffuseColor = u_diffuse;\r\ndiffuseColor = diffuseColor * texture2D(s_diffuse, v_uv);\r\n\r\nfinalColor = diffuseColor;",
            "diffuse_pars_frag": "//漫反射\r\nuniform vec4 u_diffuse;\r\nuniform sampler2D s_diffuse;",
            "envmap_frag": "finalColor = envmapMethod(finalColor);",
            "envmap_pars_frag": "uniform samplerCube s_envMap;\r\nuniform float u_reflectivity;\r\n\r\nvec4 envmapMethod(vec4 finalColor)\r\n{\r\n    vec3 cameraToVertex = normalize( v_worldPosition - u_cameraPos );\r\n    vec3 reflectVec = reflect( cameraToVertex, v_normal );\r\n    vec4 envColor = textureCube( s_envMap, reflectVec );\r\n    finalColor.xyz *= envColor.xyz * u_reflectivity;\r\n    return finalColor;\r\n}",
            "fog_frag": "finalColor = fogMethod(finalColor);",
            "fog_pars_frag": "#define FOGMODE_NONE    0.\r\n#define FOGMODE_EXP     1.\r\n#define FOGMODE_EXP2    2.\r\n#define FOGMODE_LINEAR  3.\r\n#define E 2.71828\r\n\r\nuniform float u_fogMode;\r\nuniform float u_fogMinDistance;\r\nuniform float u_fogMaxDistance;\r\nuniform float u_fogDensity;\r\nuniform vec3 u_fogColor;\r\n\r\nfloat CalcFogFactor(float fogDistance)\r\n{\r\n\tfloat fogCoeff = 1.0;\r\n\tif (FOGMODE_LINEAR == u_fogMode)\r\n\t{\r\n\t\tfogCoeff = (u_fogMaxDistance - fogDistance) / (u_fogMaxDistance - u_fogMinDistance);\r\n\t}\r\n\telse if (FOGMODE_EXP == u_fogMode)\r\n\t{\r\n\t\tfogCoeff = 1.0 / pow(E, fogDistance * u_fogDensity);\r\n\t}\r\n\telse if (FOGMODE_EXP2 == u_fogMode)\r\n\t{\r\n\t\tfogCoeff = 1.0 / pow(E, fogDistance * fogDistance * u_fogDensity * u_fogDensity);\r\n\t}\r\n\r\n\treturn clamp(fogCoeff, 0.0, 1.0);\r\n}\r\n\r\nvec4 fogMethod(vec4 color)\r\n{\r\n    vec3 fogDistance = u_cameraPos - v_worldPosition.xyz;\r\n\tfloat fog = CalcFogFactor(length(fogDistance));\r\n\tcolor.rgb = fog * color.rgb + (1.0 - fog) * u_fogColor;\r\n    return color;\r\n}",
            "lights_frag": "//渲染灯光\r\n#if NUM_LIGHT > 0\r\n    finalColor.xyz = lightShading(normal, diffuseColor.xyz, specularColor, ambientColor, glossiness);\r\n#endif",
            "lights_pars_frag": "#if NUM_POINTLIGHT > 0\r\n    // 点光源\r\n    struct PointLight\r\n    {\r\n        // 位置\r\n        vec3 position;\r\n        // 颜色\r\n        vec3 color;\r\n        // 强度\r\n        float intensity;\r\n        // 范围\r\n        float range;\r\n    };\r\n    // 点光源列表\r\n    uniform PointLight u_pointLights[NUM_POINTLIGHT];\r\n#endif\r\n\r\n#if NUM_SPOT_LIGHTS > 0\r\n    // 聚光灯\r\n    struct SpotLight\r\n    {\r\n        // 位置\r\n        vec3 position;\r\n        // 颜色\r\n        vec3 color;\r\n        // 强度\r\n        float intensity;\r\n        // 范围\r\n        float range;\r\n        // 方向\r\n        vec3 direction;\r\n        // 椎体cos值\r\n        float coneCos;\r\n        // 半影cos\r\n        float penumbraCos;\r\n    };\r\n    // 方向光源列表\r\n    uniform SpotLight u_spotLights[ NUM_SPOT_LIGHTS ];\r\n#endif\r\n\r\n#if NUM_DIRECTIONALLIGHT > 0\r\n    // 方向光源\r\n    struct DirectionalLight\r\n    {\r\n        // 方向\r\n        vec3 direction;\r\n        // 颜色\r\n        vec3 color;\r\n        // 强度\r\n        float intensity;\r\n    };\r\n    // 方向光源列表\r\n    uniform DirectionalLight u_directionalLights[ NUM_DIRECTIONALLIGHT ];\r\n#endif\r\n\r\n//卡通\r\n#include<cartoon_pars_frag>\r\n\r\n#include<shadowmap_pars_frag>\r\n\r\n//计算光照漫反射系数\r\nfloat calculateLightDiffuse(vec3 normal,vec3 lightDir)\r\n{\r\n    #ifdef IS_CARTOON\r\n        return cartoonLightDiffuse(normal,lightDir);\r\n    #else\r\n        return clamp(dot(normal,lightDir),0.0,1.0);\r\n    #endif\r\n}\r\n\r\n//计算光照镜面反射系数\r\nfloat calculateLightSpecular(vec3 normal,vec3 lightDir,vec3 viewDir,float glossiness)\r\n{\r\n    #ifdef IS_CARTOON\r\n        return cartoonLightSpecular(normal,lightDir,viewDir,glossiness);\r\n    #else\r\n        vec3 halfVec = normalize(lightDir + viewDir);\r\n        float specComp = max(dot(normal,halfVec),0.0);\r\n        specComp = pow(specComp, glossiness);\r\n\r\n        return specComp;\r\n    #endif\r\n}\r\n\r\n//根据距离计算衰减\r\nfloat computeDistanceLightFalloff(float lightDistance, float range)\r\n{\r\n    #ifdef USEPHYSICALLIGHTFALLOFF\r\n        float lightDistanceFalloff = 1.0 / ((lightDistance * lightDistance + 0.0001));\r\n    #else\r\n        float lightDistanceFalloff = max(0., 1.0 - lightDistance / range);\r\n    #endif\r\n    \r\n    return lightDistanceFalloff;\r\n}\r\n\r\n//渲染点光源\r\nvec3 lightShading(vec3 normal, vec3 diffuseColor, vec3 specularColor, vec3 ambientColor, float glossiness)\r\n{\r\n    //视线方向\r\n    vec3 viewDir = normalize(u_cameraPos - v_worldPosition);\r\n\r\n    vec3 resultColor = vec3(0.0,0.0,0.0);\r\n    \r\n    #if NUM_POINTLIGHT > 0\r\n        PointLight pointLight;\r\n        for(int i = 0;i<NUM_POINTLIGHT;i++)\r\n        {\r\n            pointLight = u_pointLights[i];\r\n            //\r\n            vec3 lightOffset = pointLight.position - v_worldPosition;\r\n            //光照方向\r\n            vec3 lightDir = normalize(lightOffset);\r\n            //灯光颜色\r\n            vec3 lightColor = pointLight.color;\r\n            //灯光强度\r\n            float lightIntensity = pointLight.intensity;\r\n            float falloff = computeDistanceLightFalloff(length(lightOffset), pointLight.range);\r\n            float diffuse = calculateLightDiffuse(normal, lightDir);\r\n            float specular = calculateLightSpecular(normal, lightDir, viewDir, glossiness);\r\n            float shadow = 1.0;\r\n            \r\n            resultColor += (diffuse * diffuseColor + specular * specularColor) * lightColor * lightIntensity * falloff * shadow;\r\n        }\r\n    #endif\r\n\r\n    #if NUM_POINTLIGHT_CASTSHADOW > 0\r\n        CastShadowPointLight castShadowPointLight;\r\n        for(int i = 0;i<NUM_POINTLIGHT_CASTSHADOW;i++)\r\n        {\r\n            castShadowPointLight = u_castShadowPointLights[i];\r\n            //\r\n            vec3 lightOffset = castShadowPointLight.position - v_worldPosition;\r\n            //光照方向\r\n            vec3 lightDir = normalize(lightOffset);\r\n            //灯光颜色\r\n            vec3 lightColor = castShadowPointLight.color;\r\n            //灯光强度\r\n            float lightIntensity = castShadowPointLight.intensity;\r\n            float falloff = computeDistanceLightFalloff(length(lightOffset), castShadowPointLight.range);\r\n            // 计算阴影\r\n            float shadow = getPointShadow( u_pointShadowMaps[ i ], castShadowPointLight.shadowType, castShadowPointLight.shadowMapSize, castShadowPointLight.shadowBias, castShadowPointLight.shadowRadius, -lightOffset, castShadowPointLight.shadowCameraNear, castShadowPointLight.shadowCameraFar );\r\n            float diffuse = calculateLightDiffuse(normal, lightDir);\r\n            float specular = calculateLightSpecular(normal, lightDir, viewDir, glossiness);\r\n            //\r\n            resultColor += (diffuse * diffuseColor + specular * specularColor) * lightColor * lightIntensity * falloff * shadow;\r\n        }\r\n    #endif\r\n\r\n    #if NUM_SPOT_LIGHTS > 0\r\n        SpotLight spotLight;\r\n        for(int i = 0; i < NUM_SPOT_LIGHTS; i++)\r\n        {\r\n            spotLight = u_spotLights[i];\r\n            //\r\n            vec3 lightOffset = spotLight.position - v_worldPosition;\r\n            //光照方向\r\n            vec3 lightDir = normalize(lightOffset);\r\n            float angleCos = dot(lightDir, -spotLight.direction);\r\n            if(angleCos > spotLight.coneCos)\r\n            {\r\n                float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\r\n                \r\n                //灯光颜色\r\n                vec3 lightColor = spotLight.color;\r\n                //灯光强度\r\n                float lightIntensity = spotLight.intensity;\r\n                float falloff = computeDistanceLightFalloff(length(lightOffset) * angleCos, spotLight.range);\r\n                float diffuse = calculateLightDiffuse(normal, lightDir);\r\n                float specular = calculateLightSpecular(normal, lightDir, viewDir, glossiness);\r\n                float shadow = 1.0;\r\n                \r\n                resultColor += (diffuse * diffuseColor + specular * specularColor) * lightColor * lightIntensity * falloff * shadow * spotEffect;\r\n            }            \r\n        }\r\n    #endif\r\n    \r\n    #if NUM_SPOT_LIGHTS_CASTSHADOW > 0\r\n        CastShadowSpotLight castShadowSpotLight;\r\n        for(int i = 0; i < NUM_SPOT_LIGHTS_CASTSHADOW; i++)\r\n        {\r\n            castShadowSpotLight = u_castShadowSpotLights[i];\r\n            //\r\n            vec3 lightOffset = castShadowSpotLight.position - v_worldPosition;\r\n            //光照方向\r\n            vec3 lightDir = normalize(lightOffset);\r\n            float angleCos = dot(lightDir, -castShadowSpotLight.direction);\r\n            if(angleCos > castShadowSpotLight.coneCos)\r\n            {\r\n                float spotEffect = smoothstep( castShadowSpotLight.coneCos, castShadowSpotLight.penumbraCos, angleCos );\r\n                \r\n                //灯光颜色\r\n                vec3 lightColor = castShadowSpotLight.color;\r\n                //灯光强度\r\n                float lightIntensity = castShadowSpotLight.intensity;\r\n                float falloff = computeDistanceLightFalloff(length(lightOffset) * angleCos, castShadowSpotLight.range);\r\n                float diffuse = calculateLightDiffuse(normal, lightDir);\r\n                float specular = calculateLightSpecular(normal, lightDir, viewDir, glossiness);\r\n                // 计算阴影\r\n                float shadow = getShadow( u_spotShadowMaps[i], castShadowSpotLight.shadowType, castShadowSpotLight.shadowMapSize, castShadowSpotLight.shadowBias, castShadowSpotLight.shadowRadius, v_spotShadowCoord[ i ], -lightOffset, castShadowSpotLight.shadowCameraNear, castShadowSpotLight.shadowCameraFar);\r\n                \r\n                resultColor += (diffuse * diffuseColor + specular * specularColor) * lightColor * lightIntensity * falloff * shadow * spotEffect;\r\n            }            \r\n        }\r\n    #endif\r\n\r\n    #if NUM_DIRECTIONALLIGHT > 0\r\n        DirectionalLight directionalLight;\r\n        for(int i = 0;i<NUM_DIRECTIONALLIGHT;i++)\r\n        {\r\n            directionalLight = u_directionalLights[i];\r\n            //光照方向\r\n            vec3 lightDir = normalize(-directionalLight.direction);\r\n            //灯光颜色\r\n            vec3 lightColor = directionalLight.color;\r\n            //灯光强度\r\n            float lightIntensity = directionalLight.intensity;\r\n\r\n            float falloff = 1.0;\r\n            float diffuse = calculateLightDiffuse(normal, lightDir);\r\n            float specular = calculateLightSpecular(normal, lightDir, viewDir, glossiness);\r\n            float shadow = 1.0;\r\n            //\r\n            resultColor += (diffuse * diffuseColor + specular * specularColor) * lightColor * lightIntensity * falloff * shadow;\r\n        }\r\n    #endif\r\n\r\n    #if NUM_DIRECTIONALLIGHT_CASTSHADOW > 0\r\n        CastShadowDirectionalLight castShadowDirectionalLight;\r\n        for(int i = 0;i<NUM_DIRECTIONALLIGHT_CASTSHADOW;i++)\r\n        {\r\n            castShadowDirectionalLight = u_castShadowDirectionalLights[i];\r\n            //\r\n            vec3 lightOffset = castShadowDirectionalLight.position - v_worldPosition;\r\n            //光照方向\r\n            vec3 lightDir = normalize(-castShadowDirectionalLight.direction);\r\n            //灯光颜色\r\n            vec3 lightColor = castShadowDirectionalLight.color;\r\n            //灯光强度\r\n            float lightIntensity = castShadowDirectionalLight.intensity;\r\n            // 计算阴影\r\n            float shadow = getShadow( u_directionalShadowMaps[i], castShadowDirectionalLight.shadowType, castShadowDirectionalLight.shadowMapSize, castShadowDirectionalLight.shadowBias, castShadowDirectionalLight.shadowRadius, v_directionalShadowCoord[ i ], -lightOffset, castShadowDirectionalLight.shadowCameraNear, castShadowDirectionalLight.shadowCameraFar);\r\n            \r\n            float falloff = 1.0;\r\n            float diffuse = calculateLightDiffuse(normal, lightDir);\r\n            float specular = calculateLightSpecular(normal, lightDir, viewDir, glossiness);\r\n            //\r\n            resultColor += (diffuse * diffuseColor + specular * specularColor) * lightColor * lightIntensity * falloff * shadow;\r\n        }\r\n    #endif\r\n\r\n    resultColor += ambientColor * diffuseColor;\r\n    return resultColor;\r\n}",
            "lights_pars_vert": "// 灯光声明\r\n\r\n#if NUM_DIRECTIONALLIGHT_CASTSHADOW > 0\r\n    // 方向光源投影矩阵列表\r\n    uniform mat4 u_directionalShadowMatrixs[ NUM_DIRECTIONALLIGHT_CASTSHADOW ];\r\n    // 方向光源投影uv列表\r\n    varying vec4 v_directionalShadowCoord[ NUM_DIRECTIONALLIGHT_CASTSHADOW ];\r\n#endif\r\n\r\n#if NUM_SPOT_LIGHTS_CASTSHADOW > 0\r\n    // 聚光灯投影矩阵列表\r\n    uniform mat4 u_spotShadowMatrix[ NUM_SPOT_LIGHTS_CASTSHADOW ];\r\n    // 聚光灯投影uv列表\r\n    varying vec4 v_spotShadowCoord[ NUM_SPOT_LIGHTS_CASTSHADOW ];\r\n#endif",
            "lights_vert": "#if NUM_DIRECTIONALLIGHT_CASTSHADOW > 0\r\n    for ( int i = 0; i < NUM_DIRECTIONALLIGHT_CASTSHADOW; i ++ ) \r\n    {\r\n        v_directionalShadowCoord[ i ] = u_directionalShadowMatrixs[ i ] * worldPosition;\r\n    }\r\n#endif\r\n\r\n#if NUM_SPOT_LIGHTS_CASTSHADOW > 0\r\n    for ( int i = 0; i < NUM_SPOT_LIGHTS_CASTSHADOW; i ++ ) \r\n    {\r\n        v_spotShadowCoord[ i ] = u_spotShadowMatrix[ i ] * worldPosition;\r\n    }\r\n#endif",
            "normalmap_pars_vert": "uniform mat4 u_ITModelMatrix;\r\n\r\nvarying vec3 v_normal;\r\nvarying vec3 v_tangent;\r\nvarying vec3 v_bitangent;",
            "normalmap_vert": "//计算法线\r\nv_normal = normalize((u_ITModelMatrix * vec4(normal, 0.0)).xyz);\r\nv_tangent = normalize((u_modelMatrix * vec4(tangent, 0.0)).xyz);\r\nv_bitangent = cross(v_normal, v_tangent);",
            "normal_frag": "//获取法线\r\nvec3 normal = texture2D(s_normal,v_uv).xyz * 2.0 - 1.0;\r\nnormal = normalize(normal.x * v_tangent + normal.y * v_bitangent + normal.z * v_normal);",
            "normal_pars_frag": "varying vec3 v_normal;\r\nvarying vec3 v_tangent;\r\nvarying vec3 v_bitangent;\r\n\r\n//法线贴图\r\nuniform sampler2D s_normal;",
            "normal_pars_vert": "attribute vec3 a_normal;",
            "normal_vert": "vec3 normal = a_normal;",
            "particle_frag": "#ifdef HAS_PARTICLE_ANIMATOR\r\n    finalColor = particleAnimation(finalColor);\r\n#endif",
            "particle_pars_frag": "#ifdef HAS_PARTICLE_ANIMATOR\r\n    varying vec4 v_particle_color;\r\n\r\n    vec4 particleAnimation(vec4 color) {\r\n\r\n        return color * v_particle_color;\r\n    }\r\n#endif",
            "particle_pars_vert": "#ifdef HAS_PARTICLE_ANIMATOR\r\n    //\r\n    attribute vec3 a_particle_position;\r\n    attribute vec3 a_particle_scale;\r\n    attribute vec3 a_particle_rotation;\r\n    attribute vec4 a_particle_color;\r\n\r\n    varying vec4 v_particle_color;\r\n\r\n    mat3 makeParticleRotationMatrix(vec3 rotation)\r\n    {\r\n        float DEG2RAD = 3.1415926 / 180.0;\r\n        \r\n        float rx = rotation.x * DEG2RAD;\r\n        float ry = rotation.y * DEG2RAD;\r\n        float rz = rotation.z * DEG2RAD;\r\n\r\n        float sx = sin(rx);\r\n        float cx = cos(rx);\r\n        float sy = sin(ry);\r\n        float cy = cos(ry);\r\n        float sz = sin(rz);\r\n        float cz = cos(rz);\r\n\r\n        mat3 tmp;\r\n        tmp[ 0 ] = vec3(cy * cz, cy * sz, -sy);\r\n        tmp[ 1 ] = vec3(sx * sy * cz - cx * sz, sx * sy * sz + cx * cz, sx * cy);\r\n        tmp[ 2 ] = vec3(cx * sy * cz + sx * sz, cx * sy * sz - sx * cz, cx * cy);\r\n        return tmp;\r\n    }\r\n\r\n    vec4 particleAnimation(vec4 position) \r\n    {\r\n        // 计算缩放\r\n        position.xyz = position.xyz * a_particle_scale;\r\n\r\n        // 计算旋转\r\n        mat3 rMat = makeParticleRotationMatrix(a_particle_rotation);\r\n        position.xyz = rMat * position.xyz;\r\n\r\n        // 位移\r\n        position.xyz = position.xyz + a_particle_position;\r\n\r\n        // 颜色\r\n        v_particle_color = a_particle_color;\r\n        \r\n        return position;\r\n    }\r\n#endif",
            "particle_vert": "#ifdef HAS_PARTICLE_ANIMATOR\r\n    position = particleAnimation(position);\r\n#endif",
            "pointsize_pars_vert": "#ifdef IS_POINTS_MODE\r\n    uniform float u_PointSize;\r\n#endif",
            "pointsize_vert": "#ifdef IS_POINTS_MODE\r\n    gl_PointSize = u_PointSize;\r\n#endif",
            "position_pars_vert": "attribute vec3 a_position;",
            "position_vert": "vec4 position = vec4(a_position, 1.0);",
            "project_pars_vert": "uniform mat4 u_viewProjection;",
            "project_vert": "//计算投影坐标\r\ngl_Position = u_viewProjection * worldPosition;",
            "shadowmap_pars_frag": "#if (NUM_POINTLIGHT_CASTSHADOW > 0) ||  (NUM_DIRECTIONALLIGHT_CASTSHADOW > 0) ||  (NUM_SPOT_LIGHTS_CASTSHADOW > 0)\r\n    #if NUM_POINTLIGHT_CASTSHADOW > 0\r\n        // 投影的点光源\r\n        struct CastShadowPointLight\r\n        {\r\n            // 位置\r\n            vec3 position;\r\n            // 颜色\r\n            vec3 color;\r\n            // 强度\r\n            float intensity;\r\n            // 范围\r\n            float range;\r\n            // 阴影类型\r\n            int shadowType;\r\n            // 阴影偏差，用来解决判断是否为阴影时精度问题\r\n            float shadowBias;\r\n            // 阴影半径，边缘宽度\r\n            float shadowRadius;\r\n            // 阴影图尺寸\r\n            vec2 shadowMapSize;\r\n            float shadowCameraNear;\r\n            float shadowCameraFar;\r\n        };\r\n        // 投影的点光源列表\r\n        uniform CastShadowPointLight u_castShadowPointLights[NUM_POINTLIGHT_CASTSHADOW];\r\n        // 点光源阴影图\r\n        uniform sampler2D u_pointShadowMaps[NUM_POINTLIGHT_CASTSHADOW];\r\n    #endif\r\n\r\n    #if NUM_SPOT_LIGHTS_CASTSHADOW > 0\r\n        // 投影的聚光灯\r\n        struct CastShadowSpotLight\r\n        {\r\n            // 位置\r\n            vec3 position;\r\n            // 颜色\r\n            vec3 color;\r\n            // 强度\r\n            float intensity;\r\n            // 范围\r\n            float range;\r\n            // 方向\r\n            vec3 direction;\r\n            // 椎体cos值\r\n            float coneCos;\r\n            // 半影cos\r\n            float penumbraCos;\r\n\r\n            // 阴影类型\r\n            int shadowType;\r\n            // 阴影偏差，用来解决判断是否为阴影时精度问题\r\n            float shadowBias;\r\n            // 阴影半径，边缘宽度\r\n            float shadowRadius;\r\n            // 阴影图尺寸\r\n            vec2 shadowMapSize;\r\n            float shadowCameraNear;\r\n            float shadowCameraFar;\r\n        };\r\n        // 投影的投影的聚光灯列表\r\n        uniform CastShadowSpotLight u_castShadowSpotLights[NUM_SPOT_LIGHTS_CASTSHADOW];\r\n        // 投影的聚光灯阴影图\r\n        uniform sampler2D u_spotShadowMaps[NUM_SPOT_LIGHTS_CASTSHADOW];\r\n        // 方向光源投影uv列表\r\n        varying vec4 v_spotShadowCoord[ NUM_SPOT_LIGHTS_CASTSHADOW ];\r\n    #endif\r\n\r\n    #if NUM_DIRECTIONALLIGHT_CASTSHADOW > 0\r\n        // 投影的方向光源\r\n        struct CastShadowDirectionalLight\r\n        {\r\n            // 方向\r\n            vec3 direction;\r\n            // 颜色\r\n            vec3 color;\r\n            // 强度\r\n            float intensity;\r\n            // 阴影类型\r\n            int shadowType;\r\n            // 阴影偏差，用来解决判断是否为阴影时精度问题\r\n            float shadowBias;\r\n            // 阴影半径，边缘宽度\r\n            float shadowRadius;\r\n            // 阴影图尺寸\r\n            vec2 shadowMapSize;\r\n            // 位置\r\n            vec3 position;\r\n            float shadowCameraNear;\r\n            float shadowCameraFar;\r\n        };\r\n        // 投影的方向光源列表\r\n        uniform CastShadowDirectionalLight u_castShadowDirectionalLights[NUM_DIRECTIONALLIGHT_CASTSHADOW];\r\n        // 方向光源阴影图\r\n        uniform sampler2D u_directionalShadowMaps[NUM_DIRECTIONALLIGHT_CASTSHADOW];\r\n        // 方向光源投影uv列表\r\n        varying vec4 v_directionalShadowCoord[ NUM_DIRECTIONALLIGHT_CASTSHADOW ];\r\n    #endif\r\n\r\n    // @see https://github.com/mrdoob/three.js/blob/dev/src/renderers/shaders/ShaderChunk/packing.glsl\r\n    const float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n    const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n    const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n    float unpackRGBAToDepth( const in vec4 v ) \r\n    {\r\n        return dot( v, UnpackFactors );\r\n    }\r\n\r\n    float texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n    {\r\n        return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n    }\r\n\r\n    float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) \r\n    {\r\n        const vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n        vec2 texelSize = vec2( 1.0 ) / size;\r\n        vec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n        float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n        float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n        float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n        float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n        vec2 f = fract( uv * size + 0.5 );\r\n\r\n        float a = mix( lb, lt, f.y );\r\n        float b = mix( rb, rt, f.y );\r\n        float c = mix( a, b, f.x );\r\n\r\n        return c;\r\n    }\r\n\r\n    // 计算阴影值 @see https://github.com/mrdoob/three.js/blob/dev/src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl\r\n    float getShadow( sampler2D shadowMap, int shadowType, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, vec3 lightToPosition, float shadowCameraNear, float shadowCameraFar) \r\n    {\r\n        float shadow = 1.0;\r\n\r\n        shadowCoord.xy /= shadowCoord.w;\r\n        shadowCoord.xy = (shadowCoord.xy + 1.0) / 2.0;\r\n\r\n        // dp = normalized distance from light to fragment position\r\n        float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?\r\n        dp += shadowBias;\r\n        shadowCoord.z = dp;\r\n\r\n        // if ( something && something ) breaks ATI OpenGL shader compiler\r\n        // if ( all( something, something ) ) using this instead\r\n\r\n        bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n        bool inFrustum = all( inFrustumVec );\r\n\r\n        bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n        bool frustumTest = all( frustumTestVec );\r\n\r\n        if ( frustumTest ) \r\n        {\r\n            if (shadowType == 2)\r\n            {\r\n                // PCF\r\n                vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n                float dx0 = - texelSize.x * shadowRadius;\r\n                float dy0 = - texelSize.y * shadowRadius;\r\n                float dx1 = + texelSize.x * shadowRadius;\r\n                float dy1 = + texelSize.y * shadowRadius;\r\n\r\n                shadow = (\r\n                    texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n                    texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n                    texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n                    texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n                    texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n                    texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n                    texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n                    texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n                    texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n                ) * ( 1.0 / 9.0 );\r\n            }\r\n            else if(shadowType == 3)\r\n            {\r\n                // PCF soft\r\n                vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n                float dx0 = - texelSize.x * shadowRadius;\r\n                float dy0 = - texelSize.y * shadowRadius;\r\n                float dx1 = + texelSize.x * shadowRadius;\r\n                float dy1 = + texelSize.y * shadowRadius;\r\n\r\n                shadow = (\r\n                    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n                    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n                    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n                    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n                    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n                    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n                    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n                    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n                    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n                ) * ( 1.0 / 9.0 );\r\n            }\r\n            else\r\n            {\r\n                shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n            }\r\n        }\r\n\r\n        return shadow;\r\n    }\r\n\r\n    // cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\r\n    // vector suitable for 2D texture mapping. This code uses the following layout for the\r\n    // 2D texture:\r\n    //\r\n    // xzXZ\r\n    //  y Y\r\n    //\r\n    // Y - Positive y direction\r\n    // y - Negative y direction\r\n    // X - Positive x direction\r\n    // x - Negative x direction\r\n    // Z - Positive z direction\r\n    // z - Negative z direction\r\n    //\r\n    // Source and test bed:\r\n    // https://gist.github.com/tschw/da10c43c467ce8afd0c4\r\n\r\n    vec2 cubeToUV( vec3 v, float texelSizeY ) \r\n    {\r\n        // Number of texels to avoid at the edge of each square\r\n        vec3 absV = abs( v );\r\n\r\n        // Intersect unit cube\r\n        float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\r\n        absV *= scaleToCube;\r\n\r\n        // Apply scale to avoid seams\r\n\r\n        // two texels less per square (one texel will do for NEAREST)\r\n        v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\r\n\r\n        // Unwrap\r\n\r\n        // space: -1 ... 1 range for each square\r\n        //\r\n        // #X##\t\tdim    := ( 1/4 , 1/2 )\r\n        //  # #\t\tcenter := ( 1/2 , 1/2 )\r\n        vec2 planar;\r\n        float almostOne = 1.0 - 1.5 * texelSizeY;\r\n        if ( absV.z >= almostOne ) \r\n        {\r\n            if ( v.z > 0.0 )\r\n            {\r\n                planar.x = (0.5 + v.x * 0.5) * 0.25 + 0.75;\r\n                planar.y = (0.5 + v.y * 0.5) * 0.5 + 0.5;\r\n            }else\r\n            {\r\n                planar.x = (0.5 - v.x * 0.5) * 0.25 + 0.25;\r\n                planar.y = (0.5 + v.y * 0.5) * 0.5 + 0.5;\r\n            }\r\n        } else if ( absV.x >= almostOne ) \r\n        {\r\n            if( v.x > 0.0)\r\n            {\r\n                planar.x = (0.5 - v.z * 0.5) * 0.25 + 0.5;\r\n                planar.y = (0.5 + v.y * 0.5) * 0.5 + 0.5;\r\n            }else\r\n            {\r\n                planar.x = (0.5 + v.z * 0.5) * 0.25 + 0.0;\r\n                planar.y = (0.5 + v.y * 0.5) * 0.5 + 0.5;\r\n            }\r\n        } else if ( absV.y >= almostOne ) \r\n        {\r\n            if( v.y > 0.0)\r\n            {\r\n                planar.x = (0.5 - v.x * 0.5) * 0.25 + 0.75;\r\n                planar.y = (0.5 + v.z * 0.5) * 0.5 + 0.0;\r\n            }else\r\n            {\r\n                planar.x = (0.5 - v.x * 0.5) * 0.25 + 0.25;\r\n                planar.y = (0.5 - v.z * 0.5) * 0.5 + 0.0;\r\n            }\r\n        }\r\n        return planar;\r\n    }\r\n\r\n    float getPointShadow( sampler2D shadowMap, int shadowType, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec3 lightToPosition, float shadowCameraNear, float shadowCameraFar ) \r\n    {\r\n        vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\r\n\r\n        // for point lights, the uniform @vShadowCoord is re-purposed to hold\r\n        // the vector from the light to the world-space position of the fragment.\r\n        // vec3 lightToPosition = shadowCoord.xyz;\r\n\r\n        // dp = normalized distance from light to fragment position\r\n        float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?\r\n        dp += shadowBias;\r\n\r\n        // bd3D = base direction 3D\r\n        vec3 bd3D = normalize( lightToPosition );\r\n\r\n        if(shadowType == 2 || shadowType == 3)\r\n        {\r\n            vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\r\n\r\n            return (\r\n                texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\r\n                texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\r\n                texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\r\n                texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\r\n                texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\r\n                texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\r\n                texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\r\n                texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\r\n                texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\r\n            ) * ( 1.0 / 9.0 );\r\n        }else\r\n        {\r\n            return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\r\n        }\r\n    }\r\n#endif",
            "skeleton_pars_vert": "#ifdef HAS_SKELETON_ANIMATION\r\n\r\n    attribute vec4 a_jointindex0;\r\n    attribute vec4 a_jointweight0;\r\n\r\n    #ifdef HAS_a_jointindex1\r\n        attribute vec4 a_jointindex1;\r\n        attribute vec4 a_jointweight1;\r\n    #endif\r\n\r\n    #ifdef NUM_SKELETONJOINT\r\n        uniform mat4 u_skeletonGlobalMatriices[NUM_SKELETONJOINT];\r\n    #endif\r\n\r\n    vec4 skeletonAnimation(vec4 position) \r\n    {\r\n        vec4 totalPosition = vec4(0.0,0.0,0.0,1.0);\r\n        for(int i = 0; i < 4; i++)\r\n        {\r\n            totalPosition += u_skeletonGlobalMatriices[int(a_jointindex0[i])] * position * a_jointweight0[i];\r\n        }\r\n        #ifdef HAS_a_jointindex1\r\n            for(int i = 0; i < 4; i++)\r\n            {\r\n                totalPosition += u_skeletonGlobalMatriices[int(a_jointindex1[i])] * position * a_jointweight1[i];\r\n            }\r\n        #endif\r\n        position.xyz = totalPosition.xyz;\r\n        return position;\r\n    }\r\n#endif",
            "skeleton_vert": "#ifdef HAS_SKELETON_ANIMATION\r\n    position = skeletonAnimation(position);\r\n#endif",
            "specular_frag": "//获取高光值\r\nfloat glossiness = u_glossiness;\r\n//获取镜面反射基本颜色\r\nvec3 specularColor = u_specular;\r\nvec4 specularMapColor = texture2D(s_specular, v_uv);\r\nspecularColor.xyz = specularMapColor.xyz;\r\nglossiness = glossiness * specularMapColor.w;",
            "specular_pars_frag": "//镜面反射\r\nuniform vec3 u_specular;\r\nuniform float u_glossiness;\r\nuniform sampler2D s_specular;",
            "tangent_pars_vert": "attribute vec3 a_tangent;",
            "tangent_vert": "vec3 tangent = a_tangent;",
            "terrainDefault_pars_frag": "uniform sampler2D s_splatTexture1;\r\nuniform sampler2D s_splatTexture2;\r\nuniform sampler2D s_splatTexture3;\r\n\r\nuniform sampler2D s_blendTexture;\r\nuniform vec4 u_splatRepeats;\r\n\r\nvec4 terrainMethod(vec4 diffuseColor,vec2 v_uv) \r\n{\r\n    vec4 blend = texture2D(s_blendTexture, v_uv);\r\n\r\n    vec2 t_uv = v_uv.xy * u_splatRepeats.y;\r\n    vec4 tColor = texture2D(s_splatTexture1, t_uv);\r\n    diffuseColor = (tColor - diffuseColor) * blend.x + diffuseColor;\r\n\r\n    t_uv = v_uv.xy * u_splatRepeats.z;\r\n    tColor = texture2D(s_splatTexture2, t_uv);\r\n    diffuseColor = (tColor - diffuseColor) * blend.y + diffuseColor;\r\n\r\n    t_uv = v_uv.xy * u_splatRepeats.w;\r\n    tColor = texture2D(s_splatTexture3, t_uv);\r\n    diffuseColor = (tColor - diffuseColor) * blend.z + diffuseColor;\r\n\r\n    return diffuseColor;\r\n}",
            "terrainMerge_pars_frag": "//代码实现lod以及线性插值 feng\r\n#extension GL_EXT_shader_texture_lod : enable\r\n#extension GL_OES_standard_derivatives : enable\r\n\r\n#define LOD_LINEAR\r\n\r\nuniform sampler2D s_splatMergeTexture;\r\nuniform sampler2D s_blendTexture;\r\nuniform vec4 u_splatRepeats;\r\n\r\nuniform vec2 u_imageSize;\r\nuniform vec4 u_tileOffset[3];\r\nuniform vec4 u_lod0vec;\r\nuniform vec2 u_tileSize;\r\nuniform float u_maxLod;\r\nuniform float u_scaleByDepth;\r\nuniform float u_uvPositionScale;\r\n\r\n\r\nvec4 terrainTexture2DLod(sampler2D s_splatMergeTexture,vec2 uv,float lod,vec4 offset){\r\n\r\n    //计算不同lod像素缩放以及起始坐标\r\n    vec4 lodvec = u_lod0vec;\r\n    lodvec.x = lodvec.x * pow(0.5,lod);\r\n    lodvec.y = lodvec.x * 2.0;\r\n    lodvec.z = 1.0 - lodvec.y;\r\n\r\n    //lod块尺寸\r\n    vec2 lodSize = u_imageSize * lodvec.xy;\r\n    vec2 lodPixelOffset = 1.0 / lodSize * 2.0;\r\n\r\n    // uv = uv - 1.0 / lodPixelOffset;\r\n    vec2 mixFactor = mod(uv, lodPixelOffset) / lodPixelOffset;\r\n\r\n    //lod块中像素索引\r\n    vec2 t_uv = fract(uv + lodPixelOffset * vec2(0.0, 0.0));\r\n    t_uv = t_uv * offset.xy + offset.zw;\r\n    //添加lod起始坐标\r\n    t_uv = t_uv * lodvec.xy + lodvec.zw;\r\n    //取整像素\r\n    t_uv = floor(t_uv * u_imageSize) / u_imageSize;\r\n    vec4 tColor00 = texture2D(s_splatMergeTexture,t_uv);\r\n\r\n    t_uv = fract(uv + lodPixelOffset * vec2(1.0, 0.0));\r\n    t_uv = t_uv * offset.xy + offset.zw;\r\n    //添加lod起始坐标\r\n    t_uv = t_uv * lodvec.xy + lodvec.zw;\r\n    //取整像素\r\n    t_uv = floor(t_uv * u_imageSize) / u_imageSize;\r\n    vec4 tColor10 = texture2D(s_splatMergeTexture,t_uv);\r\n\r\n    t_uv = fract(uv + lodPixelOffset * vec2(0.0, 1.0));\r\n    t_uv = t_uv * offset.xy + offset.zw;\r\n    //添加lod起始坐标\r\n    t_uv = t_uv * lodvec.xy + lodvec.zw;\r\n    //取整像素\r\n    t_uv = floor(t_uv * u_imageSize) / u_imageSize;\r\n    vec4 tColor01 = texture2D(s_splatMergeTexture,t_uv);\r\n\r\n    t_uv = fract(uv + lodPixelOffset * vec2(1.0, 1.0));\r\n    t_uv = t_uv * offset.xy + offset.zw;\r\n    //添加lod起始坐标\r\n    t_uv = t_uv * lodvec.xy + lodvec.zw;\r\n    //取整像素\r\n    t_uv = floor(t_uv * u_imageSize) / u_imageSize;\r\n    vec4 tColor11 = texture2D(s_splatMergeTexture,t_uv);\r\n\r\n    vec4 tColor0 = mix(tColor00,tColor10,mixFactor.x);\r\n    vec4 tColor1 = mix(tColor01,tColor11,mixFactor.x);\r\n    vec4 tColor = mix(tColor0,tColor1,mixFactor.y);\r\n\r\n    return tColor;\r\n\r\n    // return vec4(mixFactor.x,mixFactor.y,0.0,1.0);\r\n    // return vec4(mixFactor.x + 0.5,mixFactor.y + 0.5,0.0,1.0);\r\n}\r\n\r\n//参考 http://blog.csdn.net/cgwbr/article/details/6620318\r\n//计算MipMap层函数：\r\nfloat mipmapLevel(vec2 uv)\r\n{\r\n    vec2 dx = dFdx(uv);\r\n    vec2 dy = dFdy(uv);\r\n    float d = max(dot(dx, dx), dot(dy, dy));\r\n    return 0.5 * log2(d);\r\n}\r\n\r\n//根据距离以及法线计算MipMap层函数：\r\nfloat mipmapLevel1(vec2 uv)\r\n{\r\n    //视线方向\r\n    vec3 cameraDir = u_cameraPos - v_worldPosition.xyz;\r\n    float fogDistance = length(cameraDir);\r\n    float value = u_scaleByDepth * fogDistance * u_uvPositionScale;//uv变化率与距离成正比，0.001为顶点位置与uv的变化比率\r\n    cameraDir = normalize(cameraDir);\r\n    float dd = clamp(dot(cameraDir, v_normal),0.05,1.0);//取法线与视线余弦值的倒数，余弦值越大（朝向摄像机时uv变化程度越低）lod越小\r\n    value = value / dd;\r\n    value = value * 0.5;//还没搞懂0.5的来历\r\n    return log2(value);\r\n}\r\n\r\nvec4 terrainTexture2D(sampler2D s_splatMergeTexture, vec2 t_uv, float lod, vec4 offset){\r\n \r\n    #ifdef LOD_LINEAR\r\n        vec4 tColor = mix(terrainTexture2DLod(s_splatMergeTexture, t_uv, floor(lod), offset),terrainTexture2DLod(s_splatMergeTexture, t_uv, ceil(lod), offset), fract(lod));\r\n    #else\r\n        vec4 tColor = terrainTexture2DLod(s_splatMergeTexture, t_uv, ceil(lod), offset);\r\n    #endif\r\n\r\n    return tColor;\r\n}\r\n\r\nvec4 terrainMethod(vec4 diffuseColor, vec2 v_uv) \r\n{\r\n    float lod = 0.0;\r\n    vec4 blend = texture2D(s_blendTexture, v_uv);\r\n    for(int i = 0; i < 3; i++)\r\n    {\r\n        vec2 t_uv = v_uv * u_splatRepeats[i];\r\n        // lod = mipmapLevel(v_uv) + log2(u_tileSize.x * u_splatRepeats[i]);\r\n        lod = mipmapLevel1(v_uv) + log2(u_tileSize.x * u_splatRepeats[i]);\r\n        lod = clamp(lod, 0.0, u_maxLod);\r\n        vec4 tColor = terrainTexture2D(s_splatMergeTexture, t_uv, lod, u_tileOffset[i]);\r\n        diffuseColor = (tColor - diffuseColor) * blend[i] + diffuseColor;\r\n    }\r\n\r\n    // diffuseColor.xyz = vec3(1.0,0.0,0.0);\r\n    // diffuseColor.xyz = vec3(lod/u_maxLod,0.0,0.0);\r\n    // diffuseColor.xyz = vec3(floor(lod)/u_maxLod,0.0,0.0);\r\n    return diffuseColor;\r\n}",
            "terrain_frag": "diffuseColor = terrainMethod(diffuseColor, v_uv);",
            "terrain_pars_frag": "#ifdef USE_TERRAIN_MERGE\r\n    #include<terrainMerge_pars_frag>\r\n#else\r\n    #include<terrainDefault_pars_frag>\r\n#endif",
            "uv_pars_vert": "attribute vec2 a_uv;\r\n\r\nvarying vec2 v_uv;",
            "uv_vert": "v_uv = a_uv;\r\n#ifdef SCALEU\r\n    #ifdef SCALEV\r\n    v_uv = v_uv * vec2(SCALEU,SCALEV);\r\n    #endif\r\n#endif",
            "worldposition_pars_vert": "uniform mat4 u_modelMatrix;\r\n\r\nvarying vec3 v_worldPosition;",
            "worldposition_vert": "//获取全局坐标\r\nvec4 worldPosition = u_modelMatrix * position;\r\n//输出全局坐标\r\nv_worldPosition = worldPosition.xyz;"
        }
    };
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    feng3d.lazy = {
        getvalue: function (lazyItem) {
            if (typeof lazyItem == "function")
                return lazyItem();
            return lazyItem;
        }
    };
})(feng3d || (feng3d = {}));
Object.isBaseType = function (object) {
    //基础类型
    if (object == undefined
        || object == null
        || typeof object == "boolean"
        || typeof object == "string"
        || typeof object == "number")
        return true;
};
Object.getPropertyDescriptor = function (host, property) {
    var data = Object.getOwnPropertyDescriptor(host, property);
    if (data) {
        return data;
    }
    var prototype = Object.getPrototypeOf(host);
    if (prototype) {
        return Object.getPropertyDescriptor(prototype, property);
    }
    return null;
};
Object.propertyIsWritable = function (host, property) {
    var data = Object.getPropertyDescriptor(host, property);
    if (!data)
        return false;
    if (data.get && !data.set)
        return false;
    return true;
};
Object.runFunc = function (obj, func) {
    func(obj);
    return obj;
};
Object.isObject = function (obj) {
    return obj != null && (obj.constructor == Object || (obj.constructor.name == "Object")); // 兼容其他 HTMLIFrameElement 传入的Object
};
Object.getPropertyValue = function (object, property) {
    if (typeof property == "string")
        property = property.split(".");
    var value = object;
    var len = property.length;
    for (var i = 0; i < property.length; i++) {
        if (value == null)
            return undefined;
        value = value[property[i]];
    }
    return value;
};
Object.getPropertyChains = function (object) {
    var result = [];
    // 属性名称列表
    var propertys = Object.keys(object);
    // 属性所属对象列表
    var hosts = new Array(propertys.length).fill(object);
    // 父属性所在编号列表
    var parentPropertyIndices = new Array(propertys.length).fill(-1);
    // 处理到的位置
    var index = 0;
    while (index < propertys.length) {
        var host = hosts[index];
        var cp = propertys[index];
        var cv = host[cp];
        var vks;
        if (cv == null || Object.isBaseType(cv) || (vks = Object.keys(cv)).length == 0) {
            // 处理叶子属性
            var ps = [cp];
            var ci = index;
            // 查找并组合属性链
            while ((ci = parentPropertyIndices[ci]) != -1) {
                ps.push(propertys[ci]);
            }
            ps.reverse();
            result.push(ps.join("."));
        }
        else {
            // 处理中间属性
            vks.forEach(function (k) {
                propertys.push(k);
                hosts.push(cv);
                parentPropertyIndices.push(index);
            });
        }
        index++;
    }
    return result;
};
Object.equalDeep = function (a, b) {
    if (a == b)
        return true;
    if (Object.isBaseType(a) || Object.isBaseType(b))
        return a == b;
    if (typeof a == "function" || typeof b == "function")
        return a == b;
    //
    var akeys = Object.keys(a);
    var bkeys = Object.keys(b);
    if (!akeys.equal(bkeys))
        return false;
    if (Array.isArray(a) && Array.isArray(b))
        return a.length == b.length;
    // 检测所有属性
    for (var i = 0; i < akeys.length; i++) {
        var element = akeys[i];
        if (!Object.equalDeep(a[element], b[element])) {
            return false;
        }
    }
    return true;
};
Object.assignShallow = function (target, source) {
    if (source == null)
        return target;
    var keys = Object.keys(source);
    keys.forEach(function (k) {
        target[k] = source[k];
    });
    return target;
};
Object.assignDeep = function (target, source, replacers, deep) {
    if (replacers === void 0) { replacers = []; }
    if (deep === void 0) { deep = Number.MAX_SAFE_INTEGER; }
    if (source == null)
        return target;
    if (deep < 1)
        return target;
    var keys = Object.keys(source);
    keys.forEach(function (k) {
        //
        var handles = [].concat(replacers).concat(Object.assignDeepDefaultHandlers);
        for (var i = 0; i < handles.length; i++) {
            if (handles[i](target, source, k, replacers, deep)) {
                return;
            }
        }
        //
        target[k] = source[k];
    });
    return target;
};
Object.assignDeepDefaultHandlers = [
    function (target, source, key) {
        if (target[key] == source[key])
            return true;
    },
    function (target, source, key) {
        if (Object.isBaseType(target[key]) || Object.isBaseType(source[key])) {
            target[key] = source[key];
            return true;
        }
    },
    function (target, source, key, handlers, deep) {
        if (Array.isArray(source[key]) || Object.isObject(source[key])) {
            Object.assignDeep(target[key], source[key], handlers, deep - 1);
            return true;
        }
    },
];
Map.prototype.getKeys = function () {
    var keys = [];
    this.forEach(function (v, k) {
        keys.push(k);
    });
    return keys;
};
Map.prototype.getValues = function () {
    var values = [];
    this.forEach(function (v, k) {
        values.push(v);
    });
    return values;
};
Array.prototype.equal = function (arr) {
    var self = this;
    if (self.length != arr.length)
        return false;
    var keys = Object.keys(arr);
    for (var i = 0, n = keys.length; i < n; i++) {
        var key = keys[i];
        if (self[key] != arr[key])
            return false;
    }
    return true;
};
Array.prototype.concatToSelf = function () {
    var items = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        items[_i] = arguments[_i];
    }
    var self = this;
    var arr = [];
    items.forEach(function (v) { return arr = arr.concat(v); });
    arr.forEach(function (v) { return self.push(v); });
    return self;
};
Array.prototype.unique = function (compare) {
    if (compare === void 0) { compare = function (a, b) { return a == b; }; }
    var arr = this;
    var keys = Object.keys(arr);
    var ids = keys.map(function (v) { return Number(v); }).filter(function (v) { return !isNaN(v); });
    var deleteMap = {};
    //
    for (var i = 0, n = ids.length; i < n; i++) {
        var ki = ids[i];
        if (deleteMap[ki])
            continue;
        for (var j = i + 1; j < n; j++) {
            var kj = ids[j];
            if (compare(arr[ki], arr[kj]))
                deleteMap[kj] = true;
        }
    }
    //
    for (var i = ids.length - 1; i >= 0; i--) {
        var id = ids[i];
        if (deleteMap[id])
            arr.splice(id, 1);
    }
    return this;
};
Array.prototype.delete = function (item) {
    var arr = this;
    var index = arr.indexOf(item);
    if (index != -1)
        arr.splice(index, 1);
    return index;
};
var feng3d;
(function (feng3d) {
    /**
     * 函数经
     *
     * 包装函数，以及对应的拆包
     */
    var FunctionWrap = /** @class */ (function () {
        function FunctionWrap() {
            this._wrapFResult = {};
            this._state = {};
        }
        /**
         * 包装函数
         *
         * 一般用于调试
         * 使用场景示例：
         * 1. 在函数执行前后记录时间来计算函数执行时间。
         * 1. 在console.error调用前使用 debugger 进行断点调试。
         *
         * @param object 函数所属对象或者原型
         * @param funcName 函数名称
         * @param wrapFunc 在函数执行前执行的函数
         * @param before 运行在原函数之前
         */
        FunctionWrap.prototype.wrap = function (object, funcName, wrapFunc, before) {
            if (before === void 0) { before = true; }
            if (wrapFunc == undefined)
                return;
            if (!Object.getOwnPropertyDescriptor(object, feng3d.__functionwrap__)) {
                Object.defineProperty(object, feng3d.__functionwrap__, { value: {}, configurable: true, enumerable: false, writable: false });
            }
            var functionwraps = object[feng3d.__functionwrap__];
            var info = functionwraps[funcName];
            if (!info) {
                var oldPropertyDescriptor = Object.getOwnPropertyDescriptor(object, funcName);
                var original = object[funcName];
                functionwraps[funcName] = info = { space: object, funcName: funcName, oldPropertyDescriptor: oldPropertyDescriptor, original: original, funcs: [original] };
            }
            var funcs = info.funcs;
            funcs.delete(wrapFunc);
            if (before)
                funcs.unshift(wrapFunc);
            else
                funcs.push(wrapFunc);
            object[funcName] = function () {
                var _this = this;
                var args = arguments;
                info.funcs.forEach(function (f) {
                    f.apply(_this, args);
                });
            };
        };
        /**
         * 取消包装函数
         *
         * 与wrap函数对应
         *
         * @param object 函数所属对象或者原型
         * @param funcName 函数名称
         * @param wrapFunc 在函数执行前执行的函数
         * @param before 运行在原函数之前
         */
        FunctionWrap.prototype.unwrap = function (object, funcName, wrapFunc) {
            var functionwraps = object[feng3d.__functionwrap__];
            var info = functionwraps[funcName];
            if (!info)
                return;
            if (wrapFunc == undefined) {
                info.funcs = [info.original];
            }
            else {
                info.funcs.delete(wrapFunc);
            }
            if (info.funcs.length == 1) {
                delete object[funcName];
                if (info.oldPropertyDescriptor)
                    Object.defineProperty(object, funcName, info.oldPropertyDescriptor);
                delete functionwraps[funcName];
                if (Object.keys(functionwraps).length == 0) {
                    delete object[feng3d.__functionwrap__];
                }
            }
        };
        /**
         * 包装一个异步函数，使其避免重复执行
         *
         * 使用场景示例：同时加载同一资源时，使其只加载一次，完成后调用所有相关回调函数。
         *
         * @param funcHost 函数所属对象
         * @param func 函数
         * @param params 函数除callback外的参数列表
         * @param callback 完成回调函数
         */
        FunctionWrap.prototype.wrapAsyncFunc = function (funcHost, func, params, callback) {
            var _this = this;
            // 获取唯一编号
            var cuuid = feng3d.uuid.getArrayUuid([func].concat(params));
            // 检查是否执行过
            var result = this._wrapFResult[cuuid];
            if (result) {
                callback.apply(null, result);
                return;
            }
            // 监听执行完成事件
            feng3d.event.once(this, cuuid, function () {
                // 完成时重新执行函数
                _this.wrapAsyncFunc(funcHost, func, params, callback);
            });
            // 正在执行时直接返回等待完成事件
            if (this._state[cuuid])
                return;
            // 标记正在执行中
            this._state[cuuid] = true;
            // 执行函数
            func.apply(funcHost, params.concat(function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                // 清理执行标记
                delete _this._state[cuuid];
                // 保存执行结果
                _this._wrapFResult[cuuid] = args;
                // 通知执行完成
                feng3d.event.dispatch(_this, cuuid);
            }));
        };
        return FunctionWrap;
    }());
    feng3d.FunctionWrap = FunctionWrap;
    feng3d.__functionwrap__ = "__functionwrap__";
    feng3d.functionwrap = new FunctionWrap();
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 通用唯一标识符（Universally Unique Identifier）
     *
     * 用于给所有对象分配一个通用唯一标识符
     */
    var Uuid = /** @class */ (function () {
        function Uuid() {
            this.objectUuid = new WeakMap();
        }
        /**
         * 获取数组 通用唯一标识符
         *
         * @param arr 数组
         * @param separator 分割符
         */
        Uuid.prototype.getArrayUuid = function (arr, separator) {
            var _this = this;
            if (separator === void 0) { separator = "$__uuid__$"; }
            var uuids = arr.map(function (v) { return _this.getObjectUuid(v); });
            var groupUuid = uuids.join(separator);
            return groupUuid;
        };
        /**
         * 获取对象 通用唯一标识符
         *
         * 当参数object非Object对象时强制转换为字符串返回
         *
         * @param object 对象
         */
        Uuid.prototype.getObjectUuid = function (object) {
            if (Object.isBaseType(object)) {
                return String(object);
            }
            if (!object[feng3d.__uuid__]) {
                Object.defineProperty(object, feng3d.__uuid__, { value: Math.uuid() });
            }
            return object[feng3d.__uuid__];
        };
        return Uuid;
    }());
    feng3d.Uuid = Uuid;
    feng3d.__uuid__ = "__uuid__";
    feng3d.uuid = new Uuid();
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 是否开启调试
     */
    feng3d.debuger = true;
    /**
     * 调试工具
     */
    var Debug = /** @class */ (function () {
        function Debug() {
            // 断言失败前进入断点调试
            feng3d.functionwrap.wrap(console, "assert", function (test) { if (!test)
                debugger; });
            // 输出错误前进入断点调试
            feng3d.functionwrap.wrap(console, "error", function () { debugger; });
            feng3d.functionwrap.wrap(console, "warn", function () { debugger; });
        }
        /**
         * 测试代码运行时间
         * @param fn 被测试的方法
         * @param labal 标签
         */
        Debug.prototype.time = function (fn, labal) {
            labal = labal || fn["name"] || "Anonymous function " + Math.random();
            console.time(labal);
            fn();
            console.timeEnd(labal);
        };
        return Debug;
    }());
    feng3d.Debug = Debug;
    feng3d.debug = new Debug();
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 序列化装饰器
     *
     * 在属性定义前使用 @serialize 进行标记需要序列化
     *
     * @param {*} target                序列化原型
     * @param {string} propertyKey      序列化属性
     */
    function serialize(target, propertyKey) {
        if (!Object.getOwnPropertyDescriptor(target, SERIALIZE_KEY)) {
            Object.defineProperty(target, SERIALIZE_KEY, { value: [] });
        }
        var serializePropertys = target[SERIALIZE_KEY];
        serializePropertys.push(propertyKey);
    }
    feng3d.serialize = serialize;
    /**
     * 序列化属性函数
     *
     * 序列化对象时建议使用 serialization.serialize
     *
     * @param target 序列化后的对象，存放序列化后属性值的对象。
     * @param source 被序列化的对象，提供序列化前属性值的对象。
     * @param property 序列化属性名称
     * @param handlers 序列化属性函数列表
     */
    function propertyHandler(target, source, property, handlers, serialization) {
        for (var i = 0; i < handlers.length; i++) {
            if (handlers[i](target, source, property, handlers, serialization)) {
                return true;
            }
        }
        return true;
    }
    /**
     * 序列化属性函数
     *
     * 序列化对象时建议使用 serialization.serialize
     *
     * @param target 序列化后的对象，存放序列化后属性值的对象。
     * @param source 被序列化的对象，提供序列化前属性值的对象。
     * @param property 序列化属性名称
     * @param handlers 序列化属性函数列表
     */
    function differentPropertyHandler(target, source, property, different, handlers, serialization) {
        for (var i = 0; i < handlers.length; i++) {
            if (handlers[i](target, source, property, different, handlers, serialization)) {
                return true;
            }
        }
        return true;
    }
    var __root__ = "__root__";
    /**
     * 序列化
     */
    var Serialization = /** @class */ (function () {
        function Serialization() {
            /**
             * 序列化函数列表
             */
            this.serializeHandlers = [];
            /**
             * 反序列化函数列表
             */
            this.deserializeHandlers = [];
            /**
             * 比较差异函数列表
             */
            this.differentHandlers = [];
            /**
             * 设置函数列表
             */
            this.setValueHandlers = [];
        }
        /**
         * 序列化对象
         *
         * 过程中使用 different与默认值作比较减少结果中的数据。
         *
         * @param target 被序列化的对象
         *
         * @returns 序列化后简单数据对象（由Object与Array组合可 JSON.stringify 的简单结构）
         */
        Serialization.prototype.serialize = function (target) {
            var handlers = this.serializeHandlers.sort(function (a, b) { return b.priority - a.priority; }).map(function (v) { return v.handler; });
            var result = {};
            propertyHandler(result, { __root__: target }, __root__, handlers, this);
            var v = result[__root__];
            return v;
        };
        /**
         * 反序列化对象为基础对象数据（由Object与Array组合）
         *
         * @param object 换为Json的对象
         * @returns 反序列化后的数据
         */
        Serialization.prototype.deserialize = function (object) {
            var handlers = this.deserializeHandlers.sort(function (a, b) { return b.priority - a.priority; }).map(function (v) { return v.handler; });
            var result = {};
            propertyHandler(result, { __root__: object }, __root__, handlers, this);
            var v = result[__root__];
            return v;
        };
        /**
         * 比较两个对象的不同，提取出不同的数据(可能会经过反序列化处理)
         *
         * @param target 用于检测不同的数据
         * @param source   模板（默认）数据
         * @param different 比较得出的不同（简单结构）数据
         *
         * @returns 比较得出的不同数据（由Object与Array组合可 JSON.stringify 的简单结构）
         */
        Serialization.prototype.different = function (target, source) {
            var handlers = this.differentHandlers.sort(function (a, b) { return b.priority - a.priority; }).map(function (v) { return v.handler; });
            var different = { __root__: {} };
            differentPropertyHandler({ __root__: target }, { __root__: source }, __root__, different, handlers, this);
            return different[__root__];
        };
        /**
         * 从数据对象中提取数据给目标对象赋值（可能会经过序列化处理）
         *
         * @param target 目标对象
         * @param source 数据对象 可由Object与Array以及自定义类型组合
         */
        Serialization.prototype.setValue = function (target, source) {
            var handlers = this.setValueHandlers.sort(function (a, b) { return b.priority - a.priority; }).map(function (v) { return v.handler; });
            propertyHandler({ __root__: target }, { __root__: source }, __root__, handlers, this);
            return target;
        };
        /**
         * 克隆
         * @param target 被克隆对象
         */
        Serialization.prototype.clone = function (target) {
            return this.deserialize(this.serialize(target));
        };
        return Serialization;
    }());
    feng3d.Serialization = Serialization;
    feng3d.CLASS_KEY = "__class__";
    var SERIALIZE_KEY = "_serialize__";
    /**
     * 获取序列化属性列表
     */
    function getSerializableMembers(object, serializableMembers) {
        serializableMembers = serializableMembers || [];
        if (object["__proto__"]) {
            getSerializableMembers(object["__proto__"], serializableMembers);
        }
        var serializePropertys = object[SERIALIZE_KEY];
        if (serializePropertys)
            serializableMembers.concatToSelf(serializePropertys);
        serializableMembers.unique();
        return serializableMembers;
    }
    feng3d.serialization = new Serialization();
    feng3d.serialization.serializeHandlers.push(
    //基础类型
    {
        priority: 0,
        handler: function (target, source, property) {
            var spv = source[property];
            if (Object.isBaseType(spv)) {
                target[property] = spv;
                return true;
            }
            return false;
        }
    }, 
    //处理方法
    {
        priority: 0,
        handler: function (target, source, property) {
            var spv = source[property];
            if (spv && typeof spv == "function") {
                var object = {};
                object[feng3d.CLASS_KEY] = "function";
                object.data = spv.toString();
                target[property] = object;
                return true;
            }
            return false;
        }
    }, 
    // 排除不支持序列化对象 serializable == false 时不进行序列化
    {
        priority: 0,
        handler: function (target, source, property) {
            var spv = source[property];
            if (spv && spv["serializable"] == false) {
                return true;
            }
            return false;
        }
    }, 
    // 处理 Feng3dObject
    {
        priority: 0,
        handler: function (target, source, property) {
            var spv = source[property];
            if (spv instanceof feng3d.Feng3dObject && (spv.hideFlags & feng3d.HideFlags.DontSave)) {
                return true;
            }
            return false;
        }
    }, 
    // 处理资源
    {
        priority: 0,
        handler: function (target, source, property) {
            var spv = source[property];
            if (feng3d.AssetData.isAssetData(spv)) {
                // 此处需要反序列化资源完整数据
                if (property == __root__) {
                    return false;
                }
                target[property] = feng3d.AssetData.serialize(spv);
                return true;
            }
            return false;
        }
    }, 
    // 自定义序列化函数
    {
        priority: 0,
        handler: function (target, source, property) {
            var spv = source[property];
            if (spv && spv["serialize"]) {
                var object = {};
                object[feng3d.CLASS_KEY] = feng3d.classUtils.getQualifiedClassName(spv);
                spv["serialize"](object);
                target[property] = object;
                return true;
            }
            return false;
        }
    }, 
    //处理数组
    {
        priority: 0,
        handler: function (target, source, property, handlers, serialization) {
            var spv = source[property];
            if (Array.isArray(spv)) {
                var arr_1 = target[property] || [];
                var keys = Object.keys(spv);
                keys.forEach(function (v) {
                    propertyHandler(arr_1, spv, v, handlers, serialization);
                });
                target[property] = arr_1;
                return true;
            }
            return false;
        }
    }, 
    //处理普通Object
    {
        priority: 0,
        handler: function (target, source, property, handlers, serialization) {
            var spv = source[property];
            if (Object.isObject(spv)) {
                var object_1 = {};
                var keys = Object.keys(spv);
                keys.forEach(function (key) {
                    propertyHandler(object_1, spv, key, handlers, serialization);
                });
                target[property] = object_1;
                return true;
            }
            return false;
        }
    }, 
    // 使用默认序列化
    {
        priority: -10000,
        handler: function (target, source, property, handlers, serialization) {
            var tpv = target[property];
            var spv = source[property];
            if (tpv == null || tpv.constructor != spv.constructor) {
                var className = feng3d.classUtils.getQualifiedClassName(spv);
                // 获取或创建对象默认实例，把默认实例保存在构造函数上省去使用map保存。
                var inst = spv.constructor.inst;
                if (!inst)
                    inst = spv.constructor.inst = new spv.constructor();
                // .constructor 上的属性会被继承
                if (!(inst instanceof spv.constructor))
                    inst = spv.constructor.inst = new spv.constructor();
                var diff = serialization.different(spv, inst);
                diff[feng3d.CLASS_KEY] = className;
                target[property] = diff;
            }
            else {
                debugger;
                var diff = serialization.different(spv, tpv);
                if (diff)
                    target[property] = diff;
            }
            return true;
        }
    });
    feng3d.serialization.deserializeHandlers.push(
    //基础类型
    {
        priority: 0,
        handler: function (target, source, property) {
            var spv = source[property];
            if (Object.isBaseType(spv)) {
                target[property] = spv;
                return true;
            }
            return false;
        }
    }, 
    //处理方法
    {
        priority: 0,
        handler: function (target, source, property) {
            var spv = source[property];
            if (spv && spv[feng3d.CLASS_KEY] == "function") {
                target[property] = eval("(" + spv.data + ")");
                return true;
            }
            return false;
        }
    }, 
    // 处理非原生Object对象
    {
        priority: 0,
        handler: function (target, source, property) {
            var spv = source[property];
            if (!Object.isObject(spv) && !Array.isArray(spv)) {
                target[property] = spv;
                return true;
            }
            return false;
        }
    }, 
    // 处理资源
    {
        priority: 0,
        handler: function (target, source, property, handlers, serialization) {
            var tpv = target[property];
            var spv = source[property];
            if (feng3d.AssetData.isAssetData(spv)) {
                // 此处需要反序列化资源完整数据
                if (property == __root__) {
                    return false;
                }
                target[property] = feng3d.AssetData.deserialize(spv);
                return true;
            }
            if (feng3d.AssetData.isAssetData(tpv)) {
                target[property] = serialization.deserialize(spv);
                return true;
            }
            return false;
        }
    }, 
    //处理数组
    {
        priority: 0,
        handler: function (target, source, property, handlers, serialization) {
            var spv = source[property];
            if (Array.isArray(spv)) {
                var arr = target[property] || [];
                var keys = Object.keys(spv);
                keys.forEach(function (key) {
                    propertyHandler(arr, spv, key, handlers, serialization);
                });
                target[property] = arr;
                return true;
            }
            return false;
        }
    }, 
    // 处理 没有类名称标记的 普通Object
    {
        priority: 0,
        handler: function (target, source, property, handlers, serialization) {
            var tpv = target[property];
            var spv = source[property];
            if (Object.isObject(spv) && spv[feng3d.CLASS_KEY] == null) {
                var obj = {};
                if (tpv)
                    obj = tpv;
                //
                var keys = Object.keys(spv);
                keys.forEach(function (key) {
                    propertyHandler(obj, spv, key, handlers, serialization);
                });
                target[property] = obj;
                return true;
            }
            return false;
        }
    }, 
    // 处理自定义反序列化对象
    {
        priority: 0,
        handler: function (target, source, property) {
            var tpv = target[property];
            var spv = source[property];
            var inst = feng3d.classUtils.getInstanceByName(spv[feng3d.CLASS_KEY]);
            //处理自定义反序列化对象
            if (inst && inst["deserialize"]) {
                if (tpv && tpv.constructor == inst.constructor) {
                    inst = tpv;
                }
                inst["deserialize"](spv);
                target[property] = inst;
                return true;
            }
            return false;
        }
    }, 
    // 处理自定义对象的反序列化 
    {
        priority: -10000,
        handler: function (target, source, property, handlers, serialization) {
            var tpv = target[property];
            var spv = source[property];
            var inst = feng3d.classUtils.getInstanceByName(spv[feng3d.CLASS_KEY]);
            if (inst) {
                if (tpv && tpv.constructor == inst.constructor) {
                    inst = tpv;
                }
                //默认反序列
                var keys = Object.keys(spv);
                keys.forEach(function (key) {
                    if (key != feng3d.CLASS_KEY)
                        propertyHandler(inst, spv, key, handlers, serialization);
                });
                target[property] = inst;
                return true;
            }
            console.warn("\u672A\u5904\u7406");
            return false;
        }
    });
    feng3d.serialization.differentHandlers = [
        // 相等对象
        {
            priority: 0,
            handler: function (target, source, property) {
                if (target[property] == source[property]) {
                    return true;
                }
                return false;
            }
        },
        // 目标数据为null时
        {
            priority: 0,
            handler: function (target, source, property, different, handlers, serialization) {
                if (null == source[property]) {
                    different[property] = serialization.serialize(target[property]);
                    return true;
                }
                return false;
            }
        },
        // 基础类型
        {
            priority: 0,
            handler: function (target, source, property, different, handlers, serialization) {
                var tpv = target[property];
                if (Object.isBaseType(tpv)) {
                    different[property] = tpv;
                    return true;
                }
                return false;
            }
        },
        // 数组
        {
            priority: 0,
            handler: function (target, source, property, different, handlers, serialization) {
                var tpv = target[property];
                var spv = source[property];
                if (Array.isArray(tpv)) {
                    var keys = Object.keys(tpv);
                    var diff = [];
                    keys.forEach(function (key) {
                        differentPropertyHandler(tpv, spv, key, diff, handlers, serialization);
                    });
                    if (Object.keys(diff).length > 0)
                        different[property] = diff;
                    return true;
                }
                return false;
            }
        },
        // 不同对象类型
        {
            priority: 0,
            handler: function (target, source, property, different, handlers, serialization) {
                var tpv = target[property];
                var spv = source[property];
                if (spv.constructor != tpv.constructor) {
                    different[property] = serialization.serialize(tpv);
                    return true;
                }
                return false;
            }
        },
        // 资源
        {
            priority: 0,
            handler: function (target, source, property, different, handlers, serialization) {
                var tpv = target[property];
                if (feng3d.AssetData.isAssetData(tpv)) {
                    // 此处需要反序列化资源完整数据
                    if (property == __root__) {
                        return false;
                    }
                    different[property] = feng3d.AssetData.serialize(tpv);
                    return true;
                }
                return false;
            }
        },
        // 默认处理
        {
            priority: -10000,
            handler: function (target, source, property, different, handlers, serialization) {
                var tpv = target[property];
                var spv = source[property];
                var keys = getSerializableMembers(tpv);
                if (tpv.constructor == Object)
                    keys = Object.keys(tpv);
                var diff = {};
                keys.forEach(function (v) {
                    differentPropertyHandler(tpv, spv, v, diff, handlers, serialization);
                });
                if (Object.keys(diff).length > 0)
                    different[property] = diff;
                return true;
            }
        },
    ];
    /**
     * 设置函数列表
     */
    feng3d.serialization.setValueHandlers = [
        // 值相等时直接返回
        {
            priority: 0,
            handler: function (target, source, property, handlers) {
                if (target[property] == source[property]) {
                    return true;
                }
                return false;
            }
        },
        // 当原值等于null时直接反序列化赋值
        {
            priority: 0,
            handler: function (target, source, property, handlers, serialization) {
                var tpv = target[property];
                var spv = source[property];
                if (tpv == null) {
                    target[property] = serialization.deserialize(spv);
                    return true;
                }
                return false;
            }
        },
        // 处理简单类型
        {
            priority: 0,
            handler: function (target, source, property, handlers) {
                var tpv = target[property];
                var spv = source[property];
                if (Object.isBaseType(spv)) {
                    target[property] = spv;
                    return true;
                }
                return false;
            }
        },
        // 处理数组
        {
            priority: 0,
            handler: function (target, source, property, handlers, serialization) {
                var tpv = target[property];
                var spv = source[property];
                if (Array.isArray(spv)) {
                    feng3d.debuger && console.assert(!!tpv);
                    var keys = Object.keys(spv);
                    keys.forEach(function (key) {
                        propertyHandler(tpv, spv, key, handlers, serialization);
                    });
                    target[property] = tpv;
                    return true;
                }
                return false;
            }
        },
        // 处理非 Object 类型数据
        {
            priority: 0,
            handler: function (target, source, property, handlers, serialization) {
                var tpv = target[property];
                var spv = source[property];
                if (!Object.isObject(spv)) {
                    target[property] = serialization.deserialize(spv);
                    return true;
                }
                return false;
            }
        },
        // 处理资源
        {
            priority: 0,
            handler: function (target, source, property, handlers, serialization) {
                var tpv = target[property];
                var spv = source[property];
                if (feng3d.AssetData.isAssetData(spv)) {
                    // 此处需要反序列化资源完整数据
                    if (property == __root__) {
                        return false;
                    }
                    target[property] = feng3d.AssetData.deserialize(spv);
                    return true;
                }
                if (feng3d.AssetData.isAssetData(tpv)) {
                    if (spv.__class__ == null) {
                        var className = feng3d.classUtils.getQualifiedClassName(tpv);
                        var inst = feng3d.classUtils.getInstanceByName(className);
                        serialization.setValue(inst, spv);
                        target[property] = inst;
                    }
                    else {
                        target[property] = serialization.deserialize(spv);
                    }
                    return true;
                }
                return false;
            }
        },
        // 处理 Object 基础类型数据
        {
            priority: 0,
            handler: function (target, source, property, handlers, serialization) {
                var tpv = target[property];
                var spv = source[property];
                if (Object.isObject(spv) && spv[feng3d.CLASS_KEY] == undefined) {
                    feng3d.debuger && console.assert(!!tpv);
                    var keys = Object.keys(spv);
                    keys.forEach(function (key) {
                        propertyHandler(tpv, spv, key, handlers, serialization);
                    });
                    target[property] = tpv;
                    return true;
                }
                return false;
            }
        },
        // 处理自定义类型
        {
            priority: -10000,
            handler: function (target, source, property, handlers, serialization) {
                var tpv = target[property];
                var spv = source[property];
                var targetClassName = feng3d.classUtils.getQualifiedClassName(target[property]);
                // 相同对象类型
                if (targetClassName == spv[feng3d.CLASS_KEY]) {
                    var keys = Object.keys(spv);
                    keys.forEach(function (key) {
                        propertyHandler(tpv, spv, key, handlers, serialization);
                    });
                    target[property] = tpv;
                }
                else {
                    // 不同对象类型
                    target[property] = serialization.deserialize(spv);
                }
                return true;
            }
        },
    ];
})(feng3d || (feng3d = {}));
// [Float32Array, Float64Array, Int8Array, Int16Array, Int32Array, Uint8Array, Uint16Array, Uint32Array, Uint8ClampedArray].forEach(element =>
// {
//     element.prototype["serialize"] = function (object: { value: number[] })
//     {
//         object.value = Array.from(this);
//         return object;
//     }
//     element.prototype["deserialize"] = function (object: { value: number[] })
//     {
//         return new (<any>(this.constructor))(object.value);
//     }
// });
var feng3d;
(function (feng3d) {
    /**
     * 标记objectview对象界面类
     */
    function OVComponent(component) {
        return function (constructor) {
            component = component || constructor["name"];
            feng3d.objectview.OVComponent[component] = constructor;
        };
    }
    feng3d.OVComponent = OVComponent;
    /**
     * 标记objectview块界面类
     */
    function OBVComponent(component) {
        return function (constructor) {
            component = component || constructor["name"];
            feng3d.objectview.OBVComponent[component] = constructor;
        };
    }
    feng3d.OBVComponent = OBVComponent;
    /**
     * 标记objectview属性界面类
     */
    function OAVComponent(component) {
        return function (constructor) {
            component = component || constructor["name"];
            feng3d.objectview.OAVComponent[component] = constructor;
        };
    }
    feng3d.OAVComponent = OAVComponent;
    /**
     * objectview类装饰器
     */
    function ov(param) {
        return function (constructor) {
            if (!Object.getOwnPropertyDescriptor(constructor["prototype"], OBJECTVIEW_KEY))
                constructor["prototype"][OBJECTVIEW_KEY] = {};
            var objectview = constructor["prototype"][OBJECTVIEW_KEY];
            objectview.component = param.component;
            objectview.componentParam = param.componentParam;
        };
    }
    feng3d.ov = ov;
    /**
     * objectview属性装饰器
     * @param param 参数
     */
    function oav(param) {
        return function (target, propertyKey) {
            feng3d.objectview.addOAV(target, propertyKey, param);
        };
    }
    feng3d.oav = oav;
    /**
     * 对象界面
     */
    var ObjectView = /** @class */ (function () {
        function ObjectView() {
            /**
             * 默认基础类型对象界面类定义
             */
            this.defaultBaseObjectViewClass = "";
            /**
             * 默认对象界面类定义
             */
            this.defaultObjectViewClass = "";
            /**
             * 默认对象属性界面类定义
             */
            this.defaultObjectAttributeViewClass = "";
            /**
             * 属性块默认界面
             */
            this.defaultObjectAttributeBlockView = "";
            /**
             * 指定属性类型界面类定义字典（key:属性类名称,value:属性界面类定义）
             */
            this.defaultTypeAttributeView = {};
            this.OAVComponent = {};
            this.OBVComponent = {};
            this.OVComponent = {};
        }
        ObjectView.prototype.setDefaultTypeAttributeView = function (type, component) {
            this.defaultTypeAttributeView[type] = component;
        };
        /**
         * 获取对象界面
         * @param object 用于生成界面的对象
         * @param param 参数
         */
        ObjectView.prototype.getObjectView = function (object, param) {
            var p = { autocreate: true, excludeAttrs: [] };
            Object.assign(p, param);
            var classConfig = this.getObjectInfo(object, p.autocreate, p.excludeAttrs);
            classConfig.editable = classConfig.editable == undefined ? true : classConfig.editable;
            Object.assign(classConfig, param);
            // 处理 exclude
            classConfig.objectAttributeInfos = classConfig.objectAttributeInfos.filter(function (v) { return !v.exclude; });
            classConfig.objectBlockInfos.forEach(function (v) {
                v.itemList = v.itemList.filter(function (vv) { return !vv.exclude; });
            });
            classConfig.objectAttributeInfos.forEach(function (v) { v.editable = v.editable && classConfig.editable; });
            if (classConfig.component == null || classConfig.component == "") {
                //返回基础类型界面类定义
                if (!(classConfig.owner instanceof Object)) {
                    classConfig.component = this.defaultBaseObjectViewClass;
                }
                else {
                    //使用默认类型界面类定义
                    classConfig.component = this.defaultObjectViewClass;
                }
            }
            var cls = this.OVComponent[classConfig.component];
            feng3d.debuger && console.assert(cls != null, "\u6CA1\u6709\u5B9A\u4E49 " + classConfig.component + " \u5BF9\u5E94\u7684\u5BF9\u8C61\u754C\u9762\u7C7B\uFF0C\u9700\u8981\u5728 " + classConfig.component + " \u4E2D\u4F7F\u7528@OVComponent()\u6807\u8BB0");
            var view = new cls(classConfig);
            return view;
        };
        /**
         * 获取属性界面
         *
         * @static
         * @param {AttributeViewInfo} attributeViewInfo			属性界面信息
         * @returns {egret.DisplayObject}						属性界面
         *
         * @memberOf ObjectView
         */
        ObjectView.prototype.getAttributeView = function (attributeViewInfo) {
            if (attributeViewInfo.component == null || attributeViewInfo.component == "") {
                var defaultViewClass = this.defaultTypeAttributeView[attributeViewInfo.type];
                var tempComponent = defaultViewClass ? defaultViewClass.component : "";
                if (tempComponent != null && tempComponent != "") {
                    attributeViewInfo.component = defaultViewClass.component;
                    attributeViewInfo.componentParam = defaultViewClass.componentParam || attributeViewInfo.componentParam;
                }
            }
            if (attributeViewInfo.component == null || attributeViewInfo.component == "") {
                //使用默认对象属性界面类定义
                attributeViewInfo.component = this.defaultObjectAttributeViewClass;
            }
            var cls = this.OAVComponent[attributeViewInfo.component];
            feng3d.debuger && console.assert(cls != null, "\u6CA1\u6709\u5B9A\u4E49 " + attributeViewInfo.component + " \u5BF9\u5E94\u7684\u5C5E\u6027\u754C\u9762\u7C7B\uFF0C\u9700\u8981\u5728 " + attributeViewInfo.component + " \u4E2D\u4F7F\u7528@OVAComponent()\u6807\u8BB0");
            var view = new cls(attributeViewInfo);
            return view;
        };
        /**
         * 获取块界面
         *
         * @static
         * @param {BlockViewInfo} blockViewInfo			块界面信息
         * @returns {egret.DisplayObject}				块界面
         *
         * @memberOf ObjectView
         */
        ObjectView.prototype.getBlockView = function (blockViewInfo) {
            if (blockViewInfo.component == null || blockViewInfo.component == "") {
                //返回默认对象属性界面类定义
                blockViewInfo.component = this.defaultObjectAttributeBlockView;
            }
            var cls = this.OBVComponent[blockViewInfo.component];
            feng3d.debuger && console.assert(cls != null, "\u6CA1\u6709\u5B9A\u4E49 " + blockViewInfo.component + " \u5BF9\u5E94\u7684\u5757\u754C\u9762\u7C7B\uFF0C\u9700\u8981\u5728 " + blockViewInfo.component + " \u4E2D\u4F7F\u7528@OVBComponent()\u6807\u8BB0");
            var view = new cls(blockViewInfo);
            return view;
        };
        ObjectView.prototype.addOAV = function (target, propertyKey, param) {
            if (!Object.getOwnPropertyDescriptor(target, OBJECTVIEW_KEY))
                target[OBJECTVIEW_KEY] = {};
            var objectview = target[OBJECTVIEW_KEY] || {};
            var attributeDefinitionVec = objectview.attributeDefinitionVec = objectview.attributeDefinitionVec || [];
            var attributeDefinition = Object.assign({ name: propertyKey }, param);
            attributeDefinitionVec.push(attributeDefinition);
        };
        /**
         * 获取对象信息
         * @param object				对象
         * @param autocreate			当对象没有注册属性时是否自动创建属性信息
         * @param excludeAttrs			排除属性列表
         * @return
         */
        ObjectView.prototype.getObjectInfo = function (object, autocreate, excludeAttrs) {
            if (autocreate === void 0) { autocreate = true; }
            if (excludeAttrs === void 0) { excludeAttrs = []; }
            if (typeof object == "string" || typeof object == "number" || typeof object == "boolean") {
                return {
                    objectAttributeInfos: [],
                    objectBlockInfos: [],
                    owner: object,
                    component: "",
                    componentParam: undefined
                };
            }
            var classConfig = getInheritClassDefinition(object, autocreate);
            classConfig = classConfig || {
                component: "",
                componentParam: null,
                attributeDefinitionVec: [],
                blockDefinitionVec: [],
            };
            var objectAttributeInfos = [];
            classConfig.attributeDefinitionVec.forEach(function (attributeDefinition) {
                if (excludeAttrs.indexOf(attributeDefinition.name) == -1) {
                    var editable = attributeDefinition.editable == undefined ? true : attributeDefinition.editable;
                    editable = editable && Object.propertyIsWritable(object, attributeDefinition.name);
                    var obj = { owner: object, type: getAttributeType(object[attributeDefinition.name]) };
                    Object.assign(obj, attributeDefinition);
                    obj.editable = editable;
                    objectAttributeInfos.push(obj);
                }
            });
            function getAttributeType(attribute) {
                if (attribute == null)
                    return "null";
                if (typeof attribute == "number")
                    return "number";
                return attribute.constructor.name;
            }
            objectAttributeInfos.forEach(function (v, i) { v["___tempI"] = i; });
            objectAttributeInfos.sort(function (a, b) {
                return ((a.priority || 0) - (b.priority || 0)) || (a["___tempI"] - b["___tempI"]);
            });
            objectAttributeInfos.forEach(function (v, i) { delete v["___tempI"]; });
            var objectInfo = {
                objectAttributeInfos: objectAttributeInfos,
                objectBlockInfos: getObjectBlockInfos(object, objectAttributeInfos, classConfig.blockDefinitionVec),
                owner: object,
                component: classConfig.component,
                componentParam: classConfig.componentParam
            };
            return objectInfo;
        };
        return ObjectView;
    }());
    feng3d.ObjectView = ObjectView;
    feng3d.objectview = new ObjectView();
    var OBJECTVIEW_KEY = "__objectview__";
    function mergeClassDefinition(oldClassDefinition, newClassDefinition) {
        if (newClassDefinition.component && newClassDefinition.component.length > 0) {
            oldClassDefinition.component = newClassDefinition.component;
            oldClassDefinition.componentParam = newClassDefinition.componentParam;
        }
        //合并属性
        oldClassDefinition.attributeDefinitionVec = oldClassDefinition.attributeDefinitionVec || [];
        if (newClassDefinition.attributeDefinitionVec && newClassDefinition.attributeDefinitionVec.length > 0) {
            newClassDefinition.attributeDefinitionVec.forEach(function (newAttributeDefinition) {
                var isfound = false;
                oldClassDefinition.attributeDefinitionVec.forEach(function (oldAttributeDefinition) {
                    if (newAttributeDefinition && oldAttributeDefinition.name == newAttributeDefinition.name) {
                        Object.assign(oldAttributeDefinition, newAttributeDefinition);
                        //
                        var oldIndex = oldClassDefinition.attributeDefinitionVec.indexOf(oldAttributeDefinition);
                        oldClassDefinition.attributeDefinitionVec.splice(oldIndex, 1);
                        //
                        oldClassDefinition.attributeDefinitionVec.push(oldAttributeDefinition);
                        isfound = true;
                    }
                });
                if (!isfound) {
                    var attributeDefinition = {};
                    Object.assign(attributeDefinition, newAttributeDefinition);
                    oldClassDefinition.attributeDefinitionVec.push(attributeDefinition);
                }
            });
        }
        //合并块
        oldClassDefinition.blockDefinitionVec = oldClassDefinition.blockDefinitionVec || [];
        if (newClassDefinition.blockDefinitionVec && newClassDefinition.blockDefinitionVec.length > 0) {
            newClassDefinition.blockDefinitionVec.forEach(function (newBlockDefinition) {
                var isfound = false;
                oldClassDefinition.blockDefinitionVec.forEach(function (oldBlockDefinition) {
                    if (newBlockDefinition && newBlockDefinition.name == oldBlockDefinition.name) {
                        Object.assign(oldBlockDefinition, newBlockDefinition);
                        isfound = true;
                    }
                });
                if (!isfound) {
                    var blockDefinition = {};
                    Object.assign(blockDefinition, newBlockDefinition);
                    oldClassDefinition.blockDefinitionVec.push(blockDefinition);
                }
            });
        }
    }
    function getInheritClassDefinition(object, autocreate) {
        if (autocreate === void 0) { autocreate = true; }
        var classConfigVec = [];
        var prototype = object;
        while (prototype) {
            var classConfig = prototype[OBJECTVIEW_KEY];
            if (classConfig)
                classConfigVec.push(classConfig);
            prototype = prototype["__proto__"];
        }
        var resultclassConfig;
        if (classConfigVec.length > 0) {
            resultclassConfig = {};
            for (var i = classConfigVec.length - 1; i >= 0; i--) {
                mergeClassDefinition(resultclassConfig, classConfigVec[i]);
            }
        }
        else if (autocreate) {
            resultclassConfig = getDefaultClassConfig(object);
        }
        return resultclassConfig;
    }
    function getDefaultClassConfig(object, filterReg) {
        if (filterReg === void 0) { filterReg = /(([a-zA-Z0-9])+|(\d+))/; }
        //
        var attributeNames = [];
        for (var key in object) {
            var result = filterReg.exec(key);
            if (result && result[0] == key) {
                var value = object[key];
                if (value === undefined || value instanceof Function)
                    continue;
                attributeNames.push(key);
            }
        }
        attributeNames = attributeNames.sort();
        var attributeDefinitionVec = [];
        attributeNames.forEach(function (element) {
            attributeDefinitionVec.push({
                name: element,
                block: "",
            });
        });
        var defaultClassConfig = {
            component: "",
            attributeDefinitionVec: attributeDefinitionVec,
            blockDefinitionVec: []
        };
        return defaultClassConfig;
    }
    /**
     * 获取对象块信息列表
     * @param {Object} object			对象
     * @returns {BlockViewInfo[]}		对象块信息列表
     */
    function getObjectBlockInfos(object, objectAttributeInfos, blockDefinitionVec) {
        var objectBlockInfos = [];
        var dic = {};
        var objectBlockInfo;
        //收集块信息
        var i = 0;
        var tempVec = [];
        for (i = 0; i < objectAttributeInfos.length; i++) {
            var blockName = objectAttributeInfos[i].block || "";
            objectBlockInfo = dic[blockName];
            if (objectBlockInfo == null) {
                objectBlockInfo = dic[blockName] = { name: blockName, owner: object, itemList: [] };
                tempVec.push(objectBlockInfo);
            }
            objectBlockInfo.itemList.push(objectAttributeInfos[i]);
        }
        //按快的默认顺序生成 块信息列表
        var blockDefinition;
        var pushDic = {};
        if (blockDefinitionVec) {
            for (i = 0; i < blockDefinitionVec.length; i++) {
                blockDefinition = blockDefinitionVec[i];
                objectBlockInfo = dic[blockDefinition.name];
                if (objectBlockInfo == null) {
                    objectBlockInfo = {
                        name: blockDefinition.name,
                        owner: object,
                        itemList: []
                    };
                }
                objectBlockInfo.component = blockDefinition.component;
                objectBlockInfo.componentParam = blockDefinition.componentParam;
                objectBlockInfos.push(objectBlockInfo);
                pushDic[objectBlockInfo.name] = true;
            }
        }
        //添加剩余的块信息
        for (i = 0; i < tempVec.length; i++) {
            if (Boolean(pushDic[tempVec[i].name]) == false) {
                objectBlockInfos.push(tempVec[i]);
            }
        }
        return objectBlockInfos;
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 心跳计时器
     */
    var Ticker = /** @class */ (function () {
        function Ticker() {
            /**
             * 帧率
             */
            this.frameRate = 60;
        }
        /**
         * 注册帧函数
         * @param func  执行方法
         * @param thisObject    方法this指针
         * @param priority      执行优先级
         */
        Ticker.prototype.onframe = function (func, thisObject, priority) {
            var _this = this;
            if (priority === void 0) { priority = 0; }
            this.on(function () { return 1000 / _this.frameRate; }, func, thisObject, priority);
            return this;
        };
        /**
         * 下一帧执行方法
         * @param func  执行方法
         * @param thisObject    方法this指针
         * @param priority      执行优先级
         */
        Ticker.prototype.nextframe = function (func, thisObject, priority) {
            var _this = this;
            if (priority === void 0) { priority = 0; }
            this.once(function () { return 1000 / _this.frameRate; }, func, thisObject, priority);
            return this;
        };
        /**
         * 注销帧函数（只执行一次）
         * @param func  执行方法
         * @param thisObject    方法this指针
         * @param priority      执行优先级
         */
        Ticker.prototype.offframe = function (func, thisObject) {
            var _this = this;
            this.off(function () { return 1000 / _this.frameRate; }, func, thisObject);
            return this;
        };
        /**
         * 注册周期函数
         * @param interval  执行周期，以ms为单位
         * @param func  执行方法
         * @param thisObject    方法this指针
         * @param priority      执行优先级
         */
        Ticker.prototype.on = function (interval, func, thisObject, priority) {
            if (priority === void 0) { priority = 0; }
            addTickerFunc({ interval: interval, func: func, thisObject: thisObject, priority: priority, once: false });
            return this;
        };
        /**
         * 注册周期函数（只执行一次）
         * @param interval  执行周期，以ms为单位
         * @param func  执行方法
         * @param thisObject    方法this指针
         * @param priority      执行优先级
         */
        Ticker.prototype.once = function (interval, func, thisObject, priority) {
            if (priority === void 0) { priority = 0; }
            addTickerFunc({ interval: interval, func: func, thisObject: thisObject, priority: priority, once: true });
            return this;
        };
        /**
         * 注销周期函数
         * @param interval  执行周期，以ms为单位
         * @param func  执行方法
         * @param thisObject    方法this指针
         */
        Ticker.prototype.off = function (interval, func, thisObject) {
            removeTickerFunc({ interval: interval, func: func, thisObject: thisObject });
            return this;
        };
        /**
         * 重复指定次数 执行函数
         * @param interval  执行周期，以ms为单位
         * @param 	repeatCount     执行次数
         * @param func  执行方法
         * @param thisObject    方法this指针
         * @param priority      执行优先级
         */
        Ticker.prototype.repeat = function (interval, repeatCount, func, thisObject, priority) {
            if (priority === void 0) { priority = 0; }
            repeatCount = ~~repeatCount;
            if (repeatCount < 1)
                return;
            var timer = new Timer(this, interval, repeatCount, func, thisObject, priority);
            return timer;
        };
        return Ticker;
    }());
    feng3d.Ticker = Ticker;
    feng3d.ticker = new Ticker();
    var Timer = /** @class */ (function () {
        function Timer(ticker, interval, repeatCount, func, thisObject, priority) {
            if (priority === void 0) { priority = 0; }
            /**
             * 计时器从 0 开始后触发的总次数。
             */
            this.currentCount = 0;
            this.ticker = ticker;
            this.interval = interval;
            this.func = func;
            this.thisObject = thisObject;
            this.priority = priority;
        }
        /**
         * 如果计时器尚未运行，则启动计时器。
         */
        Timer.prototype.start = function () {
            this.ticker.on(this.interval, this.runfunc, this, this.priority);
            return this;
        };
        /**
         * 停止计时器。
         */
        Timer.prototype.stop = function () {
            this.ticker.off(this.interval, this.runfunc, this);
            return this;
        };
        /**
         * 如果计时器正在运行，则停止计时器，并将 currentCount 属性设回为 0，这类似于秒表的重置按钮。
         */
        Timer.prototype.reset = function () {
            this.stop();
            this.currentCount = 0;
            return this;
        };
        Timer.prototype.runfunc = function () {
            this.currentCount++;
            this.repeatCount--;
            this.func.call(this.thisObject, feng3d.lazy.getvalue(this.interval));
            if (this.repeatCount < 1)
                this.stop();
        };
        return Timer;
    }());
    feng3d.Timer = Timer;
    var tickerFuncs = [];
    function addTickerFunc(item) {
        if (running) {
            affers.push([addTickerFunc, [item]]);
            return;
        }
        // removeTickerFunc(item);
        if (item.priority == undefined)
            item.priority = 0;
        item.runtime = Date.now() + feng3d.lazy.getvalue(item.interval);
        tickerFuncs.push(item);
    }
    function removeTickerFunc(item) {
        if (running) {
            affers.push([removeTickerFunc, [item]]);
            return;
        }
        for (var i = tickerFuncs.length - 1; i >= 0; i--) {
            var element = tickerFuncs[i];
            if (feng3d.lazy.getvalue(element.interval) == feng3d.lazy.getvalue(item.interval)
                && element.func == item.func
                && element.thisObject == item.thisObject) {
                tickerFuncs.splice(i, 1);
            }
        }
    }
    var running = false;
    var affers = [];
    function runTickerFuncs() {
        running = true;
        //倒序，优先级高的排在后面
        tickerFuncs.sort(function (a, b) {
            return a.priority - b.priority;
        });
        var currenttime = Date.now();
        var needTickerFuncItems = [];
        for (var i = tickerFuncs.length - 1; i >= 0; i--) {
            var element = tickerFuncs[i];
            if (element.runtime < currenttime) {
                needTickerFuncItems.push(element);
                if (element.once) {
                    tickerFuncs.splice(i, 1);
                    continue;
                }
                element.runtime = nextRuntime(element.runtime, feng3d.lazy.getvalue(element.interval));
            }
        }
        needTickerFuncItems.reverse();
        // 相同的函数只执行一个
        needTickerFuncItems.unique(function (a, b) { return (a.func == b.func && a.thisObject == b.thisObject); });
        needTickerFuncItems.forEach(function (v) {
            // try
            // {
            v.func.call(v.thisObject, feng3d.lazy.getvalue(v.interval));
            // } catch (error)
            // {
            //     console.warn(`${v.func} 方法执行错误，从 ticker 中移除`, error)
            //     var index = tickerFuncs.indexOf(v);
            //     if (index != -1) tickerFuncs.splice(index, 1);
            // }
        });
        running = false;
        for (var i = 0; i < affers.length; i++) {
            var affer = affers[i];
            affer[0].apply(null, affer[1]);
        }
        affers.length = 0;
        localrequestAnimationFrame(runTickerFuncs);
        function nextRuntime(runtime, interval) {
            return runtime + Math.ceil((currenttime - runtime) / interval) * interval;
        }
    }
    var localrequestAnimationFrame;
    if (typeof requestAnimationFrame == "undefined") {
        var _global;
        var global;
        if (typeof window != "undefined") {
            _global = window;
            localrequestAnimationFrame =
                window["requestAnimationFrame"] ||
                    window["webkitRequestAnimationFrame"] ||
                    window["mozRequestAnimationFrame"] ||
                    window["oRequestAnimationFrame"] ||
                    window["msRequestAnimationFrame"];
        }
        else if (typeof global != "undefined") {
            _global = global;
        }
        if (localrequestAnimationFrame == undefined) {
            localrequestAnimationFrame = function (callback) {
                return _global.setTimeout(callback, 1000 / feng3d.ticker.frameRate);
            };
        }
    }
    else {
        localrequestAnimationFrame = requestAnimationFrame;
    }
    runTickerFuncs();
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 数据类型转换
     * TypeArray、ArrayBuffer、Blob、File、DataURL、canvas的相互转换
     * @see http://blog.csdn.net/yinwhm12/article/details/73482904
     */
    var DataTransform = /** @class */ (function () {
        function DataTransform() {
        }
        /**
         * Blob to ArrayBuffer
         */
        DataTransform.prototype.blobToArrayBuffer = function (blob, callback) {
            var reader = new FileReader();
            reader.onload = function (e) {
                callback(e.target["result"]);
            };
            reader.readAsArrayBuffer(blob);
        };
        /**
         * ArrayBuffer to Blob
         */
        DataTransform.prototype.arrayBufferToBlob = function (arrayBuffer) {
            var blob = new Blob([arrayBuffer]); // 注意必须包裹[]
            return blob;
        };
        /**
         * ArrayBuffer to Uint8
         * Uint8数组可以直观的看到ArrayBuffer中每个字节（1字节 == 8位）的值。一般我们要将ArrayBuffer转成Uint类型数组后才能对其中的字节进行存取操作。
         */
        DataTransform.prototype.arrayBufferToUint8 = function (arrayBuffer) {
            var u8 = new Uint8Array(arrayBuffer);
            return u8;
        };
        /**
         * Uint8 to ArrayBuffer
         * 我们Uint8数组可以直观的看到ArrayBuffer中每个字节（1字节 == 8位）的值。一般我们要将ArrayBuffer转成Uint类型数组后才能对其中的字节进行存取操作。
         */
        DataTransform.prototype.uint8ToArrayBuffer = function (uint8Array) {
            var buffer = uint8Array.buffer;
            return buffer;
        };
        /**
         * Array to ArrayBuffer
         * @param array 例如：[0x15, 0xFF, 0x01, 0x00, 0x34, 0xAB, 0x11];
         */
        DataTransform.prototype.arrayToArrayBuffer = function (array) {
            var uint8 = new Uint8Array(array);
            var buffer = uint8.buffer;
            return buffer;
        };
        /**
         * TypeArray to Array
         */
        DataTransform.prototype.uint8ArrayToArray = function (u8a) {
            var arr = [];
            for (var i = 0; i < u8a.length; i++) {
                arr.push(u8a[i]);
            }
            return arr;
        };
        /**
         * canvas转换为dataURL
         */
        DataTransform.prototype.canvasToDataURL = function (canvas, type) {
            if (type === void 0) { type = "png"; }
            if (type == "png")
                return canvas.toDataURL("image/png");
            return canvas.toDataURL("image/jpeg", 0.8);
        };
        /**
         * canvas转换为图片
         */
        DataTransform.prototype.canvasToImage = function (canvas, type, callback) {
            if (type === void 0) { type = "png"; }
            var dataURL = this.canvasToDataURL(canvas, type);
            this.dataURLToImage(dataURL, callback);
        };
        /**
         * File、Blob对象转换为dataURL
         * File对象也是一个Blob对象，二者的处理相同。
         */
        DataTransform.prototype.blobToDataURL = function (blob, callback) {
            var a = new FileReader();
            a.onload = function (e) {
                callback(e.target["result"]);
            };
            a.readAsDataURL(blob);
        };
        /**
         * dataURL转换为Blob对象
         */
        DataTransform.prototype.dataURLtoBlob = function (dataurl) {
            var arr = dataurl.split(","), mime = arr[0].match(/:(.*?);/)[1], bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n);
            while (n--) {
                u8arr[n] = bstr.charCodeAt(n);
            }
            var blob = new Blob([u8arr], { type: mime });
            return blob;
        };
        /**
         * dataURL图片数据转换为HTMLImageElement
         * dataURL图片数据绘制到canvas
         * 先构造Image对象，src为dataURL，图片onload之后绘制到canvas
         */
        DataTransform.prototype.dataURLDrawCanvas = function (dataurl, canvas, callback) {
            this.dataURLToImage(dataurl, function (img) {
                // canvas.drawImage(img);
                callback(img);
            });
        };
        DataTransform.prototype.dataURLToArrayBuffer = function (dataurl, callback) {
            var blob = this.dataURLtoBlob(dataurl);
            this.blobToArrayBuffer(blob, callback);
        };
        DataTransform.prototype.arrayBufferToDataURL = function (arrayBuffer, callback) {
            var blob = this.arrayBufferToBlob(arrayBuffer);
            this.blobToDataURL(blob, callback);
        };
        DataTransform.prototype.dataURLToImage = function (dataurl, callback) {
            var img = new Image();
            img.onload = function () {
                callback(img);
            };
            img.src = dataurl;
        };
        DataTransform.prototype.imageToDataURL = function (img) {
            var canvas = this.imageToCanvas(img);
            var dataurl = this.canvasToDataURL(canvas, "png");
            return dataurl;
        };
        DataTransform.prototype.imageToCanvas = function (img) {
            var canvas = document.createElement("canvas");
            canvas.width = img.width;
            canvas.height = img.height;
            var ctxt = canvas.getContext('2d');
            ctxt.drawImage(img, 0, 0);
            return canvas;
        };
        DataTransform.prototype.imageToArrayBuffer = function (img, callback) {
            if (img["arraybuffer"]) {
                callback(img["arraybuffer"]);
                return;
            }
            var dataUrl = this.imageToDataURL(img);
            this.dataURLToArrayBuffer(dataUrl, function (arraybuffer) {
                img["arraybuffer"] = arraybuffer;
                arraybuffer["img"] = img;
                callback(arraybuffer);
            });
        };
        DataTransform.prototype.imageDataToDataURL = function (imageData) {
            var canvas = this.imageDataToCanvas(imageData);
            var dataurl = this.canvasToDataURL(canvas, "png");
            return dataurl;
        };
        DataTransform.prototype.imageDataToCanvas = function (imageData) {
            var canvas = document.createElement("canvas");
            canvas.width = imageData.width;
            canvas.height = imageData.height;
            var ctxt = canvas.getContext('2d');
            ctxt.putImageData(imageData, 0, 0);
            return canvas;
        };
        DataTransform.prototype.imagedataToImage = function (imageData, callback) {
            var dataUrl = this.imageDataToDataURL(imageData);
            this.dataURLToImage(dataUrl, callback);
        };
        DataTransform.prototype.arrayBufferToImage = function (arrayBuffer, callback) {
            var _this = this;
            if (arrayBuffer["image"]) {
                callback(arrayBuffer["image"]);
                return;
            }
            this.arrayBufferToDataURL(arrayBuffer, function (dataurl) {
                _this.dataURLToImage(dataurl, function (img) {
                    img["arraybuffer"] = arrayBuffer;
                    arrayBuffer["image"] = img;
                    callback(img);
                });
            });
        };
        DataTransform.prototype.blobToText = function (blob, callback) {
            var a = new FileReader();
            a.onload = function (e) { callback(e.target["result"]); };
            a.readAsText(blob);
        };
        DataTransform.prototype.stringToArrayBuffer = function (str) {
            var uint8Array = this.stringToUint8Array(str);
            var buffer = this.uint8ToArrayBuffer(uint8Array);
            return buffer;
        };
        DataTransform.prototype.arrayBufferToString = function (arrayBuffer, callback) {
            var blob = this.arrayBufferToBlob(arrayBuffer);
            this.blobToText(blob, callback);
        };
        /**
         * ArrayBuffer 转换为 对象
         *
         * @param arrayBuffer
         * @param callback
         */
        DataTransform.prototype.arrayBufferToObject = function (arrayBuffer, callback) {
            this.arrayBufferToString(arrayBuffer, function (str) {
                var obj = JSON.parse(str);
                callback(obj);
            });
        };
        DataTransform.prototype.stringToUint8Array = function (str) {
            var utf8 = unescape(encodeURIComponent(str));
            var uint8Array = new Uint8Array(utf8.split('').map(function (item) {
                return item.charCodeAt(0);
            }));
            return uint8Array;
        };
        DataTransform.prototype.uint8ArrayToString = function (arr, callback) {
            // or [].slice.apply(arr)
            // var utf8 = Array.from(arr).map(function (item)
            var utf8 = [].slice.apply(arr).map(function (item) {
                return String.fromCharCode(item);
            }).join('');
            var str = decodeURIComponent(escape(utf8));
            callback(str);
        };
        return DataTransform;
    }());
    feng3d.DataTransform = DataTransform;
    feng3d.dataTransform = new DataTransform();
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var CLASS_KEY = "__class__";
    /**
     * 类工具
     */
    var ClassUtils = /** @class */ (function () {
        function ClassUtils() {
            this.defaultInstMap = {};
        }
        /**
         * 返回对象的完全限定类名。
         * @param value 需要完全限定类名称的对象，可以将任何 JavaScript 值传递给此方法，包括所有可用的 JavaScript 类型、对象实例、原始类型
         * （如number)和类对象
         * @returns 包含完全限定类名称的字符串。
         */
        ClassUtils.prototype.getQualifiedClassName = function (value) {
            if (value == null)
                return "null";
            var prototype = value.prototype ? value.prototype : Object.getPrototypeOf(value);
            if (prototype.hasOwnProperty(CLASS_KEY))
                return prototype[CLASS_KEY];
            var className = prototype.constructor.name;
            if (_global[className] == prototype.constructor)
                return className;
            //在可能的命名空间内查找
            for (var i = 0; i < _classNameSpaces.length; i++) {
                var tryClassName = _classNameSpaces[i] + "." + className;
                if (this.getDefinitionByName(tryClassName) == prototype.constructor) {
                    className = tryClassName;
                    registerClass(prototype.constructor, className);
                    return className;
                }
            }
            // console.warn(`未在给出的命名空间 ${_classNameSpaces} 内找到 ${value} 的定义`);
            return className;
        };
        /**
         * 返回 name 参数指定的类的类对象引用。
         * @param name 类的名称。
         */
        ClassUtils.prototype.getDefinitionByName = function (name, readCache) {
            if (readCache === void 0) { readCache = true; }
            if (name == "null")
                return null;
            if (!name)
                return null;
            if (_global[name])
                return _global[name];
            if (readCache && _definitionCache[name])
                return _definitionCache[name];
            var paths = name.split(".");
            var length = paths.length;
            var definition = _global;
            for (var i = 0; i < length; i++) {
                var path = paths[i];
                definition = definition[path];
                if (!definition) {
                    return null;
                }
            }
            _definitionCache[name] = definition;
            return definition;
        };
        /**
         * 获取默认实例
         *
         * @param name 类名称
         */
        ClassUtils.prototype.getDefaultInstanceByName = function (name) {
            var defaultInst = this.defaultInstMap[name];
            if (defaultInst)
                return defaultInst;
            //
            var cls = this.getDefinitionByName(name);
            if (!cls)
                return undefined;
            defaultInst = this.defaultInstMap[name] = new cls();
            // 冻结对象，防止被修改
            Object.freeze(defaultInst);
            return defaultInst;
        };
        /**
         * 获取实例
         *
         * @param name 类名称
         */
        ClassUtils.prototype.getInstanceByName = function (name) {
            var cls = this.getDefinitionByName(name);
            console.assert(cls);
            if (!cls)
                return undefined;
            return new cls();
        };
        /**
         * 新增反射对象所在的命名空间，使得getQualifiedClassName能够得到正确的结果
         */
        ClassUtils.prototype.addClassNameSpace = function (namespace) {
            if (_classNameSpaces.indexOf(namespace) == -1) {
                _classNameSpaces.push(namespace);
            }
        };
        return ClassUtils;
    }());
    feng3d.ClassUtils = ClassUtils;
    ;
    feng3d.classUtils = new ClassUtils();
    var _definitionCache = {};
    var _global;
    var global;
    if (typeof window != "undefined") {
        _global = window;
    }
    else if (typeof global != "undefined") {
        _global = global;
    }
    var _classNameSpaces = ["feng3d"];
    /**
     * 为一个类定义注册完全限定类名
     * @param classDefinition 类定义
     * @param className 完全限定类名
     */
    function registerClass(classDefinition, className) {
        var prototype = classDefinition.prototype;
        Object.defineProperty(prototype, CLASS_KEY, { value: className, writable: true });
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 图片相关工具
     */
    var ImageUtil = /** @class */ (function () {
        /**
         * 创建ImageData
         * @param width 数据宽度
         * @param height 数据高度
         * @param fillcolor 填充颜色
         */
        function ImageUtil(width, height, fillcolor) {
            if (width === void 0) { width = 1; }
            if (height === void 0) { height = 1; }
            if (fillcolor === void 0) { fillcolor = new feng3d.Color4(0, 0, 0, 0); }
            this.init(width, height, fillcolor);
        }
        /**
         * 获取图片数据
         * @param image 加载完成的图片元素
         */
        ImageUtil.fromImage = function (image) {
            return new ImageUtil().fromImage(image);
        };
        /**
         * 初始化
         * @param width 宽度
         * @param height 高度
         * @param fillcolor 填充颜色
         */
        ImageUtil.prototype.init = function (width, height, fillcolor) {
            if (width === void 0) { width = 1; }
            if (height === void 0) { height = 1; }
            if (fillcolor === void 0) { fillcolor = new feng3d.Color4(0, 0, 0, 0); }
            if (typeof document == "undefined")
                return;
            var canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            var ctx = canvas.getContext('2d');
            ctx.fillStyle = feng3d.Color3.fromColor4(fillcolor).toHexString();
            var backAlpha = ctx.globalAlpha;
            ctx.globalAlpha = fillcolor.a;
            ctx.fillRect(0, 0, width, height);
            ctx.globalAlpha = backAlpha;
            this.imageData = ctx.getImageData(0, 0, width, height);
        };
        /**
         * 获取图片数据
         * @param image 加载完成的图片元素
         */
        ImageUtil.prototype.fromImage = function (image) {
            if (!image)
                return null;
            var canvasImg = document.createElement("canvas");
            canvasImg.width = image.width;
            canvasImg.height = image.height;
            var ctxt = canvasImg.getContext('2d');
            feng3d.debuger && console.assert(!!ctxt);
            ctxt.drawImage(image, 0, 0);
            this.imageData = ctxt.getImageData(0, 0, image.width, image.height); //读取整张图片的像素。
            return this;
        };
        /**
         * 绘制图片数据指定位置颜色
         * @param x 图片数据x坐标
         * @param y 图片数据y坐标
         * @param color 颜色值
         */
        ImageUtil.prototype.drawPixel = function (x, y, color) {
            var oldColor = this.getPixel(x, y);
            oldColor.mix(color, color.a);
            this.setPixel(x, y, oldColor);
            return this;
        };
        /**
         * 获取图片指定位置颜色值
         * @param x 图片数据x坐标
         * @param y 图片数据y坐标
         */
        ImageUtil.prototype.getPixel = function (x, y) {
            var pos = (x + y * this.imageData.width) * 4;
            var color = new feng3d.Color4(this.imageData.data[pos] / 255, this.imageData.data[pos + 1] / 255, this.imageData.data[pos + 2] / 255, this.imageData.data[pos + 3] / 255);
            return color;
        };
        /**
         * 设置指定位置颜色值
         * @param imageData 图片数据
         * @param x 图片数据x坐标
         * @param y 图片数据y坐标
         * @param color 颜色值
         */
        ImageUtil.prototype.setPixel = function (x, y, color) {
            x = Math.round(x);
            y = Math.round(y);
            var pos = (x + y * this.imageData.width) * 4;
            this.imageData.data[pos] = color.r * 255;
            this.imageData.data[pos + 1] = color.g * 255;
            this.imageData.data[pos + 2] = color.b * 255;
            this.imageData.data[pos + 3] = color.a * 255;
            return this;
        };
        /**
         * 清理图片数据
         * @param clearColor 清理时填充颜色
         */
        ImageUtil.prototype.clear = function (clearColor) {
            if (clearColor === void 0) { clearColor = new feng3d.Color4(0, 0, 0, 0); }
            for (var i = 0; i < this.imageData.width; i++) {
                for (var j = 0; j < this.imageData.height; j++) {
                    this.setPixel(i, j, clearColor);
                }
            }
        };
        /**
         * 填充矩形
         * @param rect 填充的矩形
         * @param fillcolor 填充颜色
         */
        ImageUtil.prototype.fillRect = function (rect, fillcolor) {
            if (fillcolor === void 0) { fillcolor = new feng3d.Color4(); }
            for (var i = rect.x > 0 ? rect.x : 0; i < this.imageData.width && i < rect.x + rect.width; i++) {
                for (var j = rect.y > 0 ? rect.y : 0; j < this.imageData.height && j < rect.y + rect.height; j++) {
                    this.setPixel(i, j, fillcolor);
                }
            }
        };
        /**
         * 绘制线条
         * @param start 起始坐标
         * @param end 终止坐标
         * @param color 线条颜色
         */
        ImageUtil.prototype.drawLine = function (start, end, color) {
            var length = end.subTo(start).length;
            var p = new feng3d.Vector2();
            for (var i = 0; i <= length; i++) {
                start.lerpNumberTo(end, i / length, p);
                this.setPixel(p.x, p.y, color);
            }
            return this;
        };
        /**
         * 绘制点
         * @param x x坐标
         * @param y y坐标
         * @param color 颜色
         * @param size 尺寸
         */
        ImageUtil.prototype.drawPoint = function (x, y, color, size) {
            if (size === void 0) { size = 1; }
            var half = Math.floor(size / 2);
            //
            var sx = x - half;
            if (sx < 0)
                sx = 0;
            var ex = x - half + size;
            if (ex > this.imageData.width)
                ex = this.imageData.width;
            var sy = y - half;
            if (sy < 0)
                sy = 0;
            var ey = y - half + size;
            if (ey > this.imageData.height)
                ey = this.imageData.height;
            //
            for (var i = sx; i < ex; i++) {
                for (var j = sy; j < ey; j++) {
                    this.setPixel(i, j, color);
                }
            }
            return this;
        };
        /**
         * 绘制图片数据
         * @param imageData 图片数据
         * @param x x坐标
         * @param y y坐标
         */
        ImageUtil.prototype.drawImageData = function (imageData, x, y) {
            var rect = new feng3d.Rectangle(0, 0, this.imageData.width, this.imageData.height).intersection(new feng3d.Rectangle(x, y, imageData.width, imageData.height));
            var imageUtil = new ImageUtil();
            imageUtil.imageData = imageData;
            for (var i = rect.x; i < rect.x + rect.width; i++) {
                for (var j = rect.y; j < rect.y + rect.height; j++) {
                    var c = imageUtil.getPixel(i - x, j - y);
                    this.drawPixel(i, j, c);
                }
            }
            return this;
        };
        /**
         * 转换为DataUrl字符串数据
         */
        ImageUtil.prototype.toDataURL = function () {
            return feng3d.dataTransform.imageDataToDataURL(this.imageData);
        };
        /**
         * 创建默认粒子贴图
         * @param size 尺寸
         */
        ImageUtil.prototype.drawDefaultParticle = function (size) {
            if (size === void 0) { size = 64; }
            var canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            var ctx = canvas.getContext('2d');
            var imageData = ctx.getImageData(0, 0, size, size);
            var half = size / 2;
            for (var i = 0; i < size; i++) {
                for (var j = 0; j < size; j++) {
                    var l = Math.clamp(new feng3d.Vector2(i - half, j - half).length, 0, half) / half;
                    // l = l * l;
                    var f = 1 - l;
                    f = f * f;
                    // f = f * f * f;
                    // f = - 8 / 3 * f * f * f + 4 * f * f - f / 3;
                    var pos = (i + j * size) * 4;
                    imageData.data[pos] = 255;
                    imageData.data[pos + 1] = 255;
                    imageData.data[pos + 2] = 255;
                    imageData.data[pos + 3] = f * 255;
                }
            }
            this.imageData = imageData;
            return this;
        };
        /**
         * 创建颜色拾取矩形
         * @param color 基色
         * @param width 宽度
         * @param height 高度
         */
        ImageUtil.prototype.drawColorPickerRect = function (color) {
            Image;
            var leftTop = new feng3d.Color3(1, 1, 1);
            var rightTop = new feng3d.Color3().fromUnit(color);
            var leftBottom = new feng3d.Color3(0, 0, 0);
            var rightBottom = new feng3d.Color3(0, 0, 0);
            //
            for (var i = 0; i < this.imageData.width; i++) {
                for (var j = 0; j < this.imageData.height; j++) {
                    var top = leftTop.mixTo(rightTop, i / this.imageData.width);
                    var bottom = leftBottom.mixTo(rightBottom, i / this.imageData.width);
                    var v = top.mixTo(bottom, j / this.imageData.height);
                    this.setPixel(i, j, v.toColor4());
                }
            }
            return this;
        };
        ImageUtil.prototype.drawColorRect = function (color) {
            var colorHeight = Math.floor(this.imageData.height * 0.8);
            var alphaWidth = Math.floor(color.a * this.imageData.width);
            var color4 = color.clone();
            color4.a = 1;
            var white = new feng3d.Color4(1, 1, 1);
            var black = new feng3d.Color4(0, 0, 0);
            //
            for (var i = 0; i < this.imageData.width; i++) {
                for (var j = 0; j < this.imageData.height; j++) {
                    //
                    if (j <= colorHeight) {
                        this.setPixel(i, j, color4);
                    }
                    else {
                        this.setPixel(i, j, i < alphaWidth ? white : black);
                    }
                }
            }
            return this;
        };
        /**
         *
         * @param gradient
         * @param dirw true为横向条带，否则纵向条带
         */
        ImageUtil.prototype.drawMinMaxGradient = function (gradient, dirw) {
            if (dirw === void 0) { dirw = true; }
            //
            for (var i = 0; i < this.imageData.width; i++) {
                for (var j = 0; j < this.imageData.height; j++) {
                    var c = gradient.getValue(dirw ? i / (this.imageData.width - 1) : j / (this.imageData.height - 1));
                    this.setPixel(i, j, c);
                }
            }
            return this;
        };
        /**
         * 绘制曲线
         * @param curve 曲线
         * @param between0And1 是否显示值在[0,1]区间，否则[-1,1]区间
         * @param color 曲线颜色
         */
        ImageUtil.prototype.drawCurve = function (curve, between0And1, color, rect) {
            if (rect === void 0) { rect = null; }
            rect = rect || new feng3d.Rectangle(0, 0, this.imageData.width, this.imageData.height);
            var range = between0And1 ? [1, 0] : [1, -1];
            //
            for (var i = 0; i < rect.width; i++) {
                //
                var y = curve.getValue(i / (rect.width - 1));
                y = Math.mapLinear(y, range[0], range[1], 0, 1);
                var j = Math.round(y * (rect.height - 1));
                this.setPixel(rect.x + i, rect.y + j, color);
            }
            return this;
        };
        /**
         * 绘制双曲线
         * @param curve 曲线
         * @param curve1 曲线
         * @param between0And1  是否显示值在[0,1]区间，否则[-1,1]区间
         * @param curveColor 颜色
         */
        ImageUtil.prototype.drawBetweenTwoCurves = function (curve, curve1, between0And1, curveColor, fillcolor, rect) {
            if (curveColor === void 0) { curveColor = new feng3d.Color4(); }
            if (fillcolor === void 0) { fillcolor = new feng3d.Color4(1, 1, 1, 0.5); }
            if (rect === void 0) { rect = null; }
            rect = rect || new feng3d.Rectangle(0, 0, this.imageData.width, this.imageData.height);
            var range = between0And1 ? [1, 0] : [1, -1];
            //
            for (var i = 0; i < rect.width; i++) {
                //
                var y0 = curve.getValue(i / (rect.width - 1));
                var y1 = curve1.getValue(i / (rect.width - 1));
                y0 = Math.mapLinear(y0, range[0], range[1], 0, 1);
                y1 = Math.mapLinear(y1, range[0], range[1], 0, 1);
                y0 = Math.round(y0 * (rect.height - 1));
                y1 = Math.round(y1 * (rect.height - 1));
                this.drawLine(new feng3d.Vector2(rect.x + i, rect.y + y0), new feng3d.Vector2(rect.x + i, rect.y + y1), fillcolor);
                this.drawPixel(rect.x + i, rect.y + y0, curveColor);
                this.drawPixel(rect.x + i, rect.y + y1, curveColor);
            }
            return this;
        };
        /**
         * 清理背景颜色，目前仅用于特定的抠图，例如 editor\resource\assets\3d\terrain\terrain_brushes.png
         * @param backColor 背景颜色
         */
        ImageUtil.prototype.clearBackColor = function (backColor) {
            for (var i = 0; i < this.imageData.width; i++) {
                for (var j = 0; j < this.imageData.height; j++) {
                    var t = this.getPixel(i, j);
                    var a = 1 - t.r / backColor.r;
                    t.r = t.g = t.b = 0;
                    t.a = a;
                    this.setPixel(i, j, t);
                }
            }
        };
        return ImageUtil;
    }());
    feng3d.ImageUtil = ImageUtil;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var Stats = /** @class */ (function () {
        function Stats() {
            var _this = this;
            var mode = 0;
            if (typeof document == "undefined")
                return;
            var container = document.createElement('div');
            container.style.cssText = 'position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;';
            container.addEventListener('click', function (event) {
                event.preventDefault();
                showPanel(++mode % container.children.length);
            }, false);
            //
            function addPanel(panel) {
                container.appendChild(panel.dom);
                return panel;
            }
            function showPanel(id) {
                for (var i = 0; i < container.children.length; i++) {
                    container.children[i].style.display = i === id ? 'block' : 'none';
                }
                mode = id;
            }
            //
            var beginTime = (performance || Date).now(), prevTime = beginTime, frames = 0;
            var fpsPanel = addPanel(new StatsPanel('FPS', '#0ff', '#002'));
            var msPanel = addPanel(new StatsPanel('MS', '#0f0', '#020'));
            if (self.performance && self.performance.memory) {
                var memPanel = addPanel(new StatsPanel('MB', '#f08', '#201'));
            }
            showPanel(0);
            this.REVISION = 16;
            this.dom = container;
            this.addPanel = addPanel;
            this.showPanel = showPanel;
            this.begin = function () {
                beginTime = (performance || Date).now();
            };
            this.end = function () {
                frames++;
                var time = (performance || Date).now();
                msPanel.update(time - beginTime, 200);
                if (time > prevTime + 1000) {
                    fpsPanel.update((frames * 1000) / (time - prevTime), 100);
                    prevTime = time;
                    frames = 0;
                    if (memPanel) {
                        var memory = performance.memory;
                        memPanel.update(memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576);
                    }
                }
                return time;
            };
            this.update = function () {
                beginTime = _this.end();
            };
            // Backwards Compatibility
            this.domElement = container;
            this.setMode = showPanel;
        }
        Stats.init = function (parent) {
            if (!this.instance) {
                this.instance = new Stats();
                parent = parent || document.body;
                parent.appendChild(this.instance.dom);
            }
            feng3d.ticker.onframe(this.instance.update, this.instance);
        };
        ;
        return Stats;
    }());
    feng3d.Stats = Stats;
    var StatsPanel = /** @class */ (function () {
        function StatsPanel(name, fg, bg) {
            var min = Infinity, max = 0, round = Math.round;
            var PR = round(window.devicePixelRatio || 1);
            var WIDTH = 80 * PR, HEIGHT = 48 * PR, TEXT_X = 3 * PR, TEXT_Y = 2 * PR, GRAPH_X = 3 * PR, GRAPH_Y = 15 * PR, GRAPH_WIDTH = 74 * PR, GRAPH_HEIGHT = 30 * PR;
            var canvas = document.createElement('canvas');
            canvas.width = WIDTH;
            canvas.height = HEIGHT;
            canvas.style.cssText = 'width:80px;height:48px';
            var context0 = canvas.getContext('2d');
            if (context0 == null) {
                console.log("\u65E0\u6CD5\u521B\u5EFA CanvasRenderingContext2D ");
                return;
            }
            var context = context0;
            context.font = 'bold ' + (9 * PR) + 'px Helvetica,Arial,sans-serif';
            context.textBaseline = 'top';
            context.fillStyle = bg;
            context.fillRect(0, 0, WIDTH, HEIGHT);
            context.fillStyle = fg;
            context.fillText(name, TEXT_X, TEXT_Y);
            context.fillRect(GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT);
            context.fillStyle = bg;
            context.globalAlpha = 0.9;
            context.fillRect(GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT);
            this.dom = canvas;
            this.update = function (value, maxValue) {
                min = Math.min(min, value);
                max = Math.max(max, value);
                context.fillStyle = bg;
                context.globalAlpha = 1;
                context.fillRect(0, 0, WIDTH, GRAPH_Y);
                context.fillStyle = fg;
                context.fillText(round(value) + ' ' + name + ' (' + round(min) + '-' + round(max) + ')', TEXT_X, TEXT_Y);
                context.drawImage(canvas, GRAPH_X + PR, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT, GRAPH_X, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT);
                context.fillRect(GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, GRAPH_HEIGHT);
                context.fillStyle = bg;
                context.globalAlpha = 0.9;
                context.fillRect(GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, round((1 - (value / maxValue)) * GRAPH_HEIGHT));
            };
        }
        return StatsPanel;
    }());
    feng3d.StatsPanel = StatsPanel;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 路径工具
     */
    var PathUtils = /** @class */ (function () {
        function PathUtils() {
        }
        /**
         * 标准化文件夹路径
         * @param path
         */
        PathUtils.prototype.normalizeDir = function (path) {
            if (path[path.length - 1] == "/")
                path = path.substr(0, path.length - 1);
            return path;
        };
        /**
         * 是否为HTTP地址
         *
         * @param path 地址
         */
        PathUtils.prototype.isHttpURL = function (path) {
            if (path.indexOf("http://") != -1 || path.indexOf("https://") != -1 || path.indexOf("file:///") != -1)
                return true;
            return false;
        };
        /**
         * 获取不带后缀名称
         * @param path 路径
         */
        PathUtils.prototype.getName = function (path) {
            feng3d.debuger && console.assert(path != undefined);
            var name = this.getNameWithExtension(path);
            if (this.isDirectory(path))
                return name;
            name = name.split(".").shift();
            return name;
        };
        /**
         * 获取带后缀名称
         * @param path 路径
         */
        PathUtils.prototype.getNameWithExtension = function (path) {
            feng3d.debuger && console.assert(path != undefined);
            var paths = path.split("/");
            var name = paths.pop();
            if (name == "")
                name = paths.pop();
            return name;
        };
        /**
         * 获取后缀
         * @param path 路径
         */
        PathUtils.prototype.getExtension = function (path) {
            feng3d.debuger && console.assert(path != undefined);
            var name = this.getNameWithExtension(path);
            var index = name.indexOf(".");
            if (index == -1)
                return "";
            return name.substr(index);
        };
        /**
         * 父路径
         * @param path 路径
         */
        PathUtils.prototype.getParentPath = function (path) {
            feng3d.debuger && console.assert(path != undefined);
            var paths = path.split("/");
            if (this.isDirectory(path))
                paths.pop();
            paths.pop();
            return paths.join("/");
        };
        /**
         * 获取子文件（非文件夹）路径
         *
         * @param parentPath 父文件夹路径
         * @param childName 子文件名称
         */
        PathUtils.prototype.getChildFilePath = function (parentPath, childName) {
            feng3d.debuger && console.assert(parentPath != undefined);
            feng3d.debuger && console.assert(childName != undefined);
            if (parentPath.charAt(parentPath.length - 1) != "/")
                parentPath += "/";
            return parentPath + childName;
        };
        /**
         * 获取子文件夹路径
         *
         * @param parentPath 父文件夹路径
         * @param childFolderName 子文件夹名称
         */
        PathUtils.prototype.getChildFolderPath = function (parentPath, childFolderName) {
            if (parentPath.charAt(parentPath.length - 1) != "/")
                parentPath += "/";
            if (childFolderName.charAt(childFolderName.length - 1) != "/")
                childFolderName += "/";
            return parentPath + childFolderName;
        };
        /**
         * 是否文件夹
         * @param path 路径
         */
        PathUtils.prototype.isDirectory = function (path) {
            return path.split("/").pop() == "";
        };
        /**
         * 获取目录深度
         * @param path 路径
         */
        PathUtils.prototype.getDirDepth = function (path) {
            var length = path.split("/").length;
            if (this.isDirectory(path))
                length--;
            return length - 1;
        };
        return PathUtils;
    }());
    feng3d.PathUtils = PathUtils;
    feng3d.pathUtils = new PathUtils();
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * .
     */
    var CHAR_DOT = 46;
    /**
     * :
     */
    var CHAR_COLON = 58;
    /**
     * ?
     */
    var CHAR_QUESTION_MARK = 63;
    /**
     * A
     */
    var CHAR_UPPERCASE_A = 65;
    /**
     * Z
     */
    var CHAR_UPPERCASE_Z = 90;
    /**
     * a
     */
    var CHAR_LOWERCASE_A = 97;
    /**
     * z
     */
    var CHAR_LOWERCASE_Z = 122;
    /**
     * /
     */
    var CHAR_FORWARD_SLASH = 47;
    /**
     * \
     */
    var CHAR_BACKWARD_SLASH = 92;
    /**
     * 未实现其功能
     */
    var process = {
        platform: 'win32',
        env: {},
        cwd: function () { return ""; },
    };
    var ERR_INVALID_ARG_TYPE = /** @class */ (function (_super) {
        __extends(ERR_INVALID_ARG_TYPE, _super);
        function ERR_INVALID_ARG_TYPE(name, expected, actual) {
            var _this = this;
            feng3d.debuger && assert(typeof name === 'string', "'name' must be a string");
            // determiner: 'must be' or 'must not be'
            var determiner;
            if (typeof expected === 'string' && expected.startsWith('not ')) {
                determiner = 'must not be';
                expected = expected.replace(/^not /, '');
            }
            else {
                determiner = 'must be';
            }
            var msg;
            if (name.endsWith(' argument')) {
                // For cases like 'first argument'
                msg = "The " + name + " " + determiner + " " + oneOf(expected, 'type');
            }
            else {
                var type = name.includes('.') ? 'property' : 'argument';
                msg = "The \"" + name + "\" " + type + " " + determiner + " " + oneOf(expected, 'type');
            }
            // TODO(BridgeAR): Improve the output by showing `null` and similar.
            msg += ". Received type " + typeof actual;
            _this = _super.call(this, msg) || this;
            return _this;
        }
        return ERR_INVALID_ARG_TYPE;
    }(TypeError));
    function oneOf(expected, thing) {
        feng3d.debuger && assert(typeof thing === 'string', '`thing` has to be of type string');
        if (Array.isArray(expected)) {
            var len = expected.length;
            feng3d.debuger && assert(len > 0, 'At least one expected value needs to be specified');
            expected = expected.map(function (i) { return String(i); });
            if (len > 2) {
                return "one of " + thing + " " + expected.slice(0, len - 1).join(', ') + ", or " +
                    expected[len - 1];
            }
            else if (len === 2) {
                return "one of " + thing + " " + expected[0] + " or " + expected[1];
            }
            else {
                return "of " + thing + " " + expected[0];
            }
        }
        else {
            return "of " + thing + " " + String(expected);
        }
    }
    function assert(b, msg) {
        if (!b)
            throw msg;
    }
    function validateString(value, name) {
        if (typeof value !== 'string')
            throw new ERR_INVALID_ARG_TYPE(name, 'string', value);
    }
    function isPathSeparator(code) {
        return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    }
    function isPosixPathSeparator(code) {
        return code === CHAR_FORWARD_SLASH;
    }
    function isWindowsDeviceRoot(code) {
        return code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z ||
            code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z;
    }
    // Resolves . and .. elements in a path with directory names
    function normalizeString(path, allowAboveRoot, separator, isPathSeparator) {
        var res = '';
        var lastSegmentLength = 0;
        var lastSlash = -1;
        var dots = 0;
        var code = -1;
        for (var i = 0; i <= path.length; ++i) {
            if (i < path.length)
                code = path.charCodeAt(i);
            else if (isPathSeparator(code))
                break;
            else
                code = CHAR_FORWARD_SLASH;
            if (isPathSeparator(code)) {
                if (lastSlash === i - 1 || dots === 1) {
                    // NOOP
                }
                else if (lastSlash !== i - 1 && dots === 2) {
                    if (res.length < 2 || lastSegmentLength !== 2 ||
                        res.charCodeAt(res.length - 1) !== CHAR_DOT ||
                        res.charCodeAt(res.length - 2) !== CHAR_DOT) {
                        if (res.length > 2) {
                            var lastSlashIndex = res.lastIndexOf(separator);
                            if (lastSlashIndex === -1) {
                                res = '';
                                lastSegmentLength = 0;
                            }
                            else {
                                res = res.slice(0, lastSlashIndex);
                                lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                            }
                            lastSlash = i;
                            dots = 0;
                            continue;
                        }
                        else if (res.length === 2 || res.length === 1) {
                            res = '';
                            lastSegmentLength = 0;
                            lastSlash = i;
                            dots = 0;
                            continue;
                        }
                    }
                    if (allowAboveRoot) {
                        if (res.length > 0)
                            res += separator + "..";
                        else
                            res = '..';
                        lastSegmentLength = 2;
                    }
                }
                else {
                    if (res.length > 0)
                        res += separator + path.slice(lastSlash + 1, i);
                    else
                        res = path.slice(lastSlash + 1, i);
                    lastSegmentLength = i - lastSlash - 1;
                }
                lastSlash = i;
                dots = 0;
            }
            else if (code === CHAR_DOT && dots !== -1) {
                ++dots;
            }
            else {
                dots = -1;
            }
        }
        return res;
    }
    function _format(sep, pathObject) {
        var dir = pathObject.dir || pathObject.root;
        var base = pathObject.base ||
            ((pathObject.name || '') + (pathObject.ext || ''));
        if (!dir) {
            return base;
        }
        if (dir === pathObject.root) {
            return dir + base;
        }
        return dir + sep + base;
    }
    var Win32Path = /** @class */ (function () {
        function Win32Path() {
            this.sep = '\\';
            this.delimiter = ';';
            this.win32 = null;
            this.posix = null;
        }
        // path.resolve([from ...], to)
        Win32Path.prototype.resolve = function () {
            var pathSegments = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                pathSegments[_i] = arguments[_i];
            }
            var resolvedDevice = '';
            var resolvedTail = '';
            var resolvedAbsolute = false;
            for (var i = arguments.length - 1; i >= -1; i--) {
                var path;
                if (i >= 0) {
                    path = arguments[i];
                }
                else if (!resolvedDevice) {
                    path = process.cwd();
                }
                else {
                    // Windows has the concept of drive-specific current working
                    // directories. If we've resolved a drive letter but not yet an
                    // absolute path, get cwd for that drive, or the process cwd if
                    // the drive cwd is not available. We're sure the device is not
                    // a UNC path at this points, because UNC paths are always absolute.
                    path = process.env['=' + resolvedDevice] || process.cwd();
                    // Verify that a cwd was found and that it actually points
                    // to our drive. If not, default to the drive's root.
                    if (path === undefined ||
                        path.slice(0, 3).toLowerCase() !==
                            resolvedDevice.toLowerCase() + '\\') {
                        path = resolvedDevice + '\\';
                    }
                }
                validateString(path, 'path');
                // Skip empty entries
                if (path.length === 0) {
                    continue;
                }
                var len = path.length;
                var rootEnd = 0;
                var device = '';
                var isAbsolute = false;
                var code = path.charCodeAt(0);
                // Try to match a root
                if (len > 1) {
                    if (isPathSeparator(code)) {
                        // Possible UNC root
                        // If we started with a separator, we know we at least have an
                        // absolute path of some kind (UNC or otherwise)
                        isAbsolute = true;
                        if (isPathSeparator(path.charCodeAt(1))) {
                            // Matched double path separator at beginning
                            var j = 2;
                            var last = j;
                            // Match 1 or more non-path separators
                            for (; j < len; ++j) {
                                if (isPathSeparator(path.charCodeAt(j)))
                                    break;
                            }
                            if (j < len && j !== last) {
                                var firstPart = path.slice(last, j);
                                // Matched!
                                last = j;
                                // Match 1 or more path separators
                                for (; j < len; ++j) {
                                    if (!isPathSeparator(path.charCodeAt(j)))
                                        break;
                                }
                                if (j < len && j !== last) {
                                    // Matched!
                                    last = j;
                                    // Match 1 or more non-path separators
                                    for (; j < len; ++j) {
                                        if (isPathSeparator(path.charCodeAt(j)))
                                            break;
                                    }
                                    if (j === len) {
                                        // We matched a UNC root only
                                        device = '\\\\' + firstPart + '\\' + path.slice(last);
                                        rootEnd = j;
                                    }
                                    else if (j !== last) {
                                        // We matched a UNC root with leftovers
                                        device = '\\\\' + firstPart + '\\' + path.slice(last, j);
                                        rootEnd = j;
                                    }
                                }
                            }
                        }
                        else {
                            rootEnd = 1;
                        }
                    }
                    else if (isWindowsDeviceRoot(code)) {
                        // Possible device root
                        if (path.charCodeAt(1) === CHAR_COLON) {
                            device = path.slice(0, 2);
                            rootEnd = 2;
                            if (len > 2) {
                                if (isPathSeparator(path.charCodeAt(2))) {
                                    // Treat separator following drive name as an absolute path
                                    // indicator
                                    isAbsolute = true;
                                    rootEnd = 3;
                                }
                            }
                        }
                    }
                }
                else if (isPathSeparator(code)) {
                    // `path` contains just a path separator
                    rootEnd = 1;
                    isAbsolute = true;
                }
                if (device.length > 0 &&
                    resolvedDevice.length > 0 &&
                    device.toLowerCase() !== resolvedDevice.toLowerCase()) {
                    // This path points to another device so it is not applicable
                    continue;
                }
                if (resolvedDevice.length === 0 && device.length > 0) {
                    resolvedDevice = device;
                }
                if (!resolvedAbsolute) {
                    resolvedTail = path.slice(rootEnd) + '\\' + resolvedTail;
                    resolvedAbsolute = isAbsolute;
                }
                if (resolvedDevice.length > 0 && resolvedAbsolute) {
                    break;
                }
            }
            // At this point the path should be resolved to a full absolute path,
            // but handle relative paths to be safe (might happen when process.cwd()
            // fails)
            // Normalize the tail path
            resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\', isPathSeparator);
            return (resolvedDevice + (resolvedAbsolute ? '\\' : '') + resolvedTail) ||
                '.';
        };
        Win32Path.prototype.normalize = function (path) {
            validateString(path, 'path');
            var len = path.length;
            if (len === 0)
                return '.';
            var rootEnd = 0;
            var device;
            var isAbsolute = false;
            var code = path.charCodeAt(0);
            // Try to match a root
            if (len > 1) {
                if (isPathSeparator(code)) {
                    // Possible UNC root
                    // If we started with a separator, we know we at least have an absolute
                    // path of some kind (UNC or otherwise)
                    isAbsolute = true;
                    if (isPathSeparator(path.charCodeAt(1))) {
                        // Matched double path separator at beginning
                        var j = 2;
                        var last = j;
                        // Match 1 or more non-path separators
                        for (; j < len; ++j) {
                            if (isPathSeparator(path.charCodeAt(j)))
                                break;
                        }
                        if (j < len && j !== last) {
                            var firstPart = path.slice(last, j);
                            // Matched!
                            last = j;
                            // Match 1 or more path separators
                            for (; j < len; ++j) {
                                if (!isPathSeparator(path.charCodeAt(j)))
                                    break;
                            }
                            if (j < len && j !== last) {
                                // Matched!
                                last = j;
                                // Match 1 or more non-path separators
                                for (; j < len; ++j) {
                                    if (isPathSeparator(path.charCodeAt(j)))
                                        break;
                                }
                                if (j === len) {
                                    // We matched a UNC root only
                                    // Return the normalized version of the UNC root since there
                                    // is nothing left to process
                                    return '\\\\' + firstPart + '\\' + path.slice(last) + '\\';
                                }
                                else if (j !== last) {
                                    // We matched a UNC root with leftovers
                                    device = '\\\\' + firstPart + '\\' + path.slice(last, j);
                                    rootEnd = j;
                                }
                            }
                        }
                    }
                    else {
                        rootEnd = 1;
                    }
                }
                else if (isWindowsDeviceRoot(code)) {
                    // Possible device root
                    if (path.charCodeAt(1) === CHAR_COLON) {
                        device = path.slice(0, 2);
                        rootEnd = 2;
                        if (len > 2) {
                            if (isPathSeparator(path.charCodeAt(2))) {
                                // Treat separator following drive name as an absolute path
                                // indicator
                                isAbsolute = true;
                                rootEnd = 3;
                            }
                        }
                    }
                }
            }
            else if (isPathSeparator(code)) {
                // `path` contains just a path separator, exit early to avoid unnecessary
                // work
                return '\\';
            }
            var tail;
            if (rootEnd < len) {
                tail = normalizeString(path.slice(rootEnd), !isAbsolute, '\\', isPathSeparator);
            }
            else {
                tail = '';
            }
            if (tail.length === 0 && !isAbsolute)
                tail = '.';
            if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1)))
                tail += '\\';
            if (device === undefined) {
                if (isAbsolute) {
                    if (tail.length > 0)
                        return '\\' + tail;
                    else
                        return '\\';
                }
                else if (tail.length > 0) {
                    return tail;
                }
                else {
                    return '';
                }
            }
            else if (isAbsolute) {
                if (tail.length > 0)
                    return device + '\\' + tail;
                else
                    return device + '\\';
            }
            else if (tail.length > 0) {
                return device + tail;
            }
            else {
                return device;
            }
        };
        Win32Path.prototype.isAbsolute = function (path) {
            validateString(path, 'path');
            var len = path.length;
            if (len === 0)
                return false;
            var code = path.charCodeAt(0);
            if (isPathSeparator(code)) {
                return true;
            }
            else if (isWindowsDeviceRoot(code)) {
                // Possible device root
                if (len > 2 && path.charCodeAt(1) === CHAR_COLON) {
                    if (isPathSeparator(path.charCodeAt(2)))
                        return true;
                }
            }
            return false;
        };
        Win32Path.prototype.join = function () {
            if (arguments.length === 0)
                return '.';
            var joined;
            var firstPart;
            for (var i = 0; i < arguments.length; ++i) {
                var arg = arguments[i];
                validateString(arg, 'path');
                if (arg.length > 0) {
                    if (joined === undefined)
                        joined = firstPart = arg;
                    else
                        joined += '\\' + arg;
                }
            }
            if (joined === undefined)
                return '.';
            // Make sure that the joined path doesn't start with two slashes, because
            // normalize() will mistake it for an UNC path then.
            //
            // This step is skipped when it is very clear that the user actually
            // intended to point at an UNC path. This is assumed when the first
            // non-empty string arguments starts with exactly two slashes followed by
            // at least one more non-slash character.
            //
            // Note that for normalize() to treat a path as an UNC path it needs to
            // have at least 2 components, so we don't filter for that here.
            // This means that the user can use join to construct UNC paths from
            // a server name and a share name; for example:
            //   path.join('//server', 'share') -> '\\\\server\\share\\')
            var needsReplace = true;
            var slashCount = 0;
            if (isPathSeparator(firstPart.charCodeAt(0))) {
                ++slashCount;
                var firstLen = firstPart.length;
                if (firstLen > 1) {
                    if (isPathSeparator(firstPart.charCodeAt(1))) {
                        ++slashCount;
                        if (firstLen > 2) {
                            if (isPathSeparator(firstPart.charCodeAt(2)))
                                ++slashCount;
                            else {
                                // We matched a UNC path in the first part
                                needsReplace = false;
                            }
                        }
                    }
                }
            }
            if (needsReplace) {
                // Find any more consecutive slashes we need to replace
                for (; slashCount < joined.length; ++slashCount) {
                    if (!isPathSeparator(joined.charCodeAt(slashCount)))
                        break;
                }
                // Replace the slashes if needed
                if (slashCount >= 2)
                    joined = '\\' + joined.slice(slashCount);
            }
            return win32.normalize(joined);
        };
        // It will solve the relative path from `from` to `to`, for instance:
        //  from = 'C:\\orandea\\test\\aaa'
        //  to = 'C:\\orandea\\impl\\bbb'
        // The output of the function should be: '..\\..\\impl\\bbb'
        Win32Path.prototype.relative = function (from, to) {
            validateString(from, 'from');
            validateString(to, 'to');
            if (from === to)
                return '';
            var fromOrig = win32.resolve(from);
            var toOrig = win32.resolve(to);
            if (fromOrig === toOrig)
                return '';
            from = fromOrig.toLowerCase();
            to = toOrig.toLowerCase();
            if (from === to)
                return '';
            // Trim any leading backslashes
            var fromStart = 0;
            for (; fromStart < from.length; ++fromStart) {
                if (from.charCodeAt(fromStart) !== CHAR_BACKWARD_SLASH)
                    break;
            }
            // Trim trailing backslashes (applicable to UNC paths only)
            var fromEnd = from.length;
            for (; fromEnd - 1 > fromStart; --fromEnd) {
                if (from.charCodeAt(fromEnd - 1) !== CHAR_BACKWARD_SLASH)
                    break;
            }
            var fromLen = (fromEnd - fromStart);
            // Trim any leading backslashes
            var toStart = 0;
            for (; toStart < to.length; ++toStart) {
                if (to.charCodeAt(toStart) !== CHAR_BACKWARD_SLASH)
                    break;
            }
            // Trim trailing backslashes (applicable to UNC paths only)
            var toEnd = to.length;
            for (; toEnd - 1 > toStart; --toEnd) {
                if (to.charCodeAt(toEnd - 1) !== CHAR_BACKWARD_SLASH)
                    break;
            }
            var toLen = (toEnd - toStart);
            // Compare paths to find the longest common path from root
            var length = (fromLen < toLen ? fromLen : toLen);
            var lastCommonSep = -1;
            var i = 0;
            for (; i <= length; ++i) {
                if (i === length) {
                    if (toLen > length) {
                        if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {
                            // We get here if `from` is the exact base path for `to`.
                            // For example: from='C:\\foo\\bar'; to='C:\\foo\\bar\\baz'
                            return toOrig.slice(toStart + i + 1);
                        }
                        else if (i === 2) {
                            // We get here if `from` is the device root.
                            // For example: from='C:\\'; to='C:\\foo'
                            return toOrig.slice(toStart + i);
                        }
                    }
                    if (fromLen > length) {
                        if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {
                            // We get here if `to` is the exact base path for `from`.
                            // For example: from='C:\\foo\\bar'; to='C:\\foo'
                            lastCommonSep = i;
                        }
                        else if (i === 2) {
                            // We get here if `to` is the device root.
                            // For example: from='C:\\foo\\bar'; to='C:\\'
                            lastCommonSep = 3;
                        }
                    }
                    break;
                }
                var fromCode = from.charCodeAt(fromStart + i);
                var toCode = to.charCodeAt(toStart + i);
                if (fromCode !== toCode)
                    break;
                else if (fromCode === CHAR_BACKWARD_SLASH)
                    lastCommonSep = i;
            }
            // We found a mismatch before the first common path separator was seen, so
            // return the original `to`.
            if (i !== length && lastCommonSep === -1) {
                return toOrig;
            }
            var out = '';
            if (lastCommonSep === -1)
                lastCommonSep = 0;
            // Generate the relative path based on the path difference between `to` and
            // `from`
            for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
                if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {
                    if (out.length === 0)
                        out += '..';
                    else
                        out += '\\..';
                }
            }
            // Lastly, append the rest of the destination (`to`) path that comes after
            // the common path parts
            if (out.length > 0)
                return out + toOrig.slice(toStart + lastCommonSep, toEnd);
            else {
                toStart += lastCommonSep;
                if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH)
                    ++toStart;
                return toOrig.slice(toStart, toEnd);
            }
        };
        Win32Path.prototype.toNamespacedPath = function (path) {
            // Note: this will *probably* throw somewhere.
            if (typeof path !== 'string')
                return path;
            if (path.length === 0) {
                return '';
            }
            var resolvedPath = win32.resolve(path);
            if (resolvedPath.length >= 3) {
                if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {
                    // Possible UNC root
                    if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {
                        var code = resolvedPath.charCodeAt(2);
                        if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {
                            // Matched non-long UNC root, convert the path to a long UNC path
                            return '\\\\?\\UNC\\' + resolvedPath.slice(2);
                        }
                    }
                }
                else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {
                    // Possible device root
                    if (resolvedPath.charCodeAt(1) === CHAR_COLON &&
                        resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {
                        // Matched device root, convert the path to a long UNC path
                        return '\\\\?\\' + resolvedPath;
                    }
                }
            }
            return path;
        };
        Win32Path.prototype.dirname = function (path) {
            validateString(path, 'path');
            var len = path.length;
            if (len === 0)
                return '.';
            var rootEnd = -1;
            var end = -1;
            var matchedSlash = true;
            var offset = 0;
            var code = path.charCodeAt(0);
            // Try to match a root
            if (len > 1) {
                if (isPathSeparator(code)) {
                    // Possible UNC root
                    rootEnd = offset = 1;
                    if (isPathSeparator(path.charCodeAt(1))) {
                        // Matched double path separator at beginning
                        var j = 2;
                        var last = j;
                        // Match 1 or more non-path separators
                        for (; j < len; ++j) {
                            if (isPathSeparator(path.charCodeAt(j)))
                                break;
                        }
                        if (j < len && j !== last) {
                            // Matched!
                            last = j;
                            // Match 1 or more path separators
                            for (; j < len; ++j) {
                                if (!isPathSeparator(path.charCodeAt(j)))
                                    break;
                            }
                            if (j < len && j !== last) {
                                // Matched!
                                last = j;
                                // Match 1 or more non-path separators
                                for (; j < len; ++j) {
                                    if (isPathSeparator(path.charCodeAt(j)))
                                        break;
                                }
                                if (j === len) {
                                    // We matched a UNC root only
                                    return path;
                                }
                                if (j !== last) {
                                    // We matched a UNC root with leftovers
                                    // Offset by 1 to include the separator after the UNC root to
                                    // treat it as a "normal root" on top of a (UNC) root
                                    rootEnd = offset = j + 1;
                                }
                            }
                        }
                    }
                }
                else if (isWindowsDeviceRoot(code)) {
                    // Possible device root
                    if (path.charCodeAt(1) === CHAR_COLON) {
                        rootEnd = offset = 2;
                        if (len > 2) {
                            if (isPathSeparator(path.charCodeAt(2)))
                                rootEnd = offset = 3;
                        }
                    }
                }
            }
            else if (isPathSeparator(code)) {
                // `path` contains just a path separator, exit early to avoid
                // unnecessary work
                return path;
            }
            for (var i = len - 1; i >= offset; --i) {
                if (isPathSeparator(path.charCodeAt(i))) {
                    if (!matchedSlash) {
                        end = i;
                        break;
                    }
                }
                else {
                    // We saw the first non-path separator
                    matchedSlash = false;
                }
            }
            if (end === -1) {
                if (rootEnd === -1)
                    return '.';
                else
                    end = rootEnd;
            }
            return path.slice(0, end);
        };
        Win32Path.prototype.basename = function (path, ext) {
            if (ext !== undefined)
                validateString(ext, 'ext');
            validateString(path, 'path');
            var start = 0;
            var end = -1;
            var matchedSlash = true;
            var i;
            // Check for a drive letter prefix so as not to mistake the following
            // path separator as an extra separator at the end of the path that can be
            // disregarded
            if (path.length >= 2) {
                var drive = path.charCodeAt(0);
                if (isWindowsDeviceRoot(drive)) {
                    if (path.charCodeAt(1) === CHAR_COLON)
                        start = 2;
                }
            }
            if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
                if (ext.length === path.length && ext === path)
                    return '';
                var extIdx = ext.length - 1;
                var firstNonSlashEnd = -1;
                for (i = path.length - 1; i >= start; --i) {
                    var code = path.charCodeAt(i);
                    if (isPathSeparator(code)) {
                        // If we reached a path separator that was not part of a set of path
                        // separators at the end of the string, stop now
                        if (!matchedSlash) {
                            start = i + 1;
                            break;
                        }
                    }
                    else {
                        if (firstNonSlashEnd === -1) {
                            // We saw the first non-path separator, remember this index in case
                            // we need it if the extension ends up not matching
                            matchedSlash = false;
                            firstNonSlashEnd = i + 1;
                        }
                        if (extIdx >= 0) {
                            // Try to match the explicit extension
                            if (code === ext.charCodeAt(extIdx)) {
                                if (--extIdx === -1) {
                                    // We matched the extension, so mark this as the end of our path
                                    // component
                                    end = i;
                                }
                            }
                            else {
                                // Extension does not match, so our result is the entire path
                                // component
                                extIdx = -1;
                                end = firstNonSlashEnd;
                            }
                        }
                    }
                }
                if (start === end)
                    end = firstNonSlashEnd;
                else if (end === -1)
                    end = path.length;
                return path.slice(start, end);
            }
            else {
                for (i = path.length - 1; i >= start; --i) {
                    if (isPathSeparator(path.charCodeAt(i))) {
                        // If we reached a path separator that was not part of a set of path
                        // separators at the end of the string, stop now
                        if (!matchedSlash) {
                            start = i + 1;
                            break;
                        }
                    }
                    else if (end === -1) {
                        // We saw the first non-path separator, mark this as the end of our
                        // path component
                        matchedSlash = false;
                        end = i + 1;
                    }
                }
                if (end === -1)
                    return '';
                return path.slice(start, end);
            }
        };
        Win32Path.prototype.extname = function (path) {
            validateString(path, 'path');
            var start = 0;
            var startDot = -1;
            var startPart = 0;
            var end = -1;
            var matchedSlash = true;
            // Track the state of characters (if any) we see before our first dot and
            // after any path separator we find
            var preDotState = 0;
            // Check for a drive letter prefix so as not to mistake the following
            // path separator as an extra separator at the end of the path that can be
            // disregarded
            if (path.length >= 2 &&
                path.charCodeAt(1) === CHAR_COLON &&
                isWindowsDeviceRoot(path.charCodeAt(0))) {
                start = startPart = 2;
            }
            for (var i = path.length - 1; i >= start; --i) {
                var code = path.charCodeAt(i);
                if (isPathSeparator(code)) {
                    // If we reached a path separator that was not part of a set of path
                    // separators at the end of the string, stop now
                    if (!matchedSlash) {
                        startPart = i + 1;
                        break;
                    }
                    continue;
                }
                if (end === -1) {
                    // We saw the first non-path separator, mark this as the end of our
                    // extension
                    matchedSlash = false;
                    end = i + 1;
                }
                if (code === CHAR_DOT) {
                    // If this is our first dot, mark it as the start of our extension
                    if (startDot === -1)
                        startDot = i;
                    else if (preDotState !== 1)
                        preDotState = 1;
                }
                else if (startDot !== -1) {
                    // We saw a non-dot and non-path separator before our dot, so we should
                    // have a good chance at having a non-empty extension
                    preDotState = -1;
                }
            }
            if (startDot === -1 ||
                end === -1 ||
                // We saw a non-dot character immediately before the dot
                preDotState === 0 ||
                // The (right-most) trimmed path component is exactly '..'
                (preDotState === 1 &&
                    startDot === end - 1 &&
                    startDot === startPart + 1)) {
                return '';
            }
            return path.slice(startDot, end);
        };
        Win32Path.prototype.format = function (pathObject) {
            if (pathObject === null || typeof pathObject !== 'object') {
                throw new ERR_INVALID_ARG_TYPE('pathObject', 'Object', pathObject);
            }
            return _format('\\', pathObject);
        };
        Win32Path.prototype.parse = function (path) {
            validateString(path, 'path');
            var ret = { root: '', dir: '', base: '', ext: '', name: '' };
            if (path.length === 0)
                return ret;
            var len = path.length;
            var rootEnd = 0;
            var code = path.charCodeAt(0);
            // Try to match a root
            if (len > 1) {
                if (isPathSeparator(code)) {
                    // Possible UNC root
                    rootEnd = 1;
                    if (isPathSeparator(path.charCodeAt(1))) {
                        // Matched double path separator at beginning
                        var j = 2;
                        var last = j;
                        // Match 1 or more non-path separators
                        for (; j < len; ++j) {
                            if (isPathSeparator(path.charCodeAt(j)))
                                break;
                        }
                        if (j < len && j !== last) {
                            // Matched!
                            last = j;
                            // Match 1 or more path separators
                            for (; j < len; ++j) {
                                if (!isPathSeparator(path.charCodeAt(j)))
                                    break;
                            }
                            if (j < len && j !== last) {
                                // Matched!
                                last = j;
                                // Match 1 or more non-path separators
                                for (; j < len; ++j) {
                                    if (isPathSeparator(path.charCodeAt(j)))
                                        break;
                                }
                                if (j === len) {
                                    // We matched a UNC root only
                                    rootEnd = j;
                                }
                                else if (j !== last) {
                                    // We matched a UNC root with leftovers
                                    rootEnd = j + 1;
                                }
                            }
                        }
                    }
                }
                else if (isWindowsDeviceRoot(code)) {
                    // Possible device root
                    if (path.charCodeAt(1) === CHAR_COLON) {
                        rootEnd = 2;
                        if (len > 2) {
                            if (isPathSeparator(path.charCodeAt(2))) {
                                if (len === 3) {
                                    // `path` contains just a drive root, exit early to avoid
                                    // unnecessary work
                                    ret.root = ret.dir = path;
                                    return ret;
                                }
                                rootEnd = 3;
                            }
                        }
                        else {
                            // `path` contains just a drive root, exit early to avoid
                            // unnecessary work
                            ret.root = ret.dir = path;
                            return ret;
                        }
                    }
                }
            }
            else if (isPathSeparator(code)) {
                // `path` contains just a path separator, exit early to avoid
                // unnecessary work
                ret.root = ret.dir = path;
                return ret;
            }
            if (rootEnd > 0)
                ret.root = path.slice(0, rootEnd);
            var startDot = -1;
            var startPart = rootEnd;
            var end = -1;
            var matchedSlash = true;
            var i = path.length - 1;
            // Track the state of characters (if any) we see before our first dot and
            // after any path separator we find
            var preDotState = 0;
            // Get non-dir info
            for (; i >= rootEnd; --i) {
                code = path.charCodeAt(i);
                if (isPathSeparator(code)) {
                    // If we reached a path separator that was not part of a set of path
                    // separators at the end of the string, stop now
                    if (!matchedSlash) {
                        startPart = i + 1;
                        break;
                    }
                    continue;
                }
                if (end === -1) {
                    // We saw the first non-path separator, mark this as the end of our
                    // extension
                    matchedSlash = false;
                    end = i + 1;
                }
                if (code === CHAR_DOT) {
                    // If this is our first dot, mark it as the start of our extension
                    if (startDot === -1)
                        startDot = i;
                    else if (preDotState !== 1)
                        preDotState = 1;
                }
                else if (startDot !== -1) {
                    // We saw a non-dot and non-path separator before our dot, so we should
                    // have a good chance at having a non-empty extension
                    preDotState = -1;
                }
            }
            if (startDot === -1 ||
                end === -1 ||
                // We saw a non-dot character immediately before the dot
                preDotState === 0 ||
                // The (right-most) trimmed path component is exactly '..'
                (preDotState === 1 &&
                    startDot === end - 1 &&
                    startDot === startPart + 1)) {
                if (end !== -1) {
                    ret.base = ret.name = path.slice(startPart, end);
                }
            }
            else {
                ret.name = path.slice(startPart, startDot);
                ret.base = path.slice(startPart, end);
                ret.ext = path.slice(startDot, end);
            }
            // If the directory is the root, use the entire root as the `dir` including
            // the trailing slash if any (`C:\abc` -> `C:\`). Otherwise, strip out the
            // trailing slash (`C:\abc\def` -> `C:\abc`).
            if (startPart > 0 && startPart !== rootEnd)
                ret.dir = path.slice(0, startPart - 1);
            else
                ret.dir = ret.root;
            return ret;
        };
        return Win32Path;
    }());
    ;
    var PosixPath = /** @class */ (function () {
        function PosixPath() {
            this.sep = '/';
            this.delimiter = ':';
            this.win32 = null;
            this.posix = null;
        }
        // path.resolve([from ...], to)
        PosixPath.prototype.resolve = function () {
            var pathSegments = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                pathSegments[_i] = arguments[_i];
            }
            var resolvedPath = '';
            var resolvedAbsolute = false;
            for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
                var path;
                if (i >= 0)
                    path = arguments[i];
                else {
                    path = process.cwd();
                }
                validateString(path, 'path');
                // Skip empty entries
                if (path.length === 0) {
                    continue;
                }
                resolvedPath = path + '/' + resolvedPath;
                resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
            }
            // At this point the path should be resolved to a full absolute path, but
            // handle relative paths to be safe (might happen when process.cwd() fails)
            // Normalize the path
            resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/', isPosixPathSeparator);
            if (resolvedAbsolute) {
                if (resolvedPath.length > 0)
                    return '/' + resolvedPath;
                else
                    return '/';
            }
            else if (resolvedPath.length > 0) {
                return resolvedPath;
            }
            else {
                return '.';
            }
        };
        PosixPath.prototype.normalize = function (path) {
            validateString(path, 'path');
            if (path.length === 0)
                return '.';
            var isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
            var trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;
            // Normalize the path
            path = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);
            if (path.length === 0 && !isAbsolute)
                path = '.';
            if (path.length > 0 && trailingSeparator)
                path += '/';
            if (isAbsolute)
                return '/' + path;
            return path;
        };
        PosixPath.prototype.isAbsolute = function (path) {
            validateString(path, 'path');
            return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;
        };
        PosixPath.prototype.join = function () {
            if (arguments.length === 0)
                return '.';
            var joined;
            for (var i = 0; i < arguments.length; ++i) {
                var arg = arguments[i];
                validateString(arg, 'path');
                if (arg.length > 0) {
                    if (joined === undefined)
                        joined = arg;
                    else
                        joined += '/' + arg;
                }
            }
            if (joined === undefined)
                return '.';
            return posix.normalize(joined);
        };
        PosixPath.prototype.relative = function (from, to) {
            validateString(from, 'from');
            validateString(to, 'to');
            if (from === to)
                return '';
            from = posix.resolve(from);
            to = posix.resolve(to);
            if (from === to)
                return '';
            // Trim any leading backslashes
            var fromStart = 1;
            for (; fromStart < from.length; ++fromStart) {
                if (from.charCodeAt(fromStart) !== CHAR_FORWARD_SLASH)
                    break;
            }
            var fromEnd = from.length;
            var fromLen = (fromEnd - fromStart);
            // Trim any leading backslashes
            var toStart = 1;
            for (; toStart < to.length; ++toStart) {
                if (to.charCodeAt(toStart) !== CHAR_FORWARD_SLASH)
                    break;
            }
            var toEnd = to.length;
            var toLen = (toEnd - toStart);
            // Compare paths to find the longest common path from root
            var length = (fromLen < toLen ? fromLen : toLen);
            var lastCommonSep = -1;
            var i = 0;
            for (; i <= length; ++i) {
                if (i === length) {
                    if (toLen > length) {
                        if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {
                            // We get here if `from` is the exact base path for `to`.
                            // For example: from='/foo/bar'; to='/foo/bar/baz'
                            return to.slice(toStart + i + 1);
                        }
                        else if (i === 0) {
                            // We get here if `from` is the root
                            // For example: from='/'; to='/foo'
                            return to.slice(toStart + i);
                        }
                    }
                    else if (fromLen > length) {
                        if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {
                            // We get here if `to` is the exact base path for `from`.
                            // For example: from='/foo/bar/baz'; to='/foo/bar'
                            lastCommonSep = i;
                        }
                        else if (i === 0) {
                            // We get here if `to` is the root.
                            // For example: from='/foo'; to='/'
                            lastCommonSep = 0;
                        }
                    }
                    break;
                }
                var fromCode = from.charCodeAt(fromStart + i);
                var toCode = to.charCodeAt(toStart + i);
                if (fromCode !== toCode)
                    break;
                else if (fromCode === CHAR_FORWARD_SLASH)
                    lastCommonSep = i;
            }
            var out = '';
            // Generate the relative path based on the path difference between `to`
            // and `from`
            for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
                if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {
                    if (out.length === 0)
                        out += '..';
                    else
                        out += '/..';
                }
            }
            // Lastly, append the rest of the destination (`to`) path that comes after
            // the common path parts
            if (out.length > 0)
                return out + to.slice(toStart + lastCommonSep);
            else {
                toStart += lastCommonSep;
                if (to.charCodeAt(toStart) === CHAR_FORWARD_SLASH)
                    ++toStart;
                return to.slice(toStart);
            }
        };
        PosixPath.prototype.toNamespacedPath = function (path) {
            // Non-op on posix systems
            return path;
        };
        PosixPath.prototype.dirname = function (path) {
            validateString(path, 'path');
            if (path.length === 0)
                return '.';
            var hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
            var end = -1;
            var matchedSlash = true;
            for (var i = path.length - 1; i >= 1; --i) {
                if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {
                    if (!matchedSlash) {
                        end = i;
                        break;
                    }
                }
                else {
                    // We saw the first non-path separator
                    matchedSlash = false;
                }
            }
            if (end === -1)
                return hasRoot ? '/' : '.';
            if (hasRoot && end === 1)
                return '//';
            return path.slice(0, end);
        };
        PosixPath.prototype.basename = function (path, ext) {
            if (ext !== undefined)
                validateString(ext, 'ext');
            validateString(path, 'path');
            var start = 0;
            var end = -1;
            var matchedSlash = true;
            var i;
            if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
                if (ext.length === path.length && ext === path)
                    return '';
                var extIdx = ext.length - 1;
                var firstNonSlashEnd = -1;
                for (i = path.length - 1; i >= 0; --i) {
                    var code = path.charCodeAt(i);
                    if (code === CHAR_FORWARD_SLASH) {
                        // If we reached a path separator that was not part of a set of path
                        // separators at the end of the string, stop now
                        if (!matchedSlash) {
                            start = i + 1;
                            break;
                        }
                    }
                    else {
                        if (firstNonSlashEnd === -1) {
                            // We saw the first non-path separator, remember this index in case
                            // we need it if the extension ends up not matching
                            matchedSlash = false;
                            firstNonSlashEnd = i + 1;
                        }
                        if (extIdx >= 0) {
                            // Try to match the explicit extension
                            if (code === ext.charCodeAt(extIdx)) {
                                if (--extIdx === -1) {
                                    // We matched the extension, so mark this as the end of our path
                                    // component
                                    end = i;
                                }
                            }
                            else {
                                // Extension does not match, so our result is the entire path
                                // component
                                extIdx = -1;
                                end = firstNonSlashEnd;
                            }
                        }
                    }
                }
                if (start === end)
                    end = firstNonSlashEnd;
                else if (end === -1)
                    end = path.length;
                return path.slice(start, end);
            }
            else {
                for (i = path.length - 1; i >= 0; --i) {
                    if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {
                        // If we reached a path separator that was not part of a set of path
                        // separators at the end of the string, stop now
                        if (!matchedSlash) {
                            start = i + 1;
                            break;
                        }
                    }
                    else if (end === -1) {
                        // We saw the first non-path separator, mark this as the end of our
                        // path component
                        matchedSlash = false;
                        end = i + 1;
                    }
                }
                if (end === -1)
                    return '';
                return path.slice(start, end);
            }
        };
        PosixPath.prototype.extname = function (path) {
            validateString(path, 'path');
            var startDot = -1;
            var startPart = 0;
            var end = -1;
            var matchedSlash = true;
            // Track the state of characters (if any) we see before our first dot and
            // after any path separator we find
            var preDotState = 0;
            for (var i = path.length - 1; i >= 0; --i) {
                var code = path.charCodeAt(i);
                if (code === CHAR_FORWARD_SLASH) {
                    // If we reached a path separator that was not part of a set of path
                    // separators at the end of the string, stop now
                    if (!matchedSlash) {
                        startPart = i + 1;
                        break;
                    }
                    continue;
                }
                if (end === -1) {
                    // We saw the first non-path separator, mark this as the end of our
                    // extension
                    matchedSlash = false;
                    end = i + 1;
                }
                if (code === CHAR_DOT) {
                    // If this is our first dot, mark it as the start of our extension
                    if (startDot === -1)
                        startDot = i;
                    else if (preDotState !== 1)
                        preDotState = 1;
                }
                else if (startDot !== -1) {
                    // We saw a non-dot and non-path separator before our dot, so we should
                    // have a good chance at having a non-empty extension
                    preDotState = -1;
                }
            }
            if (startDot === -1 ||
                end === -1 ||
                // We saw a non-dot character immediately before the dot
                preDotState === 0 ||
                // The (right-most) trimmed path component is exactly '..'
                (preDotState === 1 &&
                    startDot === end - 1 &&
                    startDot === startPart + 1)) {
                return '';
            }
            return path.slice(startDot, end);
        };
        PosixPath.prototype.format = function (pathObject) {
            if (pathObject === null || typeof pathObject !== 'object') {
                throw new ERR_INVALID_ARG_TYPE('pathObject', 'Object', pathObject);
            }
            return _format('/', pathObject);
        };
        PosixPath.prototype.parse = function (path) {
            validateString(path, 'path');
            var ret = { root: '', dir: '', base: '', ext: '', name: '' };
            if (path.length === 0)
                return ret;
            var isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
            var start;
            if (isAbsolute) {
                ret.root = '/';
                start = 1;
            }
            else {
                start = 0;
            }
            var startDot = -1;
            var startPart = 0;
            var end = -1;
            var matchedSlash = true;
            var i = path.length - 1;
            // Track the state of characters (if any) we see before our first dot and
            // after any path separator we find
            var preDotState = 0;
            // Get non-dir info
            for (; i >= start; --i) {
                var code = path.charCodeAt(i);
                if (code === CHAR_FORWARD_SLASH) {
                    // If we reached a path separator that was not part of a set of path
                    // separators at the end of the string, stop now
                    if (!matchedSlash) {
                        startPart = i + 1;
                        break;
                    }
                    continue;
                }
                if (end === -1) {
                    // We saw the first non-path separator, mark this as the end of our
                    // extension
                    matchedSlash = false;
                    end = i + 1;
                }
                if (code === CHAR_DOT) {
                    // If this is our first dot, mark it as the start of our extension
                    if (startDot === -1)
                        startDot = i;
                    else if (preDotState !== 1)
                        preDotState = 1;
                }
                else if (startDot !== -1) {
                    // We saw a non-dot and non-path separator before our dot, so we should
                    // have a good chance at having a non-empty extension
                    preDotState = -1;
                }
            }
            if (startDot === -1 ||
                end === -1 ||
                // We saw a non-dot character immediately before the dot
                preDotState === 0 ||
                // The (right-most) trimmed path component is exactly '..'
                (preDotState === 1 &&
                    startDot === end - 1 &&
                    startDot === startPart + 1)) {
                if (end !== -1) {
                    if (startPart === 0 && isAbsolute)
                        ret.base = ret.name = path.slice(1, end);
                    else
                        ret.base = ret.name = path.slice(startPart, end);
                }
            }
            else {
                if (startPart === 0 && isAbsolute) {
                    ret.name = path.slice(1, startDot);
                    ret.base = path.slice(1, end);
                }
                else {
                    ret.name = path.slice(startPart, startDot);
                    ret.base = path.slice(startPart, end);
                }
                ret.ext = path.slice(startDot, end);
            }
            if (startPart > 0)
                ret.dir = path.slice(0, startPart - 1);
            else if (isAbsolute)
                ret.dir = '/';
            return ret;
        };
        return PosixPath;
    }());
    ;
    var win32 = new Win32Path();
    var posix = new PosixPath();
    posix.win32 = win32.win32 = win32;
    posix.posix = win32.posix = posix;
    // Legacy internal API, docs-only deprecated: DEP0080
    // win32._makeLong = win32.toNamespacedPath;
    // posix._makeLong = posix.toNamespacedPath;
    // if (process.platform === 'win32')
    //     module.exports = win32;
    // else
    //     module.exports = posix;
    // 
    if (process.platform === 'win32')
        feng3d.path = win32;
    else
        feng3d.path = posix;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 常用正则表示式
     */
    var RegExps = /** @class */ (function () {
        function RegExps() {
            /**
             * json文件
             */
            this.json = /(\.json)\b/i;
            /**
             * 图片
             */
            this.image = /(\.jpg|\.png|\.jpeg|\.gif)\b/i;
            /**
             * 声音
             */
            this.audio = /(\.ogg|\.mp3|\.wav)\b/i;
            /**
             * 命名空间
             */
            this.namespace = /namespace\s+([\w$_\d\.]+)/;
            /**
             * 类
             */
            this.classReg = /(export\s+)?(abstract\s+)?class\s+([\w$_\d]+)(\s+extends\s+([\w$_\d\.]+))?/;
        }
        return RegExps;
    }());
    feng3d.RegExps = RegExps;
    feng3d.regExps = new RegExps();
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 对象池
     *
     * 对象池并不能带来性能的提升，反而会严重影响性能。但是在管理内存时可以考虑使用。
     *
     * js虚拟机会在对象没有被引用时自动释放内存，谨慎使用对象池。
     *
     */
    var Pool = /** @class */ (function () {
        function Pool(type) {
            this._objects = [];
            this._type = type;
        }
        /**
         * 获取对象
         */
        Pool.prototype.get = function () {
            var obj = this._objects.pop();
            if (obj)
                return obj;
            return new this._type();
        };
        /**
         * 释放对象
         *
         * @param args 被释放对象列表
         */
        Pool.prototype.release = function () {
            var _this = this;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            args.forEach(function (element) {
                _this._objects.push(element);
            });
        };
        /**
         * 获取指定数量的对象
         *
         * @param num 数量
         */
        Pool.prototype.getArray = function (num) {
            var arr;
            if (this._objects.length <= num) {
                arr = this._objects.concat();
                this._objects.length = 0;
            }
            else {
                arr = this._objects.splice(0, num);
            }
            while (arr.length < num) {
                arr.push(new this._type());
            }
            return arr;
        };
        /**
         * 释放对象
         *
         * @param objects 被释放对象列表
         */
        Pool.prototype.releaseArray = function (objects) {
            var _this = this;
            objects.forEach(function (element) {
                _this._objects.push(element);
            });
        };
        return Pool;
    }());
    feng3d.Pool = Pool;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 比较器
     */
    var Comparator = /** @class */ (function () {
        /**
         * 构建比较器
         * @param compareFunction 比较函数
         */
        function Comparator(compareFunction) {
            this.compare = compareFunction || Comparator.defaultCompareFunction;
        }
        /**
         * 默认比较函数。只能处理 a和b 同为string或number的比较。
         *
         * @param a 比较值a
         * @param b 比较值b
         */
        Comparator.defaultCompareFunction = function (a, b) {
            if (a === b)
                return 0;
            return a < b ? -1 : 1;
        };
        /**
         * 检查 a 是否等于 b 。
         *
         * @param a 值a
         * @param b 值b
         */
        Comparator.prototype.equal = function (a, b) {
            return this.compare(a, b) === 0;
        };
        /**
         * 检查 a 是否小于 b 。
         *
         * @param a 值a
         * @param b 值b
         */
        Comparator.prototype.lessThan = function (a, b) {
            return this.compare(a, b) < 0;
        };
        /**
         * 检查 a 是否大于 b 。
         *
         * @param a 值a
         * @param b 值b
         */
        Comparator.prototype.greaterThan = function (a, b) {
            return this.compare(a, b) > 0;
        };
        /**
         * 检查 a 是否小于等于 b 。
         *
         * @param a 值a
         * @param b 值b
         */
        Comparator.prototype.lessThanOrEqual = function (a, b) {
            return this.lessThan(a, b) || this.equal(a, b);
        };
        /**
         * 检查 a 是否大于等于 b 。
         *
         * @param a 值a
         * @param b 值b
         */
        Comparator.prototype.greaterThanOrEqual = function (a, b) {
            return this.greaterThan(a, b) || this.equal(a, b);
        };
        /**
         * 反转比较函数。
         */
        Comparator.prototype.reverse = function () {
            var compareOriginal = this.compare;
            this.compare = function (a, b) { return compareOriginal(b, a); };
        };
        return Comparator;
    }());
    feng3d.Comparator = Comparator;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 工具
     */
    var Utils = /** @class */ (function () {
        function Utils() {
        }
        /**
         * 初始化数组
         * @param arraylike 类数组
         */
        Utils.prototype.arrayFrom = function (arraylike) {
            var arr = [];
            for (var i = 0; i < arraylike.length; i++) {
                arr[i] = arraylike[i];
            }
            return arr;
        };
        /**
         * 使数组元素变得唯一,除去相同值
         * @param equalFn 比较函数
         */
        Utils.prototype.arrayUnique = function (arr, equal) {
            if (equal === void 0) { equal = function (a, b) { return (a == b); }; }
            for (var i = arr.length - 1; i >= 0; i--) {
                for (var j = 0; j < i; j++) {
                    if (equal(arr[i], arr[j])) {
                        arr.splice(i, 1);
                        break;
                    }
                }
            }
            return this;
        };
        /**
         * 数组元素是否唯一
         * @param equalFn 比较函数
         */
        Utils.prototype.arrayIsUnique = function (array, equalFn) {
            if (equalFn === void 0) { equalFn = function (a, b) { return (a == b); }; }
            for (var i = array.length - 1; i >= 0; i--) {
                for (var j = 0; j < i; j++) {
                    if (equalFn(array[i], array[j])) {
                        return false;
                    }
                }
            }
            return true;
        };
        /**
         * 创建数组
         * @param length 长度
         * @param itemFunc 创建元素方法
         */
        Utils.prototype.createArray = function (length, itemFunc) {
            var arr = [];
            for (var i = 0; i < length; i++) {
                arr[i] = itemFunc(i);
            }
            return arr;
        };
        /**
         * 二分查找,如果有多个则返回第一个
         * @param   array   数组
         * @param	target	寻找的目标
         * @param	compare	比较函数
         * @param   start   起始位置
         * @param   end     结束位置
         * @return          查找到目标时返回所在位置，否则返回-1
         */
        Utils.prototype.binarySearch = function (array, target, compare, start, end) {
            var insert = this.binarySearchInsert(array, target, compare, start, end);
            if (array[insert] == target)
                return insert;
            return -1;
        };
        /**
         * 二分查找插入位置,如果有多个则返回第一个
         * @param   array   数组
         * @param	target	寻找的目标
         * @param	compare	比较函数
         * @param   start   起始位置
         * @param   end     结束位置
         * @return          目标所在位置（如果该位置上不是目标对象，则该索引为该目标可插入的位置）
         */
        Utils.prototype.binarySearchInsert = function (array, target, compare, start, end) {
            if (start === undefined)
                start = 0;
            if (end === undefined)
                end = array.length;
            if (start == end)
                return start;
            if (compare(array[start], target) == 0) {
                return start;
            }
            var middle = ~~((start + end) / 2);
            if (compare(array[middle], target) < 0) {
                start = middle + 1;
            }
            else {
                end = middle;
            }
            return this.binarySearchInsert(array, target, compare, start, end);
        };
        return Utils;
    }());
    feng3d.Utils = Utils;
    feng3d.utils = new Utils();
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 链表
     *
     * @see https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/linked-list/LinkedList.js
     */
    var LinkedList = /** @class */ (function () {
        /**
         * 构建双向链表
         *
         * @param comparatorFunction 比较函数
         */
        function LinkedList(comparatorFunction) {
            this.head = null;
            this.tail = null;
            this.compare = new feng3d.Comparator(comparatorFunction);
        }
        /**
         * 是否为空
         */
        LinkedList.prototype.isEmpty = function () {
            return !this.head;
        };
        /**
         * 清空
         */
        LinkedList.prototype.empty = function () {
            this.head = null;
            this.tail = null;
        };
        /**
         * 获取表头值
         */
        LinkedList.prototype.getHeadValue = function () {
            return this.head && this.head.value;
        };
        /**
         * 添加新结点到表头
         *
         * @param value 结点数据
         */
        LinkedList.prototype.addHead = function (value) {
            var newNode = { value: value, next: this.head };
            this.head = newNode;
            if (!this.tail)
                this.tail = newNode;
            return this;
        };
        /**
         * 添加新结点到表尾
         *
         * @param value 结点数据
         */
        LinkedList.prototype.addTail = function (value) {
            var newNode = { value: value, next: null };
            if (this.tail)
                this.tail.next = newNode;
            this.tail = newNode;
            if (!this.head)
                this.head = newNode;
            return this;
        };
        /**
         * 删除链表中第一个与指定值相等的结点
         *
         * @param value 结点值
         */
        LinkedList.prototype.delete = function (value) {
            if (!this.head)
                return null;
            var deletedNode = null;
            // 从表头删除结点
            while (this.head && !deletedNode && this.compare.equal(this.head.value, value)) {
                deletedNode = this.head;
                this.head = this.head.next;
            }
            var currentNode = this.head;
            if (!deletedNode && currentNode) {
                // 删除相等的下一个结点
                while (!deletedNode && currentNode.next) {
                    if (this.compare.equal(currentNode.next.value, value)) {
                        deletedNode = currentNode.next;
                        currentNode.next = currentNode.next.next;
                    }
                    else {
                        currentNode = currentNode.next;
                    }
                }
            }
            // currentNode 是否为表尾
            if (currentNode == null || currentNode.next == null) {
                this.tail = currentNode;
            }
            return deletedNode;
        };
        /**
         * 删除链表中所有与指定值相等的结点
         *
         * @param value 结点值
         */
        LinkedList.prototype.deleteAll = function (value) {
            if (!this.head)
                return null;
            var deletedNode = null;
            // 从表头删除结点
            while (this.head && this.compare.equal(this.head.value, value)) {
                deletedNode = this.head;
                this.head = this.head.next;
            }
            var currentNode = this.head;
            if (currentNode !== null) {
                // 删除相等的下一个结点
                while (currentNode.next) {
                    if (this.compare.equal(currentNode.next.value, value)) {
                        deletedNode = currentNode.next;
                        currentNode.next = currentNode.next.next;
                    }
                    else {
                        currentNode = currentNode.next;
                    }
                }
            }
            // currentNode 是否为表尾
            if (currentNode == null || currentNode.next == null) {
                this.tail = currentNode;
            }
            return deletedNode;
        };
        /**
         * 查找与结点值相等的结点
         *
         * @param value 结点值
         */
        LinkedList.prototype.find = function (value) {
            if (!this.head)
                return null;
            var currentNode = this.head;
            while (currentNode) {
                if (this.compare.equal(currentNode.value, value))
                    return currentNode;
                currentNode = currentNode.next;
            }
            return null;
        };
        /**
         * 查找与结点值相等的结点
         *
         * @param callback 判断是否为查找的元素
         */
        LinkedList.prototype.findByFunc = function (callback) {
            if (!this.head)
                return null;
            var currentNode = this.head;
            while (currentNode) {
                if (callback(currentNode.value))
                    return currentNode;
                currentNode = currentNode.next;
            }
            return null;
        };
        /**
         * 删除表头
         *
         * 删除链表前面的元素(链表的头)并返回元素值。如果队列为空，则返回null。
         */
        LinkedList.prototype.deleteHead = function () {
            if (!this.head)
                return null;
            var deletedHead = this.head;
            if (this.head.next) {
                this.head = this.head.next;
            }
            else {
                this.head = null;
                this.tail = null;
            }
            return deletedHead.value;
        };
        /**
         * 删除表尾
         */
        LinkedList.prototype.deleteTail = function () {
            if (!this.tail)
                return null;
            var deletedTail = this.tail;
            if (this.head === this.tail) {
                this.head = null;
                this.tail = null;
                return deletedTail.value;
            }
            // 遍历链表删除表尾
            var currentNode = this.head;
            while (currentNode.next) {
                if (!currentNode.next.next) {
                    currentNode.next = null;
                }
                else {
                    currentNode = currentNode.next;
                }
            }
            this.tail = currentNode;
            return deletedTail.value;
        };
        /**
         * 从数组中初始化链表
         *
         * @param values 结点值列表
         */
        LinkedList.prototype.fromArray = function (values) {
            var _this = this;
            this.empty();
            values.forEach(function (value) { return _this.addTail(value); });
            return this;
        };
        /**
         * 转换为数组
         */
        LinkedList.prototype.toArray = function () {
            var values = [];
            var currentNode = this.head;
            while (currentNode) {
                values.push(currentNode.value);
                currentNode = currentNode.next;
            }
            return values;
        };
        /**
         * 转换为字符串
         *
         * @param valueToString 值输出为字符串函数
         */
        LinkedList.prototype.toString = function (valueToString) {
            return this.toArray().map(function (value) { return valueToString ? valueToString(value) : "" + value; }).toString();
        };
        /**
         * 反转链表
         */
        LinkedList.prototype.reverse = function () {
            var currNode = this.head;
            var prevNode = null;
            var nextNode = null;
            while (currNode) {
                // 存储下一个结点
                nextNode = currNode.next;
                // 反转结点的next指向
                currNode.next = prevNode;
                // 存储上一个节点
                prevNode = currNode;
                // 遍历指针向后移动
                currNode = nextNode;
            }
            // 重置表头与表尾
            this.tail = this.head;
            this.head = prevNode;
            return this;
        };
        /**
         * 核查结构是否正确
         */
        LinkedList.prototype.checkStructure = function () {
            if (this.head) {
                var currNode = this.head;
                while (currNode.next) {
                    currNode = currNode.next;
                }
                return this.tail == currNode;
            }
            return !this.tail;
        };
        return LinkedList;
    }());
    feng3d.LinkedList = LinkedList;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 双向链表
     *
     * @see https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/doubly-linked-list/DoublyLinkedList.js
     */
    var DoublyLinkedList = /** @class */ (function () {
        /**
         * 构建双向链表
         *
         * @param comparatorFunction 比较函数
         */
        function DoublyLinkedList(comparatorFunction) {
            this.head = null;
            this.tail = null;
            this.compare = new feng3d.Comparator(comparatorFunction);
        }
        /**
         * 是否为空
         */
        DoublyLinkedList.prototype.isEmpty = function () {
            return !this.head;
        };
        /**
         * 清空
         */
        DoublyLinkedList.prototype.empty = function () {
            this.head = null;
            this.tail = null;
        };
        /**
         * 添加新结点到表头
         *
         * @param value 结点数据
         */
        DoublyLinkedList.prototype.addHead = function (value) {
            var newNode = { value: value, previous: null, next: this.head };
            if (this.head)
                this.head.previous = newNode;
            this.head = newNode;
            if (!this.tail)
                this.tail = newNode;
            return this;
        };
        /**
         * 添加新结点到表尾
         *
         * @param value 结点数据
         */
        DoublyLinkedList.prototype.addTail = function (value) {
            var newNode = { value: value, previous: this.tail, next: null };
            if (this.tail)
                this.tail.next = newNode;
            this.tail = newNode;
            if (!this.head)
                this.head = newNode;
            return this;
        };
        /**
         * 删除链表中第一个与指定值相等的结点
         *
         * @param value 结点值
         */
        DoublyLinkedList.prototype.delete = function (value) {
            if (!this.head)
                return null;
            var deletedNode = null;
            // 从表头删除结点
            while (this.head && !deletedNode && this.compare.equal(this.head.value, value)) {
                deletedNode = this.head;
                this.head = this.head.next;
                this.head.previous = null;
            }
            var currentNode = this.head;
            if (!deletedNode && currentNode) {
                // 删除相等的下一个结点
                while (!deletedNode && currentNode.next) {
                    if (this.compare.equal(currentNode.next.value, value)) {
                        deletedNode = currentNode.next;
                        currentNode.next = currentNode.next.next;
                        if (currentNode.next)
                            currentNode.next.previous = currentNode;
                    }
                    else {
                        currentNode = currentNode.next;
                    }
                }
            }
            // currentNode 是否为表尾
            if (currentNode == null || currentNode.next == null) {
                this.tail = currentNode;
            }
            return deletedNode;
        };
        /**
         * 删除链表中所有与指定值相等的结点
         *
         * @param value 结点值
         */
        DoublyLinkedList.prototype.deleteAll = function (value) {
            if (!this.head)
                return null;
            var deletedNode = null;
            // 从表头删除结点
            while (this.head && this.compare.equal(this.head.value, value)) {
                deletedNode = this.head;
                this.head = this.head.next;
                this.head.previous = null;
            }
            var currentNode = this.head;
            if (currentNode !== null) {
                // 删除相等的下一个结点
                while (currentNode.next) {
                    if (this.compare.equal(currentNode.next.value, value)) {
                        deletedNode = currentNode.next;
                        currentNode.next = currentNode.next.next;
                        if (currentNode.next)
                            currentNode.next.previous = currentNode;
                    }
                    else {
                        currentNode = currentNode.next;
                    }
                }
            }
            // currentNode 是否为表尾
            if (currentNode == null || currentNode.next == null) {
                this.tail = currentNode;
            }
            return deletedNode;
        };
        /**
         * 查找与结点值相等的结点
         *
         * @param value 结点值
         */
        DoublyLinkedList.prototype.find = function (value) {
            if (!this.head)
                return null;
            var currentNode = this.head;
            while (currentNode) {
                if (this.compare.equal(currentNode.value, value))
                    return currentNode;
                currentNode = currentNode.next;
            }
            return null;
        };
        /**
         * 查找与结点值相等的结点
         *
         * @param callback 判断是否为查找的元素
         */
        DoublyLinkedList.prototype.findByFunc = function (callback) {
            if (!this.head)
                return null;
            var currentNode = this.head;
            while (currentNode) {
                if (callback(currentNode.value))
                    return currentNode;
                currentNode = currentNode.next;
            }
            return null;
        };
        /**
         * 删除表头
         */
        DoublyLinkedList.prototype.deleteHead = function () {
            if (!this.head)
                return undefined;
            var deletedHead = this.head;
            if (this.head.next) {
                this.head = this.head.next;
                this.head.previous = null;
            }
            else {
                this.head = null;
                this.tail = null;
            }
            return deletedHead.value;
        };
        /**
         * 删除表尾
         */
        DoublyLinkedList.prototype.deleteTail = function () {
            if (!this.tail)
                return undefined;
            var deletedTail = this.tail;
            if (this.head === this.tail) {
                this.head = null;
                this.tail = null;
                return deletedTail.value;
            }
            this.tail = this.tail.previous;
            this.tail.next = null;
            return deletedTail.value;
        };
        /**
         * 从数组中初始化链表
         *
         * @param values 结点值列表
         */
        DoublyLinkedList.prototype.fromArray = function (values) {
            var _this = this;
            this.empty();
            values.forEach(function (value) { return _this.addTail(value); });
            return this;
        };
        /**
         * 转换为数组
         */
        DoublyLinkedList.prototype.toArray = function () {
            var values = [];
            var currentNode = this.head;
            while (currentNode) {
                values.push(currentNode.value);
                currentNode = currentNode.next;
            }
            return values;
        };
        /**
         * 转换为字符串
         * @param valueToString 值输出为字符串函数
         */
        DoublyLinkedList.prototype.toString = function (valueToString) {
            return this.toArray().map(function (value) { return valueToString ? valueToString(value) : "" + value; }).toString();
        };
        /**
         * 反转链表
         */
        DoublyLinkedList.prototype.reverse = function () {
            var currNode = this.head;
            var prevNode = null;
            var nextNode = null;
            while (currNode) {
                // 存储当前结点的next与previous指向
                nextNode = currNode.next;
                prevNode = currNode.previous;
                // 反转结点的next与previous指向
                currNode.next = prevNode;
                currNode.previous = nextNode;
                // 存储上一个节点
                prevNode = currNode;
                // 遍历指针向后移动
                currNode = nextNode;
            }
            // 重置表头与表尾
            this.tail = this.head;
            this.head = prevNode;
            return this;
        };
        /**
         * 核查结构是否正确
         */
        DoublyLinkedList.prototype.checkStructure = function () {
            if (this.head) {
                // 核查正向链表
                var currNode = this.head;
                while (currNode.next) {
                    currNode = currNode.next;
                }
                if (this.tail !== currNode)
                    return false;
                // 核查逆向链表
                currNode = this.tail;
                while (currNode.previous) {
                    currNode = currNode.previous;
                }
                return this.head == currNode;
            }
            return !this.tail;
        };
        return DoublyLinkedList;
    }());
    feng3d.DoublyLinkedList = DoublyLinkedList;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 队列，只能从后面进，前面出
     * 使用单向链表实现
     *
     * @see https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/queue/Queue.js
     */
    var Queue = /** @class */ (function () {
        /**
         * 构建队列
         *
         * @param comparatorFunction 比较函数
         */
        function Queue() {
            this.linkedList = new feng3d.LinkedList();
        }
        /**
         * 是否为空
         */
        Queue.prototype.isEmpty = function () {
            return this.linkedList.isEmpty();
        };
        /**
         * 清空
         */
        Queue.prototype.empty = function () {
            this.linkedList.empty();
        };
        /**
         * 读取队列前面的元素，但不删除它。
         */
        Queue.prototype.peek = function () {
            return this.linkedList.getHeadValue();
        };
        /**
         * 入队
         *
         * 在队列的末尾(链表的尾部)添加一个新元素。
         * 这个元素将在它前面的所有元素之后被处理。
         *
         * @param value 元素值
         */
        Queue.prototype.enqueue = function (value) {
            this.linkedList.addTail(value);
            return this;
        };
        /**
         * 出队
         *
         * 删除队列前面的元素(链表的头)。如果队列为空，则返回null。
         */
        Queue.prototype.dequeue = function () {
            var removedValue = this.linkedList.deleteHead();
            return removedValue;
        };
        /**
         * 转换为字符串
         *
         * @param valueToString 值输出为字符串函数
         */
        Queue.prototype.toString = function (valueToString) {
            return this.linkedList.toString(valueToString);
        };
        return Queue;
    }());
    feng3d.Queue = Queue;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 栈
     *
     * 后进先出
     *
     * @see https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/stack/Stack.js
     */
    var Stack = /** @class */ (function () {
        function Stack() {
            this.linkedList = new feng3d.LinkedList();
        }
        /**
         * 是否为空
         */
        Stack.prototype.isEmpty = function () {
            return this.linkedList.isEmpty();
        };
        /**
         * 查看第一个元素值
         */
        Stack.prototype.peek = function () {
            return this.linkedList.getHeadValue();
        };
        /**
         * 入栈
         *
         * @param value 元素值
         */
        Stack.prototype.push = function (value) {
            this.linkedList.addHead(value);
            return this;
        };
        /**
         * 出栈
         */
        Stack.prototype.pop = function () {
            return this.linkedList.deleteHead();
        };
        /**
         * 转换为数组
         */
        Stack.prototype.toArray = function () {
            return this.linkedList.toArray();
        };
        /**
         * 转换为字符串
         *
         * @param valueToString 值输出为字符串函数
         */
        Stack.prototype.toString = function (valueToString) {
            return this.linkedList.toString(valueToString);
        };
        return Stack;
    }());
    feng3d.Stack = Stack;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 堆
     *
     * 最小和最大堆的父类。
     *
     * @see https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/heap/Heap.js
     */
    var Heap = /** @class */ (function () {
        /**
         * 构建链表
         *
         * @param comparatorFunction 比较函数
         */
        function Heap(comparatorFunction) {
            var _newTarget = this.constructor;
            if (_newTarget === Heap) {
                throw new TypeError('无法直接构造堆实例');
            }
            this.heapContainer = [];
            this.compare = new feng3d.Comparator(comparatorFunction);
        }
        /**
         * 获取左边子结点索引
         *
         * @param parentIndex 父结点索引
         */
        Heap.prototype.getLeftChildIndex = function (parentIndex) {
            return (2 * parentIndex) + 1;
        };
        /**
         * 获取右边子结点索引
         *
         * @param parentIndex 父结点索引
         */
        Heap.prototype.getRightChildIndex = function (parentIndex) {
            return (2 * parentIndex) + 2;
        };
        /**
         * 获取父结点索引
         *
         * @param childIndex 子结点索引
         */
        Heap.prototype.getParentIndex = function (childIndex) {
            return Math.floor((childIndex - 1) / 2);
        };
        /**
         * 是否有父结点
         *
         * @param childIndex 子结点索引
         */
        Heap.prototype.hasParent = function (childIndex) {
            return this.getParentIndex(childIndex) >= 0;
        };
        /**
         * 是否有左结点
         *
         * @param parentIndex 父结点索引
         */
        Heap.prototype.hasLeftChild = function (parentIndex) {
            return this.getLeftChildIndex(parentIndex) < this.heapContainer.length;
        };
        /**
         * 是否有右结点
         *
         * @param parentIndex 父结点索引
         */
        Heap.prototype.hasRightChild = function (parentIndex) {
            return this.getRightChildIndex(parentIndex) < this.heapContainer.length;
        };
        /**
         * 获取左结点
         *
         * @param parentIndex 父结点索引
         */
        Heap.prototype.leftChild = function (parentIndex) {
            return this.heapContainer[this.getLeftChildIndex(parentIndex)];
        };
        /**
         * 获取右结点
         *
         * @param parentIndex 父结点索引
         */
        Heap.prototype.rightChild = function (parentIndex) {
            return this.heapContainer[this.getRightChildIndex(parentIndex)];
        };
        /**
         * 获取父结点
         *
         * @param childIndex 子结点索引
         */
        Heap.prototype.parent = function (childIndex) {
            return this.heapContainer[this.getParentIndex(childIndex)];
        };
        /**
         * 交换两个结点数据
         *
         * @param index1 索引1
         * @param index2 索引2
         */
        Heap.prototype.swap = function (index1, index2) {
            var tmp = this.heapContainer[index2];
            this.heapContainer[index2] = this.heapContainer[index1];
            this.heapContainer[index1] = tmp;
        };
        /**
         * 查看堆顶数据
         */
        Heap.prototype.peek = function () {
            if (this.heapContainer.length === 0)
                return null;
            return this.heapContainer[0];
        };
        /**
         * 出堆
         *
         * 取出堆顶元素
         */
        Heap.prototype.poll = function () {
            if (this.heapContainer.length === 0)
                return null;
            if (this.heapContainer.length === 1)
                return this.heapContainer.pop();
            var item = this.heapContainer[0];
            // 将最后一个元素从末尾移动到堆顶。
            this.heapContainer[0] = this.heapContainer.pop();
            this.heapifyDown();
            return item;
        };
        /**
         * 新增元素
         *
         * @param item 元素
         */
        Heap.prototype.add = function (item) {
            this.heapContainer.push(item);
            this.heapifyUp();
            return this;
        };
        /**
         * 移除所有指定元素
         *
         * @param item 元素
         * @param comparator 比较器
         */
        Heap.prototype.remove = function (item, comparator) {
            if (comparator === void 0) { comparator = this.compare; }
            // 找到要删除的项的数量。
            var numberOfItemsToRemove = this.find(item, comparator).length;
            for (var iteration = 0; iteration < numberOfItemsToRemove; iteration += 1) {
                // 获取一个删除元素索引
                var indexToRemove = this.find(item, comparator).pop();
                // 删除元素为最后一个索引时
                if (indexToRemove === (this.heapContainer.length - 1)) {
                    this.heapContainer.pop();
                }
                else {
                    // 把数组最后元素移动到删除位置
                    this.heapContainer[indexToRemove] = this.heapContainer.pop();
                    var parentItem = this.parent(indexToRemove);
                    if (this.hasLeftChild(indexToRemove)
                        && (!parentItem
                            || this.pairIsInCorrectOrder(parentItem, this.heapContainer[indexToRemove]))) {
                        this.heapifyDown(indexToRemove);
                    }
                    else {
                        this.heapifyUp(indexToRemove);
                    }
                }
            }
            return this;
        };
        /**
         * 查找元素所在所有索引
         *
         * @param item 查找的元素
         * @param comparator 比较器
         */
        Heap.prototype.find = function (item, comparator) {
            if (comparator === void 0) { comparator = this.compare; }
            var foundItemIndices = [];
            for (var itemIndex = 0; itemIndex < this.heapContainer.length; itemIndex += 1) {
                if (comparator.equal(item, this.heapContainer[itemIndex])) {
                    foundItemIndices.push(itemIndex);
                }
            }
            return foundItemIndices;
        };
        /**
         * 是否为空
         */
        Heap.prototype.isEmpty = function () {
            return !this.heapContainer.length;
        };
        /**
         * 转换为字符串
         */
        Heap.prototype.toString = function () {
            return this.heapContainer.toString();
        };
        /**
         * 堆冒泡
         *
         * @param startIndex 堆冒泡起始索引
         */
        Heap.prototype.heapifyUp = function (startIndex) {
            var currentIndex = startIndex || this.heapContainer.length - 1;
            while (this.hasParent(currentIndex)
                && !this.pairIsInCorrectOrder(this.parent(currentIndex), this.heapContainer[currentIndex])) {
                this.swap(currentIndex, this.getParentIndex(currentIndex));
                currentIndex = this.getParentIndex(currentIndex);
            }
        };
        /**
         * 堆下沉
         *
         * @param startIndex 堆下沉起始索引
         */
        Heap.prototype.heapifyDown = function (startIndex) {
            if (startIndex === void 0) { startIndex = 0; }
            var currentIndex = startIndex;
            var nextIndex = null;
            while (this.hasLeftChild(currentIndex)) {
                if (this.hasRightChild(currentIndex)
                    && this.pairIsInCorrectOrder(this.rightChild(currentIndex), this.leftChild(currentIndex))) {
                    nextIndex = this.getRightChildIndex(currentIndex);
                }
                else {
                    nextIndex = this.getLeftChildIndex(currentIndex);
                }
                if (this.pairIsInCorrectOrder(this.heapContainer[currentIndex], this.heapContainer[nextIndex])) {
                    break;
                }
                this.swap(currentIndex, nextIndex);
                currentIndex = nextIndex;
            }
        };
        return Heap;
    }());
    feng3d.Heap = Heap;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 最大堆
     *
     * 所有父结点都大于子结点
     */
    var MaxHeap = /** @class */ (function (_super) {
        __extends(MaxHeap, _super);
        function MaxHeap() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * 检查堆元素对的顺序是否正确。
         * 对于MinHeap，第一个元素必须总是小于等于。
         * 对于MaxHeap，第一个元素必须总是大于或等于。
         *
         * @param firstElement 第一个元素
         * @param secondElement 第二个元素
         */
        MaxHeap.prototype.pairIsInCorrectOrder = function (firstElement, secondElement) {
            return this.compare.greaterThanOrEqual(firstElement, secondElement);
        };
        return MaxHeap;
    }(feng3d.Heap));
    feng3d.MaxHeap = MaxHeap;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 最小堆
     *
     * 所有父结点都小于子结点
     */
    var MinHeap = /** @class */ (function (_super) {
        __extends(MinHeap, _super);
        function MinHeap() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * 检查堆元素对的顺序是否正确。
         * 对于MinHeap，第一个元素必须总是小于等于。
         * 对于MaxHeap，第一个元素必须总是大于或等于。
         *
         * @param firstElement 第一个元素
         * @param secondElement 第二个元素
         */
        MinHeap.prototype.pairIsInCorrectOrder = function (firstElement, secondElement) {
            return this.compare.lessThanOrEqual(firstElement, secondElement);
        };
        return MinHeap;
    }(feng3d.Heap));
    feng3d.MinHeap = MinHeap;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 默认哈希表 （建议使用Object代替）
     *
     * 哈希表的大小直接影响冲突的次数。
     * 哈希表的大小越大，冲突就越少。
     */
    var defaultHashTableSize = 32;
    /**
     * 哈希表（散列表）
     *
     * @see https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/hash-table/HashTable.js
     */
    var HashTable = /** @class */ (function () {
        /**
         * 构建哈希表
         * @param hashTableSize 哈希表尺寸
         */
        function HashTable(hashTableSize) {
            if (hashTableSize === void 0) { hashTableSize = defaultHashTableSize; }
            this.buckets = [];
            for (var i = 0; i < hashTableSize; i++) {
                this.buckets.push(new feng3d.LinkedList());
            }
            this.keys = {};
        }
        /**
         * 将字符串键转换为哈希数。
         *
         * @param key 字符串键
         */
        HashTable.prototype.hash = function (key) {
            var hash = key.split("").reduce(function (hashAccumulator, char) { return (hashAccumulator + char.charCodeAt(0)); }, 0);
            return hash % this.buckets.length;
        };
        /**
         * 设置值
         *
         * @param key 键
         * @param value 值
         */
        HashTable.prototype.set = function (key, value) {
            var keyValue = { key: key, value: value };
            var keyHash = this.hash(key);
            this.keys[key] = keyHash;
            var bucketLinkedList = this.buckets[keyHash];
            var node = bucketLinkedList.findByFunc(function (v) { return v.key === key; });
            if (!node) {
                bucketLinkedList.addTail(keyValue);
            }
            else {
                node.value.value = value;
            }
        };
        /**
         * 删除指定键以及对于值
         *
         * @param key 键
         */
        HashTable.prototype.delete = function (key) {
            var keyHash = this.hash(key);
            delete this.keys[key];
            var bucketLinkedList = this.buckets[keyHash];
            var node = bucketLinkedList.findByFunc(function (v) { return v.key === key; });
            if (node) {
                return bucketLinkedList.deleteAll(node.value);
            }
            return null;
        };
        /**
         * 获取与键对应的值
         *
         * @param key 键
         */
        HashTable.prototype.get = function (key) {
            var bucketLinkedList = this.buckets[this.hash(key)];
            var node = bucketLinkedList.findByFunc(function (v) { return v.key === key; });
            return node ? node.value.value : undefined;
        };
        /**
         * 是否拥有键
         *
         * @param key 键
         */
        HashTable.prototype.has = function (key) {
            return Object.hasOwnProperty.call(this.keys, key);
        };
        /**
         * 获取键列表
         */
        HashTable.prototype.getKeys = function () {
            return Object.keys(this.keys);
        };
        return HashTable;
    }());
    feng3d.HashTable = HashTable;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 优先队列
     *
     * 所有元素按优先级排序
     *
     * @see https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/priority-queue/PriorityQueue.js
     */
    var PriorityQueue = /** @class */ (function () {
        /**
         * 构建优先数组
         * @param   compare     比较函数
         */
        function PriorityQueue(compare) {
            this.items = [];
            this.compare = compare;
        }
        Object.defineProperty(PriorityQueue.prototype, "length", {
            /**
             * 队列长度
             */
            get: function () {
                return this.items.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PriorityQueue.prototype, "compare", {
            /**
             * 比较函数
             */
            get: function () {
                return this._compare;
            },
            set: function (v) {
                this._compare = v;
                this.items.sort(this._compare);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 尾部添加元素（进队）
         * @param items 元素列表
         * @returns 长度
         */
        PriorityQueue.prototype.push = function () {
            var _this = this;
            var items = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                items[_i] = arguments[_i];
            }
            items.forEach(function (item) {
                var insert = feng3d.utils.binarySearchInsert(_this.items, item, _this._compare);
                _this.items.splice(insert, 0, item);
            });
            return this.items.length;
        };
        /**
         * 头部移除元素（出队）
         */
        PriorityQueue.prototype.shift = function () {
            return this.items.shift();
        };
        /**
         * 转换为数组
         */
        PriorityQueue.prototype.toArray = function () {
            return this.items.concat();
        };
        /**
         * 从数组初始化链表
         */
        PriorityQueue.prototype.fromArray = function (array) {
            this.items = array.concat();
            this.items.sort(this._compare);
        };
        return PriorityQueue;
    }());
    feng3d.PriorityQueue = PriorityQueue;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 优先队列
     *
     * 与最小堆相同，只是与元素比较时不同
     * 我们考虑的不是元素的值，而是它的优先级。
     *
     * @see https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/priority-queue/PriorityQueue.js
     */
    var PriorityQueue1 = /** @class */ (function (_super) {
        __extends(PriorityQueue1, _super);
        function PriorityQueue1() {
            var _this = _super.call(this) || this;
            _this.priorities = {};
            _this.compare = new feng3d.Comparator(_this.comparePriority.bind(_this));
            return _this;
        }
        /**
         * 新增元素
         *
         * @param item 元素
         * @param priority 优先级
         */
        PriorityQueue1.prototype.add = function (item, priority) {
            if (priority === void 0) { priority = 0; }
            this.priorities[item] = priority;
            _super.prototype.add.call(this, item);
            return this;
        };
        /**
         * 移除元素
         *
         * @param item 元素
         * @param customFindingComparator 自定义查找比较器
         */
        PriorityQueue1.prototype.remove = function (item, customFindingComparator) {
            if (customFindingComparator === void 0) { customFindingComparator = this.compare; }
            _super.prototype.remove.call(this, item, customFindingComparator);
            delete this.priorities[item];
            return this;
        };
        /**
         * 改变元素优先级
         *
         * @param item 元素
         * @param priority 优先级
         */
        PriorityQueue1.prototype.changePriority = function (item, priority) {
            this.remove(item, new feng3d.Comparator(this.compareValue));
            this.add(item, priority);
            return this;
        };
        /**
         * 查找元素所在索引
         *
         * @param item 元素
         */
        PriorityQueue1.prototype.findByValue = function (item) {
            return this.find(item, new feng3d.Comparator(this.compareValue));
        };
        /**
         * 是否拥有元素
         *
         * @param item 元素
         */
        PriorityQueue1.prototype.hasValue = function (item) {
            return this.findByValue(item).length > 0;
        };
        /**
         * 比较两个元素优先级
         *
         * @param a 元素a
         * @param b 元素b
         */
        PriorityQueue1.prototype.comparePriority = function (a, b) {
            if (this.priorities[a] === this.priorities[b]) {
                return 0;
            }
            return this.priorities[a] < this.priorities[b] ? -1 : 1;
        };
        /**
         * 比较两个元素大小
         *
         * @param a 元素a
         * @param b 元素b
         */
        PriorityQueue1.prototype.compareValue = function (a, b) {
            if (a === b) {
                return 0;
            }
            return a < b ? -1 : 1;
        };
        return PriorityQueue1;
    }(feng3d.MinHeap));
    feng3d.PriorityQueue1 = PriorityQueue1;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 布隆过滤器 （ 在 JavaScript中 该类可由Object对象代替）
     *
     * 用于判断某元素是否可能插入
     *
     * @see https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/bloom-filter/BloomFilter.js
     * @see https://baike.baidu.com/item/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8
     */
    var BloomFilter = /** @class */ (function () {
        /**
         *
         * @param size 尺寸
         */
        function BloomFilter(size) {
            if (size === void 0) { size = 100; }
            this.size = 100;
            this.size = size;
            this.storage = this.createStore(size);
        }
        /**
         * 插入
         *
         * @param item 元素
         */
        BloomFilter.prototype.insert = function (item) {
            var _this = this;
            var hashValues = this.getHashValues(item);
            hashValues.forEach(function (val) { return _this.storage.setValue(val); });
        };
        /**
         * 可能包含
         *
         * @param item 元素
         */
        BloomFilter.prototype.mayContain = function (item) {
            var hashValues = this.getHashValues(item);
            for (var hashIndex = 0; hashIndex < hashValues.length; hashIndex += 1) {
                if (!this.storage.getValue(hashValues[hashIndex])) {
                    // 我们知道项目肯定没有插入。
                    return false;
                }
            }
            // 项目可能已经插入，也可能没有插入。
            return true;
        };
        /**
         * 创建存储器
         * @param size 尺寸
         */
        BloomFilter.prototype.createStore = function (size) {
            var storage = [];
            // 初始化
            for (var storageCellIndex = 0; storageCellIndex < size; storageCellIndex += 1) {
                storage.push(false);
            }
            var storageInterface = {
                getValue: function (index) {
                    return storage[index];
                },
                setValue: function (index) {
                    storage[index] = true;
                },
            };
            return storageInterface;
        };
        /**
         * 计算哈希值1
         *
         * @param item 元素
         */
        BloomFilter.prototype.hash1 = function (item) {
            var hash = 0;
            for (var charIndex = 0; charIndex < item.length; charIndex += 1) {
                var char = item.charCodeAt(charIndex);
                hash = (hash << 5) + hash + char;
                hash &= hash; // Convert to 32bit integer
                hash = Math.abs(hash);
            }
            return hash % this.size;
        };
        /**
         * 计算哈希值2
         *
         * @param item 元素
         */
        BloomFilter.prototype.hash2 = function (item) {
            var hash = 5381;
            for (var charIndex = 0; charIndex < item.length; charIndex += 1) {
                var char = item.charCodeAt(charIndex);
                hash = (hash << 5) + hash + char; /* hash * 33 + c */
            }
            return Math.abs(hash % this.size);
        };
        /**
         * 计算哈希值3
         *
         * @param item 元素
         */
        BloomFilter.prototype.hash3 = function (item) {
            var hash = 0;
            for (var charIndex = 0; charIndex < item.length; charIndex += 1) {
                var char = item.charCodeAt(charIndex);
                hash = (hash << 5) - hash;
                hash += char;
                hash &= hash; // Convert to 32bit integer
            }
            return Math.abs(hash % this.size);
        };
        /**
         * 获取3个哈希值组成的数组
         */
        BloomFilter.prototype.getHashValues = function (item) {
            return [
                this.hash1(item),
                this.hash2(item),
                this.hash3(item),
            ];
        };
        return BloomFilter;
    }());
    feng3d.BloomFilter = BloomFilter;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 并查集
     *
     * 并查集是一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题。
     *
     * @see https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/disjoint-set/DisjointSet.js
     * @see https://en.wikipedia.org/wiki/Disjoint-set_data_structure
     * @see https://www.youtube.com/watch?v=wU6udHRIkcc&index=14&t=0s&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8
     */
    var DisjointSet = /** @class */ (function () {
        /**
         * 构建 并查集
         * @param keyCallback 计算键值函数
         */
        function DisjointSet(keyCallback) {
            this.keyCallback = keyCallback;
            this.items = {};
        }
        /**
         * 创建集合
         *
         * @param nodeValue 结点值
         */
        DisjointSet.prototype.makeSet = function (nodeValue) {
            var disjointSetItem = new DisjointSetNode(nodeValue, this.keyCallback);
            if (!this.items[disjointSetItem.getKey()]) {
                this.items[disjointSetItem.getKey()] = disjointSetItem;
            }
            return this;
        };
        /**
         * 查找给出值所在集合根结点键值
         *
         * @param nodeValue 结点值
         */
        DisjointSet.prototype.find = function (nodeValue) {
            var templateDisjointItem = new DisjointSetNode(nodeValue, this.keyCallback);
            var requiredDisjointItem = this.items[templateDisjointItem.getKey()];
            if (!requiredDisjointItem) {
                return null;
            }
            return requiredDisjointItem.getRoot().getKey();
        };
        /**
         * 合并两个值所在的集合
         *
         * @param valueA 值a
         * @param valueB 值b
         */
        DisjointSet.prototype.union = function (valueA, valueB) {
            var rootKeyA = this.find(valueA);
            var rootKeyB = this.find(valueB);
            if (rootKeyA === null || rootKeyB === null) {
                throw new Error('给出值不全在集合内');
            }
            if (rootKeyA === rootKeyB) {
                return this;
            }
            var rootA = this.items[rootKeyA];
            var rootB = this.items[rootKeyB];
            // 小集合合并到大集合中
            if (rootA.getRank() < rootB.getRank()) {
                rootB.addChild(rootA);
                return this;
            }
            rootA.addChild(rootB);
            return this;
        };
        /**
         * 判断两个值是否在相同集合中
         *
         * @param valueA 值A
         * @param valueB 值B
         */
        DisjointSet.prototype.inSameSet = function (valueA, valueB) {
            var rootKeyA = this.find(valueA);
            var rootKeyB = this.find(valueB);
            if (rootKeyA === null || rootKeyB === null) {
                throw new Error('给出的值不全在集合内');
            }
            return rootKeyA === rootKeyB;
        };
        return DisjointSet;
    }());
    feng3d.DisjointSet = DisjointSet;
    /**
     * 并查集结点
     */
    var DisjointSetNode = /** @class */ (function () {
        /**
         * 构建 并查集 项
         *
         * @param value 值
         * @param keyCallback 计算键值函数
         */
        function DisjointSetNode(value, keyCallback) {
            this.value = value;
            this.keyCallback = keyCallback;
            this.parent = null;
            this.children = {};
        }
        /**
         * 获取键值
         */
        DisjointSetNode.prototype.getKey = function () {
            if (this.keyCallback) {
                return this.keyCallback(this.value);
            }
            return this.value;
        };
        /**
         * 获取根结点
         */
        DisjointSetNode.prototype.getRoot = function () {
            return this.isRoot() ? this : this.parent.getRoot();
        };
        /**
         * 是否为根结点
         */
        DisjointSetNode.prototype.isRoot = function () {
            return this.parent === null;
        };
        /**
         * 获取所有子孙结点数量
         */
        DisjointSetNode.prototype.getRank = function () {
            if (this.getChildren().length === 0) {
                return 0;
            }
            var rank = 0;
            this.getChildren().forEach(function (child) {
                rank += 1;
                rank += child.getRank();
            });
            return rank;
        };
        /**
         * 获取子结点列表
         */
        DisjointSetNode.prototype.getChildren = function () {
            var _this = this;
            var values = Object.keys(this.children).map(function (key) { return _this.children[key]; });
            return values;
        };
        /**
         * 设置父结点
         * @param parentNode 父结点
         */
        DisjointSetNode.prototype.setParent = function (parentNode) {
            this.parent = parentNode;
            this.parent.children[this.getKey()] = this;
            return this;
        };
        /**
         * 添加子结点
         * @param childNode 子结点
         */
        DisjointSetNode.prototype.addChild = function (childNode) {
            this.children[childNode.getKey()] = childNode;
            childNode.parent = this;
            return this;
        };
        return DisjointSetNode;
    }());
    feng3d.DisjointSetNode = DisjointSetNode;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 图
     *
     * @see https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/graph/Graph.js
     * @see https://en.wikipedia.org/wiki/Graph_(abstract_data_type)
     * @see https://www.youtube.com/watch?v=gXgEDyodOJU&index=9&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8
     * @see https://www.youtube.com/watch?v=k1wraWzqtvQ&index=10&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8
     */
    var Graph = /** @class */ (function () {
        /**
         * 构建图
         *
         * @param isDirected 是否有向
         */
        function Graph(isDirected) {
            if (isDirected === void 0) { isDirected = false; }
            /**
             * 是否有向
             */
            this.isDirected = false;
            this.vertices = {};
            this.edges = {};
            this.isDirected = isDirected;
        }
        /**
         * 新增顶点
         *
         * @param newVertex 新顶点
         */
        Graph.prototype.addVertex = function (newVertex) {
            this.vertices[newVertex.getKey()] = newVertex;
            return this;
        };
        /**
         * 获取顶点
         *
         * @param vertexKey 顶点键值
         */
        Graph.prototype.getVertexByKey = function (vertexKey) {
            return this.vertices[vertexKey];
        };
        /**
         * 获取相邻点
         *
         * @param vertex 顶点
         */
        Graph.prototype.getNeighbors = function (vertex) {
            return vertex.getNeighbors();
        };
        /**
         * 获取所有顶点
         */
        Graph.prototype.getAllVertices = function () {
            var _this = this;
            var values = Object.keys(this.vertices).map(function (key) { return _this.vertices[key]; });
            return values;
        };
        /**
         * 获取所有边
         */
        Graph.prototype.getAllEdges = function () {
            var _this = this;
            var values = Object.keys(this.edges).map(function (key) { return _this.edges[key]; });
            return values;
        };
        /**
         * 新增边
         *
         * @param edge 边
         */
        Graph.prototype.addEdge = function (edge) {
            // 获取起点与终点
            var startVertex = this.getVertexByKey(edge.startVertex.getKey());
            var endVertex = this.getVertexByKey(edge.endVertex.getKey());
            // 新增不存在的起点
            if (!startVertex) {
                this.addVertex(edge.startVertex);
                startVertex = this.getVertexByKey(edge.startVertex.getKey());
            }
            // 新增不存在的终点
            if (!endVertex) {
                this.addVertex(edge.endVertex);
                endVertex = this.getVertexByKey(edge.endVertex.getKey());
            }
            // 新增边到边列表
            if (this.edges[edge.getKey()]) {
                throw new Error('指定边已经存在，无法再次添加');
            }
            else {
                this.edges[edge.getKey()] = edge;
            }
            // 新增边到顶点
            if (this.isDirected) {
                startVertex.addEdge(edge);
            }
            else {
                startVertex.addEdge(edge);
                endVertex.addEdge(edge);
            }
            return this;
        };
        /**
         * 删除边
         *
         * @param edge 边
         */
        Graph.prototype.deleteEdge = function (edge) {
            // 从列表中删除边
            if (this.edges[edge.getKey()]) {
                delete this.edges[edge.getKey()];
            }
            else {
                throw new Error('图中不存在指定边');
            }
            // 从起点与终点里删除边
            var startVertex = this.getVertexByKey(edge.startVertex.getKey());
            var endVertex = this.getVertexByKey(edge.endVertex.getKey());
            startVertex.deleteEdge(edge);
            endVertex.deleteEdge(edge);
        };
        /**
         * 查找边
         *
         * @param startVertex 起始顶点
         * @param endVertex 结束顶点
         */
        Graph.prototype.findEdge = function (startVertex, endVertex) {
            var vertex = this.getVertexByKey(startVertex.getKey());
            if (!vertex) {
                return null;
            }
            return vertex.findEdge(endVertex);
        };
        /**
         * 获取权重
         */
        Graph.prototype.getWeight = function () {
            return this.getAllEdges().reduce(function (weight, graphEdge) {
                return weight + graphEdge.weight;
            }, 0);
        };
        /**
         * 反转
         */
        Graph.prototype.reverse = function () {
            var _this = this;
            // 遍历边
            this.getAllEdges().forEach(function (edge) {
                // 删除边
                _this.deleteEdge(edge);
                // 反转边
                edge.reverse();
                // 新增边
                _this.addEdge(edge);
            });
            return this;
        };
        /**
         * 获取所有顶点索引
         */
        Graph.prototype.getVerticesIndices = function () {
            var verticesIndices = {};
            this.getAllVertices().forEach(function (vertex, index) {
                verticesIndices[vertex.getKey()] = index;
            });
            return verticesIndices;
        };
        /**
         * 获取邻接矩阵
         */
        Graph.prototype.getAdjacencyMatrix = function () {
            var _this = this;
            var vertices = this.getAllVertices();
            var verticesIndices = this.getVerticesIndices();
            // 初始化邻接矩阵
            var adjacencyMatrix = [];
            var n = vertices.length;
            for (var i = 0; i < n; i++) {
                adjacencyMatrix[i] = [];
                for (var j = 0; j < n; j++) {
                    adjacencyMatrix[i][j] = Infinity;
                }
            }
            // 填充邻接矩阵
            vertices.forEach(function (vertex, vertexIndex) {
                vertex.getNeighbors().forEach(function (neighbor) {
                    var neighborIndex = verticesIndices[neighbor.getKey()];
                    adjacencyMatrix[vertexIndex][neighborIndex] = _this.findEdge(vertex, neighbor).weight;
                });
            });
            return adjacencyMatrix;
        };
        /**
         * 转换为字符串
         */
        Graph.prototype.toString = function () {
            return Object.keys(this.vertices).toString();
        };
        return Graph;
    }());
    feng3d.Graph = Graph;
    /**
     * 图边
     */
    var GraphEdge = /** @class */ (function () {
        /**
         * 构建图边
         * @param startVertex 起始顶点
         * @param endVertex 结束顶点
         * @param weight 权重
         */
        function GraphEdge(startVertex, endVertex, weight) {
            if (weight === void 0) { weight = 0; }
            this.startVertex = startVertex;
            this.endVertex = endVertex;
            this.weight = weight;
        }
        /**
         * 获取键值
         */
        GraphEdge.prototype.getKey = function () {
            var startVertexKey = this.startVertex.getKey();
            var endVertexKey = this.endVertex.getKey();
            return startVertexKey + "_" + endVertexKey;
        };
        /**
         * 反转
         */
        GraphEdge.prototype.reverse = function () {
            var tmp = this.startVertex;
            this.startVertex = this.endVertex;
            this.endVertex = tmp;
            return this;
        };
        /**
         * 转换为字符串
         */
        GraphEdge.prototype.toString = function () {
            return this.getKey();
        };
        return GraphEdge;
    }());
    feng3d.GraphEdge = GraphEdge;
    /**
     * 图顶点
     */
    var GraphVertex = /** @class */ (function () {
        /**
         * 构建图顶点
         *
         * @param value 值
         */
        function GraphVertex(value) {
            var edgeComparator = function (edgeA, edgeB) {
                if (edgeA.getKey() === edgeB.getKey()) {
                    return 0;
                }
                return edgeA.getKey() < edgeB.getKey() ? -1 : 1;
            };
            this.value = value;
            this.edges = new feng3d.LinkedList(edgeComparator);
        }
        /**
         * 新增边
         *
         * @param edge 边
         */
        GraphVertex.prototype.addEdge = function (edge) {
            this.edges.addTail(edge);
            return this;
        };
        /**
         * 删除边
         *
         * @param edge 边
         */
        GraphVertex.prototype.deleteEdge = function (edge) {
            this.edges.delete(edge);
        };
        /**
         * 获取相邻顶点
         */
        GraphVertex.prototype.getNeighbors = function () {
            var _this = this;
            var edges = this.edges.toArray();
            var neighborsConverter = function (edge) {
                return edge.startVertex === _this ? edge.endVertex : edge.startVertex;
            };
            return edges.map(neighborsConverter);
        };
        /**
         * 获取边列表
         */
        GraphVertex.prototype.getEdges = function () {
            return this.edges.toArray();
        };
        /**
         * 获取边的数量
         */
        GraphVertex.prototype.getDegree = function () {
            return this.edges.toArray().length;
        };
        /**
         * 是否存在指定边
         *
         * @param requiredEdge 边
         */
        GraphVertex.prototype.hasEdge = function (requiredEdge) {
            var edgeNode = this.edges.findByFunc(function (edge) { return edge === requiredEdge; });
            return !!edgeNode;
        };
        /**
         * 是否有相邻顶点
         *
         * @param vertex 顶点
         */
        GraphVertex.prototype.hasNeighbor = function (vertex) {
            var vertexNode = this.edges.findByFunc(function (edge) { return edge.startVertex === vertex || edge.endVertex === vertex; });
            return !!vertexNode;
        };
        /**
         * 查找边
         *
         * @param vertex 顶点
         */
        GraphVertex.prototype.findEdge = function (vertex) {
            var edgeFinder = function (edge) {
                return edge.startVertex === vertex || edge.endVertex === vertex;
            };
            var edge = this.edges.findByFunc(edgeFinder);
            return edge ? edge.value : null;
        };
        /**
         * 获取键值
         */
        GraphVertex.prototype.getKey = function () {
            return this.value;
        };
        /**
         * 删除所有边
         */
        GraphVertex.prototype.deleteAllEdges = function () {
            var _this = this;
            this.getEdges().forEach(function (edge) { return _this.deleteEdge(edge); });
            return this;
        };
        /**
         * 转换为字符串
         *
         * @param callback 转换为字符串函数
         */
        GraphVertex.prototype.toString = function (callback) {
            return callback ? callback(this.value) : "" + this.value;
        };
        return GraphVertex;
    }());
    feng3d.GraphVertex = GraphVertex;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 二叉树结点
     *
     * @see https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/tree/BinaryTreeNode.js
     */
    var BinaryTreeNode = /** @class */ (function () {
        /**
         * 构建二叉树结点
         *
         * @param value 结点值
         */
        function BinaryTreeNode(value) {
            if (value === void 0) { value = null; }
            this.left = null;
            this.right = null;
            this.parent = null;
            this.value = value;
            this.meta = new feng3d.HashTable();
            this.nodeComparator = new feng3d.Comparator();
        }
        Object.defineProperty(BinaryTreeNode.prototype, "leftHeight", {
            /**
             * 左结点高度
             */
            get: function () {
                if (!this.left) {
                    return 0;
                }
                return this.left.height + 1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BinaryTreeNode.prototype, "rightHeight", {
            /**
             * 右结点高度
             */
            get: function () {
                if (!this.right) {
                    return 0;
                }
                return this.right.height + 1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BinaryTreeNode.prototype, "height", {
            /**
             * 高度
             */
            get: function () {
                return Math.max(this.leftHeight, this.rightHeight);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BinaryTreeNode.prototype, "balanceFactor", {
            /**
             * 平衡系数
             */
            get: function () {
                return this.leftHeight - this.rightHeight;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BinaryTreeNode.prototype, "uncle", {
            /**
             * 获取叔伯结点
             */
            get: function () {
                if (!this.parent) {
                    return undefined;
                }
                if (!this.parent.parent) {
                    return undefined;
                }
                // 判断祖父结点是否有两个子结点
                if (!(this.parent.parent.left && this.parent.parent.right)) {
                    return undefined;
                }
                // 现在我们知道当前节点有祖父结点，而这个祖父结点有两个子结点。让我们看看谁是叔叔。
                if (this.nodeComparator.equal(this.parent, this.parent.parent.left)) {
                    // 右边的是一个叔叔。
                    return this.parent.parent.right;
                }
                return this.parent.parent.left;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 设置结点值
         *
         * @param value 值
         */
        BinaryTreeNode.prototype.setValue = function (value) {
            this.value = value;
            return this;
        };
        /**
         * 设置左结点
         *
         * @param node 结点
         */
        BinaryTreeNode.prototype.setLeft = function (node) {
            if (this.left) {
                this.left.parent = null;
            }
            this.left = node;
            if (this.left) {
                this.left.parent = this;
            }
            return this;
        };
        /**
         * 设置右结点
         *
         * @param node 结点
         */
        BinaryTreeNode.prototype.setRight = function (node) {
            if (this.right) {
                this.right.parent = null;
            }
            this.right = node;
            if (node) {
                this.right.parent = this;
            }
            return this;
        };
        /**
         * 移除子结点
         *
         * @param nodeToRemove 子结点
         */
        BinaryTreeNode.prototype.removeChild = function (nodeToRemove) {
            if (this.left && this.nodeComparator.equal(this.left, nodeToRemove)) {
                this.left = null;
                return true;
            }
            if (this.right && this.nodeComparator.equal(this.right, nodeToRemove)) {
                this.right = null;
                return true;
            }
            return false;
        };
        /**
         * 替换节点
         *
         * @param nodeToReplace 被替换的节点
         * @param replacementNode 替换后的节点
         */
        BinaryTreeNode.prototype.replaceChild = function (nodeToReplace, replacementNode) {
            if (!nodeToReplace || !replacementNode) {
                return false;
            }
            if (this.left && this.nodeComparator.equal(this.left, nodeToReplace)) {
                this.left = replacementNode;
                return true;
            }
            if (this.right && this.nodeComparator.equal(this.right, nodeToReplace)) {
                this.right = replacementNode;
                return true;
            }
            return false;
        };
        /**
         * 拷贝节点
         *
         * @param sourceNode 源节点
         * @param targetNode 目标节点
         */
        BinaryTreeNode.copyNode = function (sourceNode, targetNode) {
            targetNode.setValue(sourceNode.value);
            targetNode.setLeft(sourceNode.left);
            targetNode.setRight(sourceNode.right);
        };
        /**
         * 左序深度遍历
         */
        BinaryTreeNode.prototype.traverseInOrder = function () {
            var traverse = [];
            if (this.left) {
                traverse = traverse.concat(this.left.traverseInOrder());
            }
            traverse.push(this.value);
            if (this.right) {
                traverse = traverse.concat(this.right.traverseInOrder());
            }
            return traverse;
        };
        /**
         * 转换为字符串
         */
        BinaryTreeNode.prototype.toString = function () {
            return this.traverseInOrder().toString();
        };
        return BinaryTreeNode;
    }());
    feng3d.BinaryTreeNode = BinaryTreeNode;
})(feng3d || (feng3d = {}));
/// <reference path="./BinaryTreeNode.ts" />
var feng3d;
(function (feng3d) {
    /**
     * 二叉查找树结点
     *
     * @see https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/tree/binary-search-tree/BinarySearchTreeNode.js
     */
    var BinarySearchTreeNode = /** @class */ (function (_super) {
        __extends(BinarySearchTreeNode, _super);
        /**
         * 构建二叉查找树结点
         *
         * @param value 结点值
         * @param compareFunction 比较函数
         */
        function BinarySearchTreeNode(value, compareFunction) {
            var _this = _super.call(this, value) || this;
            _this.compareFunction = compareFunction;
            _this.nodeValueComparator = new feng3d.Comparator(compareFunction);
            return _this;
        }
        /**
         * 插入值
         *
         * @param value 值
         */
        BinarySearchTreeNode.prototype.insert = function (value) {
            if (this.nodeValueComparator.equal(this.value, null)) {
                this.value = value;
                return this;
            }
            if (this.nodeValueComparator.lessThan(value, this.value)) {
                // 插入到左结点
                if (this.left) {
                    return this.left.insert(value);
                }
                var newNode = new BinarySearchTreeNode(value, this.compareFunction);
                this.setLeft(newNode);
                return newNode;
            }
            if (this.nodeValueComparator.greaterThan(value, this.value)) {
                // 插入到右结点
                if (this.right) {
                    return this.right.insert(value);
                }
                var newNode = new BinarySearchTreeNode(value, this.compareFunction);
                this.setRight(newNode);
                return newNode;
            }
            return this;
        };
        /**
         * 查找结点
         *
         * @param value 值
         */
        BinarySearchTreeNode.prototype.find = function (value) {
            // 核查本结点是否为所查找结点
            if (this.nodeValueComparator.equal(this.value, value)) {
                return this;
            }
            if (this.nodeValueComparator.lessThan(value, this.value) && this.left) {
                // 从左结点中查找
                return this.left.find(value);
            }
            if (this.nodeValueComparator.greaterThan(value, this.value) && this.right) {
                // 从右结点中查找
                return this.right.find(value);
            }
            return null;
        };
        /**
         * 是否包含指定值
         *
         * @param value 结点值
         */
        BinarySearchTreeNode.prototype.contains = function (value) {
            return !!this.find(value);
        };
        /**
         * 移除指定值
         *
         * @param value 结点值
         */
        BinarySearchTreeNode.prototype.remove = function (value) {
            var nodeToRemove = this.find(value);
            if (!nodeToRemove) {
                throw new Error('无法查找到值对于的结点。');
            }
            var parent = nodeToRemove.parent;
            if (!nodeToRemove.left && !nodeToRemove.right) {
                // 删除叶子结点
                if (parent) {
                    parent.removeChild(nodeToRemove);
                }
                else {
                    // 节点没有父节点。只需清除当前节点值。
                    nodeToRemove.setValue(undefined);
                }
            }
            else if (nodeToRemove.left && nodeToRemove.right) {
                // 删除拥有两个子结点的结点
                // 查找下一个最大的值(右分支中的最小值)，并用下一个最大的值替换当前值节点。
                var nextBiggerNode = nodeToRemove.right.findMin();
                if (!this.nodeComparator.equal(nextBiggerNode, nodeToRemove.right)) {
                    this.remove(nextBiggerNode.value);
                    nodeToRemove.setValue(nextBiggerNode.value);
                }
                else {
                    //如果下一个右值是下一个更大的值，它没有左子节点，那么就用右节点替换要删除的节点。
                    nodeToRemove.setValue(nodeToRemove.right.value);
                    nodeToRemove.setRight(nodeToRemove.right.right);
                }
            }
            else {
                // 删除拥有一个子结点的结点
                // 使此子节点成为当前节点的父节点的一个子节点。
                var childNode = nodeToRemove.left || nodeToRemove.right;
                if (parent) {
                    parent.replaceChild(nodeToRemove, childNode);
                }
                else {
                    feng3d.BinaryTreeNode.copyNode(childNode, nodeToRemove);
                }
            }
            nodeToRemove.parent = null;
            return true;
        };
        /**
         * 查找最小值
         */
        BinarySearchTreeNode.prototype.findMin = function () {
            if (!this.left) {
                return this;
            }
            return this.left.findMin();
        };
        return BinarySearchTreeNode;
    }(feng3d.BinaryTreeNode));
    feng3d.BinarySearchTreeNode = BinarySearchTreeNode;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 二叉查找树
     *
     * 二叉查找树（英语：Binary Search Tree），也称为二叉搜索树、有序二叉树（ordered binary tree）或排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：
     *
     * 1. 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；
     * 1. 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；
     * 1. 任意节点的左、右子树也分别为二叉查找树；
     * 1. 没有键值相等的节点。
     *
     * @see https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/tree/binary-search-tree/BinarySearchTree.js
     * @see https://en.wikipedia.org/wiki/Binary_search_tree
     * @see https://www.youtube.com/watch?v=wcIRPqTR3Kc&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8&index=9&t=0s
     */
    var BinarySearchTree = /** @class */ (function () {
        /**
         * 构建 二叉查找树
         *
         * @param nodeValueCompareFunction 结点值比较器
         */
        function BinarySearchTree(nodeValueCompareFunction) {
            this.root = new feng3d.BinarySearchTreeNode(null, nodeValueCompareFunction);
            // 从根节点中窃取节点比较器。
            this.nodeComparator = this.root.nodeComparator;
        }
        /**
         * 插入值
         *
         * @param value 值
         */
        BinarySearchTree.prototype.insert = function (value) {
            return this.root.insert(value);
        };
        /**
         * 是否包含指定值
         *
         * @param value 值
         */
        BinarySearchTree.prototype.contains = function (value) {
            return this.root.contains(value);
        };
        /**
         * 移除指定值
         *
         * @param value 值
         */
        BinarySearchTree.prototype.remove = function (value) {
            return this.root.remove(value);
        };
        /**
         * 转换为字符串
         */
        BinarySearchTree.prototype.toString = function () {
            return this.root.toString();
        };
        return BinarySearchTree;
    }());
    feng3d.BinarySearchTree = BinarySearchTree;
})(feng3d || (feng3d = {}));
/// <reference path="./BinarySearchTree.ts" />
var feng3d;
(function (feng3d) {
    /**
     * 平衡二叉树
     *
     * AVL树（以发明者Adelson-Velsky和Landis 命名）是自平衡二叉搜索树。
     *
     * @see https://github.com/trekhleb/javascript-algorithms/tree/master/src/data-structures/tree/avl-tree
     * @see https://en.wikipedia.org/wiki/AVL_tree
     * @see https://www.tutorialspoint.com/data_structures_algorithms/avl_tree_algorithm.htm
     * @see http://btechsmartclass.com/data_structures/avl-trees.html
     */
    var AvlTree = /** @class */ (function (_super) {
        __extends(AvlTree, _super);
        function AvlTree() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @param {*} value
         */
        AvlTree.prototype.insert = function (value) {
            // Do the normal BST insert.
            _super.prototype.insert.call(this, value);
            // Let's move up to the root and check balance factors along the way.
            var currentNode = this.root.find(value);
            while (currentNode) {
                this.balance(currentNode);
                currentNode = currentNode.parent;
            }
        };
        /**
         * @param {*} value
         * @return {boolean}
         */
        AvlTree.prototype.remove = function (value) {
            // Do standard BST removal.
            var result = _super.prototype.remove.call(this, value);
            // Balance the tree starting from the root node.
            this.balance(this.root);
            return result;
        };
        /**
         * @param {BinarySearchTreeNode} node
         */
        AvlTree.prototype.balance = function (node) {
            // If balance factor is not OK then try to balance the node.
            if (node.balanceFactor > 1) {
                // Left rotation.
                if (node.left.balanceFactor > 0) {
                    // Left-Left rotation
                    this.rotateLeftLeft(node);
                }
                else if (node.left.balanceFactor < 0) {
                    // Left-Right rotation.
                    this.rotateLeftRight(node);
                }
            }
            else if (node.balanceFactor < -1) {
                // Right rotation.
                if (node.right.balanceFactor < 0) {
                    // Right-Right rotation
                    this.rotateRightRight(node);
                }
                else if (node.right.balanceFactor > 0) {
                    // Right-Left rotation.
                    this.rotateRightLeft(node);
                }
            }
        };
        /**
         * @param {BinarySearchTreeNode} rootNode
         */
        AvlTree.prototype.rotateLeftLeft = function (rootNode) {
            // Detach left node from root node.
            var leftNode = rootNode.left;
            rootNode.setLeft(null);
            // Make left node to be a child of rootNode's parent.
            if (rootNode.parent) {
                rootNode.parent.setLeft(leftNode);
            }
            else if (rootNode === this.root) {
                // If root node is root then make left node to be a new root.
                this.root = leftNode;
            }
            // If left node has a right child then detach it and
            // attach it as a left child for rootNode.
            if (leftNode.right) {
                rootNode.setLeft(leftNode.right);
            }
            // Attach rootNode to the right of leftNode.
            leftNode.setRight(rootNode);
        };
        /**
         * @param {BinarySearchTreeNode} rootNode
         */
        AvlTree.prototype.rotateLeftRight = function (rootNode) {
            // Detach left node from rootNode since it is going to be replaced.
            var leftNode = rootNode.left;
            rootNode.setLeft(null);
            // Detach right node from leftNode.
            var leftRightNode = leftNode.right;
            leftNode.setRight(null);
            // Preserve leftRightNode's left subtree.
            if (leftRightNode.left) {
                leftNode.setRight(leftRightNode.left);
                leftRightNode.setLeft(null);
            }
            // Attach leftRightNode to the rootNode.
            rootNode.setLeft(leftRightNode);
            // Attach leftNode as left node for leftRight node.
            leftRightNode.setLeft(leftNode);
            // Do left-left rotation.
            this.rotateLeftLeft(rootNode);
        };
        /**
         * @param {BinarySearchTreeNode} rootNode
         */
        AvlTree.prototype.rotateRightLeft = function (rootNode) {
            // Detach right node from rootNode since it is going to be replaced.
            var rightNode = rootNode.right;
            rootNode.setRight(null);
            // Detach left node from rightNode.
            var rightLeftNode = rightNode.left;
            rightNode.setLeft(null);
            if (rightLeftNode.right) {
                rightNode.setLeft(rightLeftNode.right);
                rightLeftNode.setRight(null);
            }
            // Attach rightLeftNode to the rootNode.
            rootNode.setRight(rightLeftNode);
            // Attach rightNode as right node for rightLeft node.
            rightLeftNode.setRight(rightNode);
            // Do right-right rotation.
            this.rotateRightRight(rootNode);
        };
        /**
         * @param {BinarySearchTreeNode} rootNode
         */
        AvlTree.prototype.rotateRightRight = function (rootNode) {
            // Detach right node from root node.
            var rightNode = rootNode.right;
            rootNode.setRight(null);
            // Make right node to be a child of rootNode's parent.
            if (rootNode.parent) {
                rootNode.parent.setRight(rightNode);
            }
            else if (rootNode === this.root) {
                // If root node is root then make right node to be a new root.
                this.root = rightNode;
            }
            // If right node has a left child then detach it and
            // attach it as a right child for rootNode.
            if (rightNode.left) {
                rootNode.setRight(rightNode.left);
            }
            // Attach rootNode to the left of rightNode.
            rightNode.setLeft(rootNode);
        };
        return AvlTree;
    }(feng3d.BinarySearchTree));
    feng3d.AvlTree = AvlTree;
})(feng3d || (feng3d = {}));
Math.DEG2RAD = Math.PI / 180;
Math.RAD2DEG = 180 / Math.PI;
Math.PRECISION = 0.000001;
/**
 * 获取唯一标识符
 * @see http://www.broofa.com/Tools/Math.uuid.htm
 */
Math.uuid = Math.uuid || function (length) {
    if (length === void 0) { length = 36; }
    var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');
    var id = new Array(length);
    var rnd = 0, r = 0;
    return function generateUUID() {
        for (var i = 0; i < length; i++) {
            if (i === 8 || i === 13 || i === 18 || i === 23) {
                id[i] = '-';
            }
            else if (i === 14) {
                id[i] = '4';
            }
            else {
                if (rnd <= 0x02)
                    rnd = 0x2000000 + (Math.random() * 0x1000000) | 0;
                r = rnd & 0xf;
                rnd = rnd >> 4;
                id[i] = chars[(i === 19) ? (r & 0x3) | 0x8 : r];
            }
        }
        return id.join('');
    };
}();
/**
 * （夹紧）计算指定值到区间[edge0 ,edge1]最近的值
 *
 * @param value 指定值
 * @param lowerlimit 区间下界
 * @param upperlimit 区间上界
 */
Math.clamp = Math.clamp || function (value, lowerlimit, upperlimit) {
    if ((value - lowerlimit) * (value - upperlimit) <= 0)
        return value;
    if (value < lowerlimit)
        return lowerlimit < upperlimit ? lowerlimit : upperlimit;
    return lowerlimit > upperlimit ? lowerlimit : upperlimit;
};
/**
 * 计算欧几里得模（整数模） ((n % m) + m) % m
 *
 * @param n 被除数
 * @param m 除数
 * @see https://en.wikipedia.org/wiki/Modulo_operation
 */
Math.euclideanModulo = Math.euclideanModulo || function (n, m) {
    return ((n % m) + m) % m;
};
/**
 * 使 x 值从区间 <a1, a2> 线性映射到区间 <b1, b2>
 *
 * @param x 第一个区间中值
 * @param a1 第一个区间起始值
 * @param a2 第一个区间终止值
 * @param b1 第二个区间起始值
 * @param b2 第二个区间起始值
 */
Math.mapLinear = Math.mapLinear || function (x, a1, a2, b1, b2) {
    return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
};
/**
 * 线性插值
 *
 * @param start 起始值
 * @param end 终止值
 * @param t 插值系数 [0 ,1]
 *
 * @see https://en.wikipedia.org/wiki/Linear_interpolation
 */
Math.lerp = Math.lerp || function (start, end, t) {
    return (1 - t) * start + t * end;
};
/**
 * 计算平滑值 3x^2 - 2x^3
 *
 * @param x
 * @param min 最小值
 * @param max 最大值
 *
 * @see http://en.wikipedia.org/wiki/Smoothstep
 */
Math.smoothstep = Math.smoothstep || function (x, min, max) {
    if (x <= min)
        return 0;
    if (x >= max)
        return 1;
    x = (x - min) / (max - min);
    return x * x * (3 - 2 * x);
};
/**
 * 计算平滑值 6x^5 - 15x^4 + 10x^3
 *
 * @param x
 * @param min 最小值
 * @param max 最大值
 */
Math.smootherstep = Math.smootherstep || function (x, min, max) {
    if (x <= min)
        return 0;
    if (x >= max)
        return 1;
    x = (x - min) / (max - min);
    return x * x * x * (x * (x * 6 - 15) + 10);
};
/**
 * 从<low, high>获取随机整数
 *
 * @param low 区间起始值
 * @param high 区间终止值
 */
Math.randInt = Math.randInt || function (low, high) {
    return low + Math.floor(Math.random() * (high - low + 1));
};
/**
 * 从<low, high>获取随机浮点数
 *
 * @param low 区间起始值
 * @param high 区间终止值
 */
Math.randFloat = Math.randFloat || function (low, high) {
    return low + Math.random() * (high - low);
};
/**
 * 从<-range/2, range/2>获取随机浮点数
 *
 * @param range 范围
 */
Math.randFloatSpread = Math.randFloatSpread || function (range) {
    return range * (0.5 - Math.random());
};
/**
 * 角度转换为弧度
 *
 * @param degrees 角度
 */
Math.degToRad = Math.degToRad || function (degrees) {
    return degrees * this.DEG2RAD;
};
/**
 * 弧度转换为角度
 *
 * @param radians 弧度
 */
Math.radToDeg = Math.radToDeg || function (radians) {
    return radians * this.RAD2DEG;
};
/**
 * 判断指定整数是否为2的幂
 *
 * @param value 整数
 */
Math.isPowerOfTwo = Math.isPowerOfTwo || function (value) {
    return (value & (value - 1)) === 0 && value !== 0;
};
/**
 * 获取离指定整数最近的2的幂
 *
 * @param value 整数
 */
Math.nearestPowerOfTwo = Math.nearestPowerOfTwo || function (value) {
    return Math.pow(2, Math.round(Math.log(value) / Math.LN2));
};
/**
 * 获取指定大于等于整数最小2的幂，3->4,5->8,17->32,33->64
 *
 * @param value 整数
 */
Math.nextPowerOfTwo = Math.nextPowerOfTwo || function (value) {
    value--;
    value |= value >> 1;
    value |= value >> 2;
    value |= value >> 4;
    value |= value >> 8;
    value |= value >> 16;
    value++;
    return value;
};
/**
 * 获取目标最近的值
 *
 * source增加或者减少整数倍precision后得到离target最近的值
 *
 * ```
 * Math.toRound(71,0,5);//运算结果为1
 * ```
 *
 * @param source 初始值
 * @param target 目标值
 * @param precision 精度
 */
Math.toRound = Math.toRound || function (source, target, precision) {
    if (precision === void 0) { precision = 360; }
    return source + Math.round((target - source) / precision) * precision;
};
/**
 * 比较两个Number是否相等
 *
 * @param a 数字a
 * @param b 数字b
 * @param precision 进度
 */
Math.equals = Math.equals || function (a, b, precision) {
    if (precision == undefined)
        precision = this.PRECISION;
    return Math.abs(a - b) < precision;
};
/**
 * 计算最大公约数
 *
 * @param a 整数a
 * @param b 整数b
 *
 * @see https://en.wikipedia.org/wiki/Greatest_common_divisor
 */
Math.gcd = Math.gcd || function (a, b) {
    if (b)
        while ((a %= b) && (b %= a))
            ;
    return a + b;
};
/**
 * 计算最小公倍数
 * Least common multiple
 *
 * @param a 整数a
 * @param b 整数b
 *
 * @see https://en.wikipedia.org/wiki/Least_common_multiple
 */
Math.lcm = Math.lcm || function (a, b) {
    return a * b / Math.gcd(a, b);
};
var feng3d;
(function (feng3d) {
    /**
     * 方程求解
     *
     * 求解方程 f(x) == 0 在[a, b]上的解
     *
     * 参考：高等数学 第七版上册 第三章第八节 方程的近似解
     * 当f(x)在区间 [a, b] 上连续，且f(a) * f(b) <= 0 时，f(x)在区间 [a, b] 上至少存在一个解使得 f(x) == 0
     *
     * 当f(x)在区间 [a, b] 上连续，且 (f(a) - y) * (f(b) - y) < 0 时，f(x)在区间 [a, b] 上至少存在一个解使得 f(x) == y
     *
     * @author feng / http://feng3d.com 05/06/2018
     */
    var EquationSolving = /** @class */ (function () {
        function EquationSolving() {
        }
        /**
         * 获取数字的(正负)符号
         * @param n 数字
         */
        EquationSolving.prototype.getSign = function (n) {
            return n > 0 ? "+" : "-";
        };
        /**
         * 比较 a 与 b 是否相等
         * @param a 值a
         * @param b 值b
         * @param precision 比较精度
         */
        EquationSolving.prototype.equalNumber = function (a, b, precision) {
            if (precision === void 0) { precision = 0.0000001; }
            return Math.abs(a - b) < precision;
        };
        /**
         * 获取近似导函数 f'(x)
         *
         * 导函数定义
         * f'(x) = (f(x + Δx) - f(x)) / Δx , Δx → 0
         *
         * 注：通过测试Δx不能太小，由于方程内存在x的n次方问题（比如0.000000000000001的10次方为0），过小会导致计算机计算进度不够反而导致求导不准确！
         *
         * 另外一种办法是还原一元多次函数，然后求出导函数。
         *
         * @param f 函数
         * @param delta Δx，进过测试该值太小或者过大都会导致求导准确率降低（个人猜测是计算机计算精度问题导致）
         */
        EquationSolving.prototype.getDerivative = function (f, delta) {
            if (delta === void 0) { delta = 0.000000001; }
            return function (x) {
                var d = (f(x + delta) - f(x)) / delta;
                return d;
            };
        };
        /**
         * 函数是否连续
         * @param f 函数
         */
        EquationSolving.prototype.isContinuous = function (f) {
            return true;
        };
        /**
         * 方程 f(x) == 0 在 [a, b] 区间内是否有解
         *
         * 当f(x)在区间 [a, b] 上连续，且f(a) * f(b) <= 0 时，f(x)在区间 [a, b] 上至少存在一个解使得 f(x) == 0
         *
         * @param f 函数f(x)
         * @param a 区间起点
         * @param b 区间终点
         * @param errorcallback  错误回调函数
         *
         * @returns 是否有解
         */
        EquationSolving.prototype.hasSolution = function (f, a, b, errorcallback) {
            if (!this.isContinuous(f)) {
                errorcallback && errorcallback(new Error("\u51FD\u6570 " + f + " \u5728 [" + a + " ," + b + "] \u533A\u95F4\u5185\u4E0D\u8FDE\u7EED\uFF0C\u65E0\u6CD5\u4E3A\u5176\u6C42\u89E3\uFF01"));
                return false;
            }
            var fa = f(a);
            var fb = f(b);
            if (fa * fb > 0) {
                errorcallback && errorcallback(new Error("f(a) * f(b) \u503C\u4E3A " + fa * fb + "\uFF0C\u4E0D\u6EE1\u8DB3 f(a) * f(b) <= 0\uFF0C\u65E0\u6CD5\u4E3A\u5176\u6C42\u89E3\uFF01"));
                return false;
            }
            return true;
        };
        /**
         * 二分法 求解 f(x) == 0
         *
         * 通过区间中点作为边界来逐步缩小求解区间，最终获得解
         *
         * @param f 函数f(x)
         * @param a 区间起点
         * @param b 区间终点
         * @param precision 求解精度
         * @param errorcallback  错误回调函数
         *
         * @returns 不存在解时返回 undefined ，存在时返回 解
         */
        EquationSolving.prototype.binary = function (f, a, b, precision, errorcallback) {
            if (precision === void 0) { precision = 0.0000001; }
            if (!this.hasSolution(f, a, b, errorcallback))
                return undefined;
            var fa = f(a);
            var fb = f(b);
            if (this.equalNumber(fa, 0, precision)) {
                return a;
            }
            if (this.equalNumber(fb, 0, precision)) {
                return b;
            }
            do {
                var x = (a + b) / 2;
                var fr = f(x);
                if (fa * fr < 0) {
                    b = x;
                    fb = fr;
                }
                else {
                    a = x;
                    fa = fr;
                }
            } while (!this.equalNumber(fr, 0, precision));
            return x;
        };
        /**
         * 连线法 求解 f(x) == 0
         *
         * 连线法是我自己想的方法，自己取的名字，目前没有找到相应的资料（这方法大家都能够想得到。）
         *
         * 用曲线弧两端的连线来代替曲线弧与X轴交点作为边界来逐步缩小求解区间，最终获得解
         *
         * 通过 A，B两点连线与x轴交点来缩小求解区间最终获得解
         *
         * A，B两点直线方程 f(x) = f(a) + (f(b) - f(a)) / (b - a) * (x-a) ,求 f(x) == 0 解得 x = a - fa * (b - a)/ (fb - fa)
         *
         * @param f 函数f(x)
         * @param a 区间起点
         * @param b 区间终点
         * @param precision 求解精度
         * @param errorcallback  错误回调函数
         *
         * @returns 不存在解时返回 undefined ，存在时返回 解
         */
        EquationSolving.prototype.line = function (f, a, b, precision, errorcallback) {
            if (precision === void 0) { precision = 0.0000001; }
            if (!this.hasSolution(f, a, b, errorcallback))
                return undefined;
            var fa = f(a);
            var fb = f(b);
            if (this.equalNumber(fa, 0, precision)) {
                return a;
            }
            if (this.equalNumber(fb, 0, precision)) {
                return b;
            }
            do {
                // 
                var x = a - fa * (b - a) / (fb - fa);
                var fr = f(x);
                if (fa * fr < 0) {
                    b = x;
                    fb = fr;
                }
                else {
                    a = x;
                    fa = fr;
                }
            } while (!this.equalNumber(fr, 0, precision));
            return x;
        };
        /**
         * 切线法 求解 f(x) == 0
         *
         * 用曲线弧一端的切线来代替曲线弧，从而求出方程实根的近似解。
         *
         * 迭代公式： Xn+1 = Xn - f(Xn) / f'(Xn)
         *
         * #### 额外需求
         * 1. f(x)在[a, b]上具有一阶导数 f'(x)
         * 1. f'(x)在[a, b]上保持定号；意味着f(x)在[a, b]上单调
         * 1. f''(x)在[a, b]上保持定号；意味着f'(x)在[a, b]上单调
         *
         * 切记，当无法满足这些额外要求时，该函数将找不到[a, b]上的解！！！！！！！！！！！
         *
         * @param f 函数f(x)
         * @param f1 一阶导函数 f'(x)
         * @param f2 二阶导函数 f''(x)
         * @param a 区间起点
         * @param b 区间终点
         * @param precision 求解精度
         * @param errorcallback  错误回调函数
         *
         * @returns 不存在解与无法使用该函数求解时返回 undefined ，否则返回 解
         */
        EquationSolving.prototype.tangent = function (f, f1, f2, a, b, precision, errorcallback) {
            if (precision === void 0) { precision = 0.0000001; }
            if (!this.hasSolution(f, a, b, errorcallback))
                return undefined;
            var fa = f(a);
            var fb = f(b);
            if (this.equalNumber(fa, 0, precision)) {
                return a;
            }
            if (this.equalNumber(fb, 0, precision)) {
                return b;
            }
            var f1Sign = fb - fa; // f'(x)在[a, b]上保持的定号
            var f1a = f1(a);
            var f1b = f1(b);
            // f'(x)在[a, b]上保持定号
            if (f1a * f1Sign <= 0) {
                errorcallback && errorcallback(new Error("[" + a + ", " + b + "] \u4E0A\u5B58\u5728\u89E3\uFF0C\u7531\u4E8Ef'(" + a + ") = " + f1a + " \u5728[a, b]\u4E0A\u6CA1\u6709\u4FDD\u6301\u5B9A\u53F7 " + this.getSign(f1Sign) + " \uFF0C\u65E0\u6CD5\u4F7F\u7528\u5207\u7EBF\u6CD5\u6C42\u89E3"));
                return undefined;
            }
            if (f1b * f1Sign <= 0) {
                errorcallback && errorcallback(new Error("[" + a + ", " + b + "] \u4E0A\u5B58\u5728\u89E3\uFF0C\u7531\u4E8Ef'(" + b + ") = " + f1b + " \u5728[a, b]\u4E0A\u6CA1\u6709\u4FDD\u6301\u5B9A\u53F7 " + this.getSign(f1Sign) + " \uFF0C\u65E0\u6CD5\u4F7F\u7528\u5207\u7EBF\u6CD5\u6C42\u89E3"));
                return undefined;
            }
            var f2Sign = fb - fa; // f''(x)在[a, b]上保持的定号
            var f2a = f2(a);
            var f2b = f2(b);
            // f''(x)在[a, b]上保持定号
            if (f2a * f2Sign <= 0) {
                errorcallback && errorcallback(new Error("[" + a + ", " + b + "] \u4E0A\u5B58\u5728\u89E3\uFF0C\u7531\u4E8Ef''(" + a + ") = " + f2a + " \u5728[a, b]\u4E0A\u6CA1\u6709\u4FDD\u6301\u5B9A\u53F7 " + this.getSign(f2Sign) + " \uFF0C\u65E0\u6CD5\u4F7F\u7528\u5207\u7EBF\u6CD5\u6C42\u89E3"));
                return undefined;
            }
            if (f2b * f2Sign <= 0) {
                errorcallback && errorcallback(new Error("[" + a + ", " + b + "] \u4E0A\u5B58\u5728\u89E3\uFF0C\u7531\u4E8Ef''(" + b + ") = " + f2b + " \u5728[a, b]\u4E0A\u6CA1\u6709\u4FDD\u6301\u5B9A\u53F7 " + this.getSign(f2Sign) + " \uFF0C\u65E0\u6CD5\u4F7F\u7528\u5207\u7EBF\u6CD5\u6C42\u89E3"));
                return undefined;
            }
            var x;
            if (f1Sign > 0) {
                if (f2Sign > 0)
                    x = b;
                else
                    x = a;
            }
            else {
                if (f2Sign > 0)
                    x = a;
                else
                    x = b;
            }
            do {
                var fx = f(x);
                var f1x = f1(x);
                var f2x = f2(x);
                // f'(x)在[a, b]上保持定号
                if (f1x * f1Sign <= 0) {
                    errorcallback && errorcallback(new Error("[" + a + ", " + b + "] \u4E0A\u5B58\u5728\u89E3\uFF0C\u7531\u4E8Ef'(" + x + ") = " + f1x + " \u5728[a, b]\u4E0A\u6CA1\u6709\u4FDD\u6301\u5B9A\u53F7 " + this.getSign(f1Sign) + " \uFF0C\u65E0\u6CD5\u4F7F\u7528\u5207\u7EBF\u6CD5\u6C42\u89E3"));
                    return undefined;
                }
                // f''(x)在[a, b]上保持定号
                if (f2x * f2Sign <= 0) {
                    errorcallback && errorcallback(new Error("[" + a + ", " + b + "] \u4E0A\u5B58\u5728\u89E3\uFF0C\u7531\u4E8Ef''(" + x + ") = " + f2x + " \u5728[a, b]\u4E0A\u6CA1\u6709\u4FDD\u6301\u5B9A\u53F7 " + this.getSign(f2Sign) + " \uFF0C\u65E0\u6CD5\u4F7F\u7528\u5207\u7EBF\u6CD5\u6C42\u89E3"));
                    return undefined;
                }
                // 迭代 Xn+1 = Xn - f(Xn) / f'(Xn)
                x = x - fx / f1x;
            } while (!this.equalNumber(fx, 0, precision));
            return x;
        };
        /**
         * 割线法（弦截法） 求解 f(x) == 0
         *
         * 使用 (f(Xn) - f(Xn-1)) / (Xn - Xn-1) 代替切线法迭代公式 Xn+1 = Xn - f(Xn) / f'(Xn) 中的 f'(x)
         *
         * 迭代公式：Xn+1 = Xn - f(Xn) * (Xn - Xn-1) / (f(Xn) - f(Xn-1));
         *
         * 用过点(Xn-1,f(Xn-1))和点(Xn,f(Xn))的割线来近似代替(Xn,f(Xn))处的切线，将这条割线与X轴交点的横坐标作为新的近似解。
         *
         * #### 额外需求
         * 1. f(x)在[a, b]上具有一阶导数 f'(x)
         * 1. f'(x)在[a, b]上保持定号；意味着f(x)在[a, b]上单调
         * 1. f''(x)在[a, b]上保持定号；意味着f'(x)在[a, b]上单调
         *
         * 切记，当无法满足这些额外要求时，该函数将找不到[a, b]上的解！！！！！！！！！！！
         *
         * @param f 函数f(x)
         * @param a 区间起点
         * @param b 区间终点
         * @param precision 求解精度
         * @param errorcallback  错误回调函数
         *
         * @returns 不存在解与无法使用该函数求解时返回 undefined ，否则返回 解
         */
        EquationSolving.prototype.secant = function (f, a, b, precision, errorcallback) {
            if (precision === void 0) { precision = 0.0000001; }
            if (!this.hasSolution(f, a, b, errorcallback))
                return undefined;
            var fa = f(a);
            var fb = f(b);
            if (this.equalNumber(fa, 0, precision)) {
                return a;
            }
            if (this.equalNumber(fb, 0, precision)) {
                return b;
            }
            // 此处创建近似导函数以及二次导函数，其实割线法使用在计算f'(x)困难时的，但是 getDerivative 方法解决了这个困难。。。。
            var f1 = this.getDerivative(f, precision);
            var f2 = this.getDerivative(f1, precision);
            var f1Sign = fb - fa; // f'(x)在[a, b]上保持的定号
            // 
            var f1a = f1(a);
            var f1b = f1(b);
            // f'(x)在[a, b]上保持定号
            if (f1a * f1Sign <= 0) {
                errorcallback && errorcallback(new Error("[" + a + ", " + b + "] \u4E0A\u5B58\u5728\u89E3\uFF0C\u7531\u4E8Ef'(" + a + ") = " + f1a + " \u5728[a, b]\u4E0A\u6CA1\u6709\u4FDD\u6301\u5B9A\u53F7 " + this.getSign(f1Sign) + " \uFF0C\u65E0\u6CD5\u4F7F\u7528\u5207\u7EBF\u6CD5\u6C42\u89E3"));
                return undefined;
            }
            if (f1b * f1Sign <= 0) {
                errorcallback && errorcallback(new Error("[" + a + ", " + b + "] \u4E0A\u5B58\u5728\u89E3\uFF0C\u7531\u4E8Ef'(" + b + ") = " + f1b + " \u5728[a, b]\u4E0A\u6CA1\u6709\u4FDD\u6301\u5B9A\u53F7 " + this.getSign(f1Sign) + " \uFF0C\u65E0\u6CD5\u4F7F\u7528\u5207\u7EBF\u6CD5\u6C42\u89E3"));
                return undefined;
            }
            var f2Sign = fb - fa; // f''(x)在[a, b]上保持的定号
            var f2a = f2(a);
            var f2b = f2(b);
            // f''(x)在[a, b]上保持定号
            if (f2a * f2Sign <= 0) {
                errorcallback && errorcallback(new Error("[" + a + ", " + b + "] \u4E0A\u5B58\u5728\u89E3\uFF0C\u7531\u4E8Ef''(" + a + ") = " + f2a + " \u5728[a, b]\u4E0A\u6CA1\u6709\u4FDD\u6301\u5B9A\u53F7 " + this.getSign(f2Sign) + " \uFF0C\u65E0\u6CD5\u4F7F\u7528\u5207\u7EBF\u6CD5\u6C42\u89E3"));
                return undefined;
            }
            if (f2b * f2Sign <= 0) {
                errorcallback && errorcallback(new Error("[" + a + ", " + b + "] \u4E0A\u5B58\u5728\u89E3\uFF0C\u7531\u4E8Ef''(" + b + ") = " + f2b + " \u5728[a, b]\u4E0A\u6CA1\u6709\u4FDD\u6301\u5B9A\u53F7 " + this.getSign(f2Sign) + " \uFF0C\u65E0\u6CD5\u4F7F\u7528\u5207\u7EBF\u6CD5\u6C42\u89E3"));
                return undefined;
            }
            var x;
            if (f1Sign > 0) {
                if (f2Sign > 0)
                    x = b;
                else
                    x = a;
            }
            else {
                if (f2Sign > 0)
                    x = a;
                else
                    x = b;
            }
            // Xn-1
            var xn_1 = x;
            var fxn_1 = f(xn_1);
            // Xn
            var xn = xn_1 - precision * f2Sign / Math.abs(f2Sign);
            var fxn = f(xn);
            // 
            if (fxn * fxn_1 < 0) {
                return xn;
            }
            // Xn+1
            var xn$1;
            do {
                var f1xn = f1(xn);
                // f'(x)在[a, b]上保持定号
                if (f1xn * f1Sign <= 0) {
                    errorcallback && errorcallback(new Error("[" + a + ", " + b + "] \u4E0A\u5B58\u5728\u89E3\uFF0C\u7531\u4E8Ef'(" + xn + ") = " + f1xn + " \u5728[a, b]\u4E0A\u6CA1\u6709\u4FDD\u6301\u5B9A\u53F7 " + this.getSign(f1Sign) + " \uFF0C\u65E0\u6CD5\u4F7F\u7528\u5207\u7EBF\u6CD5\u6C42\u89E3"));
                    return undefined;
                }
                var f2xn = f2(xn);
                // f''(x)在[a, b]上保持定号
                if (f2xn * f2Sign <= 0) {
                    errorcallback && errorcallback(new Error("[" + a + ", " + b + "] \u4E0A\u5B58\u5728\u89E3\uFF0C\u7531\u4E8Ef''(" + xn + ") = " + f2xn + " \u5728[a, b]\u4E0A\u6CA1\u6709\u4FDD\u6301\u5B9A\u53F7 " + this.getSign(f2Sign) + " \uFF0C\u65E0\u6CD5\u4F7F\u7528\u5207\u7EBF\u6CD5\u6C42\u89E3"));
                    return undefined;
                }
                // 迭代 Xn+1 = Xn - f(Xn) * (Xn - Xn-1) / (f(Xn) - f(Xn-1));
                xn$1 = xn - fxn * (xn - xn_1) / (fxn - fxn_1);
                //
                xn_1 = xn;
                fxn_1 = fxn;
                xn = xn$1;
                fxn = f(xn);
            } while (!this.equalNumber(fxn, 0, precision));
            return xn;
        };
        return EquationSolving;
    }());
    feng3d.EquationSolving = EquationSolving;
    feng3d.equationSolving = new EquationSolving();
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 高次函数
     *
     * 处理N次函数定义，求值，方程求解问题
     *
     * n次函数定义
     * f(x) = a0 * pow(x, n) + a1 * pow(x, n - 1) +.....+ an_1 * pow(x, 1) + an
     *
     * 0次 f(x) = a0;
     * 1次 f(x) = a0 * x + a1;
     * 2次 f(x) = a0 * x * x + a1 * x + a2;
     * ......
     *
     */
    var HighFunction = /** @class */ (function () {
        /**
         * 构建函数
         * @param as 函数系数 a0-an 数组
         */
        function HighFunction(as) {
            this.as = as;
        }
        /**
         * 获取函数 f(x) 的值
         * @param x x坐标
         */
        HighFunction.prototype.getValue = function (x) {
            var v = 0;
            var as = this.as;
            for (var i = 0, n = as.length; i < n; i++) {
                v = v * x + as[i];
            }
            return v;
        };
        return HighFunction;
    }());
    feng3d.HighFunction = HighFunction;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 颜色
     */
    var Color3 = /** @class */ (function () {
        /**
         * 构建颜色
         * @param r     红[0,1]
         * @param g     绿[0,1]
         * @param b     蓝[0,1]
         */
        function Color3(r, g, b) {
            if (r === void 0) { r = 1; }
            if (g === void 0) { g = 1; }
            if (b === void 0) { b = 1; }
            this.__class__ = "feng3d.Color3";
            /**
             * 红[0,1]
             */
            this.r = 1;
            /**
             * 绿[0,1]
             */
            this.g = 1;
            /**
             * 蓝[0,1]
             */
            this.b = 1;
            this.r = r;
            this.g = g;
            this.b = b;
        }
        Color3.fromUnit = function (color) {
            return new Color3().fromUnit(color);
        };
        Color3.fromColor4 = function (color4) {
            return new Color3(color4.r, color4.g, color4.b);
        };
        Color3.prototype.setTo = function (r, g, b) {
            this.r = r;
            this.g = g;
            this.b = b;
            return this;
        };
        /**
         * 通过
         * @param color
         */
        Color3.prototype.fromUnit = function (color) {
            this.r = ((color >> 16) & 0xff) / 0xff;
            this.g = ((color >> 8) & 0xff) / 0xff;
            this.b = (color & 0xff) / 0xff;
            return this;
        };
        Color3.prototype.toInt = function () {
            var value = ((this.r * 0xff) << 16) + ((this.g * 0xff) << 8) + (this.b * 0xff);
            return value;
        };
        /**
         * 输出16进制字符串
         */
        Color3.prototype.toHexString = function () {
            var intR = (this.r * 0xff) | 0;
            var intG = (this.g * 0xff) | 0;
            var intB = (this.b * 0xff) | 0;
            return "#" + Color3.ToHex(intR) + Color3.ToHex(intG) + Color3.ToHex(intB);
        };
        /**
         * 混合颜色
         * @param color 混入的颜色
         * @param rate  混入比例
         */
        Color3.prototype.mix = function (color, rate) {
            this.r = this.r * (1 - rate) + color.r * rate;
            this.g = this.g * (1 - rate) + color.g * rate;
            this.b = this.b * (1 - rate) + color.b * rate;
            return this;
        };
        /**
         * 混合颜色
         * @param color 混入的颜色
         * @param rate  混入比例
         */
        Color3.prototype.mixTo = function (color, rate, vout) {
            if (vout === void 0) { vout = new Color3(); }
            return vout.copy(this).mix(color, rate);
        };
        /**
         * 按标量（大小）缩放当前的 Color3 对象。
         */
        Color3.prototype.scale = function (s) {
            this.r *= s;
            this.g *= s;
            this.b *= s;
            return this;
        };
        /**
         * 按标量（大小）缩放当前的 Color3 对象。
         */
        Color3.prototype.scaleTo = function (s, vout) {
            if (vout === void 0) { vout = new Color3(); }
            return vout.copy(this).scale(s);
        };
        /**
         * 通过将当前 Color3 对象的 r、g 和 b 元素与指定的 Color3 对象的 r、g 和 b 元素进行比较，确定这两个对象是否相等。
         */
        Color3.prototype.equals = function (object, precision) {
            if (precision === void 0) { precision = Math.PRECISION; }
            if (!Math.equals(this.r - object.r, 0, precision))
                return false;
            if (!Math.equals(this.g - object.g, 0, precision))
                return false;
            if (!Math.equals(this.b - object.b, 0, precision))
                return false;
            return true;
        };
        /**
         * 拷贝
         */
        Color3.prototype.copy = function (color) {
            this.r = color.r;
            this.g = color.g;
            this.b = color.b;
            return this;
        };
        Color3.prototype.clone = function () {
            return new Color3(this.r, this.g, this.b);
        };
        Color3.prototype.toVector3 = function (vector3) {
            if (vector3 === void 0) { vector3 = new feng3d.Vector3(); }
            vector3.x = this.r;
            vector3.y = this.g;
            vector3.z = this.b;
            return vector3;
        };
        Color3.prototype.toColor4 = function (color4) {
            if (color4 === void 0) { color4 = new feng3d.Color4(); }
            color4.r = this.r;
            color4.g = this.g;
            color4.b = this.b;
            return color4;
        };
        /**
         * 输出字符串
         */
        Color3.prototype.toString = function () {
            return "{R: " + this.r + " G:" + this.g + " B:" + this.b + "}";
        };
        /**
         * [0,15]数值转为16进制字符串
         * param i  [0,15]数值
         */
        Color3.ToHex = function (i) {
            var str = i.toString(16);
            if (i <= 0xf) {
                return ("0" + str).toUpperCase();
            }
            return str.toUpperCase();
        };
        Color3.WHITE = new Color3();
        Color3.BLACK = new Color3(0, 0, 0);
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], Color3.prototype, "r", void 0);
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], Color3.prototype, "g", void 0);
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], Color3.prototype, "b", void 0);
        return Color3;
    }());
    feng3d.Color3 = Color3;
    feng3d.ColorKeywords = {
        'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
        'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
        'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
        'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
        'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
        'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
        'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
        'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
        'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
        'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
        'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
        'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
        'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
        'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
        'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
        'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
        'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
        'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
        'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
        'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
        'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
        'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
        'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
        'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32
    };
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 颜色（包含透明度）
     */
    var Color4 = /** @class */ (function () {
        /**
         * 构建颜色
         * @param r     红[0,1]
         * @param g     绿[0,1]
         * @param b     蓝[0,1]
         * @param a     透明度[0,1]
         */
        function Color4(r, g, b, a) {
            if (r === void 0) { r = 1; }
            if (g === void 0) { g = 1; }
            if (b === void 0) { b = 1; }
            if (a === void 0) { a = 1; }
            this.__class__ = "feng3d.Color4";
            /**
             * 红[0,1]
             */
            this.r = 1;
            /**
             * 绿[0,1]
             */
            this.g = 1;
            /**
             * 蓝[0,1]
             */
            this.b = 1;
            /**
             * 透明度[0,1]
             */
            this.a = 1;
            this.r = r;
            this.g = g;
            this.b = b;
            this.a = a;
        }
        Color4.fromUnit = function (color) {
            return new Color4().fromUnit(color);
        };
        Color4.fromUnit24 = function (color, a) {
            if (a === void 0) { a = 1; }
            return Color4.fromColor3(feng3d.Color3.fromUnit(color), a);
        };
        Color4.fromColor3 = function (color3, a) {
            if (a === void 0) { a = 1; }
            return new Color4(color3.r, color3.g, color3.b, a);
        };
        Color4.prototype.setTo = function (r, g, b, a) {
            if (a === void 0) { a = 1; }
            this.r = r;
            this.g = g;
            this.b = b;
            this.a = a;
            return this;
        };
        /**
         * 通过
         * @param color
         */
        Color4.prototype.fromUnit = function (color) {
            this.a = ((color >> 24) & 0xff) / 0xff;
            this.r = ((color >> 16) & 0xff) / 0xff;
            this.g = ((color >> 8) & 0xff) / 0xff;
            this.b = (color & 0xff) / 0xff;
            return this;
        };
        Color4.prototype.toInt = function () {
            var value = ((this.a * 0xff) << 24) + ((this.r * 0xff) << 16) + ((this.g * 0xff) << 8) + (this.b * 0xff);
            return value;
        };
        /**
         * 输出16进制字符串
         */
        Color4.prototype.toHexString = function () {
            var intR = (this.r * 0xff) | 0;
            var intG = (this.g * 0xff) | 0;
            var intB = (this.b * 0xff) | 0;
            var intA = (this.a * 0xff) | 0;
            return "#" + feng3d.Color3.ToHex(intA) + feng3d.Color3.ToHex(intR) + feng3d.Color3.ToHex(intG) + feng3d.Color3.ToHex(intB);
        };
        /**
         * 混合颜色
         * @param color 混入的颜色
         * @param rate  混入比例
         */
        Color4.prototype.mix = function (color, rate) {
            if (rate === void 0) { rate = 0.5; }
            this.r = this.r * (1 - rate) + color.r * rate;
            this.g = this.g * (1 - rate) + color.g * rate;
            this.b = this.b * (1 - rate) + color.b * rate;
            this.a = this.a * (1 - rate) + color.a * rate;
            return this;
        };
        /**
         * 混合颜色
         * @param color 混入的颜色
         * @param rate  混入比例
         */
        Color4.prototype.mixTo = function (color, rate, vout) {
            if (vout === void 0) { vout = new Color4(); }
            return vout.copy(this).mix(color, rate);
        };
        /**
         * 乘以指定颜色
         * @param c 乘以的颜色
         * @return 返回自身
         */
        Color4.prototype.multiply = function (c) {
            this.r *= c.r;
            this.g *= c.g;
            this.b *= c.b;
            this.a *= c.a;
            return this;
        };
        /**
         * 乘以指定颜色
         * @param v 乘以的颜色
         * @return 返回新颜色
         */
        Color4.prototype.multiplyTo = function (v, vout) {
            if (vout === void 0) { vout = new Color4(); }
            return vout.copy(this).multiply(v);
        };
        /**
         * 通过将当前 Color3 对象的 r、g 和 b 元素与指定的 Color3 对象的 r、g 和 b 元素进行比较，确定这两个对象是否相等。
         */
        Color4.prototype.equals = function (object, precision) {
            if (precision === void 0) { precision = Math.PRECISION; }
            if (!Math.equals(this.r - object.r, 0, precision))
                return false;
            if (!Math.equals(this.g - object.g, 0, precision))
                return false;
            if (!Math.equals(this.b - object.b, 0, precision))
                return false;
            if (!Math.equals(this.a - object.a, 0, precision))
                return false;
            return true;
        };
        /**
         * 拷贝
         */
        Color4.prototype.copy = function (color) {
            this.r = color.r;
            this.g = color.g;
            this.b = color.b;
            this.a = color.a;
            return this;
        };
        /**
         * 输出字符串
         */
        Color4.prototype.toString = function () {
            return "{R: " + this.r + " G:" + this.g + " B:" + this.b + " A:" + this.a + "}";
        };
        Color4.prototype.toColor3 = function (color) {
            if (color === void 0) { color = new feng3d.Color3(); }
            color.r = this.r;
            color.g = this.g;
            color.b = this.b;
            return color;
        };
        Color4.prototype.toVector4 = function (vector4) {
            if (vector4 === void 0) { vector4 = new feng3d.Vector4(); }
            vector4.x = this.r;
            vector4.y = this.g;
            vector4.z = this.b;
            vector4.w = this.a;
            return vector4;
        };
        Color4.prototype.clone = function () {
            return new Color4(this.r, this.g, this.b, this.a);
        };
        Color4.WHITE = new Color4();
        Color4.BLACK = new Color4(0, 0, 0);
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], Color4.prototype, "r", void 0);
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], Color4.prototype, "g", void 0);
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], Color4.prototype, "b", void 0);
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], Color4.prototype, "a", void 0);
        return Color4;
    }());
    feng3d.Color4 = Color4;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var DEG_TO_RAD = Math.PI / 180;
    /**
     * Point 对象表示二维坐标系统中的某个位置，其中 x 表示水平轴，y 表示垂直轴。
     */
    var Vector2 = /** @class */ (function () {
        /**
         * 创建一个 Vector2 对象.若不传入任何参数，将会创建一个位于（0，0）位置的点。
         *
         * @param x 该对象的x属性值，默认为0
         * @param y 该对象的y属性值，默认为0
         */
        function Vector2(x, y) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            this.x = x;
            this.y = y;
        }
        /**
         * 将一对极坐标转换为笛卡尔点坐标。
         * @param len 极坐标对的长度。
         * @param angle 极坐标对的角度（以弧度表示）。
         */
        Vector2.polar = function (len, angle) {
            return new Vector2(len * Math.cos(angle / DEG_TO_RAD), len * Math.sin(angle / DEG_TO_RAD));
        };
        Object.defineProperty(Vector2.prototype, "length", {
            /**
             * 长度
             */
            get: function () {
                return Math.sqrt(this.lengthSquared);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vector2.prototype, "lengthSquared", {
            /**
            * 长度的平方
            */
            get: function () {
                return this.x * this.x + this.y * this.y;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 将 Point 的成员设置为指定值
         * @param x 该对象的x属性值
         * @param y 该对象的y属性值
         */
        Vector2.prototype.init = function (x, y) {
            this.x = x;
            this.y = y;
            return this;
        };
        /**
         * 克隆点对象
         */
        Vector2.prototype.clone = function () {
            return new Vector2(this.x, this.y);
        };
        /**
         * 确定两个点是否相同。如果两个点具有相同的 x 和 y 值，则它们是相同的点。
         * @param toCompare 要比较的点。
         * @returns 如果该对象与此 Point 对象相同，则为 true 值，如果不相同，则为 false。
         */
        Vector2.prototype.equals = function (toCompare) {
            return this.x == toCompare.x && this.y == toCompare.y;
        };
        /**
         * 返回 pt1 和 pt2 之间的距离。
         * @param p1 第一个点
         * @param p2 第二个点
         * @returns 第一个点和第二个点之间的距离。
         */
        Vector2.distance = function (p1, p2) {
            return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));
        };
        /**
         * 将源 Point 对象中的所有点数据复制到调用方 Point 对象中。
         * @param sourcePoint 要从中复制数据的 Point 对象。
         */
        Vector2.prototype.copy = function (sourcePoint) {
            this.x = sourcePoint.x;
            this.y = sourcePoint.y;
            return this;
        };
        /**
         * 加上指定向量得到新向量
         * @param v 加向量
         * @return 返回新向量
         */
        Vector2.prototype.add = function (a) {
            this.x += a.x;
            this.y += a.y;
            return this;
        };
        /**
         * 加上指定向量得到新向量
         * @param v 加向量
         * @return 返回新向量
         */
        Vector2.prototype.addTo = function (v, vout) {
            if (vout === void 0) { vout = new Vector2(); }
            return vout.init(this.x + v.x, this.y + v.y);
        };
        /**
         * 将 (0,0) 和当前点之间的线段缩放为设定的长度。
         * @param thickness 缩放值。例如，如果当前点为 (0,5) 并且您将它规范化为 1，则返回的点位于 (0,1) 处。
         */
        Vector2.prototype.normalize = function (thickness) {
            if (thickness === void 0) { thickness = 1; }
            if (this.x != 0 || this.y != 0) {
                var relativeThickness = thickness / this.length;
                this.x *= relativeThickness;
                this.y *= relativeThickness;
            }
            return this;
        };
        /**
         * 负向量
         */
        Vector2.prototype.negate = function () {
            this.x *= -1;
            this.y *= -1;
            return this;
        };
        /**
         * 按标量（大小）缩放当前的 Vector3 对象。
         */
        Vector2.prototype.scale = function (s) {
            this.x *= s;
            this.y *= s;
            return this;
        };
        /**
         * 按标量（大小）缩放当前的 Vector3 对象。
         */
        Vector2.prototype.scaleNumber = function (s) {
            this.x *= s;
            this.y *= s;
            return this;
        };
        /**
         * 按标量（大小）缩放当前的 Vector3 对象。
         */
        Vector2.prototype.scaleNumberTo = function (s, vout) {
            if (vout === void 0) { vout = new Vector2(); }
            return vout.copy(this).scaleNumber(s);
        };
        /**
         * 按指定量偏移 Point 对象。dx 的值将添加到 x 的原始值中以创建新的 x 值。dy 的值将添加到 y 的原始值中以创建新的 y 值。
         * @param dx 水平坐标 x 的偏移量。
         * @param dy 水平坐标 y 的偏移量。
         */
        Vector2.prototype.offset = function (dx, dy) {
            this.x += dx;
            this.y += dy;
            return this;
        };
        /**
         * 从此点的坐标中减去另一个点的坐标以创建一个新点。
         * @param v 要减去的点。
         * @returns 新点。
         */
        Vector2.prototype.sub = function (v) {
            this.x -= v.x;
            this.y -= v.y;
            return this;
        };
        /**
         * 从此点的坐标中减去另一个点的坐标以创建一个新点。
         * @param v 要减去的点。
         * @returns 新点。
         */
        Vector2.prototype.subTo = function (v, vout) {
            if (vout === void 0) { vout = new Vector2(); }
            return vout.init(this.x - v.x, this.y - v.y);
        };
        /**
         * 乘以向量
         * @param a 向量
         */
        Vector2.prototype.multiply = function (a) {
            this.x *= a.x;
            this.y *= a.y;
            return this;
        };
        /**
         * 乘以向量
         * @param a 向量
         * @param vout 输出向量
         */
        Vector2.prototype.multiplyTo = function (a, vout) {
            if (vout === void 0) { vout = new Vector2(); }
            return vout.copy(this).multiply(a);
        };
        /**
         * 插值到指定向量
         * @param v 目标向量
         * @param alpha 插值系数
         * @return 返回自身
         */
        Vector2.prototype.lerp = function (p, alpha) {
            this.x += (p.x - this.x) * alpha.x;
            this.y += (p.y - this.y) * alpha.y;
            return this;
        };
        /**
         * 插值到指定向量
         * @param v 目标向量
         * @param alpha 插值系数
         * @return 返回新向量
         */
        Vector2.prototype.lerpTo = function (v, alpha, vout) {
            if (vout === void 0) { vout = new Vector2(); }
            return vout.copy(this).lerp(v, alpha);
        };
        /**
         * 插值到指定向量
         * @param v 目标向量
         * @param alpha 插值系数
         * @return 返回自身
         */
        Vector2.prototype.lerpNumber = function (v, alpha) {
            this.x += (v.x - this.x) * alpha;
            this.y += (v.y - this.y) * alpha;
            return this;
        };
        /**
         * 插值到指定向量
         * @param v 目标向量
         * @param alpha 插值系数
         * @return 返回自身
         */
        Vector2.prototype.lerpNumberTo = function (v, alpha, vout) {
            if (vout === void 0) { vout = new Vector2(); }
            return vout.copy(this).lerpNumber(v, alpha);
        };
        /**
         * 夹紧？
         * @param min 最小值
         * @param max 最大值
         */
        Vector2.prototype.clamp = function (min, max) {
            this.x = Math.clamp(this.x, min.x, max.x);
            this.y = Math.clamp(this.y, min.y, max.y);
            return this;
        };
        /**
         * 夹紧？
         * @param min 最小值
         * @param max 最大值
         */
        Vector2.prototype.clampTo = function (min, max, vout) {
            if (vout === void 0) { vout = new Vector2(); }
            return vout.copy(this).clamp(min, max);
        };
        /**
         * 取最小元素
         * @param v 向量
         */
        Vector2.prototype.min = function (v) {
            this.x = Math.min(this.x, v.x);
            this.y = Math.min(this.y, v.y);
            return this;
        };
        /**
         * 取最大元素
         * @param v 向量
         */
        Vector2.prototype.max = function (v) {
            this.x = Math.max(this.x, v.x);
            this.y = Math.max(this.y, v.y);
            return this;
        };
        /**
         * 各分量均取最近的整数
         */
        Vector2.prototype.round = function () {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            return this;
        };
        /**
         * 返回包含 x 和 y 坐标的值的字符串。该字符串的格式为 "(x=x, y=y)"，因此为点 23,17 调用 toString() 方法将返回 "(x=23, y=17)"。
         * @returns 坐标的字符串表示形式。
         */
        Vector2.prototype.toString = function () {
            return "(x=" + this.x + ", y=" + this.y + ")";
        };
        /**
         * 返回包含 x 和 y 坐标值的数组
         */
        Vector2.prototype.toArray = function () {
            return [this.x, this.y];
        };
        /**
         * 原点
         */
        Vector2.ZERO = new Vector2();
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], Vector2.prototype, "x", void 0);
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], Vector2.prototype, "y", void 0);
        return Vector2;
    }());
    feng3d.Vector2 = Vector2;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Vector3 类使用笛卡尔坐标 x、y 和 z 表示三维空间中的点或位置
     */
    var Vector3 = /** @class */ (function () {
        /**
         * 创建 Vector3 对象的实例。如果未指定构造函数的参数，则将使用元素 (0,0,0,0) 创建 Vector3 对象。
         * @param x 第一个元素，例如 x 坐标。
         * @param y 第二个元素，例如 y 坐标。
         * @param z 第三个元素，例如 z 坐标。
         */
        function Vector3(x, y, z) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            if (z === void 0) { z = 0; }
            this.__class__ = "feng3d.Vector3";
            /**
            * Vector3 对象中的第一个元素，例如，三维空间中某个点的 x 坐标。默认值为 0
            */
            this.x = 0;
            /**
             * Vector3 对象中的第二个元素，例如，三维空间中某个点的 y 坐标。默认值为 0
             */
            this.y = 0;
            /**
             * Vector3 对象中的第三个元素，例如，三维空间中某个点的 z 坐标。默认值为 0
             */
            this.z = 0;
            this.x = x;
            this.y = y;
            this.z = z;
        }
        /**
         * 从数组中初始化向量
         * @param array 数组
         * @param offset 偏移
         * @return 返回新向量
         */
        Vector3.fromArray = function (array, offset) {
            if (offset === void 0) { offset = 0; }
            return new Vector3().fromArray(array, offset);
        };
        /**
         * 随机三维向量
         * @param size 尺寸
         */
        Vector3.random = function (size) {
            if (size === void 0) { size = 1; }
            return new Vector3(Math.random() * size, Math.random() * size, Math.random() * size);
        };
        /**
         * 从Vector2初始化
         */
        Vector3.fromVector2 = function (vector, z) {
            if (z === void 0) { z = 0; }
            return new Vector3().fromVector2(vector, z);
        };
        Object.defineProperty(Vector3.prototype, "length", {
            /**
            * 当前 Vector3 对象的长度（大小），即从原点 (0,0,0) 到该对象的 x、y 和 z 坐标的距离。w 属性将被忽略。单位矢量具有的长度或大小为一。
            */
            get: function () {
                return Math.sqrt(this.lengthSquared);
            },
            set: function (v) {
                this.normalize().scaleNumber(length);
            },
            enumerable: true,
            configurable: true
        });
        Vector3.prototype.setLength = function (length) {
            return this.normalize().scaleNumber(length);
        };
        Object.defineProperty(Vector3.prototype, "lengthSquared", {
            /**
            * 当前 Vector3 对象长度的平方，它是使用 x、y 和 z 属性计算出来的。w 属性将被忽略。尽可能使用 lengthSquared() 方法，而不要使用 Vector3.length() 方法的 Math.sqrt() 方法调用，后者速度较慢。
            */
            get: function () {
                return this.x * this.x + this.y * this.y + this.z * this.z;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 将 Vector3 的成员设置为指定值
         */
        Vector3.prototype.init = function (x, y, z) {
            this.x = x;
            this.y = y;
            this.z = z;
            return this;
        };
        /**
         * 把所有分量都设为零
         */
        Vector3.prototype.setZero = function () {
            this.x = this.y = this.z = 0;
        };
        /**
         * 从Vector2初始化
         */
        Vector3.prototype.fromVector2 = function (vector, z) {
            if (z === void 0) { z = 0; }
            this.x = vector.x;
            this.y = vector.y;
            this.z = z;
            return this;
        };
        Vector3.prototype.fromArray = function (array, offset) {
            if (offset === void 0) { offset = 0; }
            this.x = array[offset];
            this.y = array[offset + 1];
            this.z = array[offset + 2];
            return this;
        };
        /**
         * 转换为Vector2
         */
        Vector3.prototype.toVector2 = function (vector) {
            if (vector === void 0) { vector = new feng3d.Vector2(); }
            return vector.init(this.x, this.y);
        };
        /**
         * 转换为Vector4
         */
        Vector3.prototype.toVector4 = function (vector4) {
            if (vector4 === void 0) { vector4 = new feng3d.Vector4(); }
            vector4.x = this.x;
            vector4.y = this.y;
            vector4.z = this.z;
            return vector4;
        };
        /**
         * 加上指定向量得到新向量
         * @param v 加向量
         * @return 返回新向量
         */
        Vector3.prototype.add = function (a) {
            this.x += a.x;
            this.y += a.y;
            this.z += a.z;
            return this;
        };
        /**
         * 加上指定向量得到新向量
         * @param v 加向量
         * @return 返回新向量
         */
        Vector3.prototype.addTo = function (a, vout) {
            if (vout === void 0) { vout = new Vector3(); }
            if (a == vout)
                a = a.clone();
            return vout.copy(this).add(a);
        };
        /**
         * 乘以向量
         * @param a 向量
         */
        Vector3.prototype.multiply = function (a) {
            this.x *= a.x;
            this.y *= a.y;
            this.z *= a.z;
            return this;
        };
        /**
         * 乘以向量
         * @param a 向量
         * @param vout 输出向量
         */
        Vector3.prototype.multiplyTo = function (a, vout) {
            if (vout === void 0) { vout = new Vector3(); }
            if (a == vout)
                a = a.clone();
            return vout.copy(this).multiply(a);
        };
        /**
         * 除以向量
         * @param a 向量
         */
        Vector3.prototype.divide = function (a) {
            this.x /= a.x;
            this.y /= a.y;
            this.z /= a.z;
            return this;
        };
        /**
         * 除以向量
         * @param a 向量
         * @param vout 输出向量
         */
        Vector3.prototype.divideTo = function (a, vout) {
            if (vout === void 0) { vout = new Vector3(); }
            if (a == vout)
                a = a.clone();
            return vout.copy(this).divide(a);
        };
        /**
         * 叉乘向量
         * @param a 向量
         */
        Vector3.prototype.cross = function (a) {
            return this.init(this.y * a.z - this.z * a.y, this.z * a.x - this.x * a.z, this.x * a.y - this.y * a.x);
        };
        /**
         * 叉乘向量
         * @param a 向量
         * @param vout 输出向量
         */
        Vector3.prototype.crossTo = function (a, vout) {
            if (vout === void 0) { vout = new Vector3(); }
            if (a == vout)
                a = a.clone();
            return vout.copy(this).cross(a);
        };
        /**
         * 如果当前 Vector3 对象和作为参数指定的 Vector3 对象均为单位顶点，此方法将返回这两个顶点之间所成角的余弦值。
         */
        Vector3.prototype.dot = function (a) {
            return this.x * a.x + this.y * a.y + this.z * a.z;
        };
        /**
         * 是否为零向量
         */
        Vector3.prototype.isZero = function () {
            return this.x === 0 && this.y === 0 && this.z === 0;
        };
        Vector3.prototype.tangents = function (t1, t2) {
            var norm = this.length;
            if (norm > 0.0) {
                var n = new Vector3();
                var inorm = 1 / norm;
                n.init(this.x * inorm, this.y * inorm, this.z * inorm);
                var randVec = new Vector3();
                if (Math.abs(n.x) < 0.9) {
                    randVec.init(1, 0, 0);
                    n.crossTo(randVec, t1);
                }
                else {
                    randVec.init(0, 1, 0);
                    n.crossTo(randVec, t1);
                }
                n.crossTo(t1, t2);
            }
            else {
                // The normal length is zero, make something up
                t1.init(1, 0, 0);
                t2.init(0, 1, 0);
            }
        };
        /**
         * 检查一个向量是否接近零
         *
         * @param precision
         */
        Vector3.prototype.almostZero = function (precision) {
            if (precision === void 0) { precision = Math.PRECISION; }
            if (Math.abs(this.x) > precision ||
                Math.abs(this.y) > precision ||
                Math.abs(this.z) > precision) {
                return false;
            }
            return true;
        };
        /**
         * 检查这个向量是否与另一个向量反平行。
         *
         * @param  v
         * @param  precision 设置为零以进行精确比较
         */
        Vector3.prototype.isAntiparallelTo = function (v, precision) {
            if (precision === void 0) { precision = Math.PRECISION; }
            var t = new Vector3();
            this.negateTo(t);
            return t.equals(v, precision);
        };
        /**
         * 加上标量
         * @param n 标量
         */
        Vector3.prototype.addNumber = function (n) {
            this.x += n;
            this.y += n;
            this.z += n;
            return this;
        };
        /**
         * 增加标量
         * @param n 标量
         */
        Vector3.prototype.addNumberTo = function (n, vout) {
            if (vout === void 0) { vout = new Vector3(); }
            return vout.copy(this).addNumber(n);
        };
        /**
         * 减去标量
         * @param n 标量
         */
        Vector3.prototype.subNumber = function (n) {
            this.x -= n;
            this.y -= n;
            this.z -= n;
            return this;
        };
        /**
         * 减去标量
         * @param n 标量
         */
        Vector3.prototype.subNumberTo = function (n, vout) {
            if (vout === void 0) { vout = new Vector3(); }
            return vout.copy(this).subNumber(n);
        };
        /**
         * 乘以标量
         * @param n 标量
         */
        Vector3.prototype.multiplyNumber = function (n) {
            this.x *= n;
            this.y *= n;
            this.z *= n;
            return this;
        };
        /**
         * 乘以标量
         * @param n 标量
         * @param vout 输出向量
         */
        Vector3.prototype.multiplyNumberTo = function (n, vout) {
            if (vout === void 0) { vout = new Vector3(); }
            return vout.copy(this).multiplyNumber(n);
        };
        /**
         * 除以标量
         * @param n 标量
         */
        Vector3.prototype.divideNumber = function (n) {
            this.x /= n;
            this.y /= n;
            this.z /= n;
            return this;
        };
        /**
         * 除以标量
         * @param n 标量
         * @param vout 输出向量
         */
        Vector3.prototype.divideNumberTo = function (n, vout) {
            if (vout === void 0) { vout = new Vector3(); }
            return vout.copy(this).divideNumber(n);
        };
        /**
         * 返回一个新 Vector3 对象，它是与当前 Vector3 对象完全相同的副本。
         * @return 一个新 Vector3 对象，它是当前 Vector3 对象的副本。
         */
        Vector3.prototype.clone = function () {
            return new Vector3(this.x, this.y, this.z);
        };
        /**
         * 将源 Vector3 对象中的所有矢量数据复制到调用方 Vector3 对象中。
         * @return 要从中复制数据的 Vector3 对象。
         */
        Vector3.prototype.copy = function (v) {
            this.x = v.x;
            this.y = v.y;
            this.z = v.z;
            return this;
        };
        /**
         * 通过将当前 Vector3 对象的 x、y 和 z 元素与指定的 Vector3 对象的 x、y 和 z 元素进行比较，确定这两个对象是否相等。
         */
        Vector3.prototype.equals = function (object, precision) {
            if (precision === void 0) { precision = Math.PRECISION; }
            if (!Math.equals(this.x - object.x, 0, precision))
                return false;
            if (!Math.equals(this.y - object.y, 0, precision))
                return false;
            if (!Math.equals(this.z - object.z, 0, precision))
                return false;
            return true;
        };
        /**
         * 负向量
         * (a,b,c)->(-a,-b,-c)
         */
        Vector3.prototype.negate = function () {
            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;
            return this;
        };
        /**
         * 负向量
         * (a,b,c)->(-a,-b,-c)
         */
        Vector3.prototype.negateTo = function (vout) {
            if (vout === void 0) { vout = new Vector3(); }
            return vout.copy(this).negate();
        };
        /**
         * 倒向量
         * (a,b,c)->(1/a,1/b,1/c)
         */
        Vector3.prototype.inverse = function () {
            this.x = 1 / this.x;
            this.y = 1 / this.y;
            this.z = 1 / this.z;
            return this;
        };
        /**
         * 倒向量
         * (a,b,c)->(1/a,1/b,1/c)
         */
        Vector3.prototype.inverseTo = function (vout) {
            if (vout === void 0) { vout = new Vector3(); }
            return vout.copy(this).inverse();
        };
        /**
         * 通过将最前面的三个元素（x、y、z）除以矢量的长度可将 Vector3 对象转换为单位矢量。
         */
        Vector3.prototype.normalize = function (thickness) {
            if (thickness === void 0) { thickness = 1; }
            var length = this.lengthSquared;
            if (length > 0) {
                length = Math.sqrt(length);
                var invLength = thickness / length;
                this.x *= invLength;
                this.y *= invLength;
                this.z *= invLength;
            }
            return this;
        };
        /**
         * 得到这个向量长度为1
         */
        Vector3.prototype.unit = function (target) {
            if (target === void 0) { target = new Vector3(); }
            var x = this.x, y = this.y, z = this.z;
            var ninv = x * x + y * y + z * z;
            if (ninv > 0.0) {
                var ninv = Math.sqrt(ninv);
                ninv = 1.0 / ninv;
                target.x = x * ninv;
                target.y = y * ninv;
                target.z = z * ninv;
            }
            else {
                target.x = 1;
                target.y = 0;
                target.z = 0;
            }
            return target;
        };
        /**
         * 按标量（大小）缩放当前的 Vector3 对象。
         */
        Vector3.prototype.scaleNumber = function (s) {
            this.x *= s;
            this.y *= s;
            this.z *= s;
            return this;
        };
        /**
         * 按标量（大小）缩放当前的 Vector3 对象。
         */
        Vector3.prototype.scaleNumberTo = function (s, vout) {
            if (vout === void 0) { vout = new Vector3(); }
            return vout.copy(this).scaleNumber(s);
        };
        /**
         * 缩放
         * @param s 缩放量
         */
        Vector3.prototype.scale = function (s) {
            this.x *= s.x;
            this.y *= s.y;
            this.z *= s.z;
            return this;
        };
        /**
         * 缩放
         * @param s 缩放量
         */
        Vector3.prototype.scaleTo = function (s, vout) {
            if (vout === void 0) { vout = new Vector3(); }
            if (s == vout)
                s = s.clone();
            return vout.copy(this).scale(s);
        };
        /**
         * 减去向量
         * @param a 减去的向量
         * @return 返回新向量
         */
        Vector3.prototype.sub = function (a) {
            this.x -= a.x;
            this.y -= a.y;
            this.z -= a.z;
            return this;
        };
        /**
         * 减去向量
         * @param a 减去的向量
         * @return 返回新向量
         */
        Vector3.prototype.subTo = function (a, vout) {
            if (vout === void 0) { vout = new Vector3(); }
            if (a == vout)
                a = a.clone();
            return vout.copy(this).sub(a);
        };
        /**
         * 插值到指定向量
         * @param v 目标向量
         * @param alpha 插值系数
         * @return 返回自身
         */
        Vector3.prototype.lerp = function (v, alpha) {
            this.x += (v.x - this.x) * alpha.x;
            this.y += (v.y - this.y) * alpha.y;
            this.z += (v.z - this.z) * alpha.z;
            return this;
        };
        /**
         * 插值到指定向量
         * @param v 目标向量
         * @param alpha 插值系数
         * @return 返回自身
         */
        Vector3.prototype.lerpTo = function (v, alpha, vout) {
            if (vout === void 0) { vout = new Vector3(); }
            if (v == vout)
                v = v.clone();
            return vout.copy(this).lerp(v, alpha);
        };
        /**
         * 插值到指定向量
         * @param v 目标向量
         * @param alpha 插值系数
         * @return 返回自身
         */
        Vector3.prototype.lerpNumber = function (v, alpha) {
            this.x += (v.x - this.x) * alpha;
            this.y += (v.y - this.y) * alpha;
            this.z += (v.z - this.z) * alpha;
            return this;
        };
        /**
         * 插值到指定向量
         * @param v 目标向量
         * @param alpha 插值系数
         * @return 返回自身
         */
        Vector3.prototype.lerpNumberTo = function (v, alpha, vout) {
            if (vout === void 0) { vout = new Vector3(); }
            if (v == vout)
                v = v.clone();
            return vout.copy(this).lerpNumber(v, alpha);
        };
        /**
         * 小于指定点
         * @param p 点
         */
        Vector3.prototype.less = function (p) {
            return this.x < p.x && this.y < p.y && this.z < p.z;
        };
        /**
         * 小于等于指定点
         * @param p 点
         */
        Vector3.prototype.lessequal = function (p) {
            return this.x <= p.x && this.y <= p.y && this.z <= p.z;
        };
        /**
         * 大于指定点
         * @param p 点
         */
        Vector3.prototype.greater = function (p) {
            return this.x > p.x && this.y > p.y && this.z > p.z;
        };
        /**
         * 大于等于指定点
         * @param p 点
         */
        Vector3.prototype.greaterequal = function (p) {
            return this.x >= p.x && this.y >= p.y && this.z >= p.z;
        };
        /**
         * 夹紧？
         * @param min 最小值
         * @param max 最大值
         */
        Vector3.prototype.clamp = function (min, max) {
            this.x = Math.clamp(this.x, min.x, max.x);
            this.y = Math.clamp(this.y, min.y, max.y);
            this.z = Math.clamp(this.z, min.z, max.z);
            return this;
        };
        /**
         * 夹紧？
         * @param min 最小值
         * @param max 最大值
         */
        Vector3.prototype.clampTo = function (min, max, vout) {
            if (vout === void 0) { vout = new Vector3(); }
            return vout.copy(this).clamp(min, max);
        };
        /**
         * 取最小元素
         * @param v 向量
         */
        Vector3.prototype.min = function (v) {
            this.x = Math.min(this.x, v.x);
            this.y = Math.min(this.y, v.y);
            this.z = Math.min(this.z, v.z);
            return this;
        };
        /**
         * 取最大元素
         * @param v 向量
         */
        Vector3.prototype.max = function (v) {
            this.x = Math.max(this.x, v.x);
            this.y = Math.max(this.y, v.y);
            this.z = Math.max(this.z, v.z);
            return this;
        };
        /**
         * 应用矩阵
         * @param mat 矩阵
         */
        Vector3.prototype.applyMatrix4x4 = function (mat) {
            mat.transformVector(this, this);
            return this;
        };
        /**
         * 应用四元素
         * @param q 四元素
         */
        Vector3.prototype.applyQuaternion = function (q) {
            var x = this.x, y = this.y, z = this.z;
            var qx = q.x, qy = q.y, qz = q.z, qw = q.w;
            // calculate quat * vector
            var ix = qw * x + qy * z - qz * y;
            var iy = qw * y + qz * x - qx * z;
            var iz = qw * z + qx * y - qy * x;
            var iw = -qx * x - qy * y - qz * z;
            // calculate result * inverse quat
            this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
            this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
            this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
            return this;
        };
        /**
         * 与点之间的距离平方
         * @param v 点
         */
        Vector3.prototype.distanceSquared = function (v) {
            var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
            return dx * dx + dy * dy + dz * dz;
        };
        /**
         * 与点之间的距离平方
         * @param v 点
         */
        Vector3.prototype.distance = function (v) {
            return Math.sqrt(this.distanceSquared(v));
        };
        /**
         * 反射
         * @param normal
         */
        Vector3.prototype.reflect = function (normal) {
            return this.sub(normal.multiplyNumberTo(2 * this.dot(normal)));
        };
        /**
         * 向下取整
         */
        Vector3.prototype.floor = function () {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            this.z = Math.floor(this.z);
            return this;
        };
        /**
         * 向上取整
         */
        Vector3.prototype.ceil = function () {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            this.z = Math.ceil(this.z);
            return this;
        };
        /**
         * 四舍五入
         */
        Vector3.prototype.round = function () {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            this.z = Math.round(this.z);
            return this;
        };
        /**
         * 向0取整
         */
        Vector3.prototype.roundToZero = function () {
            this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
            this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
            this.z = (this.z < 0) ? Math.ceil(this.z) : Math.floor(this.z);
            return this;
        };
        /**
         * 与指定向量是否平行
         * @param v 向量
         */
        Vector3.prototype.isParallel = function (v, precision) {
            if (precision === void 0) { precision = Math.PRECISION; }
            return Math.equals(Math.abs(this.clone().normalize().dot(v.clone().normalize())), 1, precision);
        };
        /**
         * 从向量中得到叉乘矩阵a_cross，使得a x b = a_cross * b = c
         * @see http://www8.cs.umu.se/kurser/TDBD24/VT06/lectures/Lecture6.pdf
         */
        Vector3.prototype.crossmat = function () {
            return new feng3d.Matrix3x3([0, -this.z, this.y,
                this.z, 0, -this.x,
                -this.y, this.x, 0]);
        };
        /**
         * 返回当前 Vector3 对象的字符串表示形式。
         */
        Vector3.prototype.toString = function () {
            return "<" + this.x + ", " + this.y + ", " + this.z + ">";
        };
        /**
         * 转换为数组
         * @param array 数组
         * @param offset 偏移
         * @return 返回数组
         */
        Vector3.prototype.toArray = function (array, offset) {
            if (array === void 0) { array = []; }
            if (offset === void 0) { offset = 0; }
            array[offset] = this.x;
            array[offset + 1] = this.y;
            array[offset + 2] = this.z;
            return array;
        };
        /**
        * 定义为 Vector3 对象的 x 轴，坐标为 (1,0,0)。
        */
        Vector3.X_AXIS = new Vector3(1, 0, 0);
        /**
        * 定义为 Vector3 对象的 y 轴，坐标为 (0,1,0)
        */
        Vector3.Y_AXIS = new Vector3(0, 1, 0);
        /**
        * 定义为 Vector3 对象的 z 轴，坐标为 (0,0,1)
        */
        Vector3.Z_AXIS = new Vector3(0, 0, 1);
        /**
         * 原点
         */
        Vector3.ZERO = new Vector3();
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], Vector3.prototype, "x", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], Vector3.prototype, "y", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], Vector3.prototype, "z", void 0);
        return Vector3;
    }());
    feng3d.Vector3 = Vector3;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 四维向量
     */
    var Vector4 = /** @class */ (function () {
        /**
         * 创建 Vector4 对象的实例。如果未指定构造函数的参数，则将使用元素 (0,0,0,0) 创建 Vector4 对象。
         * @param x 第一个元素
         * @param y 第二个元素
         * @param z 第三个元素
         * @param w 第四个元素
         */
        function Vector4(x, y, z, w) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            if (z === void 0) { z = 0; }
            if (w === void 0) { w = 0; }
            /**
            * Vector4 对象中的第一个元素。默认值为 0
            */
            this.x = 0;
            /**
             * Vector4 对象中的第二个元素。默认值为 0
             */
            this.y = 0;
            /**
             * Vector4 对象中的第三个元素。默认值为 0
             */
            this.z = 0;
            /**
             * Vector4 对象的第四个元素。默认值为 0
             */
            this.w = 0;
            this.init(x, y, z, w);
        }
        Vector4.fromArray = function (array, offset) {
            if (offset === void 0) { offset = 0; }
            return new Vector4().fromArray(array, offset);
        };
        Vector4.fromVector3 = function (vector3, w) {
            if (w === void 0) { w = 0; }
            return new Vector4().fromVector3(vector3, w);
        };
        Vector4.random = function () {
            return new Vector4(Math.random(), Math.random(), Math.random(), Math.random());
        };
        /**
         * 初始化向量
         * @param x 第一个元素
         * @param y 第二个元素
         * @param z 第三个元素
         * @param w 第四个元素
         * @return 返回自身
         */
        Vector4.prototype.init = function (x, y, z, w) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
            return this;
        };
        /**
         * 从数组初始化
         * @param array 提供数据的数组
         * @param offset 数组中起始位置
         * @return 返回自身
         */
        Vector4.prototype.fromArray = function (array, offset) {
            if (offset === void 0) { offset = 0; }
            this.x = array[offset];
            this.y = array[offset + 1];
            this.z = array[offset + 2];
            this.w = array[offset + 3];
            return this;
        };
        /**
         * 从三维向量初始化
         * @param vector3 三维向量
         * @param w 向量第四个值
         * @return 返回自身
         */
        Vector4.prototype.fromVector3 = function (vector3, w) {
            if (w === void 0) { w = 0; }
            this.x = vector3.x;
            this.y = vector3.y;
            this.z = vector3.z;
            this.w = w;
            return this;
        };
        /**
         * 转换为三维向量
         * @param v3 三维向量
         */
        Vector4.prototype.toVector3 = function (v3) {
            if (v3 === void 0) { v3 = new feng3d.Vector3(); }
            v3.init(this.x, this.y, this.z);
            return v3;
        };
        /**
         * 转换为数组
         * @param array 数组
         * @param offset 偏移
         */
        Vector4.prototype.toArray = function (array, offset) {
            if (array === void 0) { array = []; }
            if (offset === void 0) { offset = 0; }
            array[offset] = this.x;
            array[offset + 1] = this.y;
            array[offset + 2] = this.z;
            array[offset + 3] = this.w;
            return array;
        };
        /**
         * 加上指定向量得到新向量
         * @param v 加向量
         * @return 返回新向量
         */
        Vector4.prototype.add = function (v) {
            this.x += v.x;
            this.y += v.y;
            this.z += v.z;
            this.w += v.w;
            return this;
        };
        /**
         * 加上指定向量得到新向量
         * @param v 加向量
         * @return 返回新向量
         */
        Vector4.prototype.addTo = function (v, vout) {
            if (vout === void 0) { vout = new Vector4(); }
            return vout.copy(this).add(v);
        };
        /**
         * 克隆一个向量
         * @return 返回一个拷贝向量
         */
        Vector4.prototype.clone = function () {
            return new Vector4(this.x, this.y, this.z, this.w);
        };
        /**
         * 从指定向量拷贝数据
         * @param v 被拷贝向量
         * @return 返回自身
         */
        Vector4.prototype.copy = function (v) {
            this.x = v.x;
            this.y = v.y;
            this.z = v.z;
            this.w = v.w;
            return this;
        };
        /**
         * 减去指定向量
         * @param v 减去的向量
         * @return 返回自身
         */
        Vector4.prototype.sub = function (v) {
            this.x -= v.x;
            this.y -= v.y;
            this.z -= v.z;
            this.w -= v.w;
            return this;
        };
        /**
         * 减去指定向量
         * @param v 减去的向量
         * @return 返回新向量
         */
        Vector4.prototype.subTo = function (v, vout) {
            if (vout === void 0) { vout = new Vector4(); }
            return vout.copy(this).sub(v);
        };
        /**
         * 乘以指定向量
         * @param v 乘以的向量
         * @return 返回自身
         */
        Vector4.prototype.multiply = function (v) {
            this.x *= v.x;
            this.y *= v.y;
            this.z *= v.z;
            this.w *= v.w;
            return this;
        };
        /**
         * 乘以指定向量
         * @param v 乘以的向量
         * @return 返回新向量
         */
        Vector4.prototype.multiplyTo = function (v, vout) {
            if (vout === void 0) { vout = new Vector4(); }
            return vout.copy(this).multiply(v);
        };
        /**
         * 除以指定向量
         * @param v 除以的向量
         * @return 返回自身
         */
        Vector4.prototype.div = function (v) {
            this.x /= v.x;
            this.y /= v.y;
            this.z /= v.z;
            this.w /= v.w;
            return this;
        };
        /**
         * 除以指定向量
         * @param v 除以的向量
         * @return 返回新向量
         */
        Vector4.prototype.divTo = function (v, vout) {
            if (vout === void 0) { vout = new Vector4(); }
            return vout.copy(this).div(v);
        };
        /**
         * 与指定向量比较是否相等
         * @param v 比较的向量
         * @param precision 允许误差
         * @return 相等返回true，否则false
         */
        Vector4.prototype.equals = function (v, precision) {
            if (precision === void 0) { precision = Math.PRECISION; }
            if (!Math.equals(this.x - v.x, 0, precision))
                return false;
            if (!Math.equals(this.y - v.y, 0, precision))
                return false;
            if (!Math.equals(this.z - v.z, 0, precision))
                return false;
            if (!Math.equals(this.w - v.w, 0, precision))
                return false;
            return true;
        };
        /**
         * 负向量
         * @return 返回自身
         */
        Vector4.prototype.negate = function () {
            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;
            this.w = -this.w;
            return this;
        };
        /**
         * 负向量
         * @return 返回新向量
         */
        Vector4.prototype.negateTo = function (vout) {
            if (vout === void 0) { vout = new Vector4(); }
            return vout.copy(this).negate();
        };
        /**
         * 缩放指定系数
         * @param s 缩放系数
         * @return 返回自身
         */
        Vector4.prototype.scale = function (s) {
            this.x *= s;
            this.y *= s;
            this.z *= s;
            this.w *= s;
            return this;
        };
        /**
         * 缩放指定系数
         * @param s 缩放系数
         * @return 返回新向量
         */
        Vector4.prototype.scaleTo = function (s) {
            return this.clone().scale(s);
        };
        /**
         * 如果当前 Vector4 对象和作为参数指定的 Vector4 对象均为单位顶点，此方法将返回这两个顶点之间所成角的余弦值。
         */
        Vector4.prototype.dot = function (a) {
            return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w;
        };
        /**
         * 获取到指定向量的插值
         * @param v 终点插值向量
         * @param alpha 插值系数
         * @return 返回自身
         */
        Vector4.prototype.lerp = function (v, alpha) {
            this.x += (v.x - this.x) * alpha;
            this.y += (v.y - this.y) * alpha;
            this.z += (v.z - this.z) * alpha;
            this.w += (v.w - this.w) * alpha;
            return this;
        };
        /**
         * 获取到指定向量的插值
         * @param v 终点插值向量
         * @param alpha 插值系数
         * @return 返回新向量
         */
        Vector4.prototype.lerpTo = function (v, alpha, vout) {
            if (vout === void 0) { vout = new Vector4(); }
            return vout.copy(this).lerp(v, alpha);
        };
        /**
         * 应用矩阵
         * @param mat 矩阵
         */
        Vector4.prototype.applyMatrix4x4 = function (mat) {
            mat.transformVector4(this, this);
            return this;
        };
        /**
         * 返回当前 Vector4 对象的字符串表示形式。
         */
        Vector4.prototype.toString = function () {
            return "<" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + ">";
        };
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], Vector4.prototype, "x", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], Vector4.prototype, "y", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], Vector4.prototype, "z", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], Vector4.prototype, "w", void 0);
        return Vector4;
    }());
    feng3d.Vector4 = Vector4;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Orientation3D 类是用于表示 Matrix4x4 对象的方向样式的常量值枚举。方向的三个类型分别为欧拉角、轴角和四元数。Matrix4x4 对象的 decompose 和 recompose 方法采用其中的某一个枚举类型来标识矩阵的旋转组件。

     */
    var Orientation3D;
    (function (Orientation3D) {
        /**
        * 轴角方向结合使用轴和角度来确定方向。
        */
        Orientation3D["AXIS_ANGLE"] = "axisAngle";
        /**
        * 欧拉角（decompose() 和 recompose() 方法的默认方向）通过三个不同的对应于每个轴的旋转角来定义方向。
        */
        Orientation3D["EULER_ANGLES"] = "eulerAngles";
        /**
        * 四元数方向使用复数。
        */
        Orientation3D["QUATERNION"] = "quaternion";
    })(Orientation3D = feng3d.Orientation3D || (feng3d.Orientation3D = {}));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 矩形
     *
     * Rectangle 对象是按其位置（由它左上角的点 (x, y) 确定）以及宽度和高度定义的区域。<br/>
     * Rectangle 类的 x、y、width 和 height 属性相互独立；更改一个属性的值不会影响其他属性。
     * 但是，right 和 bottom 属性与这四个属性是整体相关的。例如，如果更改 right 属性的值，则 width
     * 属性的值将发生变化；如果更改 bottom 属性，则 height 属性的值将发生变化。
     */
    var Rectangle = /** @class */ (function () {
        /**
         * 创建一个新 Rectangle 对象，其左上角由 x 和 y 参数指定，并具有指定的 width 和 height 参数。
         * @param x 矩形左上角的 x 坐标。
         * @param y 矩形左上角的 y 坐标。
         * @param width 矩形的宽度（以像素为单位）。
         * @param height 矩形的高度（以像素为单位）。
         */
        function Rectangle(x, y, width, height) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            if (width === void 0) { width = 0; }
            if (height === void 0) { height = 0; }
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
        }
        Object.defineProperty(Rectangle.prototype, "right", {
            /**
             * x 和 width 属性的和。
             */
            get: function () {
                return this.x + this.width;
            },
            set: function (value) {
                this.width = value - this.x;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Rectangle.prototype, "bottom", {
            /**
             * y 和 height 属性的和。
             */
            get: function () {
                return this.y + this.height;
            },
            set: function (value) {
                this.height = value - this.y;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Rectangle.prototype, "left", {
            /**
             * 矩形左上角的 x 坐标。更改 Rectangle 对象的 left 属性对 y 和 height 属性没有影响。但是，它会影响 width 属性，而更改 x 值不会影响 width 属性。
             * left 属性的值等于 x 属性的值。
             */
            get: function () {
                return this.x;
            },
            set: function (value) {
                this.width += this.x - value;
                this.x = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Rectangle.prototype, "top", {
            /**
             * 矩形左上角的 y 坐标。更改 Rectangle 对象的 top 属性对 x 和 width 属性没有影响。但是，它会影响 height 属性，而更改 y 值不会影响 height 属性。<br/>
             * top 属性的值等于 y 属性的值。
             */
            get: function () {
                return this.y;
            },
            set: function (value) {
                this.height += this.y - value;
                this.y = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Rectangle.prototype, "topLeft", {
            /**
             * 由该点的 x 和 y 坐标确定的 Rectangle 对象左上角的位置。
             */
            get: function () {
                return new feng3d.Vector2(this.left, this.top);
            },
            set: function (value) {
                this.top = value.y;
                this.left = value.x;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Rectangle.prototype, "bottomRight", {
            /**
             * 由 right 和 bottom 属性的值确定的 Rectangle 对象的右下角的位置。
             */
            get: function () {
                return new feng3d.Vector2(this.right, this.bottom);
            },
            set: function (value) {
                this.bottom = value.y;
                this.right = value.x;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Rectangle.prototype, "center", {
            /**
             * 中心点
             */
            get: function () {
                return new feng3d.Vector2(this.x + this.width / 2, this.y + this.height / 2);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 将源 Rectangle 对象中的所有矩形数据复制到调用方 Rectangle 对象中。
         * @param sourceRect 要从中复制数据的 Rectangle 对象。
         */
        Rectangle.prototype.copyFrom = function (sourceRect) {
            this.x = sourceRect.x;
            this.y = sourceRect.y;
            this.width = sourceRect.width;
            this.height = sourceRect.height;
            return this;
        };
        /**
         * 将 Rectangle 的成员设置为指定值
         * @param x 矩形左上角的 x 坐标。
         * @param y 矩形左上角的 y 坐标。
         * @param width 矩形的宽度（以像素为单位）。
         * @param height 矩形的高度（以像素为单位）。
         */
        Rectangle.prototype.init = function (x, y, width, height) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            return this;
        };
        /**
         * 确定由此 Rectangle 对象定义的矩形区域内是否包含指定的点。
         * @param x 检测点的x轴
         * @param y 检测点的y轴
         * @returns 如果检测点位于矩形内，返回true，否则，返回false
         */
        Rectangle.prototype.contains = function (x, y) {
            return this.x <= x &&
                this.x + this.width >= x &&
                this.y <= y &&
                this.y + this.height >= y;
        };
        /**
         * 如果在 toIntersect 参数中指定的 Rectangle 对象与此 Rectangle 对象相交，则返回交集区域作为 Rectangle 对象。如果矩形不相交，
         * 则此方法返回一个空的 Rectangle 对象，其属性设置为 0。
         * @param toIntersect 要对照比较以查看其是否与此 Rectangle 对象相交的 Rectangle 对象。
         * @returns 等于交集区域的 Rectangle 对象。如果该矩形不相交，则此方法返回一个空的 Rectangle 对象；即，其 x、y、width 和
         * height 属性均设置为 0 的矩形。
         */
        Rectangle.prototype.intersection = function (toIntersect) {
            if (!this.intersects(toIntersect))
                return new Rectangle();
            var i = new Rectangle();
            if (this.x > toIntersect.x) {
                i.x = this.x;
                i.width = toIntersect.x - this.x + toIntersect.width;
                if (i.width > this.width)
                    i.width = this.width;
            }
            else {
                i.x = toIntersect.x;
                i.width = this.x - toIntersect.x + this.width;
                if (i.width > toIntersect.width)
                    i.width = toIntersect.width;
            }
            if (this.y > toIntersect.y) {
                i.y = this.y;
                i.height = toIntersect.y - this.y + toIntersect.height;
                if (i.height > this.height)
                    i.height = this.height;
            }
            else {
                i.y = toIntersect.y;
                i.height = this.y - toIntersect.y + this.height;
                if (i.height > toIntersect.height)
                    i.height = toIntersect.height;
            }
            return i;
        };
        /**
         * 按指定量增加 Rectangle 对象的大小（以像素为单位）
         * 保持 Rectangle 对象的中心点不变，使用 dx 值横向增加它的大小，使用 dy 值纵向增加它的大小。
         * @param dx Rectangle 对象横向增加的值。
         * @param dy Rectangle 对象纵向增加的值。
         */
        Rectangle.prototype.inflate = function (dx, dy) {
            this.x -= dx;
            this.width += 2 * dx;
            this.y -= dy;
            this.height += 2 * dy;
        };
        /**
         * 确定在 toIntersect 参数中指定的对象是否与此 Rectangle 对象相交。此方法检查指定的 Rectangle
         * 对象的 x、y、width 和 height 属性，以查看它是否与此 Rectangle 对象相交。
         * @param toIntersect 要与此 Rectangle 对象比较的 Rectangle 对象。
         * @returns 如果两个矩形相交，返回true，否则返回false
         */
        Rectangle.prototype.intersects = function (toIntersect) {
            return Math.max(this.x, toIntersect.x) <= Math.min(this.right, toIntersect.right)
                && Math.max(this.y, toIntersect.y) <= Math.min(this.bottom, toIntersect.bottom);
        };
        /**
         * 确定此 Rectangle 对象是否为空。
         * @returns 如果 Rectangle 对象的宽度或高度小于等于 0，则返回 true 值，否则返回 false。
         */
        Rectangle.prototype.isEmpty = function () {
            return this.width <= 0 || this.height <= 0;
        };
        /**
         * 将 Rectangle 对象的所有属性设置为 0。
         */
        Rectangle.prototype.setEmpty = function () {
            this.x = 0;
            this.y = 0;
            this.width = 0;
            this.height = 0;
        };
        /**
         * 返回一个新的 Rectangle 对象，其 x、y、width 和 height 属性的值与原始 Rectangle 对象的对应值相同。
         * @returns 新的 Rectangle 对象，其 x、y、width 和 height 属性的值与原始 Rectangle 对象的对应值相同。
         */
        Rectangle.prototype.clone = function () {
            return new Rectangle(this.x, this.y, this.width, this.height);
        };
        /**
         * 确定由此 Rectangle 对象定义的矩形区域内是否包含指定的点。
         * 此方法与 Rectangle.contains() 方法类似，只不过它采用 Point 对象作为参数。
         * @param point 包含点对象
         * @returns 如果包含，返回true，否则返回false
         */
        Rectangle.prototype.containsPoint = function (point) {
            if (this.x < point.x
                && this.x + this.width > point.x
                && this.y < point.y
                && this.y + this.height > point.y) {
                return true;
            }
            return false;
        };
        /**
         * 确定此 Rectangle 对象内是否包含由 rect 参数指定的 Rectangle 对象。
         * 如果一个 Rectangle 对象完全在另一个 Rectangle 的边界内，我们说第二个 Rectangle 包含第一个 Rectangle。
         * @param rect 所检查的 Rectangle 对象
         * @returns 如果此 Rectangle 对象包含您指定的 Rectangle 对象，则返回 true 值，否则返回 false。
         */
        Rectangle.prototype.containsRect = function (rect) {
            var r1 = rect.x + rect.width;
            var b1 = rect.y + rect.height;
            var r2 = this.x + this.width;
            var b2 = this.y + this.height;
            return (rect.x >= this.x) && (rect.x < r2) && (rect.y >= this.y) && (rect.y < b2) && (r1 > this.x) && (r1 <= r2) && (b1 > this.y) && (b1 <= b2);
        };
        /**
         * 确定在 toCompare 参数中指定的对象是否等于此 Rectangle 对象。
         * 此方法将某个对象的 x、y、width 和 height 属性与此 Rectangle 对象所对应的相同属性进行比较。
         * @param toCompare 要与此 Rectangle 对象进行比较的矩形。
         * @returns 如果对象具有与此 Rectangle 对象完全相同的 x、y、width 和 height 属性值，则返回 true 值，否则返回 false。
         */
        Rectangle.prototype.equals = function (toCompare) {
            if (this === toCompare) {
                return true;
            }
            return this.x === toCompare.x && this.y === toCompare.y
                && this.width === toCompare.width && this.height === toCompare.height;
        };
        /**
         * 增加 Rectangle 对象的大小。此方法与 Rectangle.inflate() 方法类似，只不过它采用 Point 对象作为参数。
         */
        Rectangle.prototype.inflatePoint = function (point) {
            this.inflate(point.x, point.y);
        };
        /**
         * 按指定量调整 Rectangle 对象的位置（由其左上角确定）。
         * @param dx 将 Rectangle 对象的 x 值移动此数量。
         * @param dy 将 Rectangle 对象的 t 值移动此数量。
         */
        Rectangle.prototype.offset = function (dx, dy) {
            this.x += dx;
            this.y += dy;
        };
        /**
         * 将 Point 对象用作参数来调整 Rectangle 对象的位置。此方法与 Rectangle.offset() 方法类似，只不过它采用 Point 对象作为参数。
         * @param point 要用于偏移此 Rectangle 对象的 Point 对象。
         */
        Rectangle.prototype.offsetPoint = function (point) {
            this.offset(point.x, point.y);
        };
        /**
         * 生成并返回一个字符串，该字符串列出 Rectangle 对象的水平位置和垂直位置以及高度和宽度。
         * @returns 一个字符串，它列出了 Rectangle 对象的下列各个属性的值：x、y、width 和 height。
         */
        Rectangle.prototype.toString = function () {
            return "(x=" + this.x + ", y=" + this.y + ", width=" + this.width + ", height=" + this.height + ")";
        };
        /**
         * 通过填充两个矩形之间的水平和垂直空间，将这两个矩形组合在一起以创建一个新的 Rectangle 对象。
         * @param toUnion 要添加到此 Rectangle 对象的 Rectangle 对象。
         * @returns 充当两个矩形的联合的新 Rectangle 对象。
         */
        Rectangle.prototype.union = function (toUnion) {
            var result = this.clone();
            if (toUnion.isEmpty()) {
                return result;
            }
            if (result.isEmpty()) {
                result.copyFrom(toUnion);
                return result;
            }
            var l = Math.min(result.x, toUnion.x);
            var t = Math.min(result.y, toUnion.y);
            result.init(l, t, Math.max(result.right, toUnion.right) - l, Math.max(result.bottom, toUnion.bottom) - t);
            return result;
        };
        /**
         *
         * @param point 点
         * @param pout 输出点
         */
        Rectangle.prototype.clampPoint = function (point, pout) {
            if (pout === void 0) { pout = new feng3d.Vector2(); }
            return pout.copy(point).clamp(this.topLeft, this.bottomRight);
        };
        Object.defineProperty(Rectangle.prototype, "size", {
            /**
             * The size of the Rectangle object, expressed as a Point object with the
             * values of the <code>width</code> and <code>height</code> properties.
             */
            get: function () {
                return new feng3d.Vector2(this.width, this.height);
            },
            enumerable: true,
            configurable: true
        });
        return Rectangle;
    }());
    feng3d.Rectangle = Rectangle;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * The Matrix export class represents a transformation matrix that determines how to
     * map points from one coordinate space to another. You can perform various
     * graphical transformations on a display object by setting the properties of
     * a Matrix object, applying that Matrix object to the <code>matrix</code>
     * property of a Transform object, and then applying that Transform object as
     * the <code>transform</code> property of the display object. These
     * transformation functions include translation(<i>x</i> and <i>y</i>
     * repositioning), rotation, scaling, and skewing.
     *
     * <p>Together these types of transformations are known as <i>affine
     * transformations</i>. Affine transformations preserve the straightness of
     * lines while transforming, so that parallel lines stay parallel.</p>
     *
     * <p>To apply a transformation matrix to a display object, you create a
     * Transform object, set its <code>matrix</code> property to the
     * transformation matrix, and then set the <code>transform</code> property of
     * the display object to the Transform object. Matrix objects are also used as
     * parameters of some methods, such as the following:</p>
     *
     * <ul>
     *   <li>The <code>draw()</code> method of a BitmapData object</li>
     *   <li>The <code>beginBitmapFill()</code> method,
     * <code>beginGradientFill()</code> method, or
     * <code>lineGradientStyle()</code> method of a Graphics object</li>
     * </ul>
     *
     * <p>A transformation matrix object is a 3 x 3 matrix with the following
     * contents:</p>
     *
     * <p>In traditional transformation matrixes, the <code>u</code>,
     * <code>v</code>, and <code>w</code> properties provide extra capabilities.
     * The Matrix export class can only operate in two-dimensional space, so it always
     * assumes that the property values <code>u</code> and <code>v</code> are 0.0,
     * and that the property value <code>w</code> is 1.0. The effective values of
     * the matrix are as follows:</p>
     *
     * <p>You can get and set the values of all six of the other properties in a
     * Matrix object: <code>a</code>, <code>b</code>, <code>c</code>,
     * <code>d</code>, <code>tx</code>, and <code>ty</code>.</p>
     *
     * <p>The Matrix export class supports the four major types of transformations:
     * translation, scaling, rotation, and skewing. You can set three of these
     * transformations by using specialized methods, as described in the following
     * table: </p>
     *
     * <p>Each transformation function alters the current matrix properties so
     * that you can effectively combine multiple transformations. To do this, you
     * call more than one transformation function before applying the matrix to
     * its display object target(by using the <code>transform</code> property of
     * that display object).</p>
     *
     * <p>Use the <code>new Matrix()</code> constructor to create a Matrix object
     * before you can call the methods of the Matrix object.</p>
     */
    var Matrix = /** @class */ (function () {
        function Matrix(a, b, c, d, tx, ty) {
            if (a === void 0) { a = 1; }
            if (b === void 0) { b = 0; }
            if (c === void 0) { c = 0; }
            if (d === void 0) { d = 1; }
            if (tx === void 0) { tx = 0; }
            if (ty === void 0) { ty = 0; }
            this.rawData = new Float32Array(6);
            if (a instanceof Float32Array) {
                this.copyRawDataFrom(a);
            }
            else {
                this.a = Number(a);
                this.b = b;
                this.c = c;
                this.d = d;
                this.tx = tx;
                this.ty = ty;
            }
        }
        Object.defineProperty(Matrix.prototype, "a", {
            /**
             * The value that affects the positioning of pixels along the <i>x</i> axis
             * when scaling or rotating an image.
             */
            get: function () {
                return this.rawData[0];
            },
            set: function (value) {
                this.rawData[0] = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Matrix.prototype, "b", {
            /**
             * The value that affects the positioning of pixels along the <i>y</i> axis
             * when rotating or skewing an image.
             */
            get: function () {
                return this.rawData[2];
            },
            set: function (value) {
                this.rawData[2] = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Matrix.prototype, "c", {
            /**
             * The value that affects the positioning of pixels along the <i>x</i> axis
             * when rotating or skewing an image.
             */
            get: function () {
                return this.rawData[1];
            },
            set: function (value) {
                this.rawData[1] = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Matrix.prototype, "d", {
            /**
             * The value that affects the positioning of pixels along the <i>y</i> axis
             * when scaling or rotating an image.
             */
            get: function () {
                return this.rawData[3];
            },
            set: function (value) {
                this.rawData[3] = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Matrix.prototype, "tx", {
            /**
             * The distance by which to translate each point along the <i>x</i> axis.
             */
            get: function () {
                return this.rawData[4];
            },
            set: function (value) {
                this.rawData[4] = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Matrix.prototype, "ty", {
            /**
             * The distance by which to translate each point along the <i>y</i> axis.
             */
            get: function () {
                return this.rawData[5];
            },
            set: function (value) {
                this.rawData[5] = value;
            },
            enumerable: true,
            configurable: true
        });
        Matrix.prototype.copyRawDataFrom = function (vector, index) {
            if (index === void 0) { index = 0; }
            for (var c = 0; c < 6; c++)
                this.rawData[c] = vector[c + index];
        };
        /**
         * Returns a new Matrix object that is a clone of this matrix, with an exact
         * copy of the contained object.
         *
         * @return A Matrix object.
         */
        Matrix.prototype.clone = function () {
            return new Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty);
        };
        /**
         * Concatenates a matrix with the current matrix, effectively combining the
         * geometric effects of the two. In mathematical terms, concatenating two
         * matrixes is the same as combining them using matrix multiplication.
         *
         * <p>For example, if matrix <code>m1</code> scales an object by a factor of
         * four, and matrix <code>m2</code> rotates an object by 1.5707963267949
         * radians(<code>Math.PI/2</code>), then <code>m1.concat(m2)</code>
         * transforms <code>m1</code> into a matrix that scales an object by a factor
         * of four and rotates the object by <code>Math.PI/2</code> radians. </p>
         *
         * <p>This method replaces the source matrix with the concatenated matrix. If
         * you want to concatenate two matrixes without altering either of the two
         * source matrixes, first copy the source matrix by using the
         * <code>clone()</code> method, as shown in the Class Examples section.</p>
         *
         * @param matrix The matrix to be concatenated to the source matrix.
         */
        Matrix.prototype.concat = function (matrix) {
            var a1 = this.a * matrix.a + this.b * matrix.c;
            this.b = this.a * matrix.b + this.b * matrix.d;
            this.a = a1;
            var c1 = this.c * matrix.a + this.d * matrix.c;
            this.d = this.c * matrix.b + this.d * matrix.d;
            this.c = c1;
            var tx1 = this.tx * matrix.a + this.ty * matrix.c + matrix.tx;
            this.ty = this.tx * matrix.b + this.ty * matrix.d + matrix.ty;
            this.tx = tx1;
        };
        /**
         * Copies a Vector3 object into specific column of the calling Matrix4x4
         * object.
         *
         * @param column   The column from which to copy the data from.
         * @param vector3D The Vector3 object from which to copy the data.
         */
        Matrix.prototype.copyColumnFrom = function (column, vector3D) {
            if (column > 2) {
                throw "Column " + column + " out of bounds (2)";
            }
            else if (column == 0) {
                this.a = vector3D.x;
                this.c = vector3D.y;
            }
            else if (column == 1) {
                this.b = vector3D.x;
                this.d = vector3D.y;
            }
            else {
                this.tx = vector3D.x;
                this.ty = vector3D.y;
            }
        };
        /**
         * Copies specific column of the calling Matrix object into the Vector3
         * object. The w element of the Vector3 object will not be changed.
         *
         * @param column   The column from which to copy the data from.
         * @param vector3D The Vector3 object from which to copy the data.
         */
        Matrix.prototype.copyColumnTo = function (column, vector3D) {
            if (column > 2) {
                throw new Error("ArgumentError, Column " + column + " out of bounds [0, ..., 2]");
            }
            else if (column == 0) {
                vector3D.x = this.a;
                vector3D.y = this.c;
                vector3D.z = 0;
            }
            else if (column == 1) {
                vector3D.x = this.b;
                vector3D.y = this.d;
                vector3D.z = 0;
            }
            else {
                vector3D.x = this.tx;
                vector3D.y = this.ty;
                vector3D.z = 1;
            }
        };
        /**
         * Copies all of the matrix data from the source Point object into the
         * calling Matrix object.
         *
         * @param sourceMatrix The Matrix object from which to copy the data.
         */
        Matrix.prototype.copyFrom = function (sourceMatrix) {
            this.a = sourceMatrix.a;
            this.b = sourceMatrix.b;
            this.c = sourceMatrix.c;
            this.d = sourceMatrix.d;
            this.tx = sourceMatrix.tx;
            this.ty = sourceMatrix.ty;
        };
        /**
         * Copies a Vector3 object into specific row of the calling Matrix object.
         *
         * @param row      The row from which to copy the data from.
         * @param vector3D The Vector3 object from which to copy the data.
         */
        Matrix.prototype.copyRowFrom = function (row, vector3D) {
            if (row > 2) {
                throw new Error("ArgumentError, Row " + row + " out of bounds [0, ..., 2]");
            }
            else if (row == 0) {
                this.a = vector3D.x;
                this.c = vector3D.y;
            }
            else if (row == 1) {
                this.b = vector3D.x;
                this.d = vector3D.y;
            }
            else {
                this.tx = vector3D.x;
                this.ty = vector3D.y;
            }
        };
        /**
         * Copies specific row of the calling Matrix object into the Vector3 object.
         * The w element of the Vector3 object will not be changed.
         *
         * @param row      The row from which to copy the data from.
         * @param vector3D The Vector3 object from which to copy the data.
         */
        Matrix.prototype.copyRowTo = function (row, vector3D) {
            if (row > 2) {
                throw new Error("ArgumentError, Row " + row + " out of bounds [0, ..., 2]");
            }
            else if (row == 0) {
                vector3D.x = this.a;
                vector3D.y = this.b;
                vector3D.z = this.tx;
            }
            else if (row == 1) {
                vector3D.x = this.c;
                vector3D.y = this.d;
                vector3D.z = this.ty;
            }
            else {
                vector3D.init(0, 0, 1);
            }
        };
        /**
         * Includes parameters for scaling, rotation, and translation. When applied
         * to a matrix it sets the matrix's values based on those parameters.
         *
         * <p>Using the <code>createBox()</code> method lets you obtain the same
         * matrix as you would if you applied the <code>identity()</code>,
         * <code>rotate()</code>, <code>scale()</code>, and <code>translate()</code>
         * methods in succession. For example, <code>mat1.createBox(2,2,Math.PI/4,
         * 100, 100)</code> has the same effect as the following:</p>
         *
         * @param scaleX   The factor by which to scale horizontally.
         * @param scaleY   The factor by which scale vertically.
         * @param rotation The amount to rotate, in radians.
         * @param tx       The number of pixels to translate(move) to the right
         *                 along the <i>x</i> axis.
         * @param ty       The number of pixels to translate(move) down along the
         *                 <i>y</i> axis.
         */
        Matrix.prototype.createBox = function (scaleX, scaleY, rotation, tx, ty) {
            if (rotation === void 0) { rotation = 0; }
            if (tx === void 0) { tx = 0; }
            if (ty === void 0) { ty = 0; }
            this.a = scaleX;
            this.d = scaleY;
            this.b = rotation;
            this.tx = tx;
            this.ty = ty;
        };
        /**
         * Creates the specific style of matrix expected by the
         * <code>beginGradientFill()</code> and <code>lineGradientStyle()</code>
         * methods of the Graphics class. Width and height are scaled to a
         * <code>scaleX</code>/<code>scaleY</code> pair and the
         * <code>tx</code>/<code>ty</code> values are offset by half the width and
         * height.
         *
         * <p>For example, consider a gradient with the following
         * characteristics:</p>
         *
         * <ul>
         *   <li><code>GradientType.LINEAR</code></li>
         *   <li>Two colors, green and blue, with the ratios array set to <code>[0,
         * 255]</code></li>
         *   <li><code>SpreadMethod.PAD</code></li>
         *   <li><code>InterpolationMethod.LINEAR_RGB</code></li>
         * </ul>
         *
         * <p>The following illustrations show gradients in which the matrix was
         * defined using the <code>createGradientBox()</code> method with different
         * parameter settings:</p>
         *
         * @param width    The width of the gradient box.
         * @param height   The height of the gradient box.
         * @param rotation The amount to rotate, in radians.
         * @param tx       The distance, in pixels, to translate to the right along
         *                 the <i>x</i> axis. This value is offset by half of the
         *                 <code>width</code> parameter.
         * @param ty       The distance, in pixels, to translate down along the
         *                 <i>y</i> axis. This value is offset by half of the
         *                 <code>height</code> parameter.
         */
        Matrix.prototype.createGradientBox = function (width, height, rotation, tx, ty) {
            if (rotation === void 0) { rotation = 0; }
            if (tx === void 0) { tx = 0; }
            if (ty === void 0) { ty = 0; }
            this.a = width / 1638.4;
            this.d = height / 1638.4;
            if (rotation != 0.0) {
                var cos = Math.cos(rotation);
                var sin = Math.sin(rotation);
                this.b = sin * this.d;
                this.c = -sin * this.a;
                this.a *= cos;
                this.d *= cos;
            }
            else {
                this.b = this.c = 0;
            }
            this.tx = tx + width / 2;
            this.ty = ty + height / 2;
        };
        /**
         * Given a point in the pretransform coordinate space, returns the
         * coordinates of that point after the transformation occurs. Unlike the
         * standard transformation applied using the <code>transformPoint()</code>
         * method, the <code>deltaTransformPoint()</code> method's transformation
         * does not consider the translation parameters <code>tx</code> and
         * <code>ty</code>.
         *
         * @param point The point for which you want to get the result of the matrix
         *              transformation.
         * @return The point resulting from applying the matrix transformation.
         */
        Matrix.prototype.deltaTransformPoint = function (point) {
            return new feng3d.Vector2(point.x * this.a + point.y * this.c, point.x * this.b + point.y * this.d);
        };
        /**
         * Sets each matrix property to a value that causes a null transformation. An
         * object transformed by applying an identity matrix will be identical to the
         * original.
         *
         * <p>After calling the <code>identity()</code> method, the resulting matrix
         * has the following properties: <code>a</code>=1, <code>b</code>=0,
         * <code>c</code>=0, <code>d</code>=1, <code>tx</code>=0,
         * <code>ty</code>=0.</p>
         *
         * <p>In matrix notation, the identity matrix looks like this:</p>
         *
         */
        Matrix.prototype.identity = function () {
            this.a = 1;
            this.b = 0;
            this.c = 0;
            this.d = 1;
            this.tx = 0;
            this.ty = 0;
        };
        /**
         * Performs the opposite transformation of the original matrix. You can apply
         * an inverted matrix to an object to undo the transformation performed when
         * applying the original matrix.
         */
        Matrix.prototype.invert = function () {
            var norm = this.a * this.d - this.b * this.c;
            if (norm == 0) {
                this.a = this.b = this.c = this.d = 0;
                this.tx = -this.tx;
                this.ty = -this.ty;
            }
            else {
                norm = 1.0 / norm;
                var a1 = this.d * norm;
                this.d = this.a * norm;
                this.a = a1;
                this.b *= -norm;
                this.c *= -norm;
                var tx1 = -this.a * this.tx - this.c * this.ty;
                this.ty = -this.b * this.tx - this.d * this.ty;
                this.tx = tx1;
            }
        };
        /**
         * Returns a new Matrix object that is a clone of this matrix, with an exact
         * copy of the contained object.
         *
         * @param matrix The matrix for which you want to get the result of the matrix
         *               transformation.
         * @return A Matrix object.
         */
        Matrix.prototype.multiply = function (matrix) {
            var result = new Matrix();
            result.a = this.a * matrix.a + this.b * matrix.c;
            result.b = this.a * matrix.b + this.b * matrix.d;
            result.c = this.c * matrix.a + this.d * matrix.c;
            result.d = this.c * matrix.b + this.d * matrix.d;
            result.tx = this.tx * matrix.a + this.ty * matrix.c + matrix.tx;
            result.ty = this.tx * matrix.b + this.ty * matrix.d + matrix.ty;
            return result;
        };
        /**
         * Applies a rotation transformation to the Matrix object.
         *
         * <p>The <code>rotate()</code> method alters the <code>a</code>,
         * <code>b</code>, <code>c</code>, and <code>d</code> properties of the
         * Matrix object. In matrix notation, this is the same as concatenating the
         * current matrix with the following:</p>
         *
         * @param angle The rotation angle in radians.
         */
        Matrix.prototype.rotate = function (angle) {
            var cos = Math.cos(angle);
            var sin = Math.sin(angle);
            var a1 = this.a * cos - this.b * sin;
            this.b = this.a * sin + this.b * cos;
            this.a = a1;
            var c1 = this.c * cos - this.d * sin;
            this.d = this.c * sin + this.d * cos;
            this.c = c1;
            var tx1 = this.tx * cos - this.ty * sin;
            this.ty = this.tx * sin + this.ty * cos;
            this.tx = tx1;
        };
        /**
         * Applies a scaling transformation to the matrix. The <i>x</i> axis is
         * multiplied by <code>sx</code>, and the <i>y</i> axis it is multiplied by
         * <code>sy</code>.
         *
         * <p>The <code>scale()</code> method alters the <code>a</code> and
         * <code>d</code> properties of the Matrix object. In matrix notation, this
         * is the same as concatenating the current matrix with the following
         * matrix:</p>
         *
         * @param sx A multiplier used to scale the object along the <i>x</i> axis.
         * @param sy A multiplier used to scale the object along the <i>y</i> axis.
         */
        Matrix.prototype.scale = function (sx, sy) {
            this.a *= sx;
            this.b *= sy;
            this.c *= sx;
            this.d *= sy;
            this.tx *= sx;
            this.ty *= sy;
        };
        /**
         * Sets the members of Matrix to the specified values.
         *
         * @param a  The value that affects the positioning of pixels along the
         *           <i>x</i> axis when scaling or rotating an image.
         * @param b  The value that affects the positioning of pixels along the
         *           <i>y</i> axis when rotating or skewing an image.
         * @param c  The value that affects the positioning of pixels along the
         *           <i>x</i> axis when rotating or skewing an image.
         * @param d  The value that affects the positioning of pixels along the
         *           <i>y</i> axis when scaling or rotating an image..
         * @param tx The distance by which to translate each point along the <i>x</i>
         *           axis.
         * @param ty The distance by which to translate each point along the <i>y</i>
         *           axis.
         */
        Matrix.prototype.setTo = function (a, b, c, d, tx, ty) {
            this.a = a;
            this.b = b;
            this.c = c;
            this.d = d;
            this.tx = tx;
            this.ty = ty;
        };
        /**
         * Returns a text value listing the properties of the Matrix object.
         *
         * @return A string containing the values of the properties of the Matrix
         *         object: <code>a</code>, <code>b</code>, <code>c</code>,
         *         <code>d</code>, <code>tx</code>, and <code>ty</code>.
         */
        Matrix.prototype.toString = function () {
            return "[Matrix] (a=" + this.a + ", b=" + this.b + ", c=" + this.c + ", d=" + this.d + ", tx=" + this.tx + ", ty=" + this.ty + ")";
        };
        /**
         * Returns the result of applying the geometric transformation represented by
         * the Matrix object to the specified point.
         *
         * @param point The point for which you want to get the result of the Matrix
         *              transformation.
         * @return The point resulting from applying the Matrix transformation.
         */
        Matrix.prototype.transformPoint = function (point) {
            return new feng3d.Vector2(point.x * this.a + point.y * this.c + this.tx, point.x * this.b + point.y * this.d + this.ty);
        };
        /**
         * Translates the matrix along the <i>x</i> and <i>y</i> axes, as specified
         * by the <code>dx</code> and <code>dy</code> parameters.
         *
         * @param dx The amount of movement along the <i>x</i> axis to the right, in
         *           pixels.
         * @param dy The amount of movement down along the <i>y</i> axis, in pixels.
         */
        Matrix.prototype.translate = function (dx, dy) {
            this.tx += dx;
            this.ty += dy;
        };
        return Matrix;
    }());
    feng3d.Matrix = Matrix;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var Matrix3x3 = /** @class */ (function () {
        /**
         * 构建3x3矩阵
         *
         * @param elements 九个元素的数组
         */
        function Matrix3x3(elements) {
            if (elements === void 0) { elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]; }
            this.elements = elements;
        }
        /**
         * 设置矩阵为单位矩阵
         */
        Matrix3x3.prototype.identity = function () {
            var e = this.elements;
            e[0] = 1;
            e[1] = 0;
            e[2] = 0;
            e[3] = 0;
            e[4] = 1;
            e[5] = 0;
            e[6] = 0;
            e[7] = 0;
            e[8] = 1;
            return this;
        };
        /**
         * 将所有元素设置为0
         */
        Matrix3x3.prototype.setZero = function () {
            var e = this.elements;
            e[0] = 0;
            e[1] = 0;
            e[2] = 0;
            e[3] = 0;
            e[4] = 0;
            e[5] = 0;
            e[6] = 0;
            e[7] = 0;
            e[8] = 0;
            return this;
        };
        /**
         * 根据一个 Vector3 设置矩阵对角元素
         *
         * @param vec3
         */
        Matrix3x3.prototype.setTrace = function (vec3) {
            var e = this.elements;
            e[0] = vec3.x;
            e[4] = vec3.y;
            e[8] = vec3.z;
            return this;
        };
        /**
         * 获取矩阵对角元素
         */
        Matrix3x3.prototype.getTrace = function (target) {
            if (target === void 0) { target = new feng3d.Vector3(); }
            var e = this.elements;
            target.x = e[0];
            target.y = e[4];
            target.z = e[8];
            return target;
        };
        /**
         * 矩阵向量乘法
         *
         * @param v 要乘以的向量
         * @param target 目标保存结果
         */
        Matrix3x3.prototype.vmult = function (v, target) {
            if (target === void 0) { target = new feng3d.Vector3(); }
            var e = this.elements, x = v.x, y = v.y, z = v.z;
            target.x = e[0] * x + e[1] * y + e[2] * z;
            target.y = e[3] * x + e[4] * y + e[5] * z;
            target.z = e[6] * x + e[7] * y + e[8] * z;
            return target;
        };
        /**
         * 矩阵标量乘法
         * @param s
         */
        Matrix3x3.prototype.smult = function (s) {
            for (var i = 0; i < this.elements.length; i++) {
                this.elements[i] *= s;
            }
        };
        /**
         * 矩阵乘法
         * @param  m 要从左边乘的矩阵。
         */
        Matrix3x3.prototype.mmult = function (m, target) {
            if (target === void 0) { target = new feng3d.Matrix3x3(); }
            for (var i = 0; i < 3; i++) {
                for (var j = 0; j < 3; j++) {
                    var sum = 0.0;
                    for (var k = 0; k < 3; k++) {
                        sum += m.elements[i + k * 3] * this.elements[k + j * 3];
                    }
                    target.elements[i + j * 3] = sum;
                }
            }
            return target;
        };
        /**
         * 缩放矩阵的每一列
         *
         * @param v
         */
        Matrix3x3.prototype.scale = function (v, target) {
            if (target === void 0) { target = new feng3d.Matrix3x3(); }
            var e = this.elements, t = target.elements;
            for (var i = 0; i !== 3; i++) {
                t[3 * i + 0] = v.x * e[3 * i + 0];
                t[3 * i + 1] = v.y * e[3 * i + 1];
                t[3 * i + 2] = v.z * e[3 * i + 2];
            }
            return target;
        };
        /**
         * 解决Ax = b
         *
         * @param b 右手边
         * @param target 结果
         */
        Matrix3x3.prototype.solve = function (b, target) {
            if (target === void 0) { target = new feng3d.Vector3(); }
            // Construct equations
            var nr = 3; // num rows
            var nc = 4; // num cols
            var eqns = [];
            for (var i = 0; i < nr * nc; i++) {
                eqns.push(0);
            }
            var i, j;
            for (i = 0; i < 3; i++) {
                for (j = 0; j < 3; j++) {
                    eqns[i + nc * j] = this.elements[i + 3 * j];
                }
            }
            eqns[3 + 4 * 0] = b.x;
            eqns[3 + 4 * 1] = b.y;
            eqns[3 + 4 * 2] = b.z;
            // 计算矩阵的右上三角型——高斯消去法
            var n = 3, k = n, np;
            var kp = 4; // num rows
            var p;
            do {
                i = k - n;
                if (eqns[i + nc * i] === 0) {
                    // the pivot is null, swap lines
                    for (j = i + 1; j < k; j++) {
                        if (eqns[i + nc * j] !== 0) {
                            np = kp;
                            do { // do ligne( i ) = ligne( i ) + ligne( k )
                                p = kp - np;
                                eqns[p + nc * i] += eqns[p + nc * j];
                            } while (--np);
                            break;
                        }
                    }
                }
                if (eqns[i + nc * i] !== 0) {
                    for (j = i + 1; j < k; j++) {
                        var multiplier = eqns[i + nc * j] / eqns[i + nc * i];
                        np = kp;
                        do { // do ligne( k ) = ligne( k ) - multiplier * ligne( i )
                            p = kp - np;
                            eqns[p + nc * j] = p <= i ? 0 : eqns[p + nc * j] - eqns[p + nc * i] * multiplier;
                        } while (--np);
                    }
                }
            } while (--n);
            // Get the solution
            target.z = eqns[2 * nc + 3] / eqns[2 * nc + 2];
            target.y = (eqns[1 * nc + 3] - eqns[1 * nc + 2] * target.z) / eqns[1 * nc + 1];
            target.x = (eqns[0 * nc + 3] - eqns[0 * nc + 2] * target.z - eqns[0 * nc + 1] * target.y) / eqns[0 * nc + 0];
            if (isNaN(target.x) || isNaN(target.y) || isNaN(target.z) || target.x === Infinity || target.y === Infinity || target.z === Infinity) {
                throw "Could not solve equation! Got x=[" + target.toString() + "], b=[" + b.toString() + "], A=[" + this.toString() + "]";
            }
            return target;
        };
        /**
         * 获取指定行列元素值
         *
         * @param row
         * @param column
         */
        Matrix3x3.prototype.getElement = function (row, column) {
            return this.elements[column + 3 * row];
        };
        /**
         * 设置指定行列元素值
         *
         * @param row
         * @param column
         * @param value
         */
        Matrix3x3.prototype.setElement = function (row, column, value) {
            this.elements[column + 3 * row] = value;
        };
        /**
         * 将另一个矩阵复制到这个矩阵对象中
         *
         * @param source
         */
        Matrix3x3.prototype.copy = function (source) {
            for (var i = 0; i < source.elements.length; i++) {
                this.elements[i] = source.elements[i];
            }
            return this;
        };
        /**
         * 返回矩阵的字符串表示形式
         */
        Matrix3x3.prototype.toString = function () {
            var r = "";
            var sep = ",";
            for (var i = 0; i < 9; i++) {
                r += this.elements[i] + sep;
            }
            return r;
        };
        /**
         * 逆矩阵
         */
        Matrix3x3.prototype.reverse = function () {
            // Construct equations
            var nr = 3; // num rows
            var nc = 6; // num cols
            var eqns = [];
            for (var i = 0; i < nr * nc; i++) {
                eqns.push(0);
            }
            var i, j;
            for (i = 0; i < 3; i++) {
                for (j = 0; j < 3; j++) {
                    eqns[i + nc * j] = this.elements[i + 3 * j];
                }
            }
            eqns[3 + 6 * 0] = 1;
            eqns[3 + 6 * 1] = 0;
            eqns[3 + 6 * 2] = 0;
            eqns[4 + 6 * 0] = 0;
            eqns[4 + 6 * 1] = 1;
            eqns[4 + 6 * 2] = 0;
            eqns[5 + 6 * 0] = 0;
            eqns[5 + 6 * 1] = 0;
            eqns[5 + 6 * 2] = 1;
            // Compute right upper triangular version of the matrix - Gauss elimination
            var n = 3, k = n, np;
            var kp = nc; // num rows
            var p;
            do {
                i = k - n;
                if (eqns[i + nc * i] === 0) {
                    // the pivot is null, swap lines
                    for (j = i + 1; j < k; j++) {
                        if (eqns[i + nc * j] !== 0) {
                            np = kp;
                            do { // do line( i ) = line( i ) + line( k )
                                p = kp - np;
                                eqns[p + nc * i] += eqns[p + nc * j];
                            } while (--np);
                            break;
                        }
                    }
                }
                if (eqns[i + nc * i] !== 0) {
                    for (j = i + 1; j < k; j++) {
                        var multiplier = eqns[i + nc * j] / eqns[i + nc * i];
                        np = kp;
                        do { // do line( k ) = line( k ) - multiplier * line( i )
                            p = kp - np;
                            eqns[p + nc * j] = p <= i ? 0 : eqns[p + nc * j] - eqns[p + nc * i] * multiplier;
                        } while (--np);
                    }
                }
            } while (--n);
            // eliminate the upper left triangle of the matrix
            i = 2;
            do {
                j = i - 1;
                do {
                    var multiplier = eqns[i + nc * j] / eqns[i + nc * i];
                    np = nc;
                    do {
                        p = nc - np;
                        eqns[p + nc * j] = eqns[p + nc * j] - eqns[p + nc * i] * multiplier;
                    } while (--np);
                } while (j--);
            } while (--i);
            // operations on the diagonal
            i = 2;
            do {
                var multiplier = 1 / eqns[i + nc * i];
                np = nc;
                do {
                    p = nc - np;
                    eqns[p + nc * i] = eqns[p + nc * i] * multiplier;
                } while (--np);
            } while (i--);
            i = 2;
            do {
                j = 2;
                do {
                    p = eqns[nr + j + nc * i];
                    if (isNaN(p) || p === Infinity) {
                        throw "Could not reverse! A=[" + this.toString() + "]";
                    }
                    this.setElement(i, j, p);
                } while (j--);
            } while (i--);
            return this;
        };
        /**
         * 逆矩阵
         */
        Matrix3x3.prototype.reverseTo = function (target) {
            if (target === void 0) { target = new feng3d.Matrix3x3(); }
            return target.copy(this).reverse();
        };
        /**
         * 从四元数设置矩阵
         *
         * @param q
         */
        Matrix3x3.prototype.setRotationFromQuaternion = function (q) {
            var x = q.x, y = q.y, z = q.z, w = q.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2, e = this.elements;
            e[3 * 0 + 0] = 1 - (yy + zz);
            e[3 * 0 + 1] = xy - wz;
            e[3 * 0 + 2] = xz + wy;
            e[3 * 1 + 0] = xy + wz;
            e[3 * 1 + 1] = 1 - (xx + zz);
            e[3 * 1 + 2] = yz - wx;
            e[3 * 2 + 0] = xz - wy;
            e[3 * 2 + 1] = yz + wx;
            e[3 * 2 + 2] = 1 - (xx + yy);
            return this;
        };
        /**
         * 转置矩阵
         */
        Matrix3x3.prototype.transpose = function () {
            var Mt = this.elements, M = this.elements.concat();
            for (var i = 0; i !== 3; i++) {
                for (var j = 0; j !== 3; j++) {
                    Mt[3 * i + j] = M[3 * j + i];
                }
            }
            return this;
        };
        /**
         * 转置矩阵
         */
        Matrix3x3.prototype.transposeTo = function (target) {
            if (target === void 0) { target = new feng3d.Matrix3x3(); }
            return target.copy(this).transpose();
        };
        return Matrix3x3;
    }());
    feng3d.Matrix3x3 = Matrix3x3;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Matrix4x4 类表示一个转换矩阵，该矩阵确定三维 (3D) 显示对象的位置和方向。
     * 该矩阵可以执行转换功能，包括平移（沿 x、y 和 z 轴重新定位）、旋转和缩放（调整大小）。
     * Matrix4x4 类还可以执行透视投影，这会将 3D 坐标空间中的点映射到二维 (2D) 视图。
     * ```
     *  ---                                   ---
     *  |   scaleX      0         0       0     |   x轴
     *  |     0       scaleY      0       0     |   y轴
     *  |     0         0       scaleZ    0     |   z轴
     *  |     tx        ty        tz      tw    |   平移
     *  ---                                   ---
     *
     *  ---                                   ---
     *  |     0         1         2        3    |   x轴
     *  |     4         5         6        7    |   y轴
     *  |     8         9         10       11   |   z轴
     *  |     12        13        14       15   |   平移
     *  ---                                   ---
     * ```
     */
    var Matrix4x4 = /** @class */ (function () {
        /**
         * 创建 Matrix4x4 对象。
         * @param   datas    一个由 16 个数字组成的矢量，其中，每四个元素可以是 4x4 矩阵的一列。
         */
        function Matrix4x4(datas) {
            this.rawData = datas || [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1 //
            ];
        }
        Object.defineProperty(Matrix4x4.prototype, "position", {
            /**
             * 一个保存显示对象在转换参照帧中的 3D 坐标 (x,y,z) 位置的 Vector3 对象。
             */
            get: function () {
                return new feng3d.Vector3(this.rawData[12], this.rawData[13], this.rawData[14]);
            },
            set: function (value) {
                this.rawData[12] = value.x;
                this.rawData[13] = value.y;
                this.rawData[14] = value.z;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Matrix4x4.prototype, "determinant", {
            /**
             * 一个用于确定矩阵是否可逆的数字。
             */
            get: function () {
                return ( //
                (this.rawData[0] * this.rawData[5] - this.rawData[4] * this.rawData[1]) * (this.rawData[10] * this.rawData[15] - this.rawData[14] * this.rawData[11]) //
                    - (this.rawData[0] * this.rawData[9] - this.rawData[8] * this.rawData[1]) * (this.rawData[6] * this.rawData[15] - this.rawData[14] * this.rawData[7]) //
                    + (this.rawData[0] * this.rawData[13] - this.rawData[12] * this.rawData[1]) * (this.rawData[6] * this.rawData[11] - this.rawData[10] * this.rawData[7]) //
                    + (this.rawData[4] * this.rawData[9] - this.rawData[8] * this.rawData[5]) * (this.rawData[2] * this.rawData[15] - this.rawData[14] * this.rawData[3]) //
                    - (this.rawData[4] * this.rawData[13] - this.rawData[12] * this.rawData[5]) * (this.rawData[2] * this.rawData[11] - this.rawData[10] * this.rawData[3]) //
                    + (this.rawData[8] * this.rawData[13] - this.rawData[12] * this.rawData[9]) * (this.rawData[2] * this.rawData[7] - this.rawData[6] * this.rawData[3]) //
                );
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Matrix4x4.prototype, "forward", {
            /**
             * 前方（+Z轴方向）
             */
            get: function () {
                return this.copyColumnToVector3(2).normalize();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Matrix4x4.prototype, "up", {
            /**
             * 上方（+y轴方向）
             */
            get: function () {
                return this.copyColumnToVector3(1).normalize();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Matrix4x4.prototype, "right", {
            /**
             * 右方（+x轴方向）
             */
            get: function () {
                return this.copyColumnToVector3(0).normalize();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Matrix4x4.prototype, "back", {
            /**
             * 后方（-z轴方向）
             */
            get: function () {
                return this.copyColumnToVector3(2).normalize().negate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Matrix4x4.prototype, "down", {
            /**
             * 下方（-y轴方向）
             */
            get: function () {
                return this.copyColumnToVector3(1).normalize().negate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Matrix4x4.prototype, "left", {
            /**
             * 左方（-x轴方向）
             */
            get: function () {
                return this.copyColumnToVector3(0).normalize().negate();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 创建旋转矩阵
         * @param   axis            旋转轴
         * @param   degrees         角度
         */
        Matrix4x4.fromAxisRotate = function (axis, degrees) {
            var n = axis.clone();
            n.normalize();
            var q = degrees * Math.PI / 180;
            var sinq = Math.sin(q);
            var cosq = Math.cos(q);
            var lcosq = 1 - cosq;
            var rotationMat = new Matrix4x4([
                n.x * n.x * lcosq + cosq, n.x * n.y * lcosq + n.z * sinq, n.x * n.z * lcosq - n.y * sinq, 0,
                n.x * n.y * lcosq - n.z * sinq, n.y * n.y * lcosq + cosq, n.y * n.z * lcosq + n.x * sinq, 0,
                n.x * n.z * lcosq + n.y * sinq, n.y * n.z * lcosq - n.x * sinq, n.z * n.z * lcosq + cosq, 0,
                0, 0, 0, 1 //
            ]);
            return rotationMat;
        };
        /**
         * 创建旋转矩阵
         * @param   rx      用于沿 x 轴旋转对象的角度。
         * @param   ry      用于沿 y 轴旋转对象的角度。
         * @param   rz      用于沿 z 轴旋转对象的角度。
         */
        Matrix4x4.fromRotation = function (rx, ry, rz) {
            rx = Math.degToRad(rx);
            ry = Math.degToRad(ry);
            rz = Math.degToRad(rz);
            var sx = Math.sin(rx), cx = Math.cos(rx), sy = Math.sin(ry), cy = Math.cos(ry), sz = Math.sin(rz), cz = Math.cos(rz);
            return new Matrix4x4([
                cy * cz, cy * sz, -sy, 0,
                sx * sy * cz - cx * sz, sx * sy * sz + cx * cz, sx * cy, 0,
                cx * sy * cz + sx * sz, cx * sy * sz - sx * cz, cx * cy, 0,
                0, 0, 0, 1,
            ]);
        };
        /**
         * 创建缩放矩阵
         * @param   xScale      用于沿 x 轴缩放对象的乘数。
         * @param   yScale      用于沿 y 轴缩放对象的乘数。
         * @param   zScale      用于沿 z 轴缩放对象的乘数。
         */
        Matrix4x4.fromScale = function (xScale, yScale, zScale) {
            var rotationMat = new Matrix4x4([
                xScale, 0.0000, 0.0000, 0,
                0.0000, yScale, 0.0000, 0,
                0.0000, 0.0000, zScale, 0,
                0.0000, 0.0000, 0.0000, 1 //
            ]);
            return rotationMat;
        };
        /**
         * 创建位移矩阵
         * @param   x   沿 x 轴的增量平移。
         * @param   y   沿 y 轴的增量平移。
         * @param   z   沿 z 轴的增量平移。
         */
        Matrix4x4.fromPosition = function (x, y, z) {
            var rotationMat = new Matrix4x4([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                x, y, z, 1 //
            ]);
            return rotationMat;
        };
        /**
         * 通过将另一个 Matrix4x4 对象与当前 Matrix4x4 对象相乘来后置一个矩阵。
         */
        Matrix4x4.prototype.append = function (lhs) {
            var //
            m111 = this.rawData[0], m121 = this.rawData[4], m131 = this.rawData[8], m141 = this.rawData[12], //
            m112 = this.rawData[1], m122 = this.rawData[5], m132 = this.rawData[9], m142 = this.rawData[13], //
            m113 = this.rawData[2], m123 = this.rawData[6], m133 = this.rawData[10], m143 = this.rawData[14], //
            m114 = this.rawData[3], m124 = this.rawData[7], m134 = this.rawData[11], m144 = this.rawData[15], //
            m211 = lhs.rawData[0], m221 = lhs.rawData[4], m231 = lhs.rawData[8], m241 = lhs.rawData[12], //
            m212 = lhs.rawData[1], m222 = lhs.rawData[5], m232 = lhs.rawData[9], m242 = lhs.rawData[13], //
            m213 = lhs.rawData[2], m223 = lhs.rawData[6], m233 = lhs.rawData[10], m243 = lhs.rawData[14], //
            m214 = lhs.rawData[3], m224 = lhs.rawData[7], m234 = lhs.rawData[11], m244 = lhs.rawData[15];
            this.rawData[0] = m111 * m211 + m112 * m221 + m113 * m231 + m114 * m241;
            this.rawData[1] = m111 * m212 + m112 * m222 + m113 * m232 + m114 * m242;
            this.rawData[2] = m111 * m213 + m112 * m223 + m113 * m233 + m114 * m243;
            this.rawData[3] = m111 * m214 + m112 * m224 + m113 * m234 + m114 * m244;
            this.rawData[4] = m121 * m211 + m122 * m221 + m123 * m231 + m124 * m241;
            this.rawData[5] = m121 * m212 + m122 * m222 + m123 * m232 + m124 * m242;
            this.rawData[6] = m121 * m213 + m122 * m223 + m123 * m233 + m124 * m243;
            this.rawData[7] = m121 * m214 + m122 * m224 + m123 * m234 + m124 * m244;
            this.rawData[8] = m131 * m211 + m132 * m221 + m133 * m231 + m134 * m241;
            this.rawData[9] = m131 * m212 + m132 * m222 + m133 * m232 + m134 * m242;
            this.rawData[10] = m131 * m213 + m132 * m223 + m133 * m233 + m134 * m243;
            this.rawData[11] = m131 * m214 + m132 * m224 + m133 * m234 + m134 * m244;
            this.rawData[12] = m141 * m211 + m142 * m221 + m143 * m231 + m144 * m241;
            this.rawData[13] = m141 * m212 + m142 * m222 + m143 * m232 + m144 * m242;
            this.rawData[14] = m141 * m213 + m142 * m223 + m143 * m233 + m144 * m243;
            this.rawData[15] = m141 * m214 + m142 * m224 + m143 * m234 + m144 * m244;
            feng3d.debuger && console.assert(this.rawData[0] !== NaN && this.rawData[4] !== NaN && this.rawData[8] !== NaN && this.rawData[12] !== NaN);
            return this;
        };
        /**
         * 在 Matrix4x4 对象上后置一个增量旋转。
         * @param   axis            旋转轴
         * @param   degrees         角度
         * @param   pivotPoint      旋转中心点
         */
        Matrix4x4.prototype.appendRotation = function (axis, degrees, pivotPoint) {
            var rotationMat = Matrix4x4.fromAxisRotate(axis, degrees);
            if (pivotPoint != null) {
                this.appendTranslation(-pivotPoint.x, -pivotPoint.y, -pivotPoint.z);
            }
            this.append(rotationMat);
            if (pivotPoint != null) {
                this.appendTranslation(pivotPoint.x, pivotPoint.y, pivotPoint.z);
            }
            return this;
        };
        /**
         * 在 Matrix4x4 对象上后置一个增量缩放，沿 x、y 和 z 轴改变位置。
         * @param   xScale      用于沿 x 轴缩放对象的乘数。
         * @param   yScale      用于沿 y 轴缩放对象的乘数。
         * @param   zScale      用于沿 z 轴缩放对象的乘数。
         */
        Matrix4x4.prototype.appendScale = function (xScale, yScale, zScale) {
            var scaleMat = Matrix4x4.fromScale(xScale, yScale, zScale);
            this.append(scaleMat);
            return this;
        };
        /**
         * 在 Matrix4x4 对象上后置一个增量平移，沿 x、y 和 z 轴重新定位。
         * @param   x   沿 x 轴的增量平移。
         * @param   y   沿 y 轴的增量平移。
         * @param   z   沿 z 轴的增量平移。
         */
        Matrix4x4.prototype.appendTranslation = function (x, y, z) {
            this.rawData[12] += x;
            this.rawData[13] += y;
            this.rawData[14] += z;
            return this;
        };
        /**
         * 返回一个新 Matrix4x4 对象，它是与当前 Matrix4x4 对象完全相同的副本。
         */
        Matrix4x4.prototype.clone = function () {
            var ret = new Matrix4x4();
            ret.copyFrom(this);
            return ret;
        };
        /**
         * 将 Vector3 对象复制到调用方 Matrix4x4 对象的特定列中。
         * @param   column      副本的目标列。
         * @param   vector3D    要从中复制数据的 Vector3 对象。
         */
        Matrix4x4.prototype.copyColumnFrom = function (column, vector3D) {
            this.rawData[column * 4 + 0] = vector3D.x;
            this.rawData[column * 4 + 1] = vector3D.y;
            this.rawData[column * 4 + 2] = vector3D.z;
            this.rawData[column * 4 + 3] = vector3D.w;
            return this;
        };
        /**
         * 将调用方 Matrix4x4 对象的特定列复制到 Vector3 对象中。
         * @param   column       要从中复制数据的列。
         * @param   vector3D     副本的目标 Vector3 对象。
         */
        Matrix4x4.prototype.copyColumnToVector3 = function (column, vector3D) {
            if (vector3D === void 0) { vector3D = new feng3d.Vector3(); }
            this.copyColumnToVector4(column, feng3d.Vector4.fromVector3(vector3D)).toVector3(vector3D);
            return vector3D;
        };
        /**
         * 将调用方 Matrix4x4 对象的特定列复制到 Vector3 对象中。
         * @param   column       要从中复制数据的列。
         * @param   vector3D     副本的目标 Vector3 对象。
         */
        Matrix4x4.prototype.copyColumnToVector4 = function (column, vector3D) {
            if (vector3D === void 0) { vector3D = new feng3d.Vector4(); }
            vector3D.x = this.rawData[column * 4 + 0];
            vector3D.y = this.rawData[column * 4 + 1];
            vector3D.z = this.rawData[column * 4 + 2];
            vector3D.w = this.rawData[column * 4 + 3];
            return vector3D;
        };
        /**
         * 将源 Matrix4x4 对象中的所有矩阵数据复制到调用方 Matrix4x4 对象中。
         * @param   sourceMatrix3D      要从中复制数据的 Matrix4x4 对象。
         */
        Matrix4x4.prototype.copyFrom = function (sourceMatrix3D) {
            for (var i = 0; i < 16; i++) {
                this.rawData[i] = sourceMatrix3D.rawData[i];
            }
            return this;
        };
        /**
         * 将源 Vector 对象中的所有矢量数据复制到调用方 Matrix4x4 对象中。利用可选索引参数，您可以选择矢量中的任何起始文字插槽。
         * @param   vector      要从中复制数据的 Vector 对象。
         * @param   index       vector中的起始位置
         * @param   transpose   是否转置当前矩阵
         */
        Matrix4x4.prototype.copyRawDataFrom = function (vector, index, transpose) {
            if (index === void 0) { index = 0; }
            if (transpose === void 0) { transpose = false; }
            if (vector.length - index < 16) {
                throw new Error("vector参数数据长度不够！");
            }
            if (transpose) {
                this.transpose();
            }
            for (var i = 0; i < 16; i++) {
                this.rawData[i] = vector[index + i];
            }
            if (transpose) {
                this.transpose();
            }
            return this;
        };
        /**
         * 将调用方 Matrix4x4 对象中的所有矩阵数据复制到提供的矢量中。
         * @param   vector      要将数据复制到的 Vector 对象。
         * @param   index       vector中的起始位置
         * @param   transpose   是否转置当前矩阵
         */
        Matrix4x4.prototype.copyRawDataTo = function (vector, index, transpose) {
            if (index === void 0) { index = 0; }
            if (transpose === void 0) { transpose = false; }
            if (transpose) {
                this.transpose();
            }
            for (var i = 0; i < 16; i++) {
                vector[i + index] = this.rawData[i];
            }
            if (transpose) {
                this.transpose();
            }
            return this;
        };
        /**
         * 将 Vector3 对象复制到调用方 Matrix4x4 对象的特定行中。
         * @param   row         要将数据复制到的行。
         * @param   vector3D    要从中复制数据的 Vector3 对象。
         */
        Matrix4x4.prototype.copyRowFrom = function (row, vector3D) {
            this.rawData[row + 4 * 0] = vector3D.x;
            this.rawData[row + 4 * 1] = vector3D.y;
            this.rawData[row + 4 * 2] = vector3D.z;
            this.rawData[row + 4 * 3] = vector3D.w;
            return this;
        };
        /**
         * 将调用方 Matrix4x4 对象的特定行复制到 Vector3 对象中。
         * @param   row         要从中复制数据的行。
         * @param   vector3D    将作为数据复制目的地的 Vector3 对象。
         */
        Matrix4x4.prototype.copyRowTo = function (row, vector3D) {
            vector3D.x = this.rawData[row + 4 * 0];
            vector3D.y = this.rawData[row + 4 * 1];
            vector3D.z = this.rawData[row + 4 * 2];
            vector3D.w = this.rawData[row + 4 * 3];
            return this;
        };
        /**
         * 拷贝当前矩阵
         * @param   dest    目标矩阵
         */
        Matrix4x4.prototype.copyToMatrix3D = function (dest) {
            dest.rawData = this.rawData.concat();
            return this;
        };
        /**
         * 将转换矩阵的平移、旋转和缩放设置作为由三个 Vector3 对象组成的矢量返回。
         * @return      一个由三个 Vector3 对象组成的矢量，其中，每个对象分别容纳平移、旋转和缩放设置。
         */
        Matrix4x4.prototype.decompose = function (orientationStyle, result) {
            if (orientationStyle === void 0) { orientationStyle = feng3d.Orientation3D.EULER_ANGLES; }
            var raw = this.rawData;
            var a = raw[0];
            var e = raw[1];
            var i = raw[2];
            var b = raw[4];
            var f = raw[5];
            var j = raw[6];
            var c = raw[8];
            var g = raw[9];
            var k = raw[10];
            var x = raw[12];
            var y = raw[13];
            var z = raw[14];
            var tx = Math.sqrt(a * a + e * e + i * i);
            var ty = Math.sqrt(b * b + f * f + j * j);
            var tz = Math.sqrt(c * c + g * g + k * k);
            var tw = 0;
            var scaleX = tx;
            var scaleY = ty;
            var scaleZ = tz;
            if (a * (f * k - j * g) - e * (b * k - j * c) + i * (b * g - f * c) < 0) {
                scaleZ = -scaleZ;
            }
            a = a / scaleX;
            e = e / scaleX;
            i = i / scaleX;
            b = b / scaleY;
            f = f / scaleY;
            j = j / scaleY;
            c = c / scaleZ;
            g = g / scaleZ;
            k = k / scaleZ;
            if (orientationStyle == feng3d.Orientation3D.EULER_ANGLES) {
                tx = Math.atan2(j, k);
                ty = Math.atan2(-i, Math.sqrt(a * a + e * e));
                var s1 = Math.sin(tx);
                var c1 = Math.cos(tx);
                tz = Math.atan2(s1 * c - c1 * b, c1 * f - s1 * g);
            }
            else if (orientationStyle == feng3d.Orientation3D.AXIS_ANGLE) {
                tw = Math.acos((a + f + k - 1) / 2);
                var len = Math.sqrt((j - g) * (j - g) + (c - i) * (c - i) + (e - b) * (e - b));
                tx = (j - g) / len;
                ty = (c - i) / len;
                tz = (e - b) / len;
            }
            else { //Orientation3D.QUATERNION
                var tr = a + f + k;
                if (tr > 0) {
                    tw = Math.sqrt(1 + tr) / 2;
                    tx = (j - g) / (4 * tw);
                    ty = (c - i) / (4 * tw);
                    tz = (e - b) / (4 * tw);
                }
                else if ((a > f) && (a > k)) {
                    tx = Math.sqrt(1 + a - f - k) / 2;
                    tw = (j - g) / (4 * tx);
                    ty = (e + b) / (4 * tx);
                    tz = (c + i) / (4 * tx);
                }
                else if (f > k) {
                    ty = Math.sqrt(1 + f - a - k) / 2;
                    tx = (e + b) / (4 * ty);
                    tw = (c - i) / (4 * ty);
                    tz = (j + g) / (4 * ty);
                }
                else {
                    tz = Math.sqrt(1 + k - a - f) / 2;
                    tx = (c + i) / (4 * tz);
                    ty = (j + g) / (4 * tz);
                    tw = (e - b) / (4 * tz);
                }
            }
            result = result || [new feng3d.Vector3(), new feng3d.Vector3(), new feng3d.Vector3()];
            result[0].x = x;
            result[0].y = y;
            result[0].z = z;
            result[1].x = tx;
            result[1].y = ty;
            result[1].z = tz;
            result[2].x = scaleX;
            result[2].y = scaleY;
            result[2].z = scaleZ;
            return result;
        };
        /**
         * 使用不含平移元素的转换矩阵将 Vector3 对象从一个空间坐标转换到另一个空间坐标。
         * @param   v   一个容纳要转换的坐标的 Vector3 对象。
         * @return  一个包含转换后的坐标的 Vector3 对象。
         */
        Matrix4x4.prototype.deltaTransformVector = function (v, vout) {
            if (vout === void 0) { vout = new feng3d.Vector3(); }
            var v4 = feng3d.Vector4.fromVector3(v, 0);
            //
            this.transformVector4(v4, v4);
            //
            v4.toVector3(vout);
            return vout;
        };
        /**
         * 将当前矩阵转换为恒等或单位矩阵。
         */
        Matrix4x4.prototype.identity = function () {
            var r = this.rawData;
            r[1] = 0;
            r[2] = 0;
            r[3] = 0;
            r[4] = 0;
            r[6] = 0;
            r[7] = 0;
            r[8] = 0;
            r[9] = 0;
            r[11] = 0;
            r[12] = 0;
            r[13] = 0;
            r[14] = 0;
            r[0] = 1;
            r[5] = 1;
            r[10] = 1;
            r[15] = 1;
            return this;
        };
        /**
         * 反转当前矩阵。逆矩阵
         * @return      如果成功反转矩阵，则返回 该矩阵。
         */
        Matrix4x4.prototype.invert = function () {
            var d = this.determinant;
            if (d == 0) {
                console.error("无法获取逆矩阵");
                return this;
            }
            d = 1 / d;
            var r = this.rawData;
            var m11 = r[0];
            var m21 = r[4];
            var m31 = r[8];
            var m41 = r[12];
            var m12 = r[1];
            var m22 = r[5];
            var m32 = r[9];
            var m42 = r[13];
            var m13 = r[2];
            var m23 = r[6];
            var m33 = r[10];
            var m43 = r[14];
            var m14 = r[3];
            var m24 = r[7];
            var m34 = r[11];
            var m44 = r[15];
            r[0] = d * (m22 * (m33 * m44 - m43 * m34) - m32 * (m23 * m44 - m43 * m24) + m42 * (m23 * m34 - m33 * m24));
            r[1] = -d * (m12 * (m33 * m44 - m43 * m34) - m32 * (m13 * m44 - m43 * m14) + m42 * (m13 * m34 - m33 * m14));
            r[2] = d * (m12 * (m23 * m44 - m43 * m24) - m22 * (m13 * m44 - m43 * m14) + m42 * (m13 * m24 - m23 * m14));
            r[3] = -d * (m12 * (m23 * m34 - m33 * m24) - m22 * (m13 * m34 - m33 * m14) + m32 * (m13 * m24 - m23 * m14));
            r[4] = -d * (m21 * (m33 * m44 - m43 * m34) - m31 * (m23 * m44 - m43 * m24) + m41 * (m23 * m34 - m33 * m24));
            r[5] = d * (m11 * (m33 * m44 - m43 * m34) - m31 * (m13 * m44 - m43 * m14) + m41 * (m13 * m34 - m33 * m14));
            r[6] = -d * (m11 * (m23 * m44 - m43 * m24) - m21 * (m13 * m44 - m43 * m14) + m41 * (m13 * m24 - m23 * m14));
            r[7] = d * (m11 * (m23 * m34 - m33 * m24) - m21 * (m13 * m34 - m33 * m14) + m31 * (m13 * m24 - m23 * m14));
            r[8] = d * (m21 * (m32 * m44 - m42 * m34) - m31 * (m22 * m44 - m42 * m24) + m41 * (m22 * m34 - m32 * m24));
            r[9] = -d * (m11 * (m32 * m44 - m42 * m34) - m31 * (m12 * m44 - m42 * m14) + m41 * (m12 * m34 - m32 * m14));
            r[10] = d * (m11 * (m22 * m44 - m42 * m24) - m21 * (m12 * m44 - m42 * m14) + m41 * (m12 * m24 - m22 * m14));
            r[11] = -d * (m11 * (m22 * m34 - m32 * m24) - m21 * (m12 * m34 - m32 * m14) + m31 * (m12 * m24 - m22 * m14));
            r[12] = -d * (m21 * (m32 * m43 - m42 * m33) - m31 * (m22 * m43 - m42 * m23) + m41 * (m22 * m33 - m32 * m23));
            r[13] = d * (m11 * (m32 * m43 - m42 * m33) - m31 * (m12 * m43 - m42 * m13) + m41 * (m12 * m33 - m32 * m13));
            r[14] = -d * (m11 * (m22 * m43 - m42 * m23) - m21 * (m12 * m43 - m42 * m13) + m41 * (m12 * m23 - m22 * m13));
            r[15] = d * (m11 * (m22 * m33 - m32 * m23) - m21 * (m12 * m33 - m32 * m13) + m31 * (m12 * m23 - m22 * m13));
            return this;
        };
        /**
         * 通过将当前 Matrix4x4 对象与另一个 Matrix4x4 对象相乘来前置一个矩阵。得到的结果将合并两个矩阵转换。
         * @param   rhs     个右侧矩阵，它与当前 Matrix4x4 对象相乘。
         */
        Matrix4x4.prototype.prepend = function (rhs) {
            var mat = this.clone();
            this.copyFrom(rhs);
            this.append(mat);
            return this;
        };
        /**
         * 在 Matrix4x4 对象上前置一个增量旋转。在将 Matrix4x4 对象应用于显示对象时，矩阵会在 Matrix4x4 对象中先执行旋转，然后再执行其他转换。
         * @param   axis        旋转的轴或方向。常见的轴为 X_AXIS (Vector3(1,0,0))、Y_AXIS (Vector3(0,1,0)) 和 Z_AXIS (Vector3(0,0,1))。此矢量的长度应为 1。
         * @param   degrees     旋转的角度。
         * @param   pivotPoint  一个用于确定旋转中心的点。对象的默认轴点为该对象的注册点。
         */
        Matrix4x4.prototype.prependRotation = function (axis, degrees, pivotPoint) {
            if (pivotPoint === void 0) { pivotPoint = new feng3d.Vector3(); }
            var rotationMat = Matrix4x4.fromAxisRotate(axis, degrees);
            this.prepend(rotationMat);
            return this;
        };
        /**
         * 在 Matrix4x4 对象上前置一个增量缩放，沿 x、y 和 z 轴改变位置。在将 Matrix4x4 对象应用于显示对象时，矩阵会在 Matrix4x4 对象中先执行缩放更改，然后再执行其他转换。
         * @param   xScale      用于沿 x 轴缩放对象的乘数。
         * @param   yScale      用于沿 y 轴缩放对象的乘数。
         * @param   zScale      用于沿 z 轴缩放对象的乘数。
         */
        Matrix4x4.prototype.prependScale = function (xScale, yScale, zScale) {
            var scaleMat = Matrix4x4.fromScale(xScale, yScale, zScale);
            this.prepend(scaleMat);
            return this;
        };
        /**
         * 在 Matrix4x4 对象上前置一个增量平移，沿 x、y 和 z 轴重新定位。在将 Matrix4x4 对象应用于显示对象时，矩阵会在 Matrix4x4 对象中先执行平移更改，然后再执行其他转换。
         * @param   x   沿 x 轴的增量平移。
         * @param   y   沿 y 轴的增量平移。
         * @param   z   沿 z 轴的增量平移。
         */
        Matrix4x4.prototype.prependTranslation = function (x, y, z) {
            var translationMat = Matrix4x4.fromPosition(x, y, z);
            this.prepend(translationMat);
            return this;
        };
        /**
         * X轴方向移动
         * @param distance  移动距离
         */
        Matrix4x4.prototype.moveRight = function (distance) {
            var direction = this.right;
            direction.scaleNumber(distance);
            this.position = this.position.addTo(direction);
            return this;
        };
        /**
         * Y轴方向移动
         * @param distance  移动距离
         */
        Matrix4x4.prototype.moveUp = function (distance) {
            var direction = this.up;
            direction.scaleNumber(distance);
            this.position = this.position.addTo(direction);
            return this;
        };
        /**
         * Z轴方向移动
         * @param distance  移动距离
         */
        Matrix4x4.prototype.moveForward = function (distance) {
            var direction = this.forward;
            direction.scaleNumber(distance);
            this.position = this.position.addTo(direction);
            return this;
        };
        /**
         * 设置转换矩阵的平移、旋转和缩放设置。
         * @param   components      一个由三个 Vector3 对象组成的矢量，这些对象将替代 Matrix4x4 对象的平移、旋转和缩放元素。
         */
        Matrix4x4.prototype.recompose = function (components) {
            var rx = components[1].x;
            var ry = components[1].y;
            var rz = components[1].z;
            var sx = Math.sin(rx), cx = Math.cos(rx), sy = Math.sin(ry), cy = Math.cos(ry), sz = Math.sin(rz), cz = Math.cos(rz);
            var xS = components[2].x, yS = components[2].y, zS = components[2].z;
            this.rawData = [
                cy * cz * xS, cy * sz * xS, -sy * xS, 0,
                (sx * sy * cz - cx * sz) * yS, (sx * sy * sz + cx * cz) * yS, sx * cy * yS, 0,
                (cx * sy * cz + sx * sz) * zS, (cx * sy * sz - sx * cz) * zS, cx * cy * zS, 0,
                components[0].x, components[0].y, components[0].z, 1,
            ];
            return this;
        };
        /**
         * 使用转换矩阵将 Vector3 对象从一个空间坐标转换到另一个空间坐标。
         * @param   vin   一个容纳要转换的坐标的 Vector3 对象。
         * @return  一个包含转换后的坐标的 Vector3 对象。
         */
        Matrix4x4.prototype.transformVector = function (vin, vout) {
            if (vout === void 0) { vout = new feng3d.Vector3(); }
            this.transformVector4(feng3d.Vector4.fromVector3(vin, 1)).toVector3(vout);
            return vout;
        };
        /**
         * 使用转换矩阵将 Vector3 对象从一个空间坐标转换到另一个空间坐标。
         * @param   vin   一个容纳要转换的坐标的 Vector3 对象。
         * @return  一个包含转换后的坐标的 Vector3 对象。
         */
        Matrix4x4.prototype.transformVector4 = function (vin, vout) {
            if (vout === void 0) { vout = new feng3d.Vector4(); }
            var x = vin.x;
            var y = vin.y;
            var z = vin.z;
            var w = vin.w;
            vout.x = x * this.rawData[0] + y * this.rawData[4] + z * this.rawData[8] + w * this.rawData[12];
            vout.y = x * this.rawData[1] + y * this.rawData[5] + z * this.rawData[9] + w * this.rawData[13];
            vout.z = x * this.rawData[2] + y * this.rawData[6] + z * this.rawData[10] + w * this.rawData[14];
            vout.w = x * this.rawData[3] + y * this.rawData[7] + z * this.rawData[11] + w * this.rawData[15];
            return vout;
        };
        /**
         * 使用转换矩阵将由数字构成的矢量从一个空间坐标转换到另一个空间坐标。
         * @param   vin     一个由多个数字组成的矢量，其中每三个数字构成一个要转换的 3D 坐标 (x,y,z)。
         * @param   vout    一个由多个数字组成的矢量，其中每三个数字构成一个已转换的 3D 坐标 (x,y,z)。
         */
        Matrix4x4.prototype.transformVectors = function (vin, vout) {
            var vec = new feng3d.Vector3();
            for (var i = 0; i < vin.length; i += 3) {
                vec.init(vin[i], vin[i + 1], vin[i + 2]);
                vec = this.transformVector(vec);
                vout[i] = vec.x;
                vout[i + 1] = vec.y;
                vout[i + 2] = vec.z;
            }
        };
        Matrix4x4.prototype.transformRotation = function (vin, vout) {
            //转换旋转
            var rotationMatrix3d = Matrix4x4.fromRotation(vin.x, vin.y, vin.z);
            rotationMatrix3d.append(this);
            var newrotation = rotationMatrix3d.decompose()[1];
            newrotation.scaleNumber(180 / Math.PI);
            var v = Math.round((newrotation.x - vin.x) / 180);
            if (v % 2 != 0) {
                newrotation.x += 180;
                newrotation.y = 180 - newrotation.y;
                newrotation.z += 180;
            }
            //
            var toRound = function (a, b, c) {
                if (c === void 0) { c = 360; }
                return Math.round((b - a) / c) * c + a;
            };
            newrotation.x = toRound(newrotation.x, vin.x);
            newrotation.y = toRound(newrotation.y, vin.y);
            newrotation.z = toRound(newrotation.z, vin.z);
            //
            vout = vout || new feng3d.Vector3();
            vout.x = newrotation.x;
            vout.y = newrotation.y;
            vout.z = newrotation.z;
            return vout;
        };
        /**
         * 将当前 Matrix4x4 对象转换为一个矩阵，并将互换其中的行和列。
         */
        Matrix4x4.prototype.transpose = function () {
            var swap;
            for (var i = 0; i < 4; i++) {
                for (var j = 0; j < 4; j++) {
                    if (i > j) {
                        swap = this.rawData[i * 4 + j];
                        this.rawData[i * 4 + j] = this.rawData[j * 4 + i];
                        this.rawData[j * 4 + i] = swap;
                    }
                }
            }
            return this;
        };
        /**
         * 比较矩阵是否相等
         */
        Matrix4x4.prototype.equals = function (matrix3D, precision) {
            if (precision === void 0) { precision = Math.PRECISION; }
            var r2 = matrix3D.rawData;
            for (var i = 0; i < 16; ++i) {
                if (!Math.equals(this.rawData[i] - r2[i], 0, precision))
                    return false;
            }
            return true;
        };
        /**
         * 看向目标位置
         * @param target    目标位置
         * @param upAxis    向上朝向
         */
        Matrix4x4.prototype.lookAt = function (target, upAxis) {
            //获取位移，缩放，在变换过程位移与缩放不变
            var vec = this.decompose();
            var position = vec[0];
            var scale = vec[2];
            //
            var xAxis = new feng3d.Vector3();
            var yAxis = new feng3d.Vector3();
            var zAxis = new feng3d.Vector3();
            upAxis = upAxis || feng3d.Vector3.Y_AXIS;
            zAxis.x = target.x - this.position.x;
            zAxis.y = target.y - this.position.y;
            zAxis.z = target.z - this.position.z;
            zAxis.normalize();
            xAxis.x = upAxis.y * zAxis.z - upAxis.z * zAxis.y;
            xAxis.y = upAxis.z * zAxis.x - upAxis.x * zAxis.z;
            xAxis.z = upAxis.x * zAxis.y - upAxis.y * zAxis.x;
            xAxis.normalize();
            if (xAxis.length < .05) {
                xAxis.x = upAxis.y;
                xAxis.y = upAxis.x;
                xAxis.z = 0;
                xAxis.normalize();
            }
            yAxis.x = zAxis.y * xAxis.z - zAxis.z * xAxis.y;
            yAxis.y = zAxis.z * xAxis.x - zAxis.x * xAxis.z;
            yAxis.z = zAxis.x * xAxis.y - zAxis.y * xAxis.x;
            this.rawData[0] = scale.x * xAxis.x;
            this.rawData[1] = scale.x * xAxis.y;
            this.rawData[2] = scale.x * xAxis.z;
            this.rawData[3] = 0;
            this.rawData[4] = scale.y * yAxis.x;
            this.rawData[5] = scale.y * yAxis.y;
            this.rawData[6] = scale.y * yAxis.z;
            this.rawData[7] = 0;
            this.rawData[8] = scale.z * zAxis.x;
            this.rawData[9] = scale.z * zAxis.y;
            this.rawData[10] = scale.z * zAxis.z;
            this.rawData[11] = 0;
            this.rawData[12] = position.x;
            this.rawData[13] = position.y;
            this.rawData[14] = position.z;
            this.rawData[15] = 1;
        };
        /**
         * 获取XYZ轴中最大缩放值
         */
        Matrix4x4.prototype.getMaxScaleOnAxis = function () {
            var te = this.rawData;
            var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
            var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
            var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
            return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
        };
        /**
         * 初始化正射投影矩阵
         * @param left 可视空间左边界
         * @param right 可视空间右边界
         * @param top 可视空间上边界
         * @param bottom 可视空间下边界
         * @param near 可视空间近边界
         * @param far 可视空间远边界
         *
         * 可视空间的八个顶点分别被投影到立方体 [(-1, -1, -1), (1, 1, 1)] 八个顶点上
         *
         * 将长方体 [(left, bottom, near), (right, top, far)] 投影至立方体 [(-1, -1, -1), (1, 1, 1)] 中
         */
        Matrix4x4.prototype.setOrtho = function (left, right, top, bottom, near, far) {
            var r = this.rawData;
            r[0] = 2 / (right - left);
            r[4] = 0; /**/
            r[8] = 0; /**/
            r[12] = -(right + left) / (right - left); // 
            r[1] = 0; /**/
            r[5] = 2 / (top - bottom);
            r[9] = 0; /**/
            r[13] = -(top + bottom) / (top - bottom); // 
            r[2] = 0; /**/
            r[6] = 0; /**/
            r[10] = 2 / (far - near);
            r[14] = -(far + near) / (far - near); //
            r[3] = 0; /**/
            r[7] = 0; /**/
            r[11] = 0; /**/
            r[15] = 1; //
            return this;
        };
        /**
         * 初始化透视投影矩阵
         * @param fov 垂直视角，视锥体顶面和底面间的夹角，必须大于0 （角度）
         * @param aspect 近裁剪面的宽高比
         * @param near 视锥体近边界
         * @param far 视锥体远边界
         *
         * 视锥体的八个顶点分别被投影到立方体 [(-1, -1, -1), (1, 1, 1)] 八个顶点上
         */
        Matrix4x4.prototype.setPerspectiveFromFOV = function (fov, aspect, near, far) {
            var r = this.rawData;
            var tanfov2 = Math.tan(fov * Math.PI / 360);
            r[0] = 1 / (aspect * tanfov2);
            r[4] = 0; /**/
            r[8] = 0; /**/
            r[12] = 0; // 
            r[1] = 0; /**/
            r[5] = 1 / tanfov2;
            r[9] = 0; /**/
            r[13] = 0; // 
            r[2] = 0; /**/
            r[6] = 0; /**/
            r[10] = (far + near) / (far - near);
            r[14] = -2 * (far * near) / (far - near); //
            r[3] = 0; /**/
            r[7] = 0; /**/
            r[11] = 1; /**/
            r[15] = 0; //
            return this;
        };
        /**
         * 初始化透视投影矩阵
         * @param left 可视空间左边界
         * @param right 可视空间右边界
         * @param top 可视空间上边界
         * @param bottom 可视空间下边界
         * @param near 可视空间近边界
         * @param far 可视空间远边界
         *
         * 可视空间的八个顶点分别被投影到立方体 [(-1, -1, -1), (1, 1, 1)] 八个顶点上
         *
         * 将长方体 [(left, bottom, near), (right, top, far)] 投影至立方体 [(-1, -1, -1), (1, 1, 1)] 中
         */
        Matrix4x4.prototype.setPerspective = function (left, right, top, bottom, near, far) {
            var r = this.rawData;
            r[0] = 2 * near / (right - left);
            r[4] = 0; /**/
            r[8] = 0; /**/
            r[12] = 0; // 
            r[1] = 0; /**/
            r[5] = 2 * near / (top - bottom);
            r[9] = 0; /**/
            r[13] = 0; // 
            r[2] = 0; /**/
            r[6] = 0; /**/
            r[10] = (far + near) / (far - near);
            r[14] = -2 * (far * near) / (far - near); //
            r[3] = 0; /**/
            r[7] = 0; /**/
            r[11] = 1; /**/
            r[15] = 0; //
            return this;
        };
        /**
         * 以字符串返回矩阵的值
         */
        Matrix4x4.prototype.toString = function () {
            return "Matrix4x4 [" + this.rawData.toString() + "]";
        };
        /**
         * 用于运算临时变量
         */
        Matrix4x4.RAW_DATA_CONTAINER = [
            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1 //
        ];
        __decorate([
            feng3d.serialize
        ], Matrix4x4.prototype, "rawData", void 0);
        return Matrix4x4;
    }());
    feng3d.Matrix4x4 = Matrix4x4;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 可用于表示旋转的四元数对象
     */
    var Quaternion = /** @class */ (function () {
        /**
         * 四元数描述三维空间中的旋转。四元数的数学定义为Q = x*i + y*j + z*k + w，其中(i,j,k)为虚基向量。(x,y,z)可以看作是一个与旋转轴相关的向量，而实际的乘法器w与旋转量相关。
         *
         * @param x 虚基向量i的乘子
         * @param y 虚基向量j的乘子
         * @param z 虚基向量k的乘子
         * @param w 实部的乘数
         */
        function Quaternion(x, y, z, w) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            if (z === void 0) { z = 0; }
            if (w === void 0) { w = 1; }
            /**
             * 虚基向量i的乘子
             */
            this.x = 0;
            /**
             * 虚基向量j的乘子
             */
            this.y = 0;
            /**
             * 虚基向量k的乘子
             */
            this.z = 0;
            /**
             * 实部的乘数
             */
            this.w = 1;
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }
        Quaternion.fromArray = function (array, offset) {
            if (offset === void 0) { offset = 0; }
            return new Quaternion().fromArray(array, offset);
        };
        /**
         * 随机四元数
         */
        Quaternion.random = function () {
            return new Quaternion().fromEulerAngles(Math.PI * 2 * Math.random(), Math.PI * 2 * Math.random(), Math.PI * 2 * Math.random());
        };
        Object.defineProperty(Quaternion.prototype, "magnitude", {
            /**
             * 返回四元数对象的大小
             */
            get: function () {
                return Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 设置四元数的值。
         *
         * @param x 虚基向量i的乘子
         * @param y 虚基向量j的乘子
         * @param z 虚基向量k的乘子
         * @param w 实部的乘数
         */
        Quaternion.prototype.set = function (x, y, z, w) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            if (z === void 0) { z = 0; }
            if (w === void 0) { w = 1; }
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
            return this;
        };
        Quaternion.prototype.fromArray = function (array, offset) {
            if (offset === void 0) { offset = 0; }
            this.x = array[offset];
            this.y = array[offset + 1];
            this.z = array[offset + 2];
            this.w = array[offset + 3];
            return this;
        };
        /**
         * 转换为数组
         *
         * @param array
         * @param offset
         */
        Quaternion.prototype.toArray = function (array, offset) {
            if (offset === void 0) { offset = 0; }
            array = array || [];
            array[offset] = this.x;
            array[offset + 1] = this.y;
            array[offset + 2] = this.z;
            array[offset + 3] = this.w;
            return array;
        };
        /**
         * 四元数乘法
         *
         * @param q
         * @param this
         */
        Quaternion.prototype.mult = function (q) {
            var ax = this.x, ay = this.y, az = this.z, aw = this.w, bx = q.x, by = q.y, bz = q.z, bw = q.w;
            this.x = ax * bw + aw * bx + ay * bz - az * by;
            this.y = ay * bw + aw * by + az * bx - ax * bz;
            this.z = az * bw + aw * bz + ax * by - ay * bx;
            this.w = aw * bw - ax * bx - ay * by - az * bz;
            return this;
        };
        /**
         * 四元数乘法
         *
         * @param q
         * @param target
         */
        Quaternion.prototype.multTo = function (q, target) {
            if (target === void 0) { target = new Quaternion(); }
            return target.copy(this).mult(q);
        };
        /**
         * 获取逆四元数（共轭四元数）
         */
        Quaternion.prototype.inverse = function () {
            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;
            return this;
        };
        /**
         * 获取逆四元数（共轭四元数）
         *
         * @param target
         */
        Quaternion.prototype.inverseTo = function (target) {
            if (target === void 0) { target = new Quaternion(); }
            return target.copy(this).inverse();
        };
        Quaternion.prototype.multiplyVector = function (vector, target) {
            if (target === void 0) { target = new Quaternion(); }
            var x2 = vector.x;
            var y2 = vector.y;
            var z2 = vector.z;
            target.w = -this.x * x2 - this.y * y2 - this.z * z2;
            target.x = this.w * x2 + this.y * z2 - this.z * y2;
            target.y = this.w * y2 - this.x * z2 + this.z * x2;
            target.z = this.w * z2 + this.x * y2 - this.y * x2;
            return target;
        };
        /**
         * 用表示给定绕向量旋转的值填充四元数对象。
         *
         * @param axis 要绕其旋转的轴
         * @param angle 以弧度为单位的旋转角度。
         */
        Quaternion.prototype.fromAxisAngle = function (axis, angle) {
            var sin_a = Math.sin(angle / 2);
            var cos_a = Math.cos(angle / 2);
            this.x = axis.x * sin_a;
            this.y = axis.y * sin_a;
            this.z = axis.z * sin_a;
            this.w = cos_a;
            this.normalize();
            return this;
        };
        /**
         * 将四元数转换为轴/角表示形式
         *
         * @param targetAxis 要重用的向量对象，用于存储轴
         * @return 一个数组，第一个元素是轴，第二个元素是弧度
         */
        Quaternion.prototype.toAxisAngle = function (targetAxis) {
            if (targetAxis === void 0) { targetAxis = new feng3d.Vector3(); }
            this.normalize(); // 如果w>1 acos和sqrt会产生错误，那么如果四元数被标准化，就不会发生这种情况
            var angle = 2 * Math.acos(this.w);
            var s = Math.sqrt(1 - this.w * this.w); // 假设四元数归一化了，那么w小于1，所以项总是正的。
            if (s < 0.001) { // 为了避免除以零，s总是正的，因为是根号
                // 如果s接近于零，那么轴的方向就不重要了
                targetAxis.x = this.x; // 如果轴归一化很重要，则用x=1替换;y = z = 0;
                targetAxis.y = this.y;
                targetAxis.z = this.z;
            }
            else {
                targetAxis.x = this.x / s; // 法线轴
                targetAxis.y = this.y / s;
                targetAxis.z = this.z / s;
            }
            return [targetAxis, angle];
        };
        /**
         * 给定两个向量，设置四元数值。得到的旋转将是将u旋转到v所需要的旋转。
         *
         * @param u
         * @param v
         */
        Quaternion.prototype.setFromVectors = function (u, v) {
            if (u.isAntiparallelTo(v)) {
                var t1 = new feng3d.Vector3();
                var t2 = new feng3d.Vector3();
                u.tangents(t1, t2);
                this.fromAxisAngle(t1, Math.PI);
            }
            else {
                var a = u.crossTo(v);
                this.x = a.x;
                this.y = a.y;
                this.z = a.z;
                this.w = Math.sqrt(Math.pow(u.length, 2) * Math.pow(v.length, 2)) + u.dot(v);
                this.normalize();
            }
            return this;
        };
        /**
         * 与目标四元数之间进行球面内插，提供了具有恒定角度变化率的旋转之间的内插。
         * @param qb 目标四元素
         * @param t 插值权值，一个介于0和1之间的值。
         */
        Quaternion.prototype.slerp = function (qb, t) {
            if (t === 0)
                return this;
            if (t === 1)
                return this.copy(qb);
            var x = this.x, y = this.y, z = this.z, w = this.w;
            // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
            var cosHalfTheta = w * qb.w + x * qb.x + y * qb.y + z * qb.z;
            if (cosHalfTheta < 0) {
                this.w = -qb.w;
                this.x = -qb.x;
                this.y = -qb.y;
                this.z = -qb.z;
                cosHalfTheta = -cosHalfTheta;
            }
            else {
                this.copy(qb);
            }
            if (cosHalfTheta >= 1.0) {
                this.w = w;
                this.x = x;
                this.y = y;
                this.z = z;
                return this;
            }
            var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;
            if (sqrSinHalfTheta <= Number.EPSILON) {
                var s = 1 - t;
                this.w = s * w + t * this.w;
                this.x = s * x + t * this.x;
                this.y = s * y + t * this.y;
                this.z = s * z + t * this.z;
                this.normalize();
                return this;
            }
            var sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
            var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
            var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
            this.w = (w * ratioA + this.w * ratioB);
            this.x = (x * ratioA + this.x * ratioB);
            this.y = (y * ratioA + this.y * ratioB);
            this.z = (z * ratioA + this.z * ratioB);
            return this;
        };
        /**
         * 与目标四元数之间进行球面内插，提供了具有恒定角度变化率的旋转之间的内插。
         * @param qb 目标四元素
         * @param t 插值权值，一个介于0和1之间的值。
         * @param out 保存插值结果
         */
        Quaternion.prototype.slerpTo = function (qb, t, out) {
            if (out === void 0) { out = new Quaternion(); }
            return out.copy(this).slerp(qb, t);
        };
        /**
         * 线性求插值
         * @param qa 第一个四元素
         * @param qb 第二个四元素
         * @param t 权重
         */
        Quaternion.prototype.lerp = function (qa, qb, t) {
            var w1 = qa.w, x1 = qa.x, y1 = qa.y, z1 = qa.z;
            var w2 = qb.w, x2 = qb.x, y2 = qb.y, z2 = qb.z;
            var len;
            // shortest direction
            if (w1 * w2 + x1 * x2 + y1 * y2 + z1 * z2 < 0) {
                w2 = -w2;
                x2 = -x2;
                y2 = -y2;
                z2 = -z2;
            }
            this.w = w1 + t * (w2 - w1);
            this.x = x1 + t * (x2 - x1);
            this.y = y1 + t * (y2 - y1);
            this.z = z1 + t * (z2 - z1);
            len = 1.0 / Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
            this.w *= len;
            this.x *= len;
            this.y *= len;
            this.z *= len;
        };
        /**
         * Fills the quaternion object with values representing the given euler rotation.
         *
         * @param    ax        The angle in radians of the rotation around the ax axis.
         * @param    ay        The angle in radians of the rotation around the ay axis.
         * @param    az        The angle in radians of the rotation around the az axis.
         */
        Quaternion.prototype.fromEulerAngles = function (ax, ay, az) {
            var halfX = ax * .5, halfY = ay * .5, halfZ = az * .5;
            var cosX = Math.cos(halfX), sinX = Math.sin(halfX);
            var cosY = Math.cos(halfY), sinY = Math.sin(halfY);
            var cosZ = Math.cos(halfZ), sinZ = Math.sin(halfZ);
            this.w = cosX * cosY * cosZ + sinX * sinY * sinZ;
            this.x = sinX * cosY * cosZ - cosX * sinY * sinZ;
            this.y = cosX * sinY * cosZ + sinX * cosY * sinZ;
            this.z = cosX * cosY * sinZ - sinX * sinY * cosZ;
            return this;
        };
        /**
         * Fills a target Vector3 object with the Euler angles that form the rotation represented by this quaternion.
         * @param target An optional Vector3 object to contain the Euler angles. If not provided, a new object is created.
         * @return The Vector3 containing the Euler angles.
         */
        Quaternion.prototype.toEulerAngles = function (target) {
            target = target || new feng3d.Vector3();
            target.x = Math.atan2(2 * (this.w * this.x + this.y * this.z), 1 - 2 * (this.x * this.x + this.y * this.y));
            var asinvalue = 2 * (this.w * this.y - this.z * this.x);
            //防止超出范围，获取NaN值
            asinvalue = Math.max(-1, Math.min(asinvalue, 1));
            target.y = Math.asin(asinvalue);
            target.z = Math.atan2(2 * (this.w * this.z + this.x * this.y), 1 - 2 * (this.y * this.y + this.z * this.z));
            return target;
        };
        /**
         * 四元数归一化
         */
        Quaternion.prototype.normalize = function (val) {
            if (val === void 0) { val = 1; }
            var l = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
            if (l === 0) {
                this.x = 0;
                this.y = 0;
                this.z = 0;
                this.w = 1;
            }
            else {
                l = Math.sqrt(l);
                l = 1 / l;
                this.x *= l;
                this.y *= l;
                this.z *= l;
                this.w *= l;
            }
            return this;
        };
        /**
         * 四元数归一化的近似。当quat已经几乎标准化时，效果最好。
         *
         * @see http://jsperf.com/fast-quaternion-normalization
         * @author unphased, https://github.com/unphased
         */
        Quaternion.prototype.normalizeFast = function () {
            var f = (3.0 - (this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)) / 2.0;
            if (f === 0) {
                this.x = 0;
                this.y = 0;
                this.z = 0;
                this.w = 0;
            }
            else {
                this.x *= f;
                this.y *= f;
                this.z *= f;
                this.w *= f;
            }
            return this;
        };
        /**
         * 转换为可读格式
         */
        Quaternion.prototype.toString = function () {
            return "{this.x:" + this.x + " this.y:" + this.y + " this.z:" + this.z + " this.w:" + this.w + "}";
        };
        /**
         * 转换为矩阵
         *
         * @param target
         */
        Quaternion.prototype.toMatrix3D = function (target) {
            if (target === void 0) { target = new feng3d.Matrix4x4(); }
            var rawData = target.rawData;
            var xy2 = 2.0 * this.x * this.y, xz2 = 2.0 * this.x * this.z, xw2 = 2.0 * this.x * this.w;
            var yz2 = 2.0 * this.y * this.z, yw2 = 2.0 * this.y * this.w, zw2 = 2.0 * this.z * this.w;
            var xx = this.x * this.x, yy = this.y * this.y, zz = this.z * this.z, ww = this.w * this.w;
            rawData[0] = xx - yy - zz + ww;
            rawData[4] = xy2 - zw2;
            rawData[8] = xz2 + yw2;
            rawData[12] = 0;
            rawData[1] = xy2 + zw2;
            rawData[5] = -xx + yy - zz + ww;
            rawData[9] = yz2 - xw2;
            rawData[13] = 0;
            rawData[2] = xz2 - yw2;
            rawData[6] = yz2 + xw2;
            rawData[10] = -xx - yy + zz + ww;
            rawData[14] = 0;
            rawData[3] = 0.0;
            rawData[7] = 0.0;
            rawData[11] = 0;
            rawData[15] = 1;
            target.copyRawDataFrom(rawData);
            return target;
        };
        /**
         * 从矩阵初始化四元素
         *
         * @param matrix 矩阵
         */
        Quaternion.prototype.fromMatrix = function (matrix) {
            var v = matrix.decompose()[1];
            this.fromEulerAngles(v.x, v.y, v.z);
            return this;
        };
        /**
         * 克隆
         */
        Quaternion.prototype.clone = function () {
            return new Quaternion(this.x, this.y, this.z, this.w);
        };
        /**
         * 旋转一个顶点
         *
         * @param point 被旋转的顶点
         * @param target 旋转结果
         */
        Quaternion.prototype.rotatePoint = function (point, target) {
            if (target === void 0) { target = new feng3d.Vector3(); }
            var x2 = point.x, y2 = point.y, z2 = point.z;
            // p*q'
            var w1 = -this.x * x2 - this.y * y2 - this.z * z2;
            var x1 = this.w * x2 + this.y * z2 - this.z * y2;
            var y1 = this.w * y2 - this.x * z2 + this.z * x2;
            var z1 = this.w * z2 + this.x * y2 - this.y * x2;
            target.x = -w1 * this.x + x1 * this.w - y1 * this.z + z1 * this.y;
            target.y = -w1 * this.y + x1 * this.z + y1 * this.w - z1 * this.x;
            target.z = -w1 * this.z - x1 * this.y + y1 * this.x + z1 * this.w;
            return target;
        };
        /**
         * 旋转一个绝对方向四元数给定一个角速度和一个时间步长
         *
         * @param angularVelocity
         * @param dt
         * @param angularFactor
         */
        Quaternion.prototype.integrate = function (angularVelocity, dt, angularFactor) {
            var ax = angularVelocity.x * angularFactor.x, ay = angularVelocity.y * angularFactor.y, az = angularVelocity.z * angularFactor.z, bx = this.x, by = this.y, bz = this.z, bw = this.w;
            var half_dt = dt * 0.5;
            this.x += half_dt * (ax * bw + ay * bz - az * by);
            this.y += half_dt * (ay * bw + az * bx - ax * bz);
            this.z += half_dt * (az * bw + ax * by - ay * bx);
            this.w += half_dt * (-ax * bx - ay * by - az * bz);
            return this;
        };
        /**
         * 旋转一个绝对方向四元数给定一个角速度和一个时间步长
         *
         * @param angularVelocity
         * @param dt
         * @param angularFactor
         * @param  target
         */
        Quaternion.prototype.integrateTo = function (angularVelocity, dt, angularFactor, target) {
            if (target === void 0) { target = new Quaternion(); }
            return target.copy(this).integrate(angularVelocity, dt, angularFactor);
        };
        /**
         * 将源的值复制到此四元数
         *
         * @param q 要复制的四元数
         */
        Quaternion.prototype.copy = function (q) {
            this.x = q.x;
            this.y = q.y;
            this.z = q.z;
            this.w = q.w;
            return this;
        };
        __decorate([
            feng3d.serialize
        ], Quaternion.prototype, "x", void 0);
        __decorate([
            feng3d.serialize
        ], Quaternion.prototype, "y", void 0);
        __decorate([
            feng3d.serialize
        ], Quaternion.prototype, "z", void 0);
        __decorate([
            feng3d.serialize
        ], Quaternion.prototype, "w", void 0);
        return Quaternion;
    }());
    feng3d.Quaternion = Quaternion;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3d直线

     */
    var Line3D = /** @class */ (function () {
        /**
         * 根据直线某点与方向创建直线
         * @param position 直线上某点
         * @param direction 直线的方向
         */
        function Line3D(position, direction) {
            this.position = position ? position : new feng3d.Vector3();
            this.direction = (direction ? direction : new feng3d.Vector3(0, 0, 1)).normalize();
        }
        /**
         * 根据直线上两点初始化直线
         * @param p0 Vector3
         * @param p1 Vector3
         */
        Line3D.fromPoints = function (p0, p1) {
            return new Line3D().fromPoints(p0, p1);
        };
        /**
         * 根据直线某点与方向初始化直线
         * @param position 直线上某点
         * @param direction 直线的方向
         */
        Line3D.fromPosAndDir = function (position, direction) {
            return new Line3D().fromPosAndDir(position, direction);
        };
        /**
         * 随机直线，比如用于单元测试
         */
        Line3D.random = function () {
            return new Line3D(feng3d.Vector3.random(), feng3d.Vector3.random());
        };
        /**
         * 根据直线上两点初始化直线
         * @param p0 Vector3
         * @param p1 Vector3
         */
        Line3D.prototype.fromPoints = function (p0, p1) {
            this.position = p0;
            this.direction = p1.subTo(p0).normalize();
            return this;
        };
        /**
         * 根据直线某点与方向初始化直线
         * @param position 直线上某点
         * @param direction 直线的方向
         */
        Line3D.prototype.fromPosAndDir = function (position, direction) {
            this.position = position;
            this.direction = direction.normalize();
            return this;
        };
        /**
         * 获取经过该直线的平面
         */
        Line3D.prototype.getPlane = function (plane) {
            if (plane === void 0) { plane = new feng3d.Plane3D(); }
            return plane.fromNormalAndPoint(feng3d.Vector3.random().cross(this.direction), this.position);
        };
        /**
         * 获取直线上的一个点
         * @param length 与原点距离
         */
        Line3D.prototype.getPoint = function (length, vout) {
            if (length === void 0) { length = 0; }
            if (vout === void 0) { vout = new feng3d.Vector3(); }
            return vout.copy(this.direction).scaleNumber(length).add(this.position);
        };
        /**
         * 获取指定z值的点
         * @param z z值
         * @param vout 目标点（输出）
         * @returns 目标点
         */
        Line3D.prototype.getPointWithZ = function (z, vout) {
            if (vout === void 0) { vout = new feng3d.Vector3(); }
            return this.getPoint((z - this.position.z) / this.direction.z, vout);
        };
        /**
         * 指定点到该直线距离
         * @param point 指定点
         */
        Line3D.prototype.distanceWithPoint = function (point) {
            return this.closestPointWithPoint(point).sub(point).length;
        };
        /**
         * 与指定点最近点的系数
         * @param point 点
         */
        Line3D.prototype.closestPointParameterWithPoint = function (point) {
            return point.subTo(this.position).dot(this.direction);
        };
        /**
         * 与指定点最近的点
         * @param point 点
         * @param vout 输出点
         */
        Line3D.prototype.closestPointWithPoint = function (point, vout) {
            if (vout === void 0) { vout = new feng3d.Vector3(); }
            var t = this.closestPointParameterWithPoint(point);
            return this.getPoint(t, vout);
        };
        /**
         * 判定点是否在直线上
         * @param point 点
         * @param precision 精度
         */
        Line3D.prototype.onWithPoint = function (point, precision) {
            if (precision === void 0) { precision = Math.PRECISION; }
            if (Math.equals(this.distanceWithPoint(point), 0, precision))
                return true;
            return false;
        };
        /**
         * 与直线相交
         * @param line3D 直线
         */
        Line3D.prototype.intersectWithLine3D = function (line3D) {
            // 处理相等
            if (this.equals(line3D))
                return this.clone();
            // 处理平行
            if (this.direction.isParallel(line3D.direction))
                return null;
            var plane = this.getPlane();
            var point = plane.intersectWithLine3D(line3D);
            if (this.onWithPoint(point))
                return point;
            return null;
        };
        /**
         * 应用矩阵
         * @param mat 矩阵
         */
        Line3D.prototype.applyMatri4x4 = function (mat) {
            mat.transformVector(this.position, this.position);
            mat.deltaTransformVector(this.direction, this.direction);
            return this;
        };
        /**
         * 与指定向量比较是否相等
         * @param v 比较的向量
         * @param precision 允许误差
         * @return 相等返回true，否则false
         */
        Line3D.prototype.equals = function (line, precision) {
            if (precision === void 0) { precision = Math.PRECISION; }
            if (!this.onWithPoint(line.position))
                return false;
            if (!this.onWithPoint(line.position.addTo(line.direction)))
                return false;
            return true;
        };
        /**
         * 拷贝
         * @param line 直线
         */
        Line3D.prototype.copy = function (line) {
            this.position.copy(line.position);
            this.direction.copy(line.direction);
            return this;
        };
        /**
         * 克隆
         */
        Line3D.prototype.clone = function () {
            return new Line3D().copy(this);
        };
        return Line3D;
    }());
    feng3d.Line3D = Line3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3D线段
     */
    var Segment3D = /** @class */ (function () {
        function Segment3D(p0, p1) {
            if (p0 === void 0) { p0 = new feng3d.Vector3(); }
            if (p1 === void 0) { p1 = new feng3d.Vector3(); }
            this.p0 = p0;
            this.p1 = p1;
        }
        /**
         * 初始化线段
         * @param p0
         * @param p1
         */
        Segment3D.fromPoints = function (p0, p1) {
            return new Segment3D(p0, p1);
        };
        /**
         * 随机线段
         */
        Segment3D.random = function () {
            return new Segment3D(feng3d.Vector3.random(), feng3d.Vector3.random());
        };
        /**
         * 获取线段所在直线
         */
        Segment3D.prototype.getLine = function (line) {
            if (line === void 0) { line = new feng3d.Line3D(); }
            return line.fromPoints(this.p0.clone(), this.p1.clone());
        };
        /**
         * 获取指定位置上的点，当position=0时返回p0，当position=1时返回p1
         * @param position 线段上的位置
         */
        Segment3D.prototype.getPoint = function (position, pout) {
            if (pout === void 0) { pout = new feng3d.Vector3(); }
            var newPoint = pout.copy(this.p0).add(this.p1.subTo(this.p0).scaleNumber(position));
            return newPoint;
        };
        /**
         * 判定点是否在线段上
         * @param point
         */
        Segment3D.prototype.onWithPoint = function (point, precision) {
            if (precision === void 0) { precision = Math.PRECISION; }
            return Math.equals(this.getPointDistance(point), 0, precision);
        };
        /**
         * 判定点是否投影在线段上
         * @param point
         */
        Segment3D.prototype.projectOnWithPoint = function (point) {
            var position = this.getPositionByPoint(point);
            position = Number(position.toFixed(6));
            return 0 <= position && position <= 1;
        };
        /**
         * 获取点在线段上的位置，当点投影在线段上p0位置时返回0，当点投影在线段p1上时返回1
         * @param point 点
         */
        Segment3D.prototype.getPositionByPoint = function (point) {
            var vec = this.p1.subTo(this.p0);
            var position = point.subTo(this.p0).dot(vec) / vec.lengthSquared;
            return position;
        };
        /**
         * 获取直线到点的法线（线段到点垂直方向）
         * @param point 点
         */
        Segment3D.prototype.getNormalWithPoint = function (point) {
            var direction = this.p1.subTo(this.p0);
            var l1 = point.subTo(this.p0);
            var n = direction.crossTo(l1).crossTo(direction).normalize();
            return n;
        };
        /**
         * 指定点到该线段距离，如果投影点不在线段上时，该距离为指定点到最近的线段端点的距离
         * @param point 指定点
         */
        Segment3D.prototype.getPointDistanceSquare = function (point) {
            var position = this.getPositionByPoint(point);
            if (position <= 0) {
                lengthSquared = point.subTo(this.p0).lengthSquared;
            }
            else if (position >= 1) {
                lengthSquared = point.subTo(this.p1).lengthSquared;
            }
            else {
                var s0 = point.subTo(this.p0).lengthSquared;
                var s1 = position * position * this.p1.subTo(this.p0).lengthSquared;
                var lengthSquared = Math.abs(s0 - s1);
            }
            return lengthSquared;
        };
        /**
         * 指定点到该线段距离，如果投影点不在线段上时，该距离为指定点到最近的线段端点的距离
         * @param point 指定点
         */
        Segment3D.prototype.getPointDistance = function (point) {
            var v = this.getPointDistanceSquare(point);
            v = Math.sqrt(v);
            return v;
        };
        /**
         * 与直线相交
         * @param line 直线
         */
        Segment3D.prototype.intersectionWithLine = function (line) {
            var l = this.getLine();
            var r = l.intersectWithLine3D(line);
            if (!r)
                return null;
            if (r instanceof feng3d.Line3D)
                return this.clone();
            if (this.onWithPoint(r))
                return r;
            return null;
        };
        /**
         * 与线段相交
         * @param segment 直线
         */
        Segment3D.prototype.intersectionWithSegment = function (segment) {
            var r = this.intersectionWithLine(segment.getLine());
            if (!r)
                return null;
            if (r instanceof Segment3D) {
                var ps = [this.p0, this.p1].map(function (p) {
                    return segment.clampPoint(p);
                });
                if (this.onWithPoint(ps[0]))
                    return Segment3D.fromPoints(ps[0], ps[1]);
                return null;
            }
            if (this.onWithPoint(r))
                return r;
            return null;
        };
        /**
         * 与指定点最近的点
         * @param point 点
         * @param vout 输出点
         */
        Segment3D.prototype.closestPointWithPoint = function (point, vout) {
            if (vout === void 0) { vout = new feng3d.Vector3(); }
            this.getLine().closestPointWithPoint(point, vout);
            if (this.onWithPoint(vout))
                return vout;
            if (point.distanceSquared(this.p0) < point.distanceSquared(this.p1))
                return vout.copy(this.p0);
            return vout.copy(this.p1);
        };
        /**
         * 把点压缩到线段内
         */
        Segment3D.prototype.clampPoint = function (point, pout) {
            if (pout === void 0) { pout = new feng3d.Vector3(); }
            return this.getPoint(Math.clamp(this.getPositionByPoint(point), 0, 1), pout);
        };
        /**
         * 判定线段是否相等
         */
        Segment3D.prototype.equals = function (segment) {
            return (this.p0.equals(segment.p0) && this.p1.equals(segment.p1)) || (this.p0.equals(segment.p1) && this.p1.equals(segment.p0));
        };
        /**
         * 复制
         */
        Segment3D.prototype.copy = function (segment) {
            this.p0.copy(segment.p0);
            this.p1.copy(segment.p1);
            return this;
        };
        /**
         * 克隆
         */
        Segment3D.prototype.clone = function () {
            return new Segment3D().copy(this);
        };
        return Segment3D;
    }());
    feng3d.Segment3D = Segment3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3D射线

     */
    var Ray3D = /** @class */ (function (_super) {
        __extends(Ray3D, _super);
        function Ray3D(position, direction) {
            return _super.call(this, position, direction) || this;
        }
        return Ray3D;
    }(feng3d.Line3D));
    feng3d.Ray3D = Ray3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 三角形
     */
    var Triangle3D = /** @class */ (function () {
        function Triangle3D(p0, p1, p2) {
            if (p0 === void 0) { p0 = new feng3d.Vector3(); }
            if (p1 === void 0) { p1 = new feng3d.Vector3(); }
            if (p2 === void 0) { p2 = new feng3d.Vector3(); }
            this.p0 = p0;
            this.p1 = p1;
            this.p2 = p2;
        }
        /**
         * 通过3顶点定义一个三角形
         * @param p0		点0
         * @param p1		点1
         * @param p2		点2
         */
        Triangle3D.fromPoints = function (p0, p1, p2) {
            return new Triangle3D().fromPoints(p0, p1, p2);
        };
        /**
         * 从顶点数据初始化三角形
         * @param positions 顶点数据
         */
        Triangle3D.fromPositions = function (positions) {
            return new Triangle3D().fromPositions(positions);
        };
        /**
         * 随机三角形
         * @param size 尺寸
         */
        Triangle3D.random = function (size) {
            if (size === void 0) { size = 1; }
            return new Triangle3D(feng3d.Vector3.random(size), feng3d.Vector3.random(size), feng3d.Vector3.random(size));
        };
        /**
         * 三角形三个点
         */
        Triangle3D.prototype.getPoints = function () {
            return [this.p0, this.p1, this.p2];
        };
        /**
         * 三边
         */
        Triangle3D.prototype.getSegments = function () {
            return [feng3d.Segment3D.fromPoints(this.p0, this.p1), feng3d.Segment3D.fromPoints(this.p1, this.p2), feng3d.Segment3D.fromPoints(this.p2, this.p0)];
        };
        /**
         * 三角形所在平面
         */
        Triangle3D.prototype.getPlane3d = function (pout) {
            if (pout === void 0) { pout = new feng3d.Plane3D(); }
            return pout.fromPoints(this.p0, this.p1, this.p2);
        };
        /**
         * 获取法线
         */
        Triangle3D.prototype.getNormal = function (vout) {
            if (vout === void 0) { vout = new feng3d.Vector3(); }
            return vout.copy(this.p1).sub(this.p0).cross(this.p2.subTo(this.p1)).normalize();
        };
        /**
         * 重心,三条中线相交的点叫做重心。
         */
        Triangle3D.prototype.getBarycenter = function (pout) {
            if (pout === void 0) { pout = new feng3d.Vector3(); }
            return pout.copy(this.p0).add(this.p1).add(this.p2).scaleNumber(1 / 3);
        };
        /**
         * 外心，外切圆心,三角形三边的垂直平分线的交点，称为三角形外心。
         * @see https://baike.baidu.com/item/%E4%B8%89%E8%A7%92%E5%BD%A2%E4%BA%94%E5%BF%83/218867
         */
        Triangle3D.prototype.getCircumcenter = function (pout) {
            if (pout === void 0) { pout = new feng3d.Vector3(); }
            var a = this.p2.subTo(this.p1);
            var b = this.p0.subTo(this.p2);
            var c = this.p1.subTo(this.p0);
            var d = 2 * c.crossTo(a).lengthSquared;
            var a0 = -a.dot(a) * c.dot(b) / d;
            var b0 = -b.dot(b) * c.dot(a) / d;
            var c0 = -c.dot(c) * b.dot(a) / d;
            return pout.copy(this.p0).scaleNumber(a0).add(this.p1.scaleNumberTo(b0)).add(this.p2.scaleNumberTo(c0));
        };
        /**
         * 外心，内切圆心,三角形内心为三角形三条内角平分线的交点。
         * @see https://baike.baidu.com/item/%E4%B8%89%E8%A7%92%E5%BD%A2%E4%BA%94%E5%BF%83/218867
         */
        Triangle3D.prototype.getInnercenter = function (pout) {
            if (pout === void 0) { pout = new feng3d.Vector3(); }
            var a = this.p2.subTo(this.p1).length;
            var b = this.p0.subTo(this.p2).length;
            var c = this.p1.subTo(this.p0).length;
            return pout.copy(this.p0).scaleNumber(a).add(this.p1.scaleNumberTo(b)).add(this.p2.scaleNumberTo(c)).scaleNumber(1 / (a + b + c));
        };
        /**
         * 垂心，三角形三边上的三条高或其延长线交于一点，称为三角形垂心。
         * @see https://baike.baidu.com/item/%E4%B8%89%E8%A7%92%E5%BD%A2%E4%BA%94%E5%BF%83/218867
         */
        Triangle3D.prototype.getOrthocenter = function (pout) {
            if (pout === void 0) { pout = new feng3d.Vector3(); }
            var a = this.p2.subTo(this.p1);
            var b = this.p0.subTo(this.p2);
            var c = this.p1.subTo(this.p0);
            var a0 = a.dot(b) * a.dot(c);
            var b0 = b.dot(c) * b.dot(a);
            var c0 = c.dot(a) * c.dot(b);
            return pout.copy(this.p0).scaleNumber(a0).add(this.p1.scaleNumberTo(b0)).add(this.p2.scaleNumberTo(c0)).scaleNumber(1 / (a0 + b0 + c0));
        };
        /**
         * 通过3顶点定义一个三角形
         * @param p0		点0
         * @param p1		点1
         * @param p2		点2
         */
        Triangle3D.prototype.fromPoints = function (p0, p1, p2) {
            this.p0 = p0;
            this.p1 = p1;
            this.p2 = p2;
            return this;
        };
        /**
         * 从顶点数据初始化三角形
         * @param positions 顶点数据
         */
        Triangle3D.prototype.fromPositions = function (positions) {
            this.p0.init(positions[0], positions[1], positions[2]);
            this.p1.init(positions[3], positions[4], positions[5]);
            this.p2.init(positions[6], positions[7], positions[8]);
            return this;
        };
        /**
         * 获取三角形内的点
         * @param p 三点的权重
         * @param pout 输出点
         */
        Triangle3D.prototype.getPoint = function (p, pout) {
            if (pout === void 0) { pout = new feng3d.Vector3(); }
            return pout.copy(this.p0).scaleNumber(p.x).add(this.p1.scaleNumberTo(p.y)).add(this.p2.scaleNumberTo(p.z));
        };
        /**
         * 获取三角形内随机点
         * @param pout 输出点
         */
        Triangle3D.prototype.randomPoint = function (pout) {
            if (pout === void 0) { pout = new feng3d.Vector3(); }
            var a = Math.random();
            var b = Math.random() * (1 - a);
            var c = 1 - a - b;
            return this.getPoint(new feng3d.Vector3(a, b, c), pout);
        };
        /**
         * 获取与直线相交，当直线与三角形不相交时返回null
         */
        Triangle3D.prototype.intersectionWithLine = function (line) {
            var plane3d = this.getPlane3d();
            var normal = plane3d.getNormal();
            var cross = plane3d.intersectWithLine3D(line);
            if (!cross)
                return null;
            if (cross instanceof feng3d.Vector3) {
                if (this.onWithPoint(cross))
                    return cross;
                return null;
            }
            // 直线分别于三边相交
            var crossSegment = null;
            var ps = this.getSegments().reduce(function (v, segment) {
                var r = segment.intersectionWithLine(line);
                if (!r)
                    return v;
                if (r instanceof feng3d.Segment3D) {
                    crossSegment = r;
                    return v;
                }
                v.push(r);
                return v;
            }, []);
            if (crossSegment)
                return crossSegment;
            if (ps.length == 0)
                return null;
            if (ps.length == 1)
                return ps[0];
            if (ps[0].equals(ps[1])) {
                return ps[0];
            }
            return feng3d.Segment3D.fromPoints(ps[0], ps[1]);
        };
        /**
         * 获取与线段相交
         */
        Triangle3D.prototype.intersectionWithSegment = function (segment) {
            var r = this.intersectionWithLine(segment.getLine());
            if (!r)
                return null;
            if (r instanceof feng3d.Vector3) {
                if (segment.onWithPoint(r))
                    return r;
                return null;
            }
            var p0 = segment.clampPoint(r.p0);
            var p1 = segment.clampPoint(r.p1);
            if (!r.onWithPoint(p0))
                return null;
            if (p0.equals(p1))
                return p0;
            return feng3d.Segment3D.fromPoints(p0, p1);
        };
        /**
         * 判定点是否在三角形上
         * @param p 点
         * @param precision 精度，如果距离小于精度则判定为在三角形上
         */
        Triangle3D.prototype.onWithPoint = function (p, precision) {
            if (precision === void 0) { precision = Math.PRECISION; }
            var plane3d = this.getPlane3d();
            if (plane3d.classifyPoint(p, precision) != feng3d.PlaneClassification.INTERSECT)
                return false;
            if (feng3d.Segment3D.fromPoints(this.p0, this.p1).onWithPoint(p, precision))
                return true;
            if (feng3d.Segment3D.fromPoints(this.p1, this.p2).onWithPoint(p, precision))
                return true;
            if (feng3d.Segment3D.fromPoints(this.p2, this.p0).onWithPoint(p, precision))
                return true;
            var n = this.getNormal();
            if (new Triangle3D(this.p0, this.p1, p).getNormal().dot(n) < 0)
                return false;
            if (new Triangle3D(this.p1, this.p2, p).getNormal().dot(n) < 0)
                return false;
            if (new Triangle3D(this.p2, this.p0, p).getNormal().dot(n) < 0)
                return false;
            return true;
        };
        /**
         * 获取指定点分别占三个点的混合值
         */
        Triangle3D.prototype.blendWithPoint = function (p) {
            var n = this.p1.subTo(this.p0).crossTo(this.p2.subTo(this.p1));
            var area = n.length;
            n.normalize();
            //
            var n0 = this.p1.subTo(p).crossTo(this.p2.subTo(this.p1));
            var area0 = n0.length;
            n0.normalize();
            var b0 = area0 / area * n.dot(n0);
            //
            var n1 = this.p2.subTo(p).crossTo(this.p0.subTo(this.p2));
            var area1 = n1.length;
            n1.normalize();
            var b1 = area1 / area * n.dot(n1);
            //
            var n2 = this.p0.subTo(p).crossTo(this.p1.subTo(this.p0));
            var area2 = n2.length;
            n2.normalize();
            var b2 = area2 / area * n.dot(n2);
            return new feng3d.Vector3(b0, b1, b2);
        };
        /**
         * 是否与盒子相交
         */
        Triangle3D.prototype.intersectsBox = function (box) {
            return box.intersectsTriangle(this);
        };
        /**
         * 与指定点最近的点
         * @param point 点
         * @param vout 输出点
         */
        Triangle3D.prototype.closestPointWithPoint = function (point, vout) {
            if (vout === void 0) { vout = new feng3d.Vector3(); }
            this.getPlane3d().closestPointWithPoint(point, vout);
            if (this.onWithPoint(vout))
                return vout;
            var p = this.getSegments().map(function (s) { var p = s.closestPointWithPoint(point); return { point: p, d: point.distanceSquared(p) }; }).sort(function (a, b) { return a.d - b.d; })[0].point;
            return vout.copy(p);
        };
        /**
         * 与点最近距离
         * @param point 点
         */
        Triangle3D.prototype.distanceWithPoint = function (point) {
            return this.closestPointWithPoint(point).distance(point);
        };
        /**
         * 与点最近距离平方
         * @param point 点
         */
        Triangle3D.prototype.distanceSquaredWithPoint = function (point) {
            return this.closestPointWithPoint(point).distanceSquared(point);
        };
        /**
         * 用点分解（切割）三角形
         */
        Triangle3D.prototype.decomposeWithPoint = function (p) {
            if (!this.onWithPoint(p))
                return [this];
            if (this.p0.equals(p) || this.p1.equals(p) || this.p2.equals(p))
                return [this];
            if (feng3d.Segment3D.fromPoints(this.p0, this.p1).onWithPoint(p))
                return [Triangle3D.fromPoints(this.p0, p, this.p2), Triangle3D.fromPoints(p, this.p1, this.p2)];
            if (feng3d.Segment3D.fromPoints(this.p1, this.p2).onWithPoint(p))
                return [Triangle3D.fromPoints(this.p1, p, this.p0), Triangle3D.fromPoints(p, this.p2, this.p0)];
            if (feng3d.Segment3D.fromPoints(this.p2, this.p0).onWithPoint(p))
                return [Triangle3D.fromPoints(this.p2, p, this.p1), Triangle3D.fromPoints(p, this.p0, this.p1)];
            return [Triangle3D.fromPoints(p, this.p0, this.p1), Triangle3D.fromPoints(p, this.p1, this.p2), Triangle3D.fromPoints(p, this.p2, this.p0)];
        };
        /**
         * 用点分解（切割）三角形
         */
        Triangle3D.prototype.decomposeWithPoints = function (ps) {
            // 遍历顶点分割三角形
            var ts = ps.reduce(function (v, p) {
                // 使用点分割所有三角形
                v = v.reduce(function (v0, t) {
                    return v0.concat(t.decomposeWithPoint(p));
                }, []);
                return v;
            }, [this]);
            return ts;
        };
        /**
         * 用线段分解（切割）三角形
         * @param segment 线段
         */
        Triangle3D.prototype.decomposeWithSegment = function (segment) {
            var r = this.intersectionWithSegment(segment);
            if (!r)
                return [this];
            if (r instanceof feng3d.Vector3) {
                return this.decomposeWithPoint(r);
            }
            var ts = this.decomposeWithPoints([r.p0, r.p1]);
            return ts;
        };
        /**
         * 用直线分解（切割）三角形
         * @param line 直线
         */
        Triangle3D.prototype.decomposeWithLine = function (line) {
            var r = this.intersectionWithLine(line);
            if (!r)
                return [this];
            if (r instanceof feng3d.Vector3) {
                return this.decomposeWithPoint(r);
            }
            var ts = this.decomposeWithPoints([r.p0, r.p1]);
            return ts;
        };
        /**
         * 面积
         */
        Triangle3D.prototype.area = function () {
            return this.p1.subTo(this.p0).crossTo(this.p2.subTo(this.p1)).length * 0.5;
        };
        /**
         * 栅格化，点阵化为XYZ轴间距为1的点阵
         */
        Triangle3D.prototype.rasterize = function () {
            var aabb = feng3d.AABB.fromPoints([this.p0, this.p1, this.p2]);
            aabb.min.round();
            aabb.max.round();
            var point = new feng3d.Vector3();
            var result = [];
            for (var x = aabb.min.x; x <= aabb.max.x; x++) {
                for (var y = aabb.min.y; y <= aabb.max.y; y++) {
                    for (var z = aabb.min.z; z <= aabb.max.z; z++) {
                        // 判定是否在三角形上
                        var onTri = this.onWithPoint(point.init(x, y, z), 0.5);
                        if (onTri) {
                            result.push(x, y, z);
                        }
                    }
                }
            }
            return result;
        };
        /**
         * 平移
         * @param v 向量
         */
        Triangle3D.prototype.translateVector3 = function (v) {
            this.p0.add(v);
            this.p1.add(v);
            this.p2.add(v);
            return this;
        };
        /**
         * 缩放
         * @param v 缩放量
         */
        Triangle3D.prototype.scaleVector3 = function (v) {
            this.p0.scale(v);
            this.p1.scale(v);
            this.p2.scale(v);
            return this;
        };
        /**
         * 自定义栅格化为点阵
         * @param voxelSize 体素尺寸，点阵XYZ轴间距
         * @param origin 原点，点阵中的某点正处于原点上，因此可以用作体素范围内的偏移
         */
        Triangle3D.prototype.rasterizeCustom = function (voxelSize, origin) {
            if (voxelSize === void 0) { voxelSize = new feng3d.Vector3(1, 1, 1); }
            if (origin === void 0) { origin = new feng3d.Vector3(); }
            var tri = this.clone().translateVector3(origin.negateTo()).scaleVector3(voxelSize.inverseTo());
            var ps = tri.rasterize();
            var vec = new feng3d.Vector3();
            var result = [];
            ps.forEach(function (v, i) {
                if (i % 3 == 0) {
                    vec.init(ps[i], ps[i + 1], ps[i + 2]).scale(voxelSize).add(origin);
                    result.push({ xi: ps[i], yi: ps[i + 1], zi: ps[i + 2], xv: vec.x, yv: vec.y, zv: vec.z });
                }
            });
            return result;
        };
        /**
         * 复制
         * @param triangle 三角形
         */
        Triangle3D.prototype.copy = function (triangle) {
            this.p0.copy(triangle.p0);
            this.p1.copy(triangle.p1);
            this.p2.copy(triangle.p2);
            return this;
        };
        /**
         * 克隆
         */
        Triangle3D.prototype.clone = function () {
            return new Triangle3D().copy(this);
        };
        return Triangle3D;
    }());
    feng3d.Triangle3D = Triangle3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 轴向对称包围盒
     */
    var AABB = /** @class */ (function () {
        /**
         * 创建包围盒
         * @param min 最小点
         * @param max 最大点
         */
        function AABB(min, max) {
            if (min === void 0) { min = new feng3d.Vector3(); }
            if (max === void 0) { max = new feng3d.Vector3(); }
            this.min = min.clone();
            this.max = max.clone();
        }
        /**
         * 从一组顶点初始化包围盒
         * @param positions 坐标数据列表
         */
        AABB.formPositions = function (positions) {
            return new AABB().formPositions(positions);
        };
        /**
         * 从一组点初始化包围盒
         * @param ps 点列表
         */
        AABB.fromPoints = function (ps) {
            return new AABB().fromPoints(ps);
        };
        /**
         * 随机包围盒
         */
        AABB.random = function () {
            var min = feng3d.Vector3.random();
            var max = feng3d.Vector3.random().add(min);
            return new AABB(min, max);
        };
        /**
         * 获取中心点
         * @param vout 输出向量
         */
        AABB.prototype.getCenter = function (vout) {
            if (vout === void 0) { vout = new feng3d.Vector3(); }
            return vout.copy(this.min).add(this.max).scaleNumber(0.5);
        };
        /**
         * 尺寸
         */
        AABB.prototype.getSize = function (vout) {
            if (vout === void 0) { vout = new feng3d.Vector3(); }
            return vout.copy(this.max).sub(this.min);
        };
        /**
         * 初始化包围盒
         * @param min 最小值
         * @param max 最大值
         */
        AABB.prototype.init = function (min, max) {
            this.min = min.clone();
            this.max = max.clone();
            return this;
        };
        /**
         * 转换为包围盒八个角所在点列表
         */
        AABB.prototype.toPoints = function () {
            var min = this.min;
            var max = this.max;
            return [
                new feng3d.Vector3(min.x, min.y, min.z),
                new feng3d.Vector3(max.x, min.y, min.z),
                new feng3d.Vector3(min.x, max.y, min.z),
                new feng3d.Vector3(min.x, min.y, max.z),
                new feng3d.Vector3(min.x, max.y, max.z),
                new feng3d.Vector3(max.x, min.y, max.z),
                new feng3d.Vector3(max.x, max.y, min.z),
                new feng3d.Vector3(max.x, max.y, max.z),
            ];
        };
        /**
         * 从一组顶点初始化包围盒
         * @param positions 坐标数据列表
         */
        AABB.prototype.formPositions = function (positions) {
            var minX = +Infinity;
            var minY = +Infinity;
            var minZ = +Infinity;
            var maxX = -Infinity;
            var maxY = -Infinity;
            var maxZ = -Infinity;
            for (var i = 0, l = positions.length; i < l; i += 3) {
                var x = positions[i];
                var y = positions[i + 1];
                var z = positions[i + 2];
                if (x < minX)
                    minX = x;
                if (y < minY)
                    minY = y;
                if (z < minZ)
                    minZ = z;
                if (x > maxX)
                    maxX = x;
                if (y > maxY)
                    maxY = y;
                if (z > maxZ)
                    maxZ = z;
            }
            this.min.init(minX, minY, minZ);
            this.max.init(maxX, maxY, maxZ);
            return this;
        };
        /**
         * 从一组点初始化包围盒
         * @param ps 点列表
         */
        AABB.prototype.fromPoints = function (ps) {
            var _this = this;
            this.empty();
            ps.forEach(function (element) {
                _this.expandByPoint(element);
            });
            return this;
        };
        /**
         * 包围盒内随机点
         */
        AABB.prototype.randomPoint = function (pout) {
            if (pout === void 0) { pout = new feng3d.Vector3(); }
            return pout.copy(this.min).lerp(this.max, feng3d.Vector3.random());
        };
        /**
         * 使用点扩张包围盒
         * @param point 点
         */
        AABB.prototype.expandByPoint = function (point) {
            this.min.min(point);
            this.max.max(point);
            return this;
        };
        /**
         * 应用矩阵
         * @param mat 矩阵
         */
        AABB.prototype.applyMatrix3D = function (mat) {
            this.fromPoints(this.toPoints().map(function (v) {
                return v.applyMatrix4x4(mat);
            }));
            return this;
        };
        /**
         * 应用矩阵
         * @param mat 矩阵
         */
        AABB.prototype.applyMatrix3DTo = function (mat, out) {
            if (out === void 0) { out = new AABB(); }
            return out.copy(this).applyMatrix3D(mat);
        };
        /**
         *
         */
        AABB.prototype.clone = function () {
            return new AABB(this.min.clone(), this.max.clone());
        };
        /**
         * 是否包含指定点
         * @param p 点
         */
        AABB.prototype.containsPoint = function (p) {
            return this.min.lessequal(p) && this.max.greaterequal(p);
        };
        /**
         * 是否包含包围盒
         * @param aabb 包围盒
         */
        AABB.prototype.contains = function (aabb) {
            return this.min.lessequal(aabb.min) && this.max.greaterequal(aabb.max);
        };
        /**
         * 拷贝
         * @param aabb 包围盒
         */
        AABB.prototype.copy = function (aabb) {
            this.min.copy(aabb.min);
            this.max.copy(aabb.max);
            return this;
        };
        /**
         * 比较包围盒是否相等
         * @param aabb 包围盒
         */
        AABB.prototype.equals = function (aabb) {
            return this.min.equals(aabb.min) && this.max.equals(aabb.max);
        };
        /**
         * 膨胀包围盒
         * @param dx x方向膨胀量
         * @param dy y方向膨胀量
         * @param dz z方向膨胀量
         */
        AABB.prototype.inflate = function (dx, dy, dz) {
            this.min.x -= dx / 2;
            this.min.y -= dy / 2;
            this.min.z -= dz / 2;
            this.max.x += dx / 2;
            this.max.y += dy / 2;
            this.max.z += dz / 2;
        };
        /**
         * 膨胀包围盒
         * @param delta 膨胀量
         */
        AABB.prototype.inflatePoint = function (delta) {
            delta = delta.scaleNumberTo(0.5);
            this.min.sub(delta);
            this.max.add(delta);
        };
        /**
         * 与包围盒相交
         * @param aabb 包围盒
         */
        AABB.prototype.intersection = function (aabb) {
            this.min.clamp(aabb.min, aabb.max);
            this.max.clamp(aabb.min, aabb.max);
            return this;
        };
        /**
         * 与包围盒相交
         * @param aabb 包围盒
         */
        AABB.prototype.intersectionTo = function (aabb, out) {
            if (out === void 0) { out = new AABB(); }
            return out.copy(this).intersection(aabb);
        };
        /**
         * 包围盒是否相交
         * @param aabb 包围盒
         */
        AABB.prototype.intersects = function (aabb) {
            var b = this.intersectionTo(aabb);
            var c = b.getCenter();
            return this.containsPoint(c) && aabb.containsPoint(c);
        };
        /**
         * 与射线相交
         * @param position 射线起点
         * @param direction 射线方向
         * @param targetNormal 相交处法线
         * @return 起点到包围盒距离
         */
        AABB.prototype.rayIntersection = function (position, direction, targetNormal) {
            if (this.containsPoint(position))
                return 0;
            var halfExtentsX = (this.max.x - this.min.x) / 2;
            var halfExtentsY = (this.max.y - this.min.y) / 2;
            var halfExtentsZ = (this.max.z - this.min.z) / 2;
            var centerX = this.min.x + halfExtentsX;
            var centerY = this.min.y + halfExtentsY;
            var centerZ = this.min.z + halfExtentsZ;
            var px = position.x - centerX;
            var py = position.y - centerY;
            var pz = position.z - centerZ;
            var vx = direction.x;
            var vy = direction.y;
            var vz = direction.z;
            var ix;
            var iy;
            var iz;
            var rayEntryDistance = -1;
            // 射线与平面相交测试
            var intersects = false;
            if (vx < 0) {
                rayEntryDistance = (halfExtentsX - px) / vx;
                if (rayEntryDistance > 0) {
                    iy = py + rayEntryDistance * vy;
                    iz = pz + rayEntryDistance * vz;
                    if (iy > -halfExtentsY && iy < halfExtentsY && iz > -halfExtentsZ && iz < halfExtentsZ) {
                        if (targetNormal) {
                            targetNormal.x = 1;
                            targetNormal.y = 0;
                            targetNormal.z = 0;
                        }
                        intersects = true;
                    }
                }
            }
            if (!intersects && vx > 0) {
                rayEntryDistance = (-halfExtentsX - px) / vx;
                if (rayEntryDistance > 0) {
                    iy = py + rayEntryDistance * vy;
                    iz = pz + rayEntryDistance * vz;
                    if (iy > -halfExtentsY && iy < halfExtentsY && iz > -halfExtentsZ && iz < halfExtentsZ) {
                        if (targetNormal) {
                            targetNormal.x = -1;
                            targetNormal.y = 0;
                            targetNormal.z = 0;
                        }
                        intersects = true;
                    }
                }
            }
            if (!intersects && vy < 0) {
                rayEntryDistance = (halfExtentsY - py) / vy;
                if (rayEntryDistance > 0) {
                    ix = px + rayEntryDistance * vx;
                    iz = pz + rayEntryDistance * vz;
                    if (ix > -halfExtentsX && ix < halfExtentsX && iz > -halfExtentsZ && iz < halfExtentsZ) {
                        if (targetNormal) {
                            targetNormal.x = 0;
                            targetNormal.y = 1;
                            targetNormal.z = 0;
                        }
                        intersects = true;
                    }
                }
            }
            if (!intersects && vy > 0) {
                rayEntryDistance = (-halfExtentsY - py) / vy;
                if (rayEntryDistance > 0) {
                    ix = px + rayEntryDistance * vx;
                    iz = pz + rayEntryDistance * vz;
                    if (ix > -halfExtentsX && ix < halfExtentsX && iz > -halfExtentsZ && iz < halfExtentsZ) {
                        if (targetNormal) {
                            targetNormal.x = 0;
                            targetNormal.y = -1;
                            targetNormal.z = 0;
                        }
                        intersects = true;
                    }
                }
            }
            if (!intersects && vz < 0) {
                rayEntryDistance = (halfExtentsZ - pz) / vz;
                if (rayEntryDistance > 0) {
                    ix = px + rayEntryDistance * vx;
                    iy = py + rayEntryDistance * vy;
                    if (iy > -halfExtentsY && iy < halfExtentsY && ix > -halfExtentsX && ix < halfExtentsX) {
                        if (targetNormal) {
                            targetNormal.x = 0;
                            targetNormal.y = 0;
                            targetNormal.z = 1;
                        }
                        intersects = true;
                    }
                }
            }
            if (!intersects && vz > 0) {
                rayEntryDistance = (-halfExtentsZ - pz) / vz;
                if (rayEntryDistance > 0) {
                    ix = px + rayEntryDistance * vx;
                    iy = py + rayEntryDistance * vy;
                    if (iy > -halfExtentsY && iy < halfExtentsY && ix > -halfExtentsX && ix < halfExtentsX) {
                        if (targetNormal) {
                            targetNormal.x = 0;
                            targetNormal.y = 0;
                            targetNormal.z = -1;
                        }
                        intersects = true;
                    }
                }
            }
            return intersects ? rayEntryDistance : -1;
        };
        /**
         * 获取包围盒上距离指定点最近的点
         *
         * @param point 指定点
         * @param target 存储最近的点
         */
        AABB.prototype.closestPointToPoint = function (point, target) {
            if (target === void 0) { target = new feng3d.Vector3(); }
            return this.clampPoint(point, target);
        };
        /**
         * 清空包围盒
         */
        AABB.prototype.empty = function () {
            this.min.x = this.min.y = this.min.z = +Infinity;
            this.max.x = this.max.y = this.max.z = -Infinity;
            return this;
        };
        /**
         * 是否为空
         * 当体积为0时为空
         */
        AABB.prototype.isEmpty = function () {
            return (this.max.x <= this.min.x) || (this.max.y <= this.min.y) || (this.max.z <= this.min.z);
        };
        /**
         * 偏移
         * @param dx x轴偏移
         * @param dy y轴偏移
         * @param dz z轴偏移
         */
        AABB.prototype.offset = function (dx, dy, dz) {
            return this.offsetPosition(new feng3d.Vector3(dx, dy, dz));
        };
        /**
         * 偏移
         * @param position 偏移量
         */
        AABB.prototype.offsetPosition = function (position) {
            this.min.add(position);
            this.max.add(position);
            return this;
        };
        AABB.prototype.toString = function () {
            return "[AABB] (min=" + this.min.toString() + ", max=" + this.max.toString() + ")";
        };
        /**
         * 联合包围盒
         * @param aabb 包围盒
         */
        AABB.prototype.union = function (aabb) {
            this.min.min(aabb.min);
            this.max.max(aabb.max);
            return this;
        };
        /**
         * 是否与球相交
         * @param sphere 球
         */
        AABB.prototype.intersectsSphere = function (sphere) {
            var closestPoint = new feng3d.Vector3();
            this.clampPoint(sphere.center, closestPoint);
            return closestPoint.distanceSquared(sphere.center) <= (sphere.radius * sphere.radius);
        };
        /**
         * 夹紧？
         *
         * @param point 点
         * @param out 输出点
         */
        AABB.prototype.clampPoint = function (point, out) {
            if (out === void 0) { out = new feng3d.Vector3(); }
            return out.copy(point).clamp(this.min, this.max);
        };
        /**
         * 是否与平面相交
         * @param plane 平面
         */
        AABB.prototype.intersectsPlane = function (plane) {
            var min = Infinity;
            var max = -Infinity;
            this.toPoints().forEach(function (p) {
                var d = plane.distanceWithPoint(p);
                min = d < min ? d : min;
                max = d > min ? d : min;
            });
            return min < 0 && max > 0;
        };
        /**
         * 是否与三角形相交
         * @param triangle 三角形
         */
        AABB.prototype.intersectsTriangle = function (triangle) {
            if (this.isEmpty()) {
                return false;
            }
            // 计算包围盒中心和区段
            var center = this.getCenter();
            var extents = this.max.subTo(center);
            // 把三角形顶点转换包围盒空间
            var v0 = triangle.p0.subTo(center);
            var v1 = triangle.p1.subTo(center);
            var v2 = triangle.p2.subTo(center);
            // 计算三边向量
            var f0 = v1.subTo(v0);
            var f1 = v2.subTo(v1);
            var f2 = v0.subTo(v2);
            // 测试三边向量分别所在三个轴面上的法线
            var axes = [
                0, -f0.z, f0.y, 0, -f1.z, f1.y, 0, -f2.z, f2.y,
                f0.z, 0, -f0.x, f1.z, 0, -f1.x, f2.z, 0, -f2.x,
                -f0.y, f0.x, 0, -f1.y, f1.x, 0, -f2.y, f2.x, 0
            ];
            if (!satForAxes(axes, v0, v1, v2, extents)) {
                return false;
            }
            // 测试三个面法线
            axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
            if (!satForAxes(axes, v0, v1, v2, extents)) {
                return false;
            }
            // 检测三角形面法线
            var triangleNormal = f0.crossTo(f1);
            axes = [triangleNormal.x, triangleNormal.y, triangleNormal.z];
            return satForAxes(axes, v0, v1, v2, extents);
        };
        /**
         * 转换为三角形列表
         */
        AABB.prototype.toTriangles = function (triangles) {
            if (triangles === void 0) { triangles = []; }
            var min = this.min;
            var max = this.max;
            triangles.push(
            // 前
            feng3d.Triangle3D.fromPoints(new feng3d.Vector3(min.x, min.y, min.z), new feng3d.Vector3(min.x, max.y, min.z), new feng3d.Vector3(max.x, max.y, min.z)), feng3d.Triangle3D.fromPoints(new feng3d.Vector3(min.x, min.y, min.z), new feng3d.Vector3(max.x, max.y, min.z), new feng3d.Vector3(max.x, min.y, min.z)), 
            // 后
            feng3d.Triangle3D.fromPoints(new feng3d.Vector3(min.x, min.y, max.z), new feng3d.Vector3(max.x, min.y, max.z), new feng3d.Vector3(min.x, max.y, max.z)), feng3d.Triangle3D.fromPoints(new feng3d.Vector3(max.x, min.y, max.z), new feng3d.Vector3(max.x, max.y, max.z), new feng3d.Vector3(min.x, max.y, max.z)), 
            // 右
            feng3d.Triangle3D.fromPoints(new feng3d.Vector3(max.x, min.y, min.z), new feng3d.Vector3(max.x, max.y, min.z), new feng3d.Vector3(max.x, max.y, max.z)), feng3d.Triangle3D.fromPoints(new feng3d.Vector3(max.x, min.y, min.z), new feng3d.Vector3(max.x, max.y, max.z), new feng3d.Vector3(max.x, min.y, max.z)), 
            // 左
            feng3d.Triangle3D.fromPoints(new feng3d.Vector3(min.x, min.y, max.z), new feng3d.Vector3(min.x, max.y, min.z), new feng3d.Vector3(min.x, min.y, min.z)), feng3d.Triangle3D.fromPoints(new feng3d.Vector3(min.x, min.y, max.z), new feng3d.Vector3(min.x, max.y, max.z), new feng3d.Vector3(min.x, max.y, min.z)), 
            // 上
            feng3d.Triangle3D.fromPoints(new feng3d.Vector3(min.x, max.y, min.z), new feng3d.Vector3(max.x, max.y, max.z), new feng3d.Vector3(max.x, max.y, min.z)), feng3d.Triangle3D.fromPoints(new feng3d.Vector3(min.x, max.y, min.z), new feng3d.Vector3(min.x, max.y, max.z), new feng3d.Vector3(max.x, max.y, max.z)), 
            // 下
            feng3d.Triangle3D.fromPoints(new feng3d.Vector3(min.x, min.y, min.z), new feng3d.Vector3(max.x, min.y, min.z), new feng3d.Vector3(min.x, min.y, max.z)), feng3d.Triangle3D.fromPoints(new feng3d.Vector3(max.x, min.y, min.z), new feng3d.Vector3(max.x, min.y, max.z), new feng3d.Vector3(min.x, min.y, max.z)));
            return triangles;
        };
        return AABB;
    }());
    feng3d.AABB = AABB;
    /**
     * 判断三角形三个点是否可能与包围盒在指定轴（列表）上投影相交
     *
     * @param axes
     * @param v0
     * @param v1
     * @param v2
     * @param extents
     */
    function satForAxes(axes, v0, v1, v2, extents) {
        for (var i = 0, j = axes.length - 3; i <= j; i += 3) {
            var testAxis = feng3d.Vector3.fromArray(axes, i);
            // 投影包围盒到指定轴的长度
            var r = extents.x * Math.abs(testAxis.x) + extents.y * Math.abs(testAxis.y) + extents.z * Math.abs(testAxis.z);
            // 投影三角形的三个点到指定轴
            var p0 = v0.dot(testAxis);
            var p1 = v1.dot(testAxis);
            var p2 = v2.dot(testAxis);
            // 三个点在包围盒投影外同侧
            if (Math.min(p0, p1, p2) > r || Math.max(p0, p1, p2) < -r) {
                return false;
            }
        }
        return true;
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 球
     */
    var Sphere = /** @class */ (function () {
        /**
         * Create a Sphere with ABCD coefficients
         */
        function Sphere(center, radius) {
            if (center === void 0) { center = new feng3d.Vector3(); }
            if (radius === void 0) { radius = 0; }
            this.center = center;
            this.radius = radius;
        }
        /**
         * 从一组点初始化球
         * @param points 点列表
         */
        Sphere.fromPoints = function (points) {
            return new Sphere().fromPoints(points);
        };
        /**
         * 从一组顶点初始化球
         * @param positions 坐标数据列表
         */
        Sphere.fromPositions = function (positions) {
            return new Sphere().fromPositions(positions);
        };
        /**
         * 与射线相交
         * @param position 射线起点
         * @param direction 射线方向
         * @param targetNormal 目标法线
         * @return 射线起点到交点的距离
         */
        Sphere.prototype.rayIntersection = function (position, direction, targetNormal) {
            if (this.containsPoint(position))
                return 0;
            var px = position.x - this.center.x, py = position.y - this.center.y, pz = position.z - this.center.z;
            var vx = direction.x, vy = direction.y, vz = direction.z;
            var rayEntryDistance;
            var a = vx * vx + vy * vy + vz * vz;
            var b = 2 * (px * vx + py * vy + pz * vz);
            var c = px * px + py * py + pz * pz - this.radius * this.radius;
            var det = b * b - 4 * a * c;
            if (det >= 0) { // ray goes through sphere
                var sqrtDet = Math.sqrt(det);
                rayEntryDistance = (-b - sqrtDet) / (2 * a);
                if (rayEntryDistance >= 0) {
                    targetNormal.x = px + rayEntryDistance * vx;
                    targetNormal.y = py + rayEntryDistance * vy;
                    targetNormal.z = pz + rayEntryDistance * vz;
                    targetNormal.normalize();
                    return rayEntryDistance;
                }
            }
            // ray misses sphere
            return -1;
        };
        /**
         * 是否包含指定点
         * @param position 点
         */
        Sphere.prototype.containsPoint = function (position) {
            return position.subTo(this.center).lengthSquared <= this.radius * this.radius;
        };
        /**
         * 从一组点初始化球
         * @param points 点列表
         */
        Sphere.prototype.fromPoints = function (points) {
            var box = new feng3d.AABB();
            var center = this.center;
            box.fromPoints(points).getCenter(center);
            var maxRadiusSq = 0;
            for (var i = 0, n = points.length; i < n; i++) {
                maxRadiusSq = Math.max(maxRadiusSq, center.distanceSquared(points[i]));
            }
            this.radius = Math.sqrt(maxRadiusSq);
            return this;
        };
        /**
         * 从一组顶点初始化球
         * @param positions 坐标数据列表
         */
        Sphere.prototype.fromPositions = function (positions) {
            var box = new feng3d.AABB();
            var v = new feng3d.Vector3();
            var center = this.center;
            box.formPositions(positions).getCenter(center);
            var maxRadiusSq = 0;
            for (var i = 0, n = positions.length; i < n; i += 3) {
                maxRadiusSq = Math.max(maxRadiusSq, center.distanceSquared(v.init(positions[i], positions[i + 1], positions[i + 2])));
            }
            this.radius = Math.sqrt(maxRadiusSq);
            return this;
        };
        /**
         * 拷贝
         */
        Sphere.prototype.copy = function (sphere) {
            this.center.copy(sphere.center);
            this.radius = sphere.radius;
            return this;
        };
        /**
         * 克隆
         */
        Sphere.prototype.clone = function () {
            return new Sphere().copy(this);
        };
        /**
         * 是否为空
         */
        Sphere.prototype.isEmpty = function () {
            return this.radius <= 0;
        };
        /**
         * 点到球的距离
         * @param point 点
         */
        Sphere.prototype.distanceToPoint = function (point) {
            return point.distance(this.center) - this.radius;
        };
        /**
         * 与指定球是否相交
         */
        Sphere.prototype.intersectsSphere = function (sphere) {
            var radiusSum = this.radius + sphere.radius;
            return sphere.center.distanceSquared(this.center) <= radiusSum * radiusSum;
        };
        /**
         * 是否与盒子相交
         * @param box 盒子
         */
        Sphere.prototype.intersectsBox = function (box) {
            return box.intersectsSphere(this);
        };
        /**
         * 是否与平面相交
         * @param plane 平面
         */
        Sphere.prototype.intersectsPlane = function (plane) {
            return Math.abs(plane.distanceWithPoint(this.center)) <= this.radius;
        };
        /**
         *
         * @param point 点
         * @param pout 输出点
         */
        Sphere.prototype.clampPoint = function (point, pout) {
            if (pout === void 0) { pout = new feng3d.Vector3(); }
            var deltaLengthSq = this.center.distanceSquared(point);
            pout.copy(point);
            if (deltaLengthSq > (this.radius * this.radius)) {
                pout.sub(this.center).normalize();
                pout.scaleNumber(this.radius).add(this.center);
            }
            return pout;
        };
        /**
         * 获取包围盒
         */
        Sphere.prototype.getBoundingBox = function (box) {
            if (box === void 0) { box = new feng3d.AABB(); }
            box.init(this.center.subNumberTo(this.radius), this.center.addNumberTo(this.radius));
            return box;
        };
        /**
         * 应用矩阵
         * @param matrix 矩阵
         */
        Sphere.prototype.applyMatrix4 = function (matrix) {
            this.center.applyMatrix4x4(matrix);
            this.radius = this.radius * matrix.getMaxScaleOnAxis();
            return this;
        };
        /**
         * 平移
         * @param offset 偏移量
         */
        Sphere.prototype.translate = function (offset) {
            this.center.add(offset);
            return this;
        };
        /**
         * 是否相等
         * @param sphere 球
         */
        Sphere.prototype.equals = function (sphere) {
            return sphere.center.equals(this.center) && (sphere.radius === this.radius);
        };
        Sphere.prototype.toString = function () {
            return "Sphere [center:" + this.center.toString() + ", radius:" + this.radius + "]";
        };
        return Sphere;
    }());
    feng3d.Sphere = Sphere;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3d面
     * ax+by+cz+d=0
     */
    var Plane3D = /** @class */ (function () {
        /**
         * 创建一个平面
         * @param a		A系数
         * @param b		B系数
         * @param c		C系数
         * @param d		D系数
         */
        function Plane3D(a, b, c, d) {
            if (a === void 0) { a = 0; }
            if (b === void 0) { b = 1; }
            if (c === void 0) { c = 0; }
            if (d === void 0) { d = 0; }
            this.a = a;
            this.b = b;
            this.c = c;
            this.d = d;
        }
        /**
         * 通过3顶点定义一个平面
         * @param p0		点0
         * @param p1		点1
         * @param p2		点2
         */
        Plane3D.fromPoints = function (p0, p1, p2) {
            return new Plane3D().fromPoints(p0, p1, p2);
        };
        /**
         * 根据法线与点定义平面
         * @param normal		平面法线
         * @param point			平面上任意一点
         */
        Plane3D.fromNormalAndPoint = function (normal, point) {
            return new Plane3D().fromNormalAndPoint(normal, point);
        };
        /**
         * 随机平面
         */
        Plane3D.random = function () {
            var normal = feng3d.Vector3.random().normalize();
            return new Plane3D(normal.x, normal.y, normal.z, Math.random());
        };
        /**
         * 原点在平面上的投影
         * @param vout 输出点
         */
        Plane3D.prototype.getOrigin = function (vout) {
            if (vout === void 0) { vout = new feng3d.Vector3(); }
            return this.projectPoint(new feng3d.Vector3(), vout);
        };
        /**
         * 平面上随机点
         * @param vout 输出点
         */
        Plane3D.prototype.randomPoint = function (vout) {
            if (vout === void 0) { vout = new feng3d.Vector3(); }
            return this.getOrigin(vout).add(this.getNormal().cross(feng3d.Vector3.random()));
        };
        /**
         * 法线
         */
        Plane3D.prototype.getNormal = function (vout) {
            if (vout === void 0) { vout = new feng3d.Vector3(); }
            return vout.init(this.a, this.b, this.c);
        };
        /**
         * 通过3顶点定义一个平面
         * @param p0		点0
         * @param p1		点1
         * @param p2		点2
         */
        Plane3D.prototype.fromPoints = function (p0, p1, p2) {
            // p1.subTo(p0, v0);
            // p2.subTo(p1, v1);
            // var normal = v0.crossTo(v1).normalize();
            var normal = p1.subTo(p0).crossTo(p2.subTo(p1)).normalize();
            this.a = normal.x;
            this.b = normal.y;
            this.c = normal.z;
            this.d = -normal.dot(p0);
            return this;
        };
        /**
         * 根据法线与点定义平面
         * @param normal		平面法线
         * @param point			平面上任意一点
         */
        Plane3D.prototype.fromNormalAndPoint = function (normal, point) {
            normal = normal.clone().normalize();
            this.a = normal.x;
            this.b = normal.y;
            this.c = normal.z;
            this.d = -normal.dot(point);
            return this;
        };
        /**
         * 计算点与平面的距离
         * @param p		点
         * @returns		距离
         */
        Plane3D.prototype.distanceWithPoint = function (p) {
            return this.a * p.x + this.b * p.y + this.c * p.z + this.d;
        };
        /**
         * 点是否在平面上
         * @param p 点
         */
        Plane3D.prototype.onWithPoint = function (p) {
            return Math.equals(this.distanceWithPoint(p), 0);
        };
        /**
         * 顶点分类
         * <p>把顶点分为后面、前面、相交三类</p>
         * @param p			顶点
         * @return			顶点类型 PlaneClassification.BACK,PlaneClassification.FRONT,PlaneClassification.INTERSECT
         */
        Plane3D.prototype.classifyPoint = function (p, precision) {
            if (precision === void 0) { precision = Math.PRECISION; }
            var len = this.distanceWithPoint(p);
            if (Math.equals(len, 0, precision))
                return feng3d.PlaneClassification.INTERSECT;
            if (len < 0)
                return feng3d.PlaneClassification.BACK;
            return feng3d.PlaneClassification.FRONT;
        };
        /**
         * 判定与直线是否平行
         * @param line3D
         */
        Plane3D.prototype.parallelWithLine3D = function (line3D, precision) {
            if (precision === void 0) { precision = Math.PRECISION; }
            if (Math.equals(line3D.direction.dot(this.getNormal()), 0, precision))
                return true;
            return false;
        };
        /**
         * 判定与平面是否平行
         * @param plane3D
         */
        Plane3D.prototype.parallelWithPlane3D = function (plane3D, precision) {
            if (precision === void 0) { precision = Math.PRECISION; }
            if (plane3D.getNormal().isParallel(this.getNormal(), precision))
                return true;
            return false;
        };
        /**
         * 获取与直线交点
         */
        Plane3D.prototype.intersectWithLine3D = function (line3D) {
            //处理平行
            if (this.parallelWithLine3D(line3D)) {
                // 处理直线在平面内
                if (this.onWithPoint(line3D.position))
                    return line3D.clone();
                return null;
            }
            var lineDir = line3D.direction.clone();
            lineDir.normalize();
            var cosAngle = lineDir.dot(this.getNormal());
            var distance = this.distanceWithPoint(line3D.position);
            var addVec = lineDir.clone();
            addVec.scaleNumber(-distance / cosAngle);
            var crossPos = line3D.position.addTo(addVec);
            return crossPos;
        };
        /**
         * 获取与平面相交直线
         * @param plane3D
         */
        Plane3D.prototype.intersectWithPlane3D = function (plane3D) {
            if (this.parallelWithPlane3D(plane3D))
                return null;
            var direction = this.getNormal().crossTo(plane3D.getNormal());
            var a0 = this.a, b0 = this.b, c0 = this.c, d0 = this.d, a1 = plane3D.a, b1 = plane3D.b, c1 = plane3D.c, d1 = plane3D.d;
            var x, y, z;
            // 解 方程组 a0*x+b0*y+c0*z+d0=0;a1*x+b1*y+c1*z+d1=0;
            if (b1 * c0 - b0 * c1 != 0) {
                x = 0;
                y = (-c0 * d1 + c1 * d0 + (a0 * c1 - a1 * c0) * x) / (b1 * c0 - b0 * c1);
                z = (-b1 * d0 + b0 * d1 + (a1 * b0 - a0 * b1) * x) / (b1 * c0 - b0 * c1);
            }
            else if (a0 * c1 - a1 * c0 != 0) {
                y = 0;
                x = (-c1 * d0 + c0 * d1 + (b1 * c0 - b0 * c1) * y) / (a0 * c1 - a1 * c0);
                z = (-a0 * d1 + a1 * d0 + (a1 * b0 - a0 * b1) * y) / (a0 * c1 - a1 * c0);
            }
            else if (a1 * b0 - a0 * b1 != 0) {
                z = 0;
                x = (-b0 * d1 + b1 * d0 + (b1 * c0 - b0 * c1) * z) / (a1 * b0 - a0 * b1);
                y = (-a1 * d0 + a0 * d1 + (a0 * c1 - a1 * c0) * z) / (a1 * b0 - a0 * b1);
            }
            else {
                throw "无法计算平面相交结果";
            }
            return new feng3d.Line3D(new feng3d.Vector3(x, y, z), direction);
        };
        /**
         * 翻转平面
         */
        Plane3D.prototype.negate = function () {
            this.a = -this.a;
            this.b = -this.b;
            this.c = -this.c;
            this.d = -this.d;
            return this;
        };
        /**
         * 点到平面的投影
         * @param point
         */
        Plane3D.prototype.projectPoint = function (point, vout) {
            if (vout === void 0) { vout = new feng3d.Vector3(); }
            return this.getNormal(vout).scaleNumber(-this.distanceWithPoint(point)).add(point);
        };
        /**
         * 与指定点最近的点
         * @param point 点
         * @param vout 输出点
         */
        Plane3D.prototype.closestPointWithPoint = function (point, vout) {
            if (vout === void 0) { vout = new feng3d.Vector3(); }
            return this.projectPoint(point, vout);
        };
        /**
         * 复制
         */
        Plane3D.prototype.copy = function (plane) {
            this.a = plane.a;
            this.b = plane.b;
            this.c = plane.c;
            this.d = plane.d;
            return this;
        };
        /**
         * 克隆
         */
        Plane3D.prototype.clone = function () {
            return new Plane3D().copy(this);
        };
        /**
         * 输出字符串
         */
        Plane3D.prototype.toString = function () {
            return "Plane3D [this.a:" + this.a + ", this.b:" + this.b + ", this.c:" + this.c + ", this.d:" + this.d + "]";
        };
        return Plane3D;
    }());
    feng3d.Plane3D = Plane3D;
    // var v0 = new Vector3();
    // var v1 = new Vector3();
    // var v2 = new Vector3();
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 点与面的相对位置

     */
    var PlaneClassification;
    (function (PlaneClassification) {
        /**
         * 在平面后面
         */
        PlaneClassification[PlaneClassification["BACK"] = 0] = "BACK";
        /**
         * 在平面前面
         */
        PlaneClassification[PlaneClassification["FRONT"] = 1] = "FRONT";
        /**
         * 与平面相交
         */
        PlaneClassification[PlaneClassification["INTERSECT"] = 2] = "INTERSECT";
    })(PlaneClassification = feng3d.PlaneClassification || (feng3d.PlaneClassification = {}));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 由三角形构成的几何体
     * ### 限定：
     *  * 只包含三角形，不存在四边形等其他多边形
     *  *
     */
    var TriangleGeometry = /** @class */ (function () {
        function TriangleGeometry(triangles) {
            if (triangles === void 0) { triangles = []; }
            this.triangles = triangles;
        }
        /**
         * 从盒子初始化
         * @param box 盒子
         */
        TriangleGeometry.fromBox = function (box) {
            return new TriangleGeometry().fromBox(box);
        };
        /**
         * 从盒子初始化
         * @param box 盒子
         */
        TriangleGeometry.prototype.fromBox = function (box) {
            this.triangles.length = 0;
            box.toTriangles(this.triangles);
            return this;
        };
        /**
         * 获取所有顶点，去除重复顶点
         */
        TriangleGeometry.prototype.getPoints = function () {
            var ps = this.triangles.reduce(function (v, t) { return v.concat(t.getPoints()); }, []);
            feng3d.utils.arrayUnique(ps, function (a, b) { return a.equals(b); });
            return ps;
        };
        /**
         * 是否闭合
         * 方案：获取所有三角形的线段，当每条线段（a,b）都存在且仅有一条与之相对于的线段（b，a）时几何体闭合
         */
        TriangleGeometry.prototype.isClosed = function () {
            // 获取所有线段
            var ss = this.triangles.reduce(function (ss, t) { return ss.concat(t.getSegments()); }, []);
            // 当每条线段（a,b）都存在与之相对于的线段（b，a）时几何体闭合
            var r = ss.every(function (s) { return ss.filter(function (s0) { return s.p0.equals(s0.p1) && s.p1.equals(s0.p0); }).length == 1; });
            return r;
        };
        /**
         * 包围盒
         */
        TriangleGeometry.prototype.getBox = function (box) {
            if (box === void 0) { box = new feng3d.AABB(); }
            return box.fromPoints(this.getPoints());
        };
        /**
         * 与指定点最近的点
         * @param point 点
         * @param vout 输出点
         */
        TriangleGeometry.prototype.closestPointWithPoint = function (point, vout) {
            if (vout === void 0) { vout = new feng3d.Vector3(); }
            // 计算指定点到所有平面的距离，并按距离排序
            var r = this.triangles.map(function (t) { var p = t.closestPointWithPoint(point); return { p: p, d: point.distanceSquared(p) }; }).sort(function (a, b) { return a.d - b.d; });
            return vout.copy(r[0].p);
        };
        /**
         * 给指定点分类
         * @param p 点
         * @return 点相对于几何体位置；0:在几何体表面上，1：在几何体外，-1：在几何体内
         * 方案：当指定点不在几何体上时，在几何体上找到距离指定点最近点，最近点到给定点形成的向量与最近点所在面（当最近点在多个面上时取点乘摸最大的面）法线点乘大于0时给定点在几何体内，否则在几何体外。
         */
        TriangleGeometry.prototype.classifyPoint = function (p) {
            if (!this.isClosed())
                return 1;
            // 是否在表面
            var onface = this.triangles.reduce(function (v, t) {
                return v || t.onWithPoint(p);
            }, false);
            if (onface)
                return 0;
            // 最近点
            var cp = this.closestPointWithPoint(p);
            // 到最近点的向量
            var cpv = cp.subTo(p);
            // 最近点所在平面
            var cts = this.triangles.filter(function (t) { return t.onWithPoint(cp); });
            // 最近点向量与所在平面方向相同则点在几何体内
            var v = cts.map(function (t) { return t.getNormal().dot(cpv); }).sort(function (a, b) { return Math.abs(b) - Math.abs(a); })[0];
            if (v > 0)
                return -1;
            return 1;
        };
        /**
         * 是否包含指定点
         * @param p 点
         */
        TriangleGeometry.prototype.containsPoint = function (p) {
            return this.classifyPoint(p) <= 0;
        };
        /**
         * 给指定线段分类
         * @param segment 线段
         * @return 线段相对于几何体位置；0:在几何体表面上，1：在几何体外，-1：在几何体内，2：横跨几何体
         */
        TriangleGeometry.prototype.classifySegment = function (segment) {
            var _this = this;
            // 线段与几何体不相交时
            var r = this.intersectionWithSegment(segment);
            if (!r) {
                if (this.classifyPoint(segment.p0) > 0)
                    return 1;
                return -1;
            }
            // 相交多条线段时 横跨
            if (r.segments.length > 1)
                return 2;
            if (r.segments.length == 1) {
                // 相交线段相对 几何体的位置
                var pc = [r.segments[0].p0, r.segments[0].p1].map(function (p) { return _this.classifyPoint(p); });
                if (pc[0] * pc[1] < 0)
                    return 2;
                if (pc[0] + pc[1] == 0)
                    return 0;
                if (pc[0] + pc[1] < 0)
                    return -1;
                return 1;
            }
            // 相交于点
            if (r.points.length) {
            }
        };
        /**
         * 给指定三角形分类
         * @param triangle 三角形
         * @return 三角形相对于几何体位置；0:在几何体表面上，1：在几何体外，-1：在几何体内
         */
        TriangleGeometry.prototype.classifyTriangle = function (triangle) {
        };
        /**
         * 与直线碰撞
         * @param line3d 直线
         */
        TriangleGeometry.prototype.intersectionWithLine = function (line3d) {
            // 线段与三角形碰撞
            var ss = [];
            var ps = [];
            this.triangles.forEach(function (t) {
                var r = t.intersectionWithLine(line3d);
                if (!r)
                    return;
                if (r instanceof feng3d.Segment3D) {
                    ss.push(r);
                    return;
                }
                ps.push(r);
            });
            // 清除相同的线段
            feng3d.utils.arrayUnique(ss, function (a, b) { return a.equals(b); });
            // 删除在相交线段上的交点
            ps = ps.filter(function (p) { return ss.every(function (s) { return !s.onWithPoint(p); }); });
            // 清除相同点
            feng3d.utils.arrayUnique(ps, function (a, b) { return a.equals(b); });
            if (ss.length + ps.length == 0)
                return null;
            return { segments: ss, points: ps };
        };
        /**
         * 与线段相交
         * @param segment 线段
         * @return 不相交时返回null，相交时返回 碰撞线段列表与碰撞点列表
         */
        TriangleGeometry.prototype.intersectionWithSegment = function (segment) {
            var line = segment.getLine();
            var r = this.intersectionWithLine(line);
            if (!r)
                return null;
            var ps = r.points = r.points.filter(function (p) { return segment.onWithPoint(p); });
            r.segments = r.segments.reduce(function (v, s) {
                var p0 = segment.clampPoint(s.p0);
                var p1 = segment.clampPoint(s.p1);
                if (!s.onWithPoint(p0))
                    return v;
                if (p0.equals(p1)) {
                    ps.push(p0);
                    return v;
                }
                v.push(feng3d.Segment3D.fromPoints(p0, p1));
                return v;
            }, []);
            if (r.segments.length + r.points.length == 0)
                return null;
            return r;
        };
        /**
         * 分解三角形
         * @param triangle 三角形
         */
        TriangleGeometry.prototype.decomposeTriangle = function (triangle) {
        };
        /**
         * 拷贝
         */
        TriangleGeometry.prototype.copy = function (triangleGeometry) {
            this.triangles = triangleGeometry.triangles.map(function (t) { return t.clone(); });
            return this;
        };
        /**
         * 克隆
         */
        TriangleGeometry.prototype.clone = function () {
            return new TriangleGeometry().copy(this);
        };
        return TriangleGeometry;
    }());
    feng3d.TriangleGeometry = TriangleGeometry;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 渐变模式
     */
    var GradientMode;
    (function (GradientMode) {
        /**
         * 混合
         */
        GradientMode[GradientMode["Blend"] = 0] = "Blend";
        /**
         * 阶梯
         */
        GradientMode[GradientMode["Fixed"] = 1] = "Fixed";
    })(GradientMode = feng3d.GradientMode || (feng3d.GradientMode = {}));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 颜色渐变
     */
    var Gradient = /** @class */ (function () {
        function Gradient() {
            /**
             * 渐变模式
             */
            this.mode = feng3d.GradientMode.Blend;
            /**
             * 在渐变中定义的所有alpha键。
             *
             * 注： 该值已对时间排序，否则赋值前请使用 sort((a, b) => a.time - b.time) 进行排序
             */
            this.alphaKeys = [{ alpha: 1, time: 0 }, { alpha: 1, time: 1 }];
            /**
             * 在渐变中定义的所有color键。
             *
             * 注： 该值已对时间排序，否则赋值前请使用 sort((a, b) => a.time - b.time) 进行排序
             */
            this.colorKeys = [{ color: new feng3d.Color3(1, 1, 1), time: 0 }, { color: new feng3d.Color3(1, 1, 1), time: 1 }];
        }
        /**
         * 从颜色列表初始化
         * @param colors 颜色列表
         * @param times
         */
        Gradient.prototype.fromColors = function (colors, times) {
            if (!times) {
                times = [];
                for (var i = 0; i < colors.length; i++) {
                    times[i] = i / (colors.length - 1);
                }
            }
            var colors1 = colors.map(function (v) { return new feng3d.Color3().fromUnit(v); });
            for (var i = 0; i < colors1.length; i++) {
                this.colorKeys[i] = { color: colors1[i], time: times[i] };
            }
            return this;
        };
        /**
         * 获取值
         * @param time 时间
         */
        Gradient.prototype.getValue = function (time) {
            var alpha = this.getAlpha(time);
            var color = this.getColor(time);
            return new feng3d.Color4(color.r, color.g, color.b, alpha);
        };
        /**
         * 获取透明度
         * @param time 时间
         */
        Gradient.prototype.getAlpha = function (time) {
            var alphaKeys = this.alphaKeys;
            if (alphaKeys.length == 1)
                return alphaKeys[0].alpha;
            if (time <= alphaKeys[0].time)
                return alphaKeys[0].alpha;
            if (time >= alphaKeys[alphaKeys.length - 1].time)
                return alphaKeys[alphaKeys.length - 1].alpha;
            for (var i = 0, n = alphaKeys.length - 1; i < n; i++) {
                var t = alphaKeys[i].time, v = alphaKeys[i].alpha, nt = alphaKeys[i + 1].time, nv = alphaKeys[i + 1].alpha;
                if (time == t)
                    return v;
                if (time == nt)
                    return nv;
                if (t < time && time < nt) {
                    if (this.mode == feng3d.GradientMode.Fixed)
                        return nv;
                    return Math.mapLinear(time, t, nt, v, nv);
                }
            }
            return 1;
        };
        /**
         * 获取透明度
         * @param time 时间
         */
        Gradient.prototype.getColor = function (time) {
            var colorKeys = this.colorKeys;
            if (colorKeys.length == 1)
                return colorKeys[0].color;
            if (time <= colorKeys[0].time)
                return colorKeys[0].color;
            if (time >= colorKeys[colorKeys.length - 1].time)
                return colorKeys[colorKeys.length - 1].color;
            for (var i = 0, n = colorKeys.length - 1; i < n; i++) {
                var t = colorKeys[i].time, v = colorKeys[i].color, nt = colorKeys[i + 1].time, nv = colorKeys[i + 1].color;
                if (time == t)
                    return v;
                if (time == nt)
                    return nv;
                if (t < time && time < nt) {
                    if (this.mode == feng3d.GradientMode.Fixed)
                        return nv;
                    return v.mixTo(nv, (time - t) / (nt - t));
                }
            }
            return new feng3d.Color3();
        };
        __decorate([
            feng3d.serialize
        ], Gradient.prototype, "mode", void 0);
        __decorate([
            feng3d.serialize
        ], Gradient.prototype, "alphaKeys", void 0);
        __decorate([
            feng3d.serialize
        ], Gradient.prototype, "colorKeys", void 0);
        return Gradient;
    }());
    feng3d.Gradient = Gradient;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 最大最小颜色渐变模式
     */
    var MinMaxGradientMode;
    (function (MinMaxGradientMode) {
        /**
         * 颜色常量
         */
        MinMaxGradientMode[MinMaxGradientMode["Color"] = 0] = "Color";
        /**
         * 颜色渐变
         */
        MinMaxGradientMode[MinMaxGradientMode["Gradient"] = 1] = "Gradient";
        /**
         * 从最大最小常量颜色中随机
         */
        MinMaxGradientMode[MinMaxGradientMode["RandomBetweenTwoColors"] = 2] = "RandomBetweenTwoColors";
        /**
         * 从最大最小颜色渐变值中随机
         */
        MinMaxGradientMode[MinMaxGradientMode["RandomBetweenTwoGradients"] = 3] = "RandomBetweenTwoGradients";
        /**
         * 从颜色渐变中进行随机
         */
        MinMaxGradientMode[MinMaxGradientMode["RandomColor"] = 4] = "RandomColor";
    })(MinMaxGradientMode = feng3d.MinMaxGradientMode || (feng3d.MinMaxGradientMode = {}));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 最大最小颜色渐变
     */
    var MinMaxGradient = /** @class */ (function () {
        function MinMaxGradient() {
            /**
             * 模式
             */
            this.mode = feng3d.MinMaxGradientMode.Color;
            /**
             * 常量颜色值
             */
            this.color = new feng3d.Color4();
            /**
             * 常量颜色值，作用于 MinMaxGradientMode.RandomBetweenTwoColors
             */
            this.color1 = new feng3d.Color4();
            this.gradient = new feng3d.Gradient();
            this.gradient1 = new feng3d.Gradient();
        }
        /**
         * 获取值
         * @param time 时间
         */
        MinMaxGradient.prototype.getValue = function (time) {
            switch (this.mode) {
                case feng3d.MinMaxGradientMode.Color:
                    return this.color;
                case feng3d.MinMaxGradientMode.Gradient:
                    return this.gradient.getValue(time);
                case feng3d.MinMaxGradientMode.RandomBetweenTwoColors:
                    return this.color.mixTo(this.color1, Math.random());
                case feng3d.MinMaxGradientMode.RandomBetweenTwoGradients:
                    var min = this.gradient.getValue(time);
                    var max = this.gradient1.getValue(time);
                    var v = min.mixTo(max, Math.random());
                    return v;
                case feng3d.MinMaxGradientMode.RandomColor:
                    var v = this.gradient.getValue(Math.random());
                    return v;
            }
            return this.color;
        };
        __decorate([
            feng3d.serialize
        ], MinMaxGradient.prototype, "mode", void 0);
        __decorate([
            feng3d.serialize
        ], MinMaxGradient.prototype, "color", void 0);
        __decorate([
            feng3d.serialize
        ], MinMaxGradient.prototype, "color1", void 0);
        __decorate([
            feng3d.serialize
        ], MinMaxGradient.prototype, "gradient", void 0);
        __decorate([
            feng3d.serialize
        ], MinMaxGradient.prototype, "gradient1", void 0);
        return MinMaxGradient;
    }());
    feng3d.MinMaxGradient = MinMaxGradient;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Bézier曲线
     * @see https://en.wikipedia.org/wiki/B%C3%A9zier_curve
     * @author feng / http://feng3d.com 03/06/2018
     */
    var BezierCurve = /** @class */ (function () {
        function BezierCurve() {
        }
        /**
         * 线性Bézier曲线
         * 给定不同的点P0和P1，线性Bézier曲线就是这两个点之间的直线。曲线由下式给出
         * ```
         * B(t) = p0 + t * (p1 - p0) = (1 - t) * p0 + t * p1 , 0 <= t && t <= 1
         * ```
         * 相当于线性插值
         *
         * @param t 插值度
         * @param p0 点0
         * @param p1 点1
         */
        BezierCurve.prototype.linear = function (t, p0, p1) {
            return p0 + t * (p1 - p0);
            // return (1 - t) * p0 + t * p1;
        };
        /**
         * 线性Bézier曲线关于t的导数
         * @param t 插值度
         * @param p0 点0
         * @param p1 点1
         */
        BezierCurve.prototype.linearDerivative = function (t, p0, p1) {
            return p1 - p0;
        };
        /**
         * 线性Bézier曲线关于t的二阶导数
         * @param t 插值度
         * @param p0 点0
         * @param p1 点1
         */
        BezierCurve.prototype.linearSecondDerivative = function (t, p0, p1) {
            return 0;
        };
        /**
         * 二次Bézier曲线
         *
         * 二次Bézier曲线是由函数B（t）跟踪的路径，给定点P0，P1和P2，
         * ```
         * B(t) = (1 - t) * ((1 - t) * p0 + t * p1) + t * ((1 - t) * p1 + t * p2) , 0 <= t && t <= 1
         * ```
         * 这可以解释为分别从P0到P1和从P1到P2的线性Bézier曲线上相应点的线性插值。重新排列前面的等式得出：
         * ```
         * B(t) = (1 - t) * (1 - t) * p0 + 2 * (1 - t) * t * p1 + t * t * p2 , 0 <= t && t <= 1
         * ```
         * Bézier曲线关于t的导数是
         * ```
         * B'(t) = 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1)
         * ```
         * 从中可以得出结论：在P0和P2处曲线的切线在P 1处相交。随着t从0增加到1，曲线沿P1的方向从P0偏离，然后从P1的方向弯曲到P2。
         *
         * Bézier曲线关于t的二阶导数是
         * ```
         * B''(t) = 2 * (p2 - 2 * p1 + p0)
         * ```
         *
         * @param t 插值度
         * @param p0 点0
         * @param p1 点1
         * @param p2 点2
         */
        BezierCurve.prototype.quadratic = function (t, p0, p1, p2) {
            // return this.linear(t, this.linear(t, p0, p1), this.linear(t, p1, p2));
            // return (1 - t) * ((1 - t) * p0 + t * p1) + t * ((1 - t) * p1 + t * p2);
            return (1 - t) * (1 - t) * p0 + 2 * (1 - t) * t * p1 + t * t * p2;
        };
        /**
         * 二次Bézier曲线关于t的导数
         * @param t 插值度
         * @param p0 点0
         * @param p1 点1
         * @param p2 点2
         */
        BezierCurve.prototype.quadraticDerivative = function (t, p0, p1, p2) {
            // return 2 * this.linear(t, this.linearDerivative(t, p0, p1), this.linearDerivative(t, p1, p2));
            return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);
        };
        /**
         * 二次Bézier曲线关于t的二阶导数
         * @param t 插值度
         * @param p0 点0
         * @param p1 点1
         * @param p2 点2
         */
        BezierCurve.prototype.quadraticSecondDerivative = function (t, p0, p1, p2) {
            // return 1 * 2 * this.linearDerivative(t, p1 - p0, p2 - p1)
            // return 1 * 2 * ((p2 - p1) - (p1 - p0));
            return 2 * (p2 - 2 * p1 + p0);
        };
        /**
         * 立方Bézier曲线
         *
         * 平面中或高维空间中（其实一维也是成立的，这里就是使用一维计算）的四个点P0，P1，P2和P3定义了三次Bézier曲线。
         * 曲线开始于P0朝向P1并且从P2的方向到达P3。通常不会通过P1或P2; 这些点只是为了提供方向信息。
         * P1和P2之间的距离在转向P2之前确定曲线向P1移动的“多远”和“多快” 。
         *
         * 对于由点Pi，Pj和Pk定义的二次Bézier曲线，可以将Bpipjpk(t)写成三次Bézier曲线，它可以定义为两条二次Bézier曲线的仿射组合：
         * ```
         * B(t) = (1 - t) * Bp0p1p2(t) + t * Bp1p2p3(t) , 0 <= t && t <= 1
         * ```
         * 曲线的显式形式是：
         * ```
         * B(t) = (1 - t) * (1 - t) * (1 - t) * p0 + 3 * (1 - t) * (1 - t) * t * p1 + 3 * (1 - t) * t * t * p2 + t * t * t * p3 , 0 <= t && t <= 1
         * ```
         * 对于P1和P2的一些选择，曲线可以相交，或者包含尖点。
         *
         * 三次Bézier曲线相对于t的导数是
         * ```
         * B'(t) = 3 * (1 - t) * (1 - t) * (p1 - p0) + 6 * (1 - t) * t * (p2 - p1) + 3 * t * t * (p3 - p2);
         * ```
         * 三次Bézier曲线关于t的二阶导数是
         * ```
         * 6 * (1 - t) * (p2 - 2 * p1 + p0) + 6 * t * (p3 - 2 * p2 + p1);
         * ```
         *
         * @param t 插值度
         * @param p0 点0
         * @param p1 点1
         * @param p2 点2
         * @param p3 点3
         */
        BezierCurve.prototype.cubic = function (t, p0, p1, p2, p3) {
            // return this.linear(t, this.quadratic(t, p0, p1, p2), this.quadratic(t, p1, p2, p3));
            return (1 - t) * (1 - t) * (1 - t) * p0 + 3 * (1 - t) * (1 - t) * t * p1 + 3 * (1 - t) * t * t * p2 + t * t * t * p3;
        };
        /**
         * 三次Bézier曲线关于t的导数
         * @param t 插值度
         * @param p0 点0
         * @param p1 点1
         * @param p2 点2
         * @param p3 点3
         */
        BezierCurve.prototype.cubicDerivative = function (t, p0, p1, p2, p3) {
            // return 3 * this.linear(t, this.quadraticDerivative(t, p0, p1, p2), this.quadraticDerivative(t, p1, p2, p3));
            return 3 * (1 - t) * (1 - t) * (p1 - p0) + 6 * (1 - t) * t * (p2 - p1) + 3 * t * t * (p3 - p2);
        };
        /**
         * 三次Bézier曲线关于t的二阶导数
         * @param t 插值度
         * @param p0 点0
         * @param p1 点1
         * @param p2 点2
         */
        BezierCurve.prototype.cubicSecondDerivative = function (t, p0, p1, p2, p3) {
            // return 3 * this.linear(t, this.quadraticSecondDerivative(t, p0, p1, p2), this.quadraticSecondDerivative(t, p1, p2, p3));
            return 6 * (1 - t) * (p2 - 2 * p1 + p0) + 6 * t * (p3 - 2 * p2 + p1);
        };
        /**
         * n次Bézier曲线
         *
         * 一般定义
         *
         * Bézier曲线可以定义为任意度n。
         *
         * @param t 插值度
         * @param ps 点列表 ps.length == n+1
         * @param processs 收集中间过程数据，可用作Bézier曲线动画数据
         */
        BezierCurve.prototype.bn = function (t, ps, processs) {
            if (processs === void 0) { processs = null; }
            ps = ps.concat();
            if (processs)
                processs.push(ps.concat());
            // n次Bézier递推
            for (var i = ps.length - 1; i > 0; i--) {
                for (var j = 0; j < i; j++) {
                    ps[j] = (1 - t) * ps[j] + t * ps[j + 1];
                }
                if (processs) {
                    ps.length = ps.length - 1;
                    processs.push(ps.concat());
                }
            }
            return ps[0];
        };
        /**
         * n次Bézier曲线关于t的导数
         *
         * 一般定义
         *
         * Bézier曲线可以定义为任意度n。
         *
         * @param t 插值度
         * @param ps 点列表 ps.length == n+1
         */
        BezierCurve.prototype.bnDerivative = function (t, ps) {
            if (ps.length < 2)
                return 0;
            ps = ps.concat();
            // 进行
            for (var i = 0, n = ps.length - 1; i < n; i++) {
                ps[i] = ps[i + 1] - ps[i];
            }
            //
            ps.length = ps.length - 1;
            var v = ps.length * this.bn(t, ps);
            return v;
        };
        /**
         * n次Bézier曲线关于t的二阶导数
         *
         * 一般定义
         *
         * Bézier曲线可以定义为任意度n。
         *
         * @param t 插值度
         * @param ps 点列表 ps.length == n+1
         */
        BezierCurve.prototype.bnSecondDerivative = function (t, ps) {
            if (ps.length < 3)
                return 0;
            ps = ps.concat();
            // 进行
            for (var i = 0, n = ps.length - 1; i < n; i++) {
                ps[i] = ps[i + 1] - ps[i];
            }
            //
            ps.length = ps.length - 1;
            var v = ps.length * this.bnDerivative(t, ps);
            return v;
        };
        /**
         * n次Bézier曲线关于t的dn阶导数
         *
         * Bézier曲线可以定义为任意度n。
         *
         * @param t 插值度
         * @param dn 求导次数
         * @param ps 点列表     ps.length == n+1
         */
        BezierCurve.prototype.bnND = function (t, dn, ps) {
            if (ps.length < dn + 1)
                return 0;
            var factorial = 1;
            ps = ps.concat();
            for (var j = 0; j < dn; j++) {
                // 进行
                for (var i = 0, n = ps.length - 1; i < n; i++) {
                    ps[i] = ps[i + 1] - ps[i];
                }
                //
                ps.length = ps.length - 1;
                factorial *= ps.length;
            }
            var v = factorial * this.bn(t, ps);
            return v;
        };
        /**
         * 获取曲线在指定插值度上的值
         * @param t 插值度
         * @param ps 点列表
         */
        BezierCurve.prototype.getValue = function (t, ps) {
            if (ps.length == 2) {
                return this.linear(t, ps[0], ps[1]);
            }
            if (ps.length == 3) {
                return this.quadratic(t, ps[0], ps[1], ps[2]);
            }
            if (ps.length == 4) {
                return this.cubic(t, ps[0], ps[1], ps[2], ps[3]);
            }
            return this.bn(t, ps);
            // var t1 = 1 - t;
            // return t1 * t1 * t1 * ps[0] + 3 * t1 * t1 * t * ps[1] + 3 * t1 * t * t * ps[2] + t * t * t * ps[3];
        };
        /**
         * 获取曲线在指定插值度上的导数(斜率)
         * @param t 插值度
         * @param ps 点列表
         */
        BezierCurve.prototype.getDerivative = function (t, ps) {
            if (ps.length == 2) {
                return this.linearDerivative(t, ps[0], ps[1]);
            }
            if (ps.length == 3) {
                return this.quadraticDerivative(t, ps[0], ps[1], ps[2]);
            }
            if (ps.length == 4) {
                return this.cubicDerivative(t, ps[0], ps[1], ps[2], ps[3]);
            }
            return this.bnDerivative(t, ps);
            // return 3 * (1 - t) * (1 - t) * (ps[1] - ps[0]) + 6 * (1 - t) * t * (ps[2] - ps[1]) + 3 * t * t * (ps[3] - ps[2]);
        };
        /**
         * 获取曲线在指定插值度上的二阶导数
         * @param t 插值度
         * @param ps 点列表
         */
        BezierCurve.prototype.getSecondDerivative = function (t, ps) {
            if (ps.length == 2) {
                return this.linearSecondDerivative(t, ps[0], ps[1]);
            }
            if (ps.length == 3) {
                return this.quadraticSecondDerivative(t, ps[0], ps[1], ps[2]);
            }
            if (ps.length == 4) {
                return this.cubicSecondDerivative(t, ps[0], ps[1], ps[2], ps[3]);
            }
            return this.bnSecondDerivative(t, ps);
            // return 3 * (1 - t) * (1 - t) * (ps[1] - ps[0]) + 6 * (1 - t) * t * (ps[2] - ps[1]) + 3 * t * t * (ps[3] - ps[2]);
        };
        /**
         * 查找区间内极值列表
         *
         * @param ps 点列表
         * @param numSamples 采样次数，用于分段查找极值
         * @param precision  查找精度
         *
         * @returns 极值列表 {} {ts: 极值插值度列表,vs: 极值值列表}
         */
        BezierCurve.prototype.getExtremums = function (ps, numSamples, precision) {
            var _this = this;
            if (numSamples === void 0) { numSamples = 10; }
            if (precision === void 0) { precision = 0.0000001; }
            var samples = [];
            for (var i = 0; i <= numSamples; i++) {
                samples.push(this.getDerivative(i / numSamples, ps));
            }
            // 查找存在解的分段
            //
            var resultTs = [];
            var resultVs = [];
            for (var i = 0, n = numSamples; i < n; i++) {
                if (samples[i] * samples[i + 1] < 0) {
                    var guessT = feng3d.equationSolving.line(function (x) { return _this.getDerivative(x, ps); }, i / numSamples, (i + 1) / numSamples, precision);
                    resultTs.push(guessT);
                    resultVs.push(this.getValue(guessT, ps));
                }
            }
            return { ts: resultTs, vs: resultVs };
        };
        /**
         * 获取单调区间列表
         * @returns {} {ts: 区间结点插值度列表,vs: 区间结点值列表}
         */
        BezierCurve.prototype.getMonotoneIntervals = function (ps, numSamples, precision) {
            if (numSamples === void 0) { numSamples = 10; }
            if (precision === void 0) { precision = 0.0000001; }
            // 区间内的单调区间
            var monotoneIntervalTs = [0, 1];
            var monotoneIntervalVs = [ps[0], ps[ps.length - 1]];
            // 预先计算好极值
            var extremums = this.getExtremums(ps, numSamples, precision);
            for (var i = 0; i < extremums.ts.length; i++) {
                // 增加单调区间
                monotoneIntervalTs.splice(i + 1, 0, extremums.ts[i]);
                monotoneIntervalVs.splice(i + 1, 0, extremums.vs[i]);
            }
            return { ts: monotoneIntervalTs, vs: monotoneIntervalVs };
        };
        /**
         * 获取目标值所在的插值度T
         *
         * @param targetV 目标值
         * @param ps 点列表
         * @param numSamples 分段数量，用于分段查找，用于解决寻找多个解、是否无解等问题；过少的分段可能会造成找不到存在的解决，过多的分段将会造成性能很差。
         * @param precision  查找精度
         *
         * @returns 返回解数组
         */
        BezierCurve.prototype.getTFromValue = function (targetV, ps, numSamples, precision) {
            var _this = this;
            if (numSamples === void 0) { numSamples = 10; }
            if (precision === void 0) { precision = 0.0000001; }
            // 获取单调区间
            var monotoneIntervals = this.getMonotoneIntervals(ps, numSamples, precision);
            var monotoneIntervalTs = monotoneIntervals.ts;
            var monotoneIntervalVs = monotoneIntervals.vs;
            // 存在解的单调区间
            var results = [];
            // 遍历单调区间
            for (var i = 0, n = monotoneIntervalVs.length - 1; i < n; i++) {
                if ((monotoneIntervalVs[i] - targetV) * (monotoneIntervalVs[i + 1] - targetV) <= 0) {
                    var fx = function (x) { return _this.getValue(x, ps) - targetV; };
                    // 连线法
                    var result = feng3d.equationSolving.line(fx, monotoneIntervalTs[i], monotoneIntervalTs[i + 1], precision);
                    results.push(result);
                }
            }
            return results;
        };
        /**
         * 分割曲线
         *
         * 在曲线插值度t位置分割为两条连接起来与原曲线完全重合的曲线
         *
         * @param t 分割位置（插值度）
         * @param ps 被分割曲线点列表
         * @returns 返回两条曲线组成的数组
         */
        BezierCurve.prototype.split = function (t, ps) {
            // 获取曲线的动画过程
            var processs = [];
            feng3d.bezierCurve.bn(t, ps, processs);
            // 第一条曲线
            var fps = [];
            // 第二条曲线
            var sps = [];
            // 使用当前t值进行分割曲线
            for (var i = processs.length - 1; i >= 0; i--) {
                if (i == processs.length - 1) {
                    // 添加关键点
                    fps.push(processs[i][0]);
                    fps.push(processs[i][0]);
                }
                else {
                    // 添加左右控制点
                    fps.unshift(processs[i][0]);
                    sps.push(processs[i].pop());
                }
            }
            return [fps, sps];
        };
        /**
         * 合并曲线
         *
         * 合并两条连接的曲线为一条曲线并且可以还原为分割前的曲线
         *
         * @param fps 第一条曲线点列表
         * @param sps 第二条曲线点列表
         * @param mergeType 合并方式。mergeType = 0时进行还原合并，还原拆分之前的曲线；mergeType = 1时进行拟合合并，合并后的曲线会经过两条曲线的连接点；
         */
        BezierCurve.prototype.merge = function (fps, sps, mergeType) {
            if (mergeType === void 0) { mergeType = 0; }
            fps = fps.concat();
            sps = sps.concat();
            var processs = [];
            var t;
            // 上条曲线
            var pps;
            // 当前曲线
            var ps;
            for (var i = 0, n = fps.length; i < n; i++) {
                ps = processs[i] = [];
                if (i == 0) {
                    processs[i][0] = fps.pop();
                    sps.shift();
                }
                else if (i == 1) {
                    // 计算t值
                    processs[i][0] = fps.pop();
                    processs[i][1] = sps.shift();
                    t = (processs[i - 1][0] - processs[i][0]) / (processs[i][1] - processs[i][0]);
                }
                else {
                    pps = processs[i - 1];
                    // 前面增加点
                    var nfp = fps.pop();
                    // 后面增加点
                    var nsp = sps.shift();
                    // 从前往后计算
                    var ps0 = [];
                    ps0[0] = nfp;
                    for (var j = 0, n_1 = pps.length; j < n_1; j++) {
                        ps0[j + 1] = ps0[j] + (pps[j] - ps0[j]) / t;
                    }
                    // 从后往前计算
                    var ps1 = [];
                    ps1[pps.length] = nsp;
                    for (var j = pps.length - 1; j >= 0; j--) {
                        ps1[j] = ps1[j + 1] - (ps1[j + 1] - pps[j]) / (1 - t);
                    }
                    // 拟合合并,合并前后两个方向的计算
                    if (mergeType == 1) {
                        for (var j = 0, n_2 = ps0.length - 1; j <= n_2; j++) {
                            ps[j] = (ps0[j] * (n_2 - j) + ps1[j] * j) / n_2;
                        }
                    }
                    else if (mergeType == 0) {
                        // 还原合并，前半段使用从前往后计算，后半段使用从后往前计算
                        for (var j = 0, n_3 = ps0.length - 1; j <= n_3; j++) {
                            if (j < n_3 / 2) {
                                ps[j] = ps0[j];
                            }
                            else if (j > n_3 / 2) {
                                ps[j] = ps1[j];
                            }
                            else {
                                ps[j] = (ps0[j] + ps1[j]) / 2;
                            }
                        }
                    }
                    else {
                        console.error("\u5408\u5E76\u7C7B\u578B mergeType " + mergeType + " \u9519\u8BEF!");
                    }
                }
            }
            return processs.pop();
        };
        /**
         * 获取曲线样本数据
         *
         * 这些点可用于连线来拟合曲线。
         *
         * @param ps 点列表
         * @param num 采样次数 ，采样点分别为[0,1/num,2/num,....,(num-1)/num,1]
         */
        BezierCurve.prototype.getSamples = function (ps, num) {
            if (num === void 0) { num = 100; }
            var results = [];
            for (var i = 0; i <= num; i++) {
                var t = i / num;
                var p = this.getValue(t, ps);
                results.push({ t: t, v: p });
            }
            return results;
        };
        return BezierCurve;
    }());
    feng3d.BezierCurve = BezierCurve;
    feng3d.bezierCurve = new BezierCurve();
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 动画关键帧
     */
    var AnimationCurveKeyframe = /** @class */ (function () {
        function AnimationCurveKeyframe(v) {
            feng3d.serialization.setValue(this, v);
            return this;
        }
        __decorate([
            feng3d.serialize
        ], AnimationCurveKeyframe.prototype, "time", void 0);
        __decorate([
            feng3d.serialize
        ], AnimationCurveKeyframe.prototype, "value", void 0);
        __decorate([
            feng3d.serialize
        ], AnimationCurveKeyframe.prototype, "tangent", void 0);
        return AnimationCurveKeyframe;
    }());
    feng3d.AnimationCurveKeyframe = AnimationCurveKeyframe;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 动画曲线Wrap模式，处理超出范围情况
     */
    var AnimationCurveWrapMode;
    (function (AnimationCurveWrapMode) {
        /**
         * 循环; 0->1,0->1
         */
        AnimationCurveWrapMode[AnimationCurveWrapMode["Loop"] = 0] = "Loop";
        /**
         * 来回循环; 0->1,1->0
         */
        AnimationCurveWrapMode[AnimationCurveWrapMode["PingPong"] = 1] = "PingPong";
        /**
         * 夹紧; 0>-<1
         */
        AnimationCurveWrapMode[AnimationCurveWrapMode["Clamp"] = 2] = "Clamp";
    })(AnimationCurveWrapMode = feng3d.AnimationCurveWrapMode || (feng3d.AnimationCurveWrapMode = {}));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 动画曲线
     *
     * 基于时间轴的连续三阶Bézier曲线
     */
    var AnimationCurve = /** @class */ (function () {
        function AnimationCurve() {
            /**
             * 最大tan值，超出该值后将会变成分段
             */
            this.maxtan = 1000;
            /**
             * 关键帧
             *
             * 注： 该值已对时间排序，否则赋值前请使用 sort((a, b) => a.time - b.time) 进行排序
             */
            this.keys = [{ time: 0, value: 1, tangent: 0 }, { time: 1, value: 1, tangent: 0 }];
            /**
             * Wrap模式
             */
            this.wrapMode = feng3d.AnimationCurveWrapMode.Clamp;
        }
        Object.defineProperty(AnimationCurve.prototype, "numKeys", {
            /**
             * 关键点数量
             */
            get: function () {
                return this.keys.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 添加关键点
         *
         * 添加关键点后将会执行按t进行排序
         *
         * @param key 关键点
         */
        AnimationCurve.prototype.addKey = function (key) {
            this.keys.push(key);
            this.sort();
        };
        /**
         * 关键点排序
         *
         * 当移动关键点或者新增关键点时需要再次排序
         */
        AnimationCurve.prototype.sort = function () {
            this.keys.sort(function (a, b) { return a.time - b.time; });
        };
        /**
         * 删除关键点
         * @param key 关键点
         */
        AnimationCurve.prototype.deleteKey = function (key) {
            var index = this.keys.indexOf(key);
            if (index != -1)
                this.keys.splice(index, 1);
        };
        /**
         * 获取关键点
         * @param index 索引
         */
        AnimationCurve.prototype.getKey = function (index) {
            return this.keys[index];
        };
        /**
         * 获取关键点索引
         * @param key 关键点
         */
        AnimationCurve.prototype.indexOfKeys = function (key) {
            return this.keys.indexOf(key);
        };
        /**
         * 获取曲线上点信息
         * @param t 时间轴的位置 [0,1]
         */
        AnimationCurve.prototype.getPoint = function (t) {
            switch (this.wrapMode) {
                case feng3d.AnimationCurveWrapMode.Clamp:
                    t = Math.clamp(t, 0, 1);
                    break;
                case feng3d.AnimationCurveWrapMode.Loop:
                    t = Math.clamp(t - Math.floor(t), 0, 1);
                    break;
                case feng3d.AnimationCurveWrapMode.PingPong:
                    t = Math.clamp(t - Math.floor(t), 0, 1);
                    if (Math.floor(t) % 2 == 1)
                        t = 1 - t;
                    break;
            }
            var keys = this.keys;
            var maxtan = this.maxtan;
            var value = 0, tangent = 0, isfind = false;
            ;
            for (var i = 0, n = keys.length; i < n; i++) {
                // 使用 bezierCurve 进行采样曲线点
                var key = keys[i];
                var prekey = keys[i - 1];
                if (i > 0 && prekey.time <= t && t <= key.time) {
                    var xstart = prekey.time;
                    var ystart = prekey.value;
                    var tanstart = prekey.tangent;
                    var xend = key.time;
                    var yend = key.value;
                    var tanend = key.tangent;
                    if (maxtan > Math.abs(tanstart) && maxtan > Math.abs(tanend)) {
                        var ct = (t - prekey.time) / (key.time - prekey.time);
                        var sys = [ystart, ystart + tanstart * (xend - xstart) / 3, yend - tanend * (xend - xstart) / 3, yend];
                        var fy = feng3d.bezierCurve.getValue(ct, sys);
                        isfind = true;
                        value = fy;
                        tangent = feng3d.bezierCurve.getDerivative(ct, sys) / (xend - xstart);
                        break;
                    }
                    else {
                        isfind = true;
                        value = prekey.value;
                        tangent = 0;
                        break;
                    }
                }
                if (i == 0 && t <= key.time) {
                    isfind = true;
                    value = key.value;
                    tangent = 0;
                    break;
                }
                if (i == n - 1 && t >= key.time) {
                    isfind = true;
                    value = key.value;
                    tangent = 0;
                    break;
                }
            }
            if (keys.length == 0)
                return new feng3d.AnimationCurveKeyframe({ time: t, value: 0, tangent: 0 });
            feng3d.debuger && console.assert(isfind);
            return new feng3d.AnimationCurveKeyframe({ time: t, value: value, tangent: tangent });
        };
        /**
         * 获取值
         * @param t 时间轴的位置 [0,1]
         */
        AnimationCurve.prototype.getValue = function (t) {
            var point = this.getPoint(t);
            if (!point)
                return 0;
            return point.value;
        };
        /**
         * 查找关键点
         * @param t 时间轴的位置 [0,1]
         * @param y 值
         * @param precision 查找精度
         */
        AnimationCurve.prototype.findKey = function (t, y, precision) {
            var keys = this.keys;
            for (var i = 0; i < keys.length; i++) {
                if (Math.abs(keys[i].time - t) < precision && Math.abs(keys[i].value - y) < precision) {
                    return keys[i];
                }
            }
            return null;
        };
        /**
         * 添加曲线上的关键点
         *
         * 如果该点在曲线上，则添加关键点
         *
         * @param time 时间轴的位置 [0,1]
         * @param value 值
         * @param precision 查找进度
         */
        AnimationCurve.prototype.addKeyAtCurve = function (time, value, precision) {
            var point = this.getPoint(time);
            if (Math.abs(value - point.value) < precision) {
                this.keys.push(point);
                this.keys.sort(function (a, b) { return a.time - b.time; });
                return point;
            }
            return null;
        };
        /**
         * 获取曲线样本数据
         *
         * 这些点可用于连线来拟合曲线。
         *
         * @param num 采样次数 ，采样点分别为[0,1/num,2/num,....,(num-1)/num,1]
         */
        AnimationCurve.prototype.getSamples = function (num) {
            if (num === void 0) { num = 100; }
            var results = [];
            for (var i = 0; i <= num; i++) {
                var p = this.getPoint(i / num);
                results.push(p);
            }
            return results;
        };
        __decorate([
            feng3d.serialize
        ], AnimationCurve.prototype, "keys", void 0);
        __decorate([
            feng3d.serialize
        ], AnimationCurve.prototype, "wrapMode", void 0);
        return AnimationCurve;
    }());
    feng3d.AnimationCurve = AnimationCurve;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 曲线模式
     */
    var MinMaxCurveMode;
    (function (MinMaxCurveMode) {
        /**
         * 常量
         */
        MinMaxCurveMode[MinMaxCurveMode["Constant"] = 0] = "Constant";
        /**
         * 曲线
         */
        MinMaxCurveMode[MinMaxCurveMode["Curve"] = 1] = "Curve";
        /**
         * 两个常量间取随机值
         */
        MinMaxCurveMode[MinMaxCurveMode["RandomBetweenTwoConstants"] = 2] = "RandomBetweenTwoConstants";
        /**
         * 两个曲线中取随机值
         */
        MinMaxCurveMode[MinMaxCurveMode["RandomBetweenTwoCurves"] = 3] = "RandomBetweenTwoCurves";
    })(MinMaxCurveMode = feng3d.MinMaxCurveMode || (feng3d.MinMaxCurveMode = {}));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 最大最小曲线
     */
    var MinMaxCurve = /** @class */ (function () {
        function MinMaxCurve() {
            /**
             * 模式
             */
            this.mode = feng3d.MinMaxCurveMode.Constant;
            /**
             * 常量值
             */
            this.constant = 0;
            /**
             * 常量值，用于 MinMaxCurveMode.RandomBetweenTwoConstants
             */
            this.constant1 = 0;
            /**
             * 曲线，用于 MinMaxCurveMode.RandomBetweenTwoCurves
             */
            this.curve = new feng3d.AnimationCurve();
            /**
             * 曲线1
             */
            this.curve1 = feng3d.serialization.setValue(new feng3d.AnimationCurve(), { keys: [{ time: 0, value: 0, tangent: 0 }, { time: 1, value: 1, tangent: 0 }] });
            /**
             * 曲线缩放比
             */
            this.curveMultiplier = 1;
            /**
             * 是否只取 0-1 ，例如 lifetime 为非负，需要设置为true
             */
            this.between0And1 = false;
        }
        /**
         * 获取值
         * @param time 时间
         */
        MinMaxCurve.prototype.getValue = function (time) {
            switch (this.mode) {
                case feng3d.MinMaxCurveMode.Constant:
                    return this.constant;
                case feng3d.MinMaxCurveMode.Curve:
                    return this.curve.getValue(time) * this.curveMultiplier;
                case feng3d.MinMaxCurveMode.RandomBetweenTwoConstants:
                    return Math.lerp(this.constant, this.constant1, Math.random());
                case feng3d.MinMaxCurveMode.RandomBetweenTwoCurves:
                    return Math.lerp(this.curve.getValue(time), this.curve1.getValue(time), Math.random()) * this.curveMultiplier;
            }
            return this.constant;
        };
        __decorate([
            feng3d.serialize
        ], MinMaxCurve.prototype, "mode", void 0);
        __decorate([
            feng3d.serialize
        ], MinMaxCurve.prototype, "constant", void 0);
        __decorate([
            feng3d.serialize
        ], MinMaxCurve.prototype, "constant1", void 0);
        __decorate([
            feng3d.serialize
        ], MinMaxCurve.prototype, "curve", void 0);
        __decorate([
            feng3d.serialize
        ], MinMaxCurve.prototype, "curve1", void 0);
        __decorate([
            feng3d.serialize
        ], MinMaxCurve.prototype, "curveMultiplier", void 0);
        __decorate([
            feng3d.serialize
        ], MinMaxCurve.prototype, "between0And1", void 0);
        return MinMaxCurve;
    }());
    feng3d.MinMaxCurve = MinMaxCurve;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var MinMaxCurveVector3 = /** @class */ (function () {
        function MinMaxCurveVector3() {
            /**
             * x 曲线
             */
            this.xCurve = new feng3d.MinMaxCurve();
            /**
             * y 曲线
             */
            this.yCurve = new feng3d.MinMaxCurve();
            /**
             * z 曲线
             */
            this.zCurve = new feng3d.MinMaxCurve();
        }
        /**
         * 获取值
         * @param time 时间
         */
        MinMaxCurveVector3.prototype.getValue = function (time) {
            return new feng3d.Vector3(this.xCurve.getValue(time), this.yCurve.getValue(time), this.zCurve.getValue(time));
        };
        __decorate([
            feng3d.serialize
        ], MinMaxCurveVector3.prototype, "xCurve", void 0);
        __decorate([
            feng3d.serialize
        ], MinMaxCurveVector3.prototype, "yCurve", void 0);
        __decorate([
            feng3d.serialize
        ], MinMaxCurveVector3.prototype, "zCurve", void 0);
        return MinMaxCurveVector3;
    }());
    feng3d.MinMaxCurveVector3 = MinMaxCurveVector3;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 事件
     */
    var FEvent = /** @class */ (function () {
        function FEvent() {
            this.feventMap = new Map();
        }
        FEvent.prototype.getBubbleTargets = function (target) {
            return [target["parent"]];
        };
        /**
         * 监听一次事件后将会被移除
         * @param type						事件的类型。
         * @param listener					处理事件的侦听器函数。
         * @param thisObject                listener函数作用域
         * @param priority					事件侦听器的优先级。数字越大，优先级越高。默认优先级为 0。
         */
        FEvent.prototype.once = function (obj, type, listener, thisObject, priority) {
            if (thisObject === void 0) { thisObject = null; }
            if (priority === void 0) { priority = 0; }
            this.on(obj, type, listener, thisObject, priority, true);
        };
        /**
         * 派发事件
         *
         * 当事件重复流向一个对象时将不会被处理。
         *
         * @param e   事件对象
         * @returns 返回事件是否被该对象处理
         */
        FEvent.prototype.dispatchEvent = function (obj, e) {
            var targets = e.targets = e.targets || [];
            if (targets.indexOf(obj) != -1)
                return false;
            targets.push(obj);
            e.handles = [];
            this.handleEvent(obj, e);
            this.handelEventBubbles(obj, e);
            return true;
        };
        /**
         * 将事件调度到事件流中. 事件目标是对其调用 dispatchEvent() 方法的 IEvent 对象。
         * @param type                      事件的类型。类型区分大小写。
         * @param data                      事件携带的自定义数据。
         * @param bubbles                   表示事件是否为冒泡事件。如果事件可以冒泡，则此值为 true；否则为 false。
         */
        FEvent.prototype.dispatch = function (obj, type, data, bubbles) {
            if (bubbles === void 0) { bubbles = false; }
            var e = { type: type, data: data, bubbles: bubbles, target: null, currentTarget: null, isStop: false, isStopBubbles: false, targets: [], handles: [] };
            this.dispatchEvent(obj, e);
            return e;
        };
        /**
         * 检查 Event 对象是否为特定事件类型注册了任何侦听器.
         *
         * @param type		事件的类型。
         * @return 			如果指定类型的侦听器已注册，则值为 true；否则，值为 false。
         */
        FEvent.prototype.has = function (obj, type) {
            return !!(this.feventMap.get(obj) && this.feventMap.get(obj)[type] && this.feventMap.get(obj)[type].length);
        };
        /**
         * 添加监听
         * @param type						事件的类型。
         * @param listener					处理事件的侦听器函数。
         * @param priority					事件侦听器的优先级。数字越大，优先级越高。默认优先级为 0。
         */
        FEvent.prototype.on = function (obj, type, listener, thisObject, priority, once) {
            if (priority === void 0) { priority = 0; }
            if (once === void 0) { once = false; }
            var objectListener = this.feventMap.get(obj);
            if (!objectListener)
                (this.feventMap.set(obj, objectListener = {}));
            var listeners = objectListener[type] = objectListener[type] || [];
            for (var i = 0; i < listeners.length; i++) {
                var element = listeners[i];
                if (element.listener == listener && element.thisObject == thisObject) {
                    listeners.splice(i, 1);
                    break;
                }
            }
            for (var i = 0; i < listeners.length; i++) {
                var element = listeners[i];
                if (priority > element.priority) {
                    break;
                }
            }
            listeners.splice(i, 0, { listener: listener, thisObject: thisObject, priority: priority, once: once });
        };
        /**
         * 移除监听
         * @param dispatcher 派发器
         * @param type						事件的类型。
         * @param listener					要删除的侦听器对象。
         */
        FEvent.prototype.off = function (obj, type, listener, thisObject) {
            if (!type) {
                this.feventMap.delete(obj);
                return;
            }
            if (!listener) {
                if (this.feventMap.get(obj))
                    delete this.feventMap.get(obj)[type];
                return;
            }
            var listeners = this.feventMap.get(obj) && this.feventMap.get(obj)[type];
            if (listeners) {
                for (var i = listeners.length - 1; i >= 0; i--) {
                    var element = listeners[i];
                    if (element.listener == listener && element.thisObject == thisObject) {
                        listeners.splice(i, 1);
                    }
                }
                if (listeners.length == 0) {
                    delete this.feventMap.get(obj)[type];
                }
            }
        };
        /**
         * 监听对象的所有事件
         * @param obj 被监听对象
         * @param listener 回调函数
         * @param thisObject 回调函数 this 指针
         * @param priority 优先级
         */
        FEvent.prototype.onAll = function (obj, listener, thisObject, priority) {
            if (priority === void 0) { priority = 0; }
            var objectListener = this.feventMap.get(obj);
            if (!objectListener)
                (this.feventMap.set(obj, objectListener = {}));
            var listeners = objectListener.__allEventType__ = objectListener.__allEventType__ || [];
            for (var i = 0; i < listeners.length; i++) {
                var element = listeners[i];
                if (element.listener == listener && element.thisObject == thisObject) {
                    listeners.splice(i, 1);
                    break;
                }
            }
            for (var i = 0; i < listeners.length; i++) {
                var element = listeners[i];
                if (priority > element.priority) {
                    break;
                }
            }
            listeners.splice(i, 0, { listener: listener, thisObject: thisObject, priority: priority, once: false });
        };
        /**
         * 移除监听对象的所有事件
         * @param obj 被监听对象
         * @param listener 回调函数
         * @param thisObject 回调函数 this 指针
         */
        FEvent.prototype.offAll = function (obj, listener, thisObject) {
            if (!listener) {
                if (this.feventMap.get(obj))
                    delete this.feventMap.get(obj).__allEventType__;
                return;
            }
            var listeners = this.feventMap.get(obj) && this.feventMap.get(obj).__allEventType__;
            if (listeners) {
                for (var i = listeners.length - 1; i >= 0; i--) {
                    var element = listeners[i];
                    if (element.listener == listener && element.thisObject == thisObject) {
                        listeners.splice(i, 1);
                    }
                }
                if (listeners.length == 0) {
                    delete this.feventMap.get(obj).__allEventType__;
                }
            }
        };
        /**
         * 处理事件
         * @param e 事件
         */
        FEvent.prototype.handleEvent = function (obj, e) {
            //设置目标
            e.target || (e.target = obj);
            try {
                //使用 try 处理 MouseEvent 等无法更改currentTarget的对象
                e.currentTarget = obj;
            }
            catch (error) { }
            var listeners = this.feventMap.get(obj) && this.feventMap.get(obj)[e.type];
            if (listeners) {
                //遍历调用事件回调函数
                var listeners0 = listeners.concat();
                for (var i = 0; i < listeners0.length && !e.isStop; i++) {
                    listeners0[i].listener.call(listeners0[i].thisObject, e); //此处可能会删除当前事件，所以上面必须拷贝
                    e.handles.push(listeners0[i]);
                }
                for (var i = listeners.length - 1; i >= 0; i--) {
                    if (listeners[i].once)
                        listeners.splice(i, 1);
                }
                if (listeners.length == 0)
                    delete this.feventMap.get(obj)[e.type];
            }
            // All_EVENT_Type
            listeners = this.feventMap.get(obj) && this.feventMap.get(obj).__allEventType__;
            if (listeners) {
                //遍历调用事件回调函数
                var listeners0 = listeners.concat();
                for (var i = 0; i < listeners0.length && !e.isStop; i++) {
                    listeners0[i].listener.call(listeners0[i].thisObject, e); //此处可能会删除当前事件，所以上面必须拷贝
                }
                for (var i = listeners.length - 1; i >= 0; i--) {
                    if (listeners[i].once)
                        listeners.splice(i, 1);
                }
                if (listeners.length == 0)
                    delete this.feventMap.get(obj).__allEventType__;
            }
        };
        /**
         * 处理事件冒泡
         * @param e 事件
         */
        FEvent.prototype.handelEventBubbles = function (obj, e) {
            if (e.bubbles && !e.isStopBubbles) {
                var bubbleTargets = this.getBubbleTargets(obj);
                for (var i = 0, n = bubbleTargets.length; i < n; i++) {
                    var bubbleTarget = bubbleTargets[i];
                    if (!e.isStop && bubbleTarget && bubbleTarget.dispatchEvent)
                        bubbleTarget.dispatchEvent(e);
                }
            }
        };
        return FEvent;
    }());
    feng3d.FEvent = FEvent;
    feng3d.objectevent = feng3d.event = new FEvent();
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 事件适配器
     */
    var EventDispatcher = /** @class */ (function () {
        function EventDispatcher() {
        }
        /**
         * 监听一次事件后将会被移除
         * @param type						事件的类型。
         * @param listener					处理事件的侦听器函数。
         * @param thisObject                listener函数作用域
         * @param priority					事件侦听器的优先级。数字越大，优先级越高。默认优先级为 0。
         */
        EventDispatcher.prototype.once = function (type, listener, thisObject, priority) {
            if (thisObject === void 0) { thisObject = null; }
            if (priority === void 0) { priority = 0; }
            feng3d.event.on(this, type, listener, thisObject, priority, true);
        };
        /**
         * 派发事件
         *
         * 当事件重复流向一个对象时将不会被处理。
         *
         * @param e   事件对象
         * @returns 返回事件是否被该对象处理
         */
        EventDispatcher.prototype.dispatchEvent = function (e) {
            return feng3d.event.dispatchEvent(this, e);
        };
        /**
         * 将事件调度到事件流中. 事件目标是对其调用 dispatchEvent() 方法的 IEvent 对象。
         * @param type                      事件的类型。类型区分大小写。
         * @param data                      事件携带的自定义数据。
         * @param bubbles                   表示事件是否为冒泡事件。如果事件可以冒泡，则此值为 true；否则为 false。
         */
        EventDispatcher.prototype.dispatch = function (type, data, bubbles) {
            if (bubbles === void 0) { bubbles = false; }
            return feng3d.event.dispatch(this, type, data, bubbles);
        };
        /**
         * 检查 Event 对象是否为特定事件类型注册了任何侦听器.
         *
         * @param type		事件的类型。
         * @return 			如果指定类型的侦听器已注册，则值为 true；否则，值为 false。
         */
        EventDispatcher.prototype.has = function (type) {
            return feng3d.event.has(this, type);
        };
        /**
         * 添加监听
         * @param type						事件的类型。
         * @param listener					处理事件的侦听器函数。
         * @param priority					事件侦听器的优先级。数字越大，优先级越高。默认优先级为 0。
         */
        EventDispatcher.prototype.on = function (type, listener, thisObject, priority, once) {
            if (priority === void 0) { priority = 0; }
            if (once === void 0) { once = false; }
            feng3d.event.on(this, type, listener, thisObject, priority, once);
        };
        /**
         * 移除监听
         * @param dispatcher 派发器
         * @param type						事件的类型。
         * @param listener					要删除的侦听器对象。
         */
        EventDispatcher.prototype.off = function (type, listener, thisObject) {
            feng3d.event.off(this, type, listener, thisObject);
        };
        /**
         * 监听对象的所有事件
         * @param obj 被监听对象
         * @param listener 回调函数
         * @param thisObject 回调函数 this 指针
         * @param priority 优先级
         */
        EventDispatcher.prototype.onAll = function (listener, thisObject, priority) {
            if (priority === void 0) { priority = 0; }
            feng3d.event.onAll(this, listener, thisObject, priority);
        };
        /**
         * 移除监听对象的所有事件
         * @param obj 被监听对象
         * @param listener 回调函数
         * @param thisObject 回调函数 this 指针
         */
        EventDispatcher.prototype.offAll = function (listener, thisObject) {
            feng3d.event.offAll(this, listener, thisObject);
        };
        /**
         * 处理事件
         * @param e 事件
         */
        EventDispatcher.prototype.handleEvent = function (e) {
            feng3d.event["handleEvent"](this, e);
        };
        /**
         * 处理事件冒泡
         * @param e 事件
         */
        EventDispatcher.prototype.handelEventBubbles = function (e) {
            feng3d.event["handelEventBubbles"](this, e);
        };
        return EventDispatcher;
    }());
    feng3d.EventDispatcher = EventDispatcher;
    feng3d.dispatcher = new EventDispatcher();
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 代理 EventTarget, 处理js事件中this关键字问题
     */
    var EventProxy = /** @class */ (function (_super) {
        __extends(EventProxy, _super);
        function EventProxy(target) {
            var _this = _super.call(this) || this;
            _this.pageX = 0;
            _this.pageY = 0;
            _this.clientX = 0;
            _this.clientY = 0;
            /**
             * 是否右击
             */
            _this.rightmouse = false;
            _this.key = "";
            _this.keyCode = 0;
            _this.deltaY = 0;
            _this.listentypes = [];
            /**
             * 处理鼠标按下时同时出发 "mousemove" 事件bug
             */
            _this.handleMouseMoveBug = true;
            /**
             * 键盘按下事件
             */
            _this.onMouseKey = function (event) {
                // this.clear();
                if (event["clientX"] != undefined) {
                    event = event;
                    _this.clientX = event.clientX;
                    _this.clientY = event.clientY;
                    _this.pageX = event.pageX;
                    _this.pageY = event.pageY;
                }
                if (event instanceof MouseEvent) {
                    _this.rightmouse = event.button == 2;
                    // 处理鼠标按下时同时出发 "mousemove" 事件bug
                    if (_this.handleMouseMoveBug) {
                        if (event.type == "mousedown") {
                            _this.mousedownposition = new feng3d.Vector2(event.clientX, event.clientY);
                        }
                        if (event.type == "mousemove") {
                            if (_this.mousedownposition) {
                                var position = new feng3d.Vector2(event.clientX, event.clientY);
                                if (position.equals(_this.mousedownposition)) {
                                    // console.log(`由于系统原因，触发mousedown同时触发了mousemove，此处屏蔽mousemove事件派发！`);
                                    return;
                                }
                            }
                        }
                        if (event.type == "mouseup") {
                            _this.mousedownposition = null;
                        }
                    }
                }
                if (event instanceof KeyboardEvent) {
                    _this.keyCode = event.keyCode;
                    _this.key = event.key;
                }
                if (event instanceof WheelEvent) {
                    _this.deltaY = event.deltaY;
                }
                // 赋值上次鼠标事件值
                // event.clientX = this.clientX;
                // event.clientY = this.clientY;
                // event.pageX = this.pageX;
                // event.pageY = this.pageY;
                _this.dispatchEvent(event);
            };
            _this.target = target;
            return _this;
        }
        Object.defineProperty(EventProxy.prototype, "target", {
            get: function () {
                return this._target;
            },
            set: function (v) {
                var _this = this;
                if (this._target == v)
                    return;
                if (this._target) {
                    this.listentypes.forEach(function (element) {
                        _this._target.removeEventListener(element, _this.onMouseKey);
                    });
                }
                this._target = v;
                if (this._target) {
                    this.listentypes.forEach(function (element) {
                        _this._target.addEventListener(element, _this.onMouseKey);
                    });
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 监听一次事件后将会被移除
         * @param type						事件的类型。
         * @param listener					处理事件的侦听器函数。
         * @param thisObject                listener函数作用域
         * @param priority					事件侦听器的优先级。数字越大，优先级越高。默认优先级为 0。
         */
        EventProxy.prototype.once = function (type, listener, thisObject, priority) {
            this.on(type, listener, thisObject, priority, true);
        };
        /**
         * 添加监听
         * @param type						事件的类型。
         * @param listener					处理事件的侦听器函数。
         * @param priority					事件侦听器的优先级。数字越大，优先级越高。默认优先级为 0。
         */
        EventProxy.prototype.on = function (type, listener, thisObject, priority, once) {
            if (priority === void 0) { priority = 0; }
            if (once === void 0) { once = false; }
            _super.prototype.on.call(this, type, listener, thisObject, priority, once);
            if (this.listentypes.indexOf(type) == -1) {
                this.listentypes.push(type);
                this._target.addEventListener(type, this.onMouseKey);
            }
        };
        /**
         * 移除监听
         * @param dispatcher 派发器
         * @param type						事件的类型。
         * @param listener					要删除的侦听器对象。
         */
        EventProxy.prototype.off = function (type, listener, thisObject) {
            var _this = this;
            _super.prototype.off.call(this, type, listener, thisObject);
            if (!type) {
                this.listentypes.forEach(function (element) {
                    _this._target.removeEventListener(element, _this.onMouseKey);
                });
                this.listentypes.length = 0;
            }
            else if (!this.has(type)) {
                this._target.removeEventListener(type, this.onMouseKey);
                this.listentypes.splice(this.listentypes.indexOf(type), 1);
            }
        };
        /**
         * 清理数据
         */
        EventProxy.prototype.clear = function () {
            this.clientX = 0;
            this.clientY = 0;
            this.rightmouse = false;
            this.key = "";
            this.keyCode = 0;
            this.deltaY = 0;
        };
        return EventProxy;
    }(feng3d.EventDispatcher));
    feng3d.EventProxy = EventProxy;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var WindowEventProxy = /** @class */ (function (_super) {
        __extends(WindowEventProxy, _super);
        function WindowEventProxy() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return WindowEventProxy;
    }(feng3d.EventProxy));
    feng3d.WindowEventProxy = WindowEventProxy;
    if (typeof window != "undefined")
        feng3d.windowEventProxy = new WindowEventProxy(window);
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 任务
     *
     * 处理 异步任务(函数)串联并联执行功能
     */
    var Task = /** @class */ (function () {
        function Task() {
        }
        /**
         * 并联多个异步函数为一个函数
         *
         * 这些异步函数同时执行
         *
         * @param fns 一组异步函数
         */
        Task.prototype.parallel = function (fns) {
            var result = function (callback) {
                if (fns.length == 0) {
                    callback();
                    return;
                }
                var index = 0;
                fns.forEach(function (fn) {
                    var callbackNum = 0;
                    fn(function () {
                        callbackNum++;
                        if (callbackNum == 1) {
                            index++;
                            if (index == fns.length) {
                                callback();
                            }
                        }
                        else {
                            console.warn((fn.name ? "函数" + fn.name : "匿名函数") + " \u591A\u6B21\u8C03\u7528\u56DE\u8C03\u51FD\u6570\uFF0C\u5F53\u524D\u6B21\u6570 " + callbackNum);
                        }
                    });
                });
            };
            return result;
        };
        /**
         * 串联多个异步函数为一个函数
         *
         * 这些异步函数按顺序依次执行，等待前一个异步函数执行完调用回调后才执行下一个异步函数。
         *
         * @param fns 一组异步函数
         */
        Task.prototype.series = function (fns) {
            var result = function (callback) {
                if (fns.length == 0) {
                    callback();
                    return;
                }
                var index = 0;
                var next = function () {
                    var fn = fns[index];
                    var callbackNum = 0;
                    fn(function () {
                        callbackNum++;
                        if (callbackNum == 1) {
                            index++;
                            if (index < fns.length) {
                                next();
                            }
                            else {
                                callback && callback();
                            }
                        }
                        else {
                            console.warn((fn.name ? "函数" + fn.name : "匿名函数") + " \u591A\u6B21\u8C03\u7528\u56DE\u8C03\u51FD\u6570\uFF0C\u5F53\u524D\u6B21\u6570 " + callbackNum);
                        }
                    });
                };
                next();
            };
            return result;
        };
        /**
         * 创建一组并行同类任务，例如同时加载一组资源，并在回调中返回结果数组
         *
         * @param ps 一组参数
         * @param fn 单一任务函数
         * @param done 完成回调
         */
        Task.prototype.parallelResults = function (ps, fn, done) {
            var map = new Map();
            // 包装函数
            var fns = ps.map(function (p) { return function (callback) {
                fn(p, function (r) {
                    map.set(p, r);
                    callback();
                });
            }; });
            this.parallel(fns)(function () {
                var results = ps.map(function (p) {
                    return map.get(p);
                });
                map.clear();
                done(results);
            });
        };
        /**
         * 创建一组串联同类任务，例如排序加载一组资源
         *
         * @param ps 一组参数
         * @param fn 单一任务函数
         * @param done 完成回调
         */
        Task.prototype.seriesResults = function (ps, fn, done) {
            var map = new Map();
            // 包装函数
            var fns = ps.map(function (p) { return function (callback) {
                fn(p, function (r) {
                    map.set(p, r);
                    callback();
                });
            }; });
            this.series(fns)(function () {
                var results = ps.map(function (p) {
                    return map.get(p);
                });
                map.clear();
                done(results);
            });
        };
        return Task;
    }());
    feng3d.task = new Task();
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 所有feng3d对象的基类
     */
    var Feng3dObject = /** @class */ (function (_super) {
        __extends(Feng3dObject, _super);
        /**
         * 构建
         *
         * 新增不可修改属性 guid
         */
        function Feng3dObject() {
            var _this = _super.call(this) || this;
            /**
             * 隐藏标记，用于控制是否在层级界面、检查器显示，是否保存
             */
            _this.hideFlags = feng3d.HideFlags.None;
            Object.defineProperty(_this, "uuid", { value: Math.uuid() });
            Object.defineProperty(_this, "disposed", { value: false, configurable: true });
            feng3d.debuger && console.assert(!Feng3dObject.objectLib[_this.uuid], "\u552F\u4E00\u6807\u8BC6\u7B26\u5B58\u5728\u91CD\u590D\uFF01\uFF1F");
            Feng3dObject.objectLib[_this.uuid] = _this;
            return _this;
        }
        /**
         * 销毁
         */
        Feng3dObject.prototype.dispose = function () {
            Object.defineProperty(this, "disposed", { value: true, configurable: false });
        };
        /**
         * 获取对象
         *
         * @param uuid 通用唯一标识符
         */
        Feng3dObject.getObject = function (uuid) {
            return this.objectLib[uuid];
        };
        /**
         * 获取对象
         *
         * @param type
         */
        Feng3dObject.getObjects = function (type) {
            var _this = this;
            var objects = Object.keys(this.objectLib).map(function (v) { return _this.objectLib[v]; });
            //
            var filterResult = objects;
            if (type) {
                filterResult = objects.filter(function (v) { return v instanceof type; });
            }
            return filterResult;
        };
        __decorate([
            feng3d.serialize
        ], Feng3dObject.prototype, "hideFlags", void 0);
        return Feng3dObject;
    }(feng3d.EventDispatcher));
    feng3d.Feng3dObject = Feng3dObject;
    Object.defineProperty(Feng3dObject, "objectLib", { value: {} });
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 资源数据
     *
     * 该对象可由资源文件中读取，或者保存为资源
     */
    var AssetData = /** @class */ (function (_super) {
        __extends(AssetData, _super);
        function AssetData() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(AssetData.prototype, "name", {
            /**
             * 资源名称
             */
            get: function () {
                var asset = feng3d.rs.getAsset(this.assetId);
                if (asset)
                    this._name = asset.fileName;
                return this._name;
            },
            set: function (v) { this._name = v; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AssetData.prototype, "assetId", {
            /**
             * 资源编号
             */
            get: function () {
                return this._assetId;
            },
            set: function (v) {
                if (this._assetId == v)
                    return;
                if (this._assetId != undefined) {
                    feng3d.debuger && console.error("\u4E0D\u5141\u8BB8\u4FEE\u6539 assetId");
                    return;
                }
                this._assetId = v;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 新增资源数据
         *
         * @param assetId 资源编号
         * @param data 资源数据
         */
        AssetData.addAssetData = function (assetId, data) {
            if (!data)
                return;
            if (data.assetId != assetId)
                console.warn("\u540C\u4E00\u4E2A\u6750\u8D28\u88AB\u4FDD\u5B58\u5728\u591A\u4E2A\u8D44\u6E90\u4E2D\uFF01");
            this.assetMap.set(data, assetId);
            this.idAssetMap.set(assetId, data);
        };
        /**
         * 删除资源数据
         *
         * @param data 资源数据
         */
        AssetData.deleteAssetData = function (data) {
            if (!data)
                return;
            feng3d.debuger && console.assert(this.assetMap.has(data));
            var assetId = this.assetMap.get(data);
            this._delete(assetId, data);
        };
        AssetData.deleteAssetDataById = function (assetId) {
            feng3d.debuger && console.assert(this.idAssetMap.has(assetId));
            var data = this.idAssetMap.get(assetId);
            this._delete(assetId, data);
        };
        AssetData._delete = function (assetId, data) {
            this.assetMap.delete(data);
            this.idAssetMap.delete(assetId);
        };
        /**
         * 判断是否为资源数据
         *
         * @param asset 可能的资源数据
         */
        AssetData.isAssetData = function (asset) {
            if (!asset || asset.assetId == undefined)
                return false;
            if (feng3d.classUtils.getDefaultInstanceByName(asset[feng3d.CLASS_KEY]) instanceof AssetData)
                return true;
            return false;
        };
        /**
         * 序列化
         *
         * @param asset 资源数据
         */
        AssetData.serialize = function (asset) {
            var obj = {};
            obj[feng3d.CLASS_KEY] = feng3d.classUtils.getQualifiedClassName(asset);
            obj.assetId = asset.assetId;
            return obj;
        };
        /**
         * 反序列化
         *
         * @param object 资源对象
         */
        AssetData.deserialize = function (object) {
            var result = this.getLoadedAssetData(object.assetId);
            feng3d.debuger && console.assert(!!result, "\u8D44\u6E90 " + object.assetId + " \u672A\u52A0\u8F7D\uFF0C\u8BF7\u4F7F\u7528 ReadRS.deserializeWithAssets \u8FDB\u884C\u5E8F\u5217\u5316\u5305\u542B\u52A0\u8F7D\u7684\u8D44\u6E90\u5BF9\u8C61\u3002");
            return result;
        };
        /**
         * 获取已加载的资源数据
         *
         * @param assetId 资源编号
         */
        AssetData.getLoadedAssetData = function (assetId) {
            return this.idAssetMap.get(assetId);
        };
        /**
         * 获取所有已加载资源数据
         */
        AssetData.getAllLoadedAssetDatas = function () {
            return this.assetMap.getKeys();
        };
        /**
         * 资源属性标记名称
         */
        AssetData.assetPropertySign = "assetId";
        /**
         * 资源与编号对应表
         */
        AssetData.assetMap = new Map();
        /**
         * 编号与资源对应表
         */
        AssetData.idAssetMap = new Map();
        __decorate([
            feng3d.serialize
        ], AssetData.prototype, "name", null);
        __decorate([
            feng3d.serialize
        ], AssetData.prototype, "assetId", null);
        return AssetData;
    }(feng3d.Feng3dObject));
    feng3d.AssetData = AssetData;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    feng3d.loadjs = {
        load: load,
        ready: ready,
    };
    /**
     * 加载文件
     * @param params.paths          加载路径
     * @param params.bundleId       加载包编号
     * @param params.success        成功回调
     * @param params.error          错误回调
     * @param params.async          是否异步加载
     * @param params.numRetries     加载失败尝试次数
     * @param params.before         加载前回调
     * @param params.onitemload     单条文件加载完成回调
     */
    function load(params) {
        // throw error if bundle is already defined
        if (params.bundleId) {
            if (params.bundleId in bundleIdCache) {
                throw "LoadJS";
            }
            else {
                bundleIdCache[params.bundleId] = true;
            }
        }
        var paths = getPaths(params.paths);
        // load scripts
        loadFiles(paths, function (pathsNotFound) {
            // success and error callbacks
            if (pathsNotFound.length)
                (params.error || devnull)(pathsNotFound);
            else
                (params.success || devnull)();
            // publish bundle load event
            publish(params.bundleId, pathsNotFound);
        }, params);
    }
    /**
     * 准备依赖包
     * @param params.depends        依赖包编号
     * @param params.success        成功回调
     * @param params.error          错误回调
     */
    function ready(params) {
        // subscribe to bundle load event
        subscribe(params.depends, function (depsNotFound) {
            // execute callbacks
            if (depsNotFound.length)
                (params.error || devnull)(depsNotFound);
            else
                (params.success || devnull)();
        });
    }
    /**
     * 完成下载包
     * @param bundleId 下载包编号
     */
    function done(bundleId) {
        publish(bundleId, []);
    }
    /**
     * 重置下载包依赖状态
     */
    function reset() {
        bundleIdCache = {};
        bundleResultCache = {};
        bundleCallbackQueue = {};
    }
    /**
     * 是否定义下载包
     * @param {string} bundleId 包编号
     */
    function isDefined(bundleId) {
        return bundleId in bundleIdCache;
    }
    var devnull = function () { }, bundleIdCache = {}, bundleResultCache = {}, bundleCallbackQueue = {};
    /**
     * 订阅包加载事件
     * @param bundleIds              包编号
     * @param callbackFn             完成回调
     */
    function subscribe(bundleIds, callbackFn) {
        var depsNotFound = [];
        // listify
        if (bundleIds instanceof String) {
            bundleIds = [bundleIds];
        }
        // define callback function
        var numWaiting = bundleIds.length;
        var fn = function (bundleId, pathsNotFound) {
            if (pathsNotFound.length)
                depsNotFound.push(bundleId);
            numWaiting--;
            if (!numWaiting)
                callbackFn(depsNotFound);
        };
        // register callback
        var i = bundleIds.length;
        while (i--) {
            var bundleId = bundleIds[i];
            // execute callback if in result cache
            var r = bundleResultCache[bundleId];
            if (r) {
                fn(bundleId, r);
                continue;
            }
            // add to callback queue
            var q = bundleCallbackQueue[bundleId] = bundleCallbackQueue[bundleId] || [];
            q.push(fn);
        }
    }
    /**
     * 派发加载包完成事件
     * @param bundleId                  加载包编号
     * @param pathsNotFound             加载失败包
     */
    function publish(bundleId, pathsNotFound) {
        // exit if id isn't defined
        if (!bundleId)
            return;
        var q = bundleCallbackQueue[bundleId];
        // cache result
        bundleResultCache[bundleId] = pathsNotFound;
        // exit if queue is empty
        if (!q)
            return;
        // empty callback queue
        while (q.length) {
            q[0](bundleId, pathsNotFound);
            q.splice(0, 1);
        }
    }
    /**
     * 加载单个文件
     * @param path                          文件路径
     * @param callbackFn                    加载完成回调
     * @param args                          加载参数
     * @param args.async                    是否异步加载
     * @param args.numRetries               尝试加载次数
     * @param args.before                   加载前回调
     * @param numTries                      当前尝试次数
     */
    function loadFile(path, callbackFn, args, numTries) {
        var loaderFun = loaders[path.type] || loadTxt;
        loaderFun(path, callbackFn, args, numTries);
    }
    /**
     * 加载单个Image文件
     * @param path                          文件路径
     * @param callbackFn                    加载完成回调
     * @param args                          加载参数
     * @param args.async                    是否异步加载
     * @param args.numRetries               尝试加载次数
     * @param args.before                   加载前回调
     * @param numTries                      当前尝试次数
     */
    function loadImage(path, callbackFn, args, numTries) {
        if (numTries === void 0) { numTries = 0; }
        var image = new Image();
        image.crossOrigin = "Anonymous";
        image.onerror = image.onload = function (ev) {
            var result = ev.type;
            // handle retries in case of load failure
            if (result == 'error') {
                // increment counter
                numTries = ~~numTries + 1;
                // exit function and try again
                args.numRetries = args.numRetries || 0;
                if (numTries < ~~args.numRetries + 1) {
                    return loadImage(path, callbackFn, args, numTries);
                }
                image.src = "data:image/jpg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/4QBmRXhpZgAATU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAAExAAIAAAAQAAAATgAAAAAAAABgAAAAAQAAAGAAAAABcGFpbnQubmV0IDQuMC41AP/bAEMABAIDAwMCBAMDAwQEBAQFCQYFBQUFCwgIBgkNCw0NDQsMDA4QFBEODxMPDAwSGBITFRYXFxcOERkbGRYaFBYXFv/bAEMBBAQEBQUFCgYGChYPDA8WFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFv/AABEIAQABAAMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/APH6KKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76P//Z";
            }
            // execute callback
            callbackFn(path, result, ev.defaultPrevented, image);
        };
        //
        var beforeCallbackFn = args.before || (function () { return true; });
        if (beforeCallbackFn(path, image) !== false)
            image.src = path.url;
    }
    /**
     * 加载单个txt文件
     * @param path                          文件路径
     * @param callbackFn                    加载完成回调
     * @param args                          加载参数
     * @param args.async                    是否异步加载
     * @param args.numRetries               尝试加载次数
     * @param args.before                   加载前回调
     * @param numTries                      当前尝试次数
     */
    function loadTxt(path, callbackFn, args, numTries) {
        if (numTries === void 0) { numTries = 0; }
        var request = new XMLHttpRequest();
        request.onreadystatechange = function (ev) {
            var result = ev.type;
            if (request.readyState == 4) { // 4 = "loaded"
                request.onreadystatechange = null;
                // handle retries in case of load failure
                if (request.status < 200 || request.status > 300) {
                    // increment counter
                    numTries = ~~numTries + 1;
                    // exit function and try again
                    args.numRetries = args.numRetries || 0;
                    if (numTries < ~~args.numRetries + 1) {
                        return loadTxt(path, callbackFn, args, numTries);
                    }
                }
                // execute callback
                callbackFn(path, result, ev.defaultPrevented, request.responseText);
            }
        };
        request.open('Get', path.url, true);
        //
        var beforeCallbackFn = args.before || (function () { return true; });
        if (beforeCallbackFn(path, request) !== false)
            request.send();
    }
    /**
     * 加载单个js或者css文件
     * @param path                          文件路径
     * @param callbackFn                    加载完成回调
     * @param args                          加载参数
     * @param args.async                    是否异步加载
     * @param args.numRetries               尝试加载次数
     * @param args.before                   加载前回调
     * @param numTries                      当前尝试次数
     */
    function loadJsCss(path, callbackFn, args, numTries) {
        if (numTries === void 0) { numTries = 0; }
        var doc = document, isCss, e;
        if (/(^css!|\.css$)/.test(path.url)) {
            isCss = true;
            // css
            e = doc.createElement('link');
            e.rel = 'stylesheet';
            e.href = path.url.replace(/^css!/, ''); // remove "css!" prefix
        }
        else {
            // javascript
            e = doc.createElement('script');
            e.src = path.url;
            e.async = !!args.async;
        }
        e.onload = e.onerror = e.onbeforeload = function (ev) {
            var result = ev.type;
            // Note: The following code isolates IE using `hideFocus` and treats empty
            // stylesheets as failures to get around lack of onerror support
            if (isCss && 'hideFocus' in e) {
                try {
                    if (!e.sheet.cssText.length)
                        result = 'error';
                }
                catch (x) {
                    // sheets objects created from load errors don't allow access to
                    // `cssText`
                    result = 'error';
                }
            }
            // handle retries in case of load failure
            if (result == 'error') {
                // increment counter
                numTries = ~~numTries + 1;
                // exit function and try again
                args.numRetries = args.numRetries || 0;
                if (numTries < ~~args.numRetries + 1) {
                    return loadJsCss(path, callbackFn, args, numTries);
                }
            }
            // execute callback
            callbackFn(path, result, ev.defaultPrevented, e);
        };
        // add to document (unless callback returns `false`)
        var beforeCallbackFn = args.before || (function () { return true; });
        if (beforeCallbackFn(path, e) !== false)
            doc.head.appendChild(e);
    }
    /**
     * 加载多文件
     * @param paths         文件路径
     * @param callbackFn    加载完成回调
     */
    function loadFiles(paths, callbackFn, args) {
        var notLoadFiles = paths.concat();
        var loadingFiles = [];
        var pathsNotFound = [];
        // define callback function
        var fn = function (path, result, defaultPrevented, content) {
            // handle error
            if (result == 'error')
                pathsNotFound.push(path.url);
            // handle beforeload event. If defaultPrevented then that means the load
            // will be blocked (ex. Ghostery/ABP on Safari)
            if (result[0] == 'b') {
                if (defaultPrevented)
                    pathsNotFound.push(path.url);
                else
                    return;
            }
            var index = loadingFiles.indexOf(path);
            loadingFiles.splice(index, 1);
            args.onitemload && args.onitemload(path.url, content);
            if (loadingFiles.length == 0 && notLoadFiles.length == 0)
                callbackFn(pathsNotFound);
            if (notLoadFiles.length) {
                var file = notLoadFiles[0];
                notLoadFiles.shift();
                loadingFiles.push(file);
                loadFile(file, fn, args);
            }
        };
        // load scripts
        var file;
        if (!!args.async) {
            for (var i = 0, x = notLoadFiles.length; i < x; i++) {
                file = notLoadFiles[i];
                loadingFiles.push(file);
                loadFile(file, fn, args);
            }
            notLoadFiles.length = 0;
        }
        else {
            file = notLoadFiles[0];
            notLoadFiles.shift();
            loadingFiles.push(file);
            loadFile(file, fn, args);
        }
    }
    /**
     * 获取路径以及类型
     * @param pathUrls 路径
     */
    function getPaths(pathUrls) {
        var paths = [];
        if (typeof pathUrls == "string") {
            pathUrls = [pathUrls];
        }
        if (!Array.isArray(pathUrls)) {
            pathUrls = [pathUrls];
        }
        for (var i = 0; i < pathUrls.length; i++) {
            var pathurl = pathUrls[i];
            if (typeof pathurl == "string") {
                paths[i] = { url: pathurl, type: getPathType(pathurl) };
            }
            else {
                paths[i] = pathurl;
            }
        }
        return paths;
    }
    /**
     * 获取路径类型
     * @param path 路径
     */
    function getPathType(path) {
        var type = "txt";
        for (var i = 0; i < typeRegExps.length; i++) {
            var element = typeRegExps[i];
            if (element.reg.test(path))
                type = element.type;
        }
        return type;
    }
    /**
     * 资源类型
     */
    var types = { js: "js", css: "css", txt: "txt", image: "image" };
    /**
     * 加载函数
     */
    var loaders = {
        txt: loadTxt,
        js: loadJsCss,
        css: loadJsCss,
        image: loadImage,
    };
    var typeRegExps = [
        { reg: /(^css!|\.css$)/i, type: types.css },
        { reg: /(\.js\b)/i, type: types.js },
        { reg: /(\.png\b)/i, type: types.image },
        { reg: /(\.jpg\b)/i, type: types.image },
    ];
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var databases = {};
    /**
     *
     */
    var _IndexedDB = /** @class */ (function () {
        function _IndexedDB() {
            /**
             * 数据库状态
             */
            this._dbStatus = {};
        }
        /**
         * 是否支持 indexedDB
         */
        _IndexedDB.prototype.support = function () {
            if (typeof indexedDB == "undefined") {
                indexedDB = window.indexedDB || window["mozIndexedDB"] || window["webkitIndexedDB"] || window["msIndexedDB"];
                if (indexedDB == undefined) {
                    return false;
                }
            }
            return true;
        };
        /**
         * 获取数据库，如果不存在则新建数据库
         *
         * @param dbname 数据库名称
         * @param callback 完成回调
         */
        _IndexedDB.prototype.getDatabase = function (dbname, callback) {
            if (databases[dbname]) {
                callback(null, databases[dbname]);
                return;
            }
            this._open(dbname, callback);
        };
        /**
         * 打开或者升级数据库
         *
         * @param dbname 数据库名称
         * @param callback 完成回调
         * @param upgrade 是否升级数据库
         * @param onupgrade 升级回调
         */
        _IndexedDB.prototype._open = function (dbname, callback, upgrade, onupgrade) {
            var _this = this;
            if (upgrade === void 0) { upgrade = false; }
            if (!this._dbStatus[dbname])
                this._dbStatus[dbname] = { status: DBStatus.unOpen, onsuccessCallbacks: [], onupgradeneededCallbacks: [] };
            this._dbStatus[dbname].onsuccessCallbacks.push(callback);
            if (upgrade) {
                feng3d.debuger && console.assert(!!onupgrade);
                this._dbStatus[dbname].onupgradeneededCallbacks.push(onupgrade);
            }
            if (this._dbStatus[dbname].status == DBStatus.opening || this._dbStatus[dbname].status == DBStatus.upgrading)
                return;
            var request;
            if (!upgrade) {
                request = indexedDB.open(dbname);
                this._dbStatus[dbname].status = DBStatus.opening;
            }
            else {
                var oldDatabase = databases[dbname];
                oldDatabase.close();
                delete databases[dbname];
                request = indexedDB.open(dbname, oldDatabase.version + 1);
                this._dbStatus[dbname].status = DBStatus.upgrading;
            }
            request.onupgradeneeded = function (event) {
                var newdatabase = event.target["result"];
                request.onupgradeneeded = null;
                var callbacks = _this._dbStatus[dbname].onupgradeneededCallbacks.concat();
                _this._dbStatus[dbname].onupgradeneededCallbacks.length = 0;
                callbacks.forEach(function (element) {
                    element(newdatabase);
                });
            };
            request.onsuccess = function (event) {
                databases[dbname] = event.target["result"];
                request.onsuccess = null;
                _this._dbStatus[dbname].status = DBStatus.opened;
                var callbacks = _this._dbStatus[dbname].onsuccessCallbacks.concat();
                _this._dbStatus[dbname].onsuccessCallbacks.length = 0;
                callbacks.forEach(function (element) {
                    element(null, databases[dbname]);
                });
            };
            request.onerror = function (event) {
                request.onerror = null;
                _this._dbStatus[dbname].status = DBStatus.error;
                var callbacks = _this._dbStatus[dbname].onsuccessCallbacks.concat();
                _this._dbStatus[dbname].onsuccessCallbacks.length = 0;
                callbacks.forEach(function (element) {
                    element(event, null);
                });
            };
        };
        /**
         * 删除数据库
         *
         * @param dbname 数据库名称
         * @param callback 完成回调
         */
        _IndexedDB.prototype.deleteDatabase = function (dbname, callback) {
            var request = indexedDB.deleteDatabase(dbname);
            request.onsuccess = function (event) {
                delete databases[dbname];
                callback && callback(null);
                request.onsuccess = null;
            };
            request.onerror = function (event) {
                callback && callback(event);
                request.onerror = null;
            };
        };
        /**
         * 是否存在指定的对象存储
         *
         * @param dbname 数据库名称
         * @param objectStroreName 对象存储名称
         * @param callback 完成回调
         */
        _IndexedDB.prototype.hasObjectStore = function (dbname, objectStroreName, callback) {
            this.getDatabase(dbname, function (err, database) {
                callback(database.objectStoreNames.contains(objectStroreName));
            });
        };
        /**
         * 获取对象存储名称列表
         *
         * @param dbname 数据库
         * @param callback 完成回调
         */
        _IndexedDB.prototype.getObjectStoreNames = function (dbname, callback) {
            this.getDatabase(dbname, function (err, database) {
                var objectStoreNames = [];
                for (var i = 0; i < database.objectStoreNames.length; i++) {
                    objectStoreNames.push(database.objectStoreNames.item(i));
                }
                callback(null, objectStoreNames);
            });
        };
        /**
         * 创建对象存储
         *
         * @param dbname 数据库名称
         * @param objectStroreName 对象存储名称
         * @param callback 完成回调
         */
        _IndexedDB.prototype.createObjectStore = function (dbname, objectStroreName, callback) {
            var _this = this;
            this.getDatabase(dbname, function (err, database) {
                if (database.objectStoreNames.contains(objectStroreName)) {
                    callback && callback(null);
                    return;
                }
                _this._open(dbname, callback, true, function (newdatabase) {
                    newdatabase.createObjectStore(objectStroreName);
                });
            });
        };
        /**
         * 删除对象存储
         *
         * @param dbname 数据库名称
         * @param objectStroreName 对象存储名称
         * @param callback 完成回调
         */
        _IndexedDB.prototype.deleteObjectStore = function (dbname, objectStroreName, callback) {
            var _this = this;
            this.getDatabase(dbname, function (err, database) {
                if (!database.objectStoreNames.contains(objectStroreName)) {
                    callback && callback(null);
                    return;
                }
                _this._open(dbname, callback, true, function (newdatabase) {
                    newdatabase.deleteObjectStore(objectStroreName);
                });
            });
        };
        /**
         * 获取对象存储中所有键列表
         *
         * @param dbname 数据库名称
         * @param objectStroreName 对象存储名称
         * @param callback 完成回调
         */
        _IndexedDB.prototype.getAllKeys = function (dbname, objectStroreName, callback) {
            this.getDatabase(dbname, function (err, database) {
                try {
                    var transaction = database.transaction([objectStroreName], 'readwrite');
                    var objectStore = transaction.objectStore(objectStroreName);
                    var request = objectStore.getAllKeys();
                    request.onsuccess = function (event) {
                        callback && callback(null, event.target["result"]);
                        request.onsuccess = null;
                    };
                }
                catch (error) {
                    callback && callback(error, null);
                }
            });
        };
        /**
         * 获取对象存储中指定键对应的数据
         *
         * @param dbname 数据库名称
         * @param objectStroreName 对象存储名称
         * @param key 键
         * @param callback 完成回调
         */
        _IndexedDB.prototype.objectStoreGet = function (dbname, objectStroreName, key, callback) {
            this.getDatabase(dbname, function (err, database) {
                var transaction = database.transaction([objectStroreName], 'readwrite');
                var objectStore = transaction.objectStore(objectStroreName);
                var request = objectStore.get(key);
                request.onsuccess = function (event) {
                    var result = event.target["result"];
                    callback && callback(result != null ? null : new Error("\u6CA1\u6709\u627E\u5230\u8D44\u6E90 " + key), result);
                    request.onsuccess = null;
                };
            });
        };
        /**
         * 设置对象存储的键与值，如果不存在指定键则新增否则修改。
         *
         * @param dbname 数据库名称
         * @param objectStroreName 对象存储名称
         * @param key 键
         * @param data 数据
         * @param callback 完成回调
         */
        _IndexedDB.prototype.objectStorePut = function (dbname, objectStroreName, key, data, callback) {
            this.getDatabase(dbname, function (err, database) {
                try {
                    var transaction = database.transaction([objectStroreName], 'readwrite');
                    var objectStore = transaction.objectStore(objectStroreName);
                    var request = objectStore.put(data, key);
                    request.onsuccess = function (event) {
                        callback && callback(null);
                        request.onsuccess = null;
                    };
                }
                catch (error) {
                    callback && callback(error);
                }
            });
        };
        /**
         * 删除对象存储中指定键以及对于数据
         *
         * @param dbname 数据库名称
         * @param objectStroreName 对象存储名称
         * @param key 键
         * @param callback 完成回调
         */
        _IndexedDB.prototype.objectStoreDelete = function (dbname, objectStroreName, key, callback) {
            this.getDatabase(dbname, function (err, database) {
                try {
                    var transaction = database.transaction([objectStroreName], 'readwrite');
                    var objectStore = transaction.objectStore(objectStroreName);
                    var request = objectStore.delete(key);
                    request.onsuccess = function (event) {
                        callback && callback();
                        request.onsuccess = null;
                    };
                }
                catch (error) {
                    callback && callback(error);
                }
            });
        };
        /**
         * 清空对象存储中数据
         *
         * @param dbname 数据库名称
         * @param objectStroreName 对象存储名称
         * @param callback 完成回调
         */
        _IndexedDB.prototype.objectStoreClear = function (dbname, objectStroreName, callback) {
            this.getDatabase(dbname, function (err, database) {
                try {
                    var transaction = database.transaction([objectStroreName], 'readwrite');
                    var objectStore = transaction.objectStore(objectStroreName);
                    var request = objectStore.clear();
                    request.onsuccess = function (event) {
                        callback && callback();
                        request.onsuccess = null;
                    };
                }
                catch (error) {
                    callback && callback(error);
                }
            });
        };
        return _IndexedDB;
    }());
    feng3d._IndexedDB = _IndexedDB;
    feng3d._indexedDB = new _IndexedDB();
    /**
     * 数据库状态
     */
    var DBStatus;
    (function (DBStatus) {
        /**
         * 未开启
         */
        DBStatus[DBStatus["unOpen"] = 0] = "unOpen";
        /**
         * 正在开启中
         */
        DBStatus[DBStatus["opening"] = 1] = "opening";
        /**
         * 已开启
         */
        DBStatus[DBStatus["opened"] = 2] = "opened";
        /**
         * 正在升级中
         */
        DBStatus[DBStatus["upgrading"] = 3] = "upgrading";
        /**
         * 开启或者升级失败
         */
        DBStatus[DBStatus["error"] = 4] = "error";
    })(DBStatus || (DBStatus = {}));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 文件系统类型
     */
    var FSType;
    (function (FSType) {
        FSType["http"] = "http";
        FSType["native"] = "native";
        FSType["indexedDB"] = "indexedDB";
    })(FSType = feng3d.FSType || (feng3d.FSType = {}));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 可读文件系统
     */
    var ReadFS = /** @class */ (function () {
        function ReadFS(fs) {
            this._images = {};
            this._state = {};
            this.fs = fs;
        }
        Object.defineProperty(ReadFS.prototype, "fs", {
            /**
             * 基础文件系统
             */
            get: function () { return this._fs || feng3d.basefs; },
            set: function (v) { this._fs = v; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ReadFS.prototype, "type", {
            /**
             * 文件系统类型
             */
            get: function () { return this.fs.type; },
            enumerable: true,
            configurable: true
        });
        /**
         * 读取文件为ArrayBuffer
         * @param path 路径
         * @param callback 读取完成回调 当err不为null时表示读取失败
         */
        ReadFS.prototype.readArrayBuffer = function (path, callback) {
            this.fs.readArrayBuffer(path, callback);
        };
        /**
         * 读取文件为字符串
         * @param path 路径
         * @param callback 读取完成回调 当err不为null时表示读取失败
         */
        ReadFS.prototype.readString = function (path, callback) {
            this.fs.readString(path, callback);
        };
        /**
         * 读取文件为Object
         * @param path 路径
         * @param callback 读取完成回调 当err不为null时表示读取失败
         */
        ReadFS.prototype.readObject = function (path, callback) {
            this.fs.readObject(path, callback);
        };
        /**
         * 加载图片
         * @param path 图片路径
         * @param callback 加载完成回调
         */
        ReadFS.prototype.readImage = function (path, callback) {
            this.fs.readImage(path, callback);
            // functionwrap.wrapF(this.fs, this.fs.readImage, [path], callback);
        };
        /**
         * 获取文件绝对路径
         * @param path （相对）路径
         */
        ReadFS.prototype.getAbsolutePath = function (path) {
            return this.fs.getAbsolutePath(path);
        };
        /**
         * 读取文件列表为字符串列表
         *
         * @param path 路径
         * @param callback 读取完成回调 当err不为null时表示读取失败
         */
        ReadFS.prototype.readStrings = function (paths, callback) {
            var _this = this;
            feng3d.task.parallelResults(paths, function (path, callback) {
                _this.readString(path, function (err, str) {
                    callback(err || str);
                });
            }, callback);
        };
        return ReadFS;
    }());
    feng3d.ReadFS = ReadFS;
    feng3d.fs = new ReadFS();
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 可读写文件系统
     *
     * 扩展基础可读写文件系统
     */
    var ReadWriteFS = /** @class */ (function (_super) {
        __extends(ReadWriteFS, _super);
        function ReadWriteFS(fs) {
            return _super.call(this, fs) || this;
        }
        /**
         * 文件是否存在
         * @param path 文件路径
         * @param callback 回调函数
         */
        ReadWriteFS.prototype.exists = function (path, callback) {
            this.fs.exists(path, callback);
        };
        /**
         * 读取文件夹中文件列表
         * @param path 路径
         * @param callback 回调函数
         */
        ReadWriteFS.prototype.readdir = function (path, callback) {
            this.fs.readdir(path, callback);
        };
        /**
         * 新建文件夹
         * @param path 文件夹路径
         * @param callback 回调函数
         */
        ReadWriteFS.prototype.mkdir = function (path, callback) {
            var _this = this;
            path = feng3d.pathUtils.normalizeDir(path);
            this.fs.exists(path, function (exists) {
                if (exists) {
                    callback && callback(null);
                    return;
                }
                _this.fs.mkdir(path, callback);
            });
        };
        /**
         * 删除文件
         * @param path 文件路径
         * @param callback 回调函数
         */
        ReadWriteFS.prototype.deleteFile = function (path, callback) {
            this.fs.deleteFile(path, callback);
        };
        /**
         * 写(新建)文件
         * 自动根据文件类型保存为对应结构
         *
         * @param path 文件路径
         * @param arraybuffer 文件数据
         * @param callback 回调函数
         */
        ReadWriteFS.prototype.writeFile = function (path, arraybuffer, callback) {
            var _this = this;
            var ext = feng3d.pathUtils.getExtension(path);
            ext = ext.split(".").pop();
            var fileTypedic = { "meta": "txt", "json": "object", "jpg": "arraybuffer", "png": "arraybuffer", "mp3": "arraybuffer", "js": "txt", "ts": "txt", "map": "txt", "html": "txt" };
            var type = fileTypedic[ext];
            if (path == "tsconfig.json" || path == ".vscode/settings.json")
                type = "txt";
            if (type == "txt") {
                feng3d.dataTransform.arrayBufferToString(arraybuffer, function (str) {
                    _this.fs.writeString(path, str, function (err) {
                        callback(err);
                    });
                });
            }
            else if (type == "object") {
                feng3d.dataTransform.arrayBufferToObject(arraybuffer, function (obj) {
                    _this.fs.writeObject(path, obj, function (err) {
                        callback(err);
                    });
                });
            }
            else if (type == "arraybuffer") {
                this.writeArrayBuffer(path, arraybuffer, function (err) {
                    callback(err);
                });
            }
            else {
                console.error("\u65E0\u6CD5\u5BFC\u5165\u6587\u4EF6 " + path);
            }
        };
        /**
         * 写ArrayBuffer(新建)文件
         * @param path 文件路径
         * @param arraybuffer 文件数据
         * @param callback 回调函数
         */
        ReadWriteFS.prototype.writeArrayBuffer = function (path, arraybuffer, callback) {
            var _this = this;
            // 如果所属文件夹不存在则新建
            var dirpath = feng3d.pathUtils.getParentPath(path);
            this.mkdir(dirpath, function (err) {
                if (err) {
                    callback && callback(err);
                    return;
                }
                _this.fs.writeArrayBuffer(path, arraybuffer, callback);
            });
        };
        /**
         * 写字符串到(新建)文件
         * @param path 文件路径
         * @param str 文件数据
         * @param callback 回调函数
         */
        ReadWriteFS.prototype.writeString = function (path, str, callback) {
            var _this = this;
            // 如果所属文件夹不存在则新建
            var dirpath = feng3d.pathUtils.getParentPath(path);
            this.mkdir(dirpath, function (err) {
                if (err) {
                    callback && callback(err);
                    return;
                }
                _this.fs.writeString(path, str, callback);
            });
        };
        /**
         * 写Object到(新建)文件
         * @param path 文件路径
         * @param object 文件数据
         * @param callback 回调函数
         */
        ReadWriteFS.prototype.writeObject = function (path, object, callback) {
            var _this = this;
            // 如果所属文件夹不存在则新建
            var dirpath = feng3d.pathUtils.getParentPath(path);
            this.mkdir(dirpath, function (err) {
                if (err) {
                    callback && callback(err);
                    return;
                }
                _this.fs.writeObject(path, object, callback);
            });
        };
        /**
         * 写图片
         * @param path 图片路径
         * @param image 图片
         * @param callback 回调函数
         */
        ReadWriteFS.prototype.writeImage = function (path, image, callback) {
            var _this = this;
            // 如果所属文件夹不存在则新建
            var dirpath = feng3d.pathUtils.getParentPath(path);
            this.mkdir(dirpath, function (err) {
                if (err) {
                    callback && callback(err);
                    return;
                }
                _this.fs.writeImage(path, image, callback);
            });
        };
        /**
         * 复制文件
         * @param src    源路径
         * @param dest    目标路径
         * @param callback 回调函数
         */
        ReadWriteFS.prototype.copyFile = function (src, dest, callback) {
            this.fs.copyFile(src, dest, callback);
        };
        /**
         * 是否为文件夹
         *
         * @param path 文件路径
         * @param callback 完成回调
         */
        ReadWriteFS.prototype.isDirectory = function (path, callback) {
            this.fs.isDirectory(path, callback);
        };
        /**
         * 初始化项目
         * @param projectname 项目名称
         * @param callback 回调函数
         */
        ReadWriteFS.prototype.initproject = function (projectname, callback) {
            this.fs.initproject(projectname, callback);
        };
        /**
         * 是否存在指定项目
         * @param projectname 项目名称
         * @param callback 回调函数
         */
        ReadWriteFS.prototype.hasProject = function (projectname, callback) {
            this.fs.hasProject(projectname, callback);
        };
        /**
         * 获取指定文件下所有文件路径列表
         */
        ReadWriteFS.prototype.getAllPathsInFolder = function (dirpath, callback) {
            var _this = this;
            if (dirpath === void 0) { dirpath = ""; }
            var dirs = [dirpath];
            var result = [];
            var currentdir = "";
            // 递归获取文件
            var handle = function () {
                if (dirs.length > 0) {
                    currentdir = dirs.shift();
                    _this.readdir(currentdir, function (err, files) {
                        // 获取子文件路径
                        var getChildPath = function () {
                            if (files.length == 0) {
                                handle();
                                return;
                            }
                            var childpath = currentdir + (currentdir == "" ? "" : "/") + files.shift();
                            result.push(childpath);
                            _this.isDirectory(childpath, function (result) {
                                if (result)
                                    dirs.push(childpath);
                                getChildPath();
                            });
                        };
                        getChildPath();
                    });
                }
                else {
                    callback(null, result);
                }
            };
            handle();
        };
        /**
         * 移动文件
         * @param src 源路径
         * @param dest 目标路径
         * @param callback 回调函数
         */
        ReadWriteFS.prototype.moveFile = function (src, dest, callback) {
            var _this = this;
            this.copyFile(src, dest, function (err) {
                if (err) {
                    callback && callback(err);
                    return;
                }
                _this.deleteFile(src, callback);
            });
        };
        /**
         * 重命名文件
         * @param oldPath 老路径
         * @param newPath 新路径
         * @param callback 回调函数
         */
        ReadWriteFS.prototype.renameFile = function (oldPath, newPath, callback) {
            this.moveFile(oldPath, newPath, callback);
        };
        /**
         * 移动一组文件
         * @param movelists 移动列表
         * @param callback 回调函数
         */
        ReadWriteFS.prototype.moveFiles = function (movelists, callback) {
            var _this = this;
            this.copyFiles(movelists.concat(), function (err) {
                if (err) {
                    callback && callback(err);
                    return;
                }
                var deletelists = movelists.reduce(function (value, current) { value.push(current[0]); return value; }, []);
                _this.deleteFiles(deletelists, callback);
            });
        };
        /**
         * 复制一组文件
         * @param copylists 复制列表
         * @param callback 回调函数
         */
        ReadWriteFS.prototype.copyFiles = function (copylists, callback) {
            var _this = this;
            if (copylists.length > 0) {
                var copyitem = copylists.shift();
                this.copyFile(copyitem[0], copyitem[1], function (err) {
                    if (err) {
                        callback && callback(err);
                        return;
                    }
                    _this.copyFiles(copylists, callback);
                });
                return;
            }
            callback && callback(null);
        };
        /**
         * 删除一组文件
         * @param deletelists 删除列表
         * @param callback 回调函数
         */
        ReadWriteFS.prototype.deleteFiles = function (deletelists, callback) {
            var _this = this;
            if (deletelists.length > 0) {
                this.deleteFile(deletelists.shift(), function (err) {
                    if (err) {
                        callback && callback(err);
                        return;
                    }
                    _this.deleteFiles(deletelists, callback);
                });
                return;
            }
            callback && callback(null);
        };
        /**
         * 重命名文件(夹)
         * @param oldPath 老路径
         * @param newPath 新路径
         * @param callback 回调函数
         */
        ReadWriteFS.prototype.rename = function (oldPath, newPath, callback) {
            var _this = this;
            this.isDirectory(oldPath, function (result) {
                if (result) {
                    _this.getAllPathsInFolder(oldPath, function (err, filepaths) {
                        if (err) {
                            callback && callback(err);
                            return;
                        }
                        var renamelists = [[oldPath, newPath]];
                        filepaths.forEach(function (element) {
                            renamelists.push([element, element.replace(oldPath, newPath)]);
                        });
                        _this.moveFiles(renamelists, callback);
                    });
                }
                else {
                    _this.renameFile(oldPath, newPath, callback);
                }
            });
        };
        /**
         * 移动文件(夹)
         *
         * @param src 源路径
         * @param dest 目标路径
         * @param callback 回调函数
         */
        ReadWriteFS.prototype.move = function (src, dest, callback) {
            this.rename(src, dest, callback);
        };
        /**
         * 删除文件(夹)
         * @param path 路径
         * @param callback 回调函数
         */
        ReadWriteFS.prototype.delete = function (path, callback) {
            var _this = this;
            this.isDirectory(path, function (result) {
                if (result) {
                    _this.getAllPathsInFolder(path, function (err, filepaths) {
                        if (err) {
                            callback && callback(err);
                            return;
                        }
                        var removelists = filepaths.concat(path);
                        _this.deleteFiles(removelists, callback);
                    });
                }
                else {
                    _this.deleteFile(path, callback);
                }
            });
        };
        return ReadWriteFS;
    }(feng3d.ReadFS));
    feng3d.ReadWriteFS = ReadWriteFS;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 用于是否为文件夹
     */
    var directorytoken = "!!!___directory___!!!";
    /**
     * 索引数据文件系统
     */
    var IndexedDBFS = /** @class */ (function () {
        function IndexedDBFS(DBname, projectname) {
            if (DBname === void 0) { DBname = "feng3d-editor"; }
            if (projectname === void 0) { projectname = "testproject"; }
            this.DBname = DBname;
            this.projectname = projectname;
        }
        Object.defineProperty(IndexedDBFS.prototype, "type", {
            get: function () {
                return feng3d.FSType.indexedDB;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 读取文件
         * @param path 路径
         * @param callback 读取完成回调 当err不为null时表示读取失败
         */
        IndexedDBFS.prototype.readArrayBuffer = function (path, callback) {
            feng3d._indexedDB.objectStoreGet(this.DBname, this.projectname, path, function (err, data) {
                if (err) {
                    callback(err, data);
                    return;
                }
                if (data instanceof ArrayBuffer) {
                    callback(null, data);
                }
                else if (data instanceof Object) {
                    var str = JSON.stringify(data, null, '\t').replace(/[\n\t]+([\d\.e\-\[\]]+)/g, '$1');
                    var arraybuffer = feng3d.dataTransform.stringToArrayBuffer(str);
                    callback(null, arraybuffer);
                }
                else {
                    var arraybuffer = feng3d.dataTransform.stringToArrayBuffer(data);
                    callback(null, arraybuffer);
                }
            });
        };
        /**
         * 读取文件
         * @param path 路径
         * @param callback 读取完成回调 当err不为null时表示读取失败
         */
        IndexedDBFS.prototype.readString = function (path, callback) {
            feng3d._indexedDB.objectStoreGet(this.DBname, this.projectname, path, function (err, data) {
                if (err) {
                    callback(err, data);
                    return;
                }
                if (data instanceof ArrayBuffer) {
                    feng3d.dataTransform.arrayBufferToString(data, function (str) {
                        callback(null, str);
                    });
                }
                else if (data instanceof Object) {
                    var str = JSON.stringify(data, null, '\t').replace(/[\n\t]+([\d\.e\-\[\]]+)/g, '$1');
                    callback(null, str);
                }
                else {
                    callback(null, data);
                }
            });
        };
        /**
         * 读取文件
         * @param path 路径
         * @param callback 读取完成回调 当err不为null时表示读取失败
         */
        IndexedDBFS.prototype.readObject = function (path, callback) {
            feng3d._indexedDB.objectStoreGet(this.DBname, this.projectname, path, function (err, data) {
                if (err) {
                    callback(err, data);
                    return;
                }
                if (data instanceof ArrayBuffer) {
                    feng3d.dataTransform.arrayBufferToString(data, function (str) {
                        var obj = JSON.parse(str);
                        callback(null, obj);
                    });
                }
                else if (data instanceof Object) {
                    callback(null, data);
                }
                else {
                    feng3d.debuger && console.assert(typeof data == "string");
                    var obj = JSON.parse(data);
                    callback(null, obj);
                }
            });
        };
        /**
         * 加载图片
         * @param path 图片路径
         * @param callback 加载完成回调
         */
        IndexedDBFS.prototype.readImage = function (path, callback) {
            this.readArrayBuffer(path, function (err, data) {
                if (err) {
                    callback(err, null);
                    return;
                }
                feng3d.dataTransform.arrayBufferToImage(data, function (img) {
                    callback(null, img);
                });
            });
        };
        /**
         * 获取文件绝对路径
         * @param path （相对）路径
         * @param callback 回调函数
         */
        IndexedDBFS.prototype.getAbsolutePath = function (path) {
            return path;
        };
        /**
         * 是否为文件夹
         *
         * @param path 文件路径
         * @param callback 完成回调
         */
        IndexedDBFS.prototype.isDirectory = function (path, callback) {
            this.readString(path, function (err, data) {
                callback(data == directorytoken);
            });
        };
        /**
         * 文件是否存在
         * @param path 文件路径
         * @param callback 回调函数
         */
        IndexedDBFS.prototype.exists = function (path, callback) {
            feng3d._indexedDB.objectStoreGet(this.DBname, this.projectname, path, function (err, data) {
                callback(!!data);
            });
        };
        /**
         * 读取文件夹中文件列表
         * @param path 路径
         * @param callback 回调函数
         */
        IndexedDBFS.prototype.readdir = function (path, callback) {
            feng3d._indexedDB.getAllKeys(this.DBname, this.projectname, function (err, allfilepaths) {
                if (!allfilepaths) {
                    callback(err, null);
                    return;
                }
                var subfilemap = {};
                allfilepaths.forEach(function (element) {
                    var dirp = path == "" ? path : (path + "/");
                    if (element.substr(0, dirp.length) == dirp && element != path) {
                        var result = element.substr(dirp.length);
                        var subfile = result.split("/").shift();
                        subfilemap[subfile] = 1;
                    }
                });
                var files = Object.keys(subfilemap);
                callback(null, files);
            });
        };
        /**
         * 新建文件夹
         * @param path 文件夹路径
         * @param callback 回调函数
         */
        IndexedDBFS.prototype.mkdir = function (path, callback) {
            var _this = this;
            this.exists(path, function (exists) {
                if (exists) {
                    callback(new Error("\u6587\u4EF6\u5939" + path + "\u5DF2\u5B58\u5728\u65E0\u6CD5\u65B0\u5EFA"));
                    return;
                }
                feng3d._indexedDB.objectStorePut(_this.DBname, _this.projectname, path, directorytoken, callback);
            });
        };
        /**
         * 删除文件
         * @param path 文件路径
         * @param callback 回调函数
         */
        IndexedDBFS.prototype.deleteFile = function (path, callback) {
            // 删除文件
            feng3d._indexedDB.objectStoreDelete(this.DBname, this.projectname, path, callback);
            feng3d.dispatcher.dispatch("fs.delete", path);
        };
        /**
         * 写文件
         * @param path 文件路径
         * @param data 文件数据
         * @param callback 回调函数
         */
        IndexedDBFS.prototype.writeArrayBuffer = function (path, data, callback) {
            feng3d._indexedDB.objectStorePut(this.DBname, this.projectname, path, data, callback);
            feng3d.dispatcher.dispatch("fs.write", path);
        };
        /**
         * 写文件
         * @param path 文件路径
         * @param data 文件数据
         * @param callback 回调函数
         */
        IndexedDBFS.prototype.writeString = function (path, data, callback) {
            feng3d._indexedDB.objectStorePut(this.DBname, this.projectname, path, data, callback);
            feng3d.dispatcher.dispatch("fs.write", path);
        };
        /**
         * 写文件
         * @param path 文件路径
         * @param object 文件数据
         * @param callback 回调函数
         */
        IndexedDBFS.prototype.writeObject = function (path, object, callback) {
            feng3d._indexedDB.objectStorePut(this.DBname, this.projectname, path, object, callback);
            feng3d.dispatcher.dispatch("fs.write", path);
        };
        /**
         * 写图片
         * @param path 图片路径
         * @param image 图片
         * @param callback 回调函数
         */
        IndexedDBFS.prototype.writeImage = function (path, image, callback) {
            var _this = this;
            feng3d.dataTransform.imageToArrayBuffer(image, function (arraybuffer) {
                _this.writeArrayBuffer(path, arraybuffer, callback);
                feng3d.dispatcher.dispatch("fs.write", path);
            });
        };
        /**
         * 复制文件
         * @param src    源路径
         * @param dest    目标路径
         * @param callback 回调函数
         */
        IndexedDBFS.prototype.copyFile = function (src, dest, callback) {
            var _this = this;
            feng3d._indexedDB.objectStoreGet(this.DBname, this.projectname, src, function (err, data) {
                if (err) {
                    callback(err);
                    return;
                }
                feng3d._indexedDB.objectStorePut(_this.DBname, _this.projectname, dest, data, callback);
            });
        };
        /**
         * 是否存在指定项目
         * @param projectname 项目名称
         * @param callback 回调函数
         */
        IndexedDBFS.prototype.hasProject = function (projectname, callback) {
            feng3d._indexedDB.getObjectStoreNames(this.DBname, function (err, objectStoreNames) {
                if (err) {
                    callback(false);
                    return;
                }
                callback(objectStoreNames.indexOf(projectname) != -1);
            });
        };
        /**
         * 初始化项目
         * @param projectname 项目名称
         * @param callback 回调函数
         */
        IndexedDBFS.prototype.initproject = function (projectname, callback) {
            this.projectname = projectname;
            feng3d._indexedDB.createObjectStore(this.DBname, projectname, callback);
        };
        return IndexedDBFS;
    }());
    feng3d.IndexedDBFS = IndexedDBFS;
    feng3d.indexedDBFS = new IndexedDBFS();
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Http可读文件系统
     */
    var HttpFS = /** @class */ (function () {
        function HttpFS(rootPath) {
            if (rootPath === void 0) { rootPath = ""; }
            /**
             * 根路径
             */
            this.rootPath = "";
            this.type = feng3d.FSType.http;
            this.rootPath = rootPath;
            if (this.rootPath == "") {
                if (typeof document != "undefined") {
                    this.rootPath = document.URL.substring(0, document.URL.lastIndexOf("/") + 1);
                }
            }
        }
        /**
         * 读取文件
         * @param path 路径
         * @param callback 读取完成回调 当err不为null时表示读取失败
         */
        HttpFS.prototype.readArrayBuffer = function (path, callback) {
            // rootPath
            feng3d.loader.loadBinary(this.getAbsolutePath(path), function (content) {
                callback(null, content);
            }, null, function (e) {
                callback(e, null);
            });
        };
        /**
         * 读取文件为字符串
         * @param path 路径
         * @param callback 读取完成回调 当err不为null时表示读取失败
         */
        HttpFS.prototype.readString = function (path, callback) {
            feng3d.loader.loadText(this.getAbsolutePath(path), function (content) {
                callback(null, content);
            }, null, function (e) {
                callback(e, null);
            });
        };
        /**
         * 读取文件为Object
         * @param path 路径
         * @param callback 读取完成回调 当err不为null时表示读取失败
         */
        HttpFS.prototype.readObject = function (path, callback) {
            feng3d.loader.loadText(this.getAbsolutePath(path), function (content) {
                var obj = JSON.parse(content);
                callback(null, obj);
            }, null, function (e) {
                callback(e, null);
            });
        };
        /**
         * 加载图片
         * @param path 图片路径
         * @param callback 加载完成回调
         */
        HttpFS.prototype.readImage = function (path, callback) {
            var img = new Image();
            img.onload = function () {
                callback(null, img);
            };
            img.onerror = function (evt) {
                callback(new Error("\u52A0\u8F7D\u56FE\u7247" + path + "\u5931\u8D25"), null);
            };
            img.src = this.getAbsolutePath(path);
        };
        /**
         * 获取文件绝对路径
         * @param path （相对）路径
         * @param callback 回调函数
         */
        HttpFS.prototype.getAbsolutePath = function (path) {
            return this.rootPath + path;
        };
        return HttpFS;
    }());
    feng3d.HttpFS = HttpFS;
    feng3d.basefs = new HttpFS();
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 资源扩展名
     */
    var AssetType;
    (function (AssetType) {
        /**
         * 文件夹
         */
        AssetType["folder"] = "folder";
        /**
         * 音频
         */
        AssetType["audio"] = "audio";
        /**
         * ts文件
         */
        AssetType["ts"] = "ts";
        /**
         * js文件
         */
        AssetType["js"] = "js";
        /**
         * 文本文件
         */
        AssetType["txt"] = "txt";
        /**
         * json文件
         */
        AssetType["json"] = "json";
        /**
         * OBJ模型资源附带的材质文件
         */
        AssetType["mtl"] = "mtl";
        /**
         * OBJ模型文件
         */
        AssetType["obj"] = "obj";
        /**
         * MD5模型文件
         */
        AssetType["md5mesh"] = "md5mesh";
        /**
         * MD5动画
         */
        AssetType["md5anim"] = "md5anim";
        /**
         * 魔兽MDL模型
         */
        AssetType["mdl"] = "mdl";
        // -- feng3d中的类型
        /**
         * 纹理
         */
        AssetType["texture"] = "texture";
        /**
         * 立方体纹理
         */
        AssetType["texturecube"] = "texturecube";
        /**
         * 材质
         */
        AssetType["material"] = "material";
        /**
         * 几何体
         */
        AssetType["geometry"] = "geometry";
        /**
         * 游戏对象
         */
        AssetType["gameobject"] = "gameobject";
        /**
         * 场景
         */
        AssetType["scene"] = "scene";
        /**
         * 动画
         */
        AssetType["anim"] = "anim";
        /**
         * 着色器
         */
        AssetType["shader"] = "shader";
        /**
         * 脚本
         */
        AssetType["script"] = "script";
    })(AssetType = feng3d.AssetType || (feng3d.AssetType = {}));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * feng3d资源
     */
    var FileAsset = /** @class */ (function () {
        function FileAsset() {
            /**
             * 是否已加载
             */
            this.isLoaded = false;
            /**
             * 是否正在加载中
             */
            this.isLoading = false;
        }
        Object.defineProperty(FileAsset.prototype, "extenson", {
            /**
             * 文件后缀
             */
            get: function () {
                feng3d.debuger && console.assert(!!this.assetPath);
                var ext = feng3d.pathUtils.getExtension(this.assetPath);
                return ext;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileAsset.prototype, "fileName", {
            /**
             * 文件名称
             *
             * 不包含后缀
             */
            get: function () {
                feng3d.debuger && console.assert(!!this.assetPath);
                var fn = feng3d.pathUtils.getName(this.assetPath);
                return fn;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 初始化资源
         */
        FileAsset.prototype.initAsset = function () {
        };
        /**
         * 获取资源数据
         *
         * @param callback 完成回调，当资源已加载时会立即调用回调，否则在资源加载完成后调用。
         */
        FileAsset.prototype.getAssetData = function (callback) {
            var _this = this;
            if (!this.isLoaded) {
                if (callback) {
                    this.read(function (err) {
                        feng3d.debuger && console.assert(!err);
                        _this.getAssetData(callback);
                    });
                }
                return null;
            }
            var assetData = this._getAssetData();
            callback && callback(assetData);
            return assetData;
        };
        /**
         * 资源已加载时获取资源数据，内部使用
         */
        FileAsset.prototype._getAssetData = function () {
            return this.data;
        };
        /**
         * 读取资源
         *
         * @param callback 完成回调
         */
        FileAsset.prototype.read = function (callback) {
            var _this = this;
            if (this.isLoaded) {
                callback();
                return;
            }
            var eventtype = "loaded";
            feng3d.event.once(this, eventtype, function () {
                _this.isLoaded = true;
                _this.isLoading = false;
                callback();
            });
            if (this.isLoading)
                return;
            this.isLoading = true;
            this.readMeta(function (err) {
                if (err) {
                    feng3d.event.dispatch(_this, eventtype);
                    return;
                }
                _this.readFile(function (err) {
                    feng3d.event.dispatch(_this, eventtype);
                });
            });
        };
        /**
         * 写入资源
         *
         * @param callback 完成回调
         */
        FileAsset.prototype.write = function (callback) {
            var _this = this;
            this.meta.mtimeMs = Date.now();
            this.writeMeta(function (err) {
                if (err) {
                    callback && callback(err);
                    return;
                }
                _this.saveFile(function (err) {
                    callback && callback(err);
                });
            });
        };
        /**
         * 删除资源
         *
         * @param callback 完成回调
         */
        FileAsset.prototype.delete = function (callback) {
            var _this = this;
            // 删除 meta 文件
            this.deleteMeta(function (err) {
                if (err) {
                    callback && callback(err);
                    return;
                }
                _this.deleteFile(function (err) {
                    // 删除父子资源关系
                    if (_this.parentAsset) {
                        _this.parentAsset.childrenAssets.delete(_this);
                        _this.parentAsset = null;
                    }
                    // 删除映射
                    delete feng3d.rs.idMap[_this.assetId];
                    delete feng3d.rs.pathMap[_this.assetPath];
                    callback && callback();
                });
            });
        };
        /**
         * 读取资源预览图标
         *
         * @param callback 完成回调
         */
        FileAsset.prototype.readPreview = function (callback) {
            var _this = this;
            if (this._preview) {
                callback(null, this._preview);
                return;
            }
            this.rs.fs.readImage(this.previewPath, function (err, image) {
                _this._preview = image;
                callback(err, image);
            });
        };
        /**
         * 读取资源预览图标
         *
         * @param image 预览图
         * @param callback 完成回调
         */
        FileAsset.prototype.writePreview = function (image, callback) {
            if (this._preview == image) {
                callback && callback(null);
                return;
            }
            this._preview = image;
            this.rs.fs.writeImage(this.previewPath, image, callback);
        };
        /**
         * 删除资源预览图标
         *
         * @param callback 完成回调
         */
        FileAsset.prototype.deletePreview = function (callback) {
            this.rs.fs.deleteFile(this.previewPath, callback);
        };
        /**
         * 删除文件
         *
         * @param callback 完成回调
         */
        FileAsset.prototype.deleteFile = function (callback) {
            var _this = this;
            this.rs.fs.deleteFile(this.assetPath, callback);
            // 延迟一帧判断该资源是否被删除，排除移动文件时出现的临时删除情况
            feng3d.ticker.once(1000, function () {
                if (_this.rs.getAsset(_this.assetId) == null) {
                    _this.deletePreview();
                }
            });
        };
        Object.defineProperty(FileAsset.prototype, "metaPath", {
            /**
             * 元标签路径
             */
            get: function () {
                return this.assetPath + ".meta";
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 读取元标签
         *
         * @param callback 完成回调
         */
        FileAsset.prototype.readMeta = function (callback) {
            var _this = this;
            this.rs.fs.readObject(this.metaPath, function (err, meta) {
                _this.meta = meta;
                callback && callback(err);
            });
        };
        /**
         * 写元标签
         *
         * @param callback 完成回调
         */
        FileAsset.prototype.writeMeta = function (callback) {
            this.rs.fs.writeObject(this.metaPath, this.meta, callback);
        };
        /**
         * 删除元标签
         *
         * @param callback 完成回调
         */
        FileAsset.prototype.deleteMeta = function (callback) {
            this.rs.fs.deleteFile(this.metaPath, callback);
        };
        Object.defineProperty(FileAsset.prototype, "previewPath", {
            /**
             * 预览图路径
             */
            get: function () {
                return "previews/" + this.assetId + ".png";
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            feng3d.serialize
        ], FileAsset.prototype, "assetId", void 0);
        __decorate([
            feng3d.serialize
        ], FileAsset.prototype, "assetPath", void 0);
        return FileAsset;
    }());
    feng3d.FileAsset = FileAsset;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 可读资源系统
     */
    var ReadRS = /** @class */ (function () {
        /**
         * 构建可读资源系统
         *
         * @param fs 可读文件系统
         */
        function ReadRS(fs) {
            /**
             * 资源编号映射
             */
            this.idMap = {};
            /**
             * 资源路径映射
             */
            this.pathMap = {};
            /**
             * 资源树保存路径
             */
            this.resources = "resource.json";
            this._fs = fs;
        }
        Object.defineProperty(ReadRS.prototype, "fs", {
            /**
             * 文件系统
             */
            get: function () { return this._fs || feng3d.fs; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ReadRS.prototype, "root", {
            /**
             * 根文件夹
             */
            get: function () { return this._root; },
            enumerable: true,
            configurable: true
        });
        /**
         * 初始化
         *
         * @param callback 完成回调
         */
        ReadRS.prototype.init = function (callback) {
            var _this = this;
            this.fs.readObject(this.resources, function (err, object) {
                if (object) {
                    var data = feng3d.serialization.deserialize(object);
                    _this._root = data;
                    //
                    var assets = [data];
                    var index = 0;
                    while (index < assets.length) {
                        var asset = assets[index];
                        // 设置资源系统
                        asset.rs = _this;
                        // 新增映射
                        _this.idMap[asset.assetId] = asset;
                        _this.pathMap[asset.assetPath] = asset;
                        // 
                        if (asset instanceof feng3d.FolderAsset) {
                            for (var i = 0; i < asset.childrenAssets.length; i++) {
                                var v = asset.childrenAssets[i];
                                // 处理资源父子关系
                                v.parentAsset = asset;
                                //
                                assets.push(v);
                            }
                        }
                        index++;
                    }
                    callback();
                }
                else {
                    _this.createAsset(feng3d.FolderAsset, "Assets", null, null, function (err, asset) {
                        _this._root = asset;
                        callback();
                    });
                }
            });
        };
        /**
         * 新建资源
         *
         * @param cls 资源类定义
         * @param fileName 文件名称
         * @param value 初始数据
         * @param parent 所在文件夹，如果值为null时默认添加到根文件夹中
         * @param callback 完成回调函数
         */
        ReadRS.prototype.createAsset = function (cls, fileName, value, parent, callback) {
            parent = parent || this._root;
            //
            var asset = new cls();
            var assetId = Math.uuid();
            // 初始化
            asset.rs = this;
            feng3d.serialization.setValue(asset, value);
            asset.assetId = assetId;
            asset.meta = { guid: assetId, mtimeMs: Date.now(), birthtimeMs: Date.now(), assetType: asset.assetType };
            asset.initAsset();
            feng3d.AssetData.addAssetData(asset.assetId, asset.data);
            //
            var extenson = feng3d.pathUtils.getExtension(fileName);
            fileName = feng3d.pathUtils.getName(fileName);
            // 设置默认名称
            fileName = fileName || "new " + asset.assetType;
            if (parent) {
                // 计算有效名称
                fileName = this.getValidChildName(parent, fileName);
                // 处理资源父子关系
                parent.childrenAssets.push(asset);
                asset.parentAsset = parent;
            }
            // 计算路径
            if (extenson == "")
                extenson = cls["extenson"];
            feng3d.debuger && console.assert(extenson != undefined, "\u5BF9\u8C61 " + cls + " \u6CA1\u6709\u8BBE\u7F6E extenson \u503C\uFF0C\u53C2\u8003 FolderAsset.extenson");
            var path = fileName + extenson;
            if (asset.parentAsset)
                path = asset.parentAsset.assetPath + "/" + path;
            asset.assetPath = path;
            // 新增映射
            this.idMap[asset.assetId] = asset;
            this.pathMap[asset.assetPath] = asset;
            //
            asset.write(function (err) {
                callback && callback(null, asset);
            });
        };
        /**
         * 获取有效子文件名称
         *
         * @param parent 父文件夹
         * @param fileName 文件名称
         */
        ReadRS.prototype.getValidChildName = function (parent, fileName) {
            var childrenNames = parent.childrenAssets.map(function (v) { return v.fileName; });
            var newName = fileName;
            var index = 1;
            while (childrenNames.indexOf(newName) != -1) {
                newName = fileName + index;
                index++;
            }
            return newName;
        };
        /**
         * 读取文件为资源对象
         * @param id 资源编号
         * @param callback 读取完成回调
         */
        ReadRS.prototype.readAsset = function (id, callback) {
            var asset = this.idMap[id];
            if (!asset) {
                callback(new Error("\u4E0D\u5B58\u5728\u8D44\u6E90 " + id), asset);
                return;
            }
            asset.read(function (err) {
                if (asset)
                    feng3d.AssetData.addAssetData(asset.assetId, asset.data);
                callback(err, asset);
            });
        };
        /**
         * 读取资源数据
         *
         * @param id 资源编号
         * @param callback 完成回调
         */
        ReadRS.prototype.readAssetData = function (id, callback) {
            var asset = feng3d.AssetData.getLoadedAssetData(id);
            if (asset) {
                callback(null, asset);
                return;
            }
            this.readAsset(id, function (err, asset) {
                callback(err, asset && asset.getAssetData());
            });
        };
        /**
         * 读取资源数据列表
         *
         * @param assetids 资源编号列表
         * @param callback 完成回调
         */
        ReadRS.prototype.readAssetDatas = function (assetids, callback) {
            var result = [];
            var fns = assetids.map(function (v) { return function (callback) {
                feng3d.rs.readAssetData(v, function (err, data) {
                    feng3d.debuger && console.assert(!!data);
                    result.push(data);
                    callback();
                });
            }; });
            feng3d.task.parallel(fns)(function () {
                feng3d.debuger && console.assert(assetids.length == result.filter(function (v) { return v != null; }).length);
                callback(null, result);
            });
        };
        /**
         * 获取指定类型资源
         *
         * @param type 资源类型
         */
        ReadRS.prototype.getAssetsByType = function (type) {
            var _this = this;
            var assets = Object.keys(this.idMap).map(function (v) { return _this.idMap[v]; });
            return assets.filter(function (v) { return v instanceof type; });
        };
        /**
         * 获取指定类型资源数据
         *
         * @param type 资源类型
         */
        ReadRS.prototype.getLoadedAssetDatasByType = function (type) {
            var assets = feng3d.AssetData.getAllLoadedAssetDatas();
            return assets.filter(function (v) { return v instanceof type; });
        };
        /**
         * 获取资源
         *
         * @param assetId 资源编号
         */
        ReadRS.prototype.getAsset = function (assetId) {
            return this.idMap[assetId];
        };
        /**
         * 获取所有资源
         */
        ReadRS.prototype.getAllAssets = function () {
            var _this = this;
            var assets = Object.keys(this.idMap).map(function (v) { return _this.idMap[v]; });
            return assets;
        };
        /**
         * 获取需要反序列化对象中的资源id列表
         */
        ReadRS.prototype.getAssetsWithObject = function (object, assetids) {
            var _this = this;
            if (assetids === void 0) { assetids = []; }
            if (Object.isBaseType(object))
                return [];
            //
            if (feng3d.AssetData.isAssetData(object))
                assetids.push(object.assetId);
            //
            if (Object.isObject(object) || Array.isArray(object)) {
                var keys = Object.keys(object);
                keys.forEach(function (k) {
                    _this.getAssetsWithObject(object[k], assetids);
                });
            }
            return assetids;
        };
        /**
         * 反序列化包含资源的对象
         *
         * @param object 反序列化的对象
         * @param callback 完成回调
         */
        ReadRS.prototype.deserializeWithAssets = function (object, callback) {
            // 获取所包含的资源列表
            var assetids = this.getAssetsWithObject(object);
            // 不需要加载本资源，移除自身资源
            assetids.delete(object.assetId);
            // 加载包含的资源数据
            this.readAssetDatas(assetids, function (err, result) {
                // 创建资源数据实例
                var assetData = feng3d.classUtils.getInstanceByName(object[feng3d.CLASS_KEY]);
                //默认反序列
                feng3d.serialization.setValue(assetData, object);
                callback(assetData);
            });
        };
        return ReadRS;
    }());
    feng3d.ReadRS = ReadRS;
    feng3d.rs = new ReadRS();
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 可读写资源系统
     */
    var ReadWriteRS = /** @class */ (function (_super) {
        __extends(ReadWriteRS, _super);
        /**
         * 构建可读写资源系统
         *
         * @param fs 可读写文件系统
         */
        function ReadWriteRS(fs) {
            var _this = _super.call(this, fs) || this;
            /**
             * 延迟保存执行函数
             */
            _this.laterSaveFunc = function (interval) { _this.save(); };
            /**
             * 延迟保存，避免多次操作时频繁调用保存
             */
            _this.laterSave = function () { feng3d.ticker.nextframe(_this.laterSaveFunc, _this); };
            return _this;
        }
        /**
         * 在更改资源结构（新增，移动，删除）时会自动保存
         *
         * @param callback 完成回调
         */
        ReadWriteRS.prototype.save = function (callback) {
            var object = feng3d.serialization.serialize(this.root);
            this.fs.writeObject(this.resources, object, callback);
        };
        /**
         * 新建资源
         *
         * @param cls 资源类定义
         * @param fileName 文件名称
         * @param value 初始数据
         * @param parent 所在文件夹，如果值为null时默认添加到根文件夹中
         * @param callback 完成回调函数
         */
        ReadWriteRS.prototype.createAsset = function (cls, fileName, value, parent, callback) {
            var _this = this;
            // 新建资源
            _super.prototype.createAsset.call(this, cls, fileName, value, parent, function (err, asset) {
                if (asset) {
                    // 保存资源
                    _this.writeAsset(asset, function (err) {
                        callback && callback(err, asset);
                        // 保存资源库
                        _this.laterSave();
                    });
                }
                else {
                    callback && callback(err, null);
                }
            });
        };
        /**
         * 写（保存）资源
         *
         * @param asset 资源对象
         * @param callback 完成回调
         */
        ReadWriteRS.prototype.writeAsset = function (asset, callback) {
            asset.write(callback);
        };
        /**
         * 移动资源到指定文件夹
         *
         * @param asset 被移动资源
         * @param folder 目标文件夹
         * @param callback 完成回调
         */
        ReadWriteRS.prototype.moveAsset = function (asset, folder, callback) {
            var _this = this;
            var filename = asset.fileName + asset.extenson;
            var cnames = folder.childrenAssets.map(function (v) { return v.fileName + v.extenson; });
            if (cnames.indexOf(filename) != -1) {
                callback && callback(new Error("\u76EE\u6807\u6587\u4EF6\u5939\u4E2D\u5B58\u5728\u540C\u540D\u6587\u4EF6\uFF08\u5939\uFF09\uFF0C\u65E0\u6CD5\u79FB\u52A8"));
                return;
            }
            var fp = folder;
            while (fp) {
                if (fp == asset) {
                    callback && callback(new Error("\u65E0\u6CD5\u79FB\u52A8\u8FBE\u5230\u5B50\u6587\u4EF6\u5939\u4E2D"));
                    return;
                }
                fp = fp.parentAsset;
            }
            // 重新设置父子资源关系
            var index = asset.parentAsset.childrenAssets.indexOf(asset);
            asset.parentAsset.childrenAssets.splice(index, 1);
            folder.childrenAssets.push(asset);
            asset.parentAsset = folder;
            // 获取需要移动的资源列表
            var assets = [asset];
            var index = 0;
            while (index < assets.length) {
                var ca = assets[index];
                if (ca instanceof feng3d.FolderAsset) {
                    assets = assets.concat(ca.childrenAssets);
                }
                index++;
            }
            // 最后根据 parentAsset 修复 childrenAssets
            var copyassets = assets.concat();
            // 移动最后一个资源
            var moveLastAsset = function () {
                if (assets.length == 0) {
                    // 修复 childrenAssets
                    copyassets.forEach(function (v) {
                        v.parentAsset.childrenAssets.push(v);
                    });
                    callback && callback(null);
                    // 保存资源库
                    _this.laterSave();
                    return;
                }
                var la = assets.pop();
                // 读取资源
                _this.readAsset(la.assetId, function (err, a) {
                    if (err) {
                        callback && callback(err);
                        return;
                    }
                    // 备份父资源
                    var pla = la.parentAsset;
                    // 从原路径上删除资源
                    _this.deleteAsset(la, function (err) {
                        if (err) {
                            callback && callback(err);
                            return;
                        }
                        // 修复删除资源时破坏的父资源引用
                        la.parentAsset = pla;
                        // 计算资源新路径
                        var np = la.fileName + la.extenson;
                        var p = la.parentAsset;
                        while (p) {
                            np = p.fileName + "/" + np;
                            p = p.parentAsset;
                        }
                        la.assetPath = np;
                        // 新增映射
                        _this.idMap[la.assetId] = la;
                        _this.pathMap[la.assetPath] = la;
                        // 保存资源到新路径
                        _this.writeAsset(la, function (err) {
                            if (err) {
                                callback && callback(err);
                                return;
                            }
                            moveLastAsset();
                        });
                    });
                });
            };
            moveLastAsset();
        };
        /**
         * 删除资源
         *
         * @param asset 资源
         * @param callback 完成回调
         */
        ReadWriteRS.prototype.deleteAsset = function (asset, callback) {
            var _this = this;
            // 获取需要移动的资源列表
            var assets = [asset];
            var index = 0;
            while (index < assets.length) {
                var ca = assets[index];
                if (ca instanceof feng3d.FolderAsset) {
                    assets = assets.concat(ca.childrenAssets);
                }
                index++;
            }
            // 删除最后一个资源
            var deleteLastAsset = function () {
                if (assets.length == 0) {
                    callback && callback(null);
                    // 保存资源库
                    _this.laterSave();
                    return;
                }
                var la = assets.pop();
                la.delete(function () {
                    feng3d.AssetData.deleteAssetData(la.data);
                    deleteLastAsset();
                });
            };
            deleteLastAsset();
        };
        return ReadWriteRS;
    }(feng3d.ReadRS));
    feng3d.ReadWriteRS = ReadWriteRS;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 键盘按键字典 （补充常量，a-z以及鼠标按键不必再次列出）
     * 例如 boardKeyDic[17] = "ctrl";
     */
    var boardKeyDic = {
        17: "ctrl",
        16: "shift",
        32: "escape",
        18: "alt",
        46: "del",
    };
    var KeyBoard = /** @class */ (function () {
        function KeyBoard() {
        }
        /**
         * 获取键盘按键名称
         * @param code   按键值
         */
        KeyBoard.getKey = function (code) {
            var key = boardKeyDic[code];
            if (key == null && 65 <= code && code <= 90) {
                key = String.fromCharCode(code).toLocaleLowerCase();
            }
            return key;
        };
        /**
         * 获取按键值
         * @param key 按键
         */
        KeyBoard.getCode = function (key) {
            key = key.toLocaleLowerCase();
            var code = key.charCodeAt(0);
            if (key.length == 1 && 65 <= code && code <= 90) {
                return code;
            }
            for (var code_1 in boardKeyDic) {
                if (boardKeyDic.hasOwnProperty(code_1)) {
                    if (boardKeyDic[code_1] == key)
                        return Number(code_1);
                }
            }
            console.error("\u65E0\u6CD5\u83B7\u53D6\u6309\u952E " + key + " \u7684\u503C\uFF01");
            return code;
        };
        return KeyBoard;
    }());
    feng3d.KeyBoard = KeyBoard;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 按键捕获

     */
    var KeyCapture = /** @class */ (function () {
        /**
         * 构建
         * @param stage		舞台
         */
        function KeyCapture(shortCut) {
            /**
             * 捕获的按键字典
             */
            this._mouseKeyDic = {};
            this._keyState = shortCut.keyState;
            //
            if (!feng3d.windowEventProxy) {
                return;
            }
            feng3d.windowEventProxy.on("keydown", this.onKeydown, this);
            feng3d.windowEventProxy.on("keyup", this.onKeyup, this);
            //监听鼠标事件
            var mouseEvents = [
                "dblclick",
                "click",
                "mousedown",
                "mouseup",
                "mousemove",
                "mouseover",
                "mouseout",
            ];
            for (var i = 0; i < mouseEvents.length; i++) {
                feng3d.windowEventProxy.on(mouseEvents[i], this.onMouseOnce, this);
            }
            feng3d.windowEventProxy.on("wheel", this.onMousewheel, this);
        }
        /**
         * 鼠标事件
         */
        KeyCapture.prototype.onMouseOnce = function (event) {
            if (!feng3d.shortcut.enable)
                return;
            var mouseKey = event.type;
            this._keyState.pressKey(mouseKey, event);
            this._keyState.releaseKey(mouseKey, event);
        };
        /**
         * 鼠标事件
         */
        KeyCapture.prototype.onMousewheel = function (event) {
            if (!feng3d.shortcut.enable)
                return;
            var mouseKey = event.type;
            this._keyState.pressKey(mouseKey, event);
            this._keyState.releaseKey(mouseKey, event);
        };
        /**
         * 键盘按下事件
         */
        KeyCapture.prototype.onKeydown = function (event) {
            if (!feng3d.shortcut.enable)
                return;
            var boardKey = feng3d.KeyBoard.getKey(event.keyCode);
            boardKey = boardKey || event.key;
            if (boardKey) {
                boardKey = boardKey.toLocaleLowerCase();
                this._keyState.pressKey(boardKey, event);
            }
            else {
                console.error("\u65E0\u6CD5\u8BC6\u522B\u6309\u94AE " + event.key);
            }
        };
        /**
         * 键盘弹起事件
         */
        KeyCapture.prototype.onKeyup = function (event) {
            if (!feng3d.shortcut.enable)
                return;
            var boardKey = feng3d.KeyBoard.getKey(event.keyCode);
            boardKey = boardKey || event.key;
            if (boardKey) {
                boardKey = boardKey.toLocaleLowerCase();
                this._keyState.releaseKey(boardKey, event);
            }
            else {
                console.error("\u65E0\u6CD5\u8BC6\u522B\u6309\u94AE " + event.key);
            }
        };
        return KeyCapture;
    }());
    feng3d.KeyCapture = KeyCapture;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 按键状态

     */
    var KeyState = /** @class */ (function (_super) {
        __extends(KeyState, _super);
        /**
         * 构建
         */
        function KeyState() {
            var _this = _super.call(this) || this;
            _this._keyStateDic = {};
            return _this;
        }
        /**
         * 按下键
         * @param key 	键名称
         * @param data	携带数据
         */
        KeyState.prototype.pressKey = function (key, data) {
            // 处理鼠标中键与右键
            if (data instanceof MouseEvent) {
                if (["click", "mousedown", "mouseup"].indexOf(data.type) != -1) {
                    key = ["", "middle", "right"][data.button] + data.type;
                }
            }
            this._keyStateDic[key] = true;
            this.dispatch(key, data);
        };
        /**
         * 释放键
         * @param key	键名称
         * @param data	携带数据
         */
        KeyState.prototype.releaseKey = function (key, data) {
            // 处理鼠标中键与右键
            if (data instanceof MouseEvent) {
                if (["click", "mousedown", "mouseup"].indexOf(data.type) != -1) {
                    key = ["", "middle", "right"][data.button] + data.type;
                }
            }
            this._keyStateDic[key] = false;
            this.dispatch(key, data);
        };
        /**
         * 获取按键状态
         * @param key 按键名称
         */
        KeyState.prototype.getKeyState = function (key) {
            return !!this._keyStateDic[key];
        };
        return KeyState;
    }(feng3d.EventDispatcher));
    feng3d.KeyState = KeyState;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 快捷键捕获
     */
    var ShortCutCapture = /** @class */ (function () {
        /**
         * 构建快捷键捕获
         * @param shortCut				快捷键环境
         * @param key					快捷键；用“+”连接多个按键，“!”表示没按下某键；例如 “a+!b”表示按下“a”与没按下“b”时触发。
         * @param command				要执行的command的id；使用“,”连接触发多个命令；例如 “commandA,commandB”表示满足触发条件后依次执行commandA与commandB命令。
         * @param stateCommand			要执行的状态命令id；使用“,”连接触发多个状态命令，没带“!”表示激活该状态，否则表示使其处于非激活状态；例如 “stateA,!stateB”表示满足触发条件后激活状态“stateA，使“stateB处于非激活状态。
         * @param when					快捷键激活的条件；使用“+”连接多个状态，没带“!”表示需要处于激活状态，否则需要处于非激活状态； 例如 “stateA+!stateB”表示stateA处于激活状态且stateB处于非激活状态时会判断按键是否满足条件。
         */
        function ShortCutCapture(shortCut, key, command, stateCommand, when) {
            this._shortCut = shortCut;
            this._keyState = shortCut.keyState;
            this._key = key;
            this._command = command;
            this._stateCommand = stateCommand;
            this._when = when;
            this._keys = this.getKeys(key);
            this._states = this.getStates(when);
            this._commands = this.getCommands(command);
            this._stateCommands = this.getStateCommand(stateCommand);
            this.init();
        }
        /**
         * 初始化
         */
        ShortCutCapture.prototype.init = function () {
            for (var i = 0; i < this._keys.length; i++) {
                this._keyState.on(this._keys[i].key, this.onCapture, this);
            }
        };
        /**
         * 处理捕获事件
         */
        ShortCutCapture.prototype.onCapture = function (event) {
            var inWhen = this.checkActivityStates(this._states);
            var pressKeys = this.checkActivityKeys(this._keys);
            if (pressKeys && inWhen) {
                this.dispatchCommands(this._commands, event);
                this.executeStateCommands(this._stateCommands);
            }
        };
        /**
         * 派发命令
         */
        ShortCutCapture.prototype.dispatchCommands = function (commands, data) {
            for (var i = 0; i < commands.length; i++) {
                this._shortCut.dispatch(commands[i], data);
            }
        };
        /**
         * 执行状态命令
         */
        ShortCutCapture.prototype.executeStateCommands = function (stateCommands) {
            for (var i = 0; i < stateCommands.length; i++) {
                var stateCommand = stateCommands[i];
                if (stateCommand.not)
                    this._shortCut.deactivityState(stateCommand.state);
                else
                    this._shortCut.activityState(stateCommand.state);
            }
        };
        /**
         * 检测快捷键是否处于活跃状态
         */
        ShortCutCapture.prototype.checkActivityStates = function (states) {
            for (var i = 0; i < states.length; i++) {
                if (!this.getState(states[i]))
                    return false;
            }
            return true;
        };
        /**
         * 获取是否处于指定状态中（支持一个！取反）
         * @param state 状态名称
         */
        ShortCutCapture.prototype.getState = function (state) {
            var result = this._shortCut.getState(state.state);
            if (state.not) {
                result = !result;
            }
            return result;
        };
        /**
         * 检测是否按下给出的键
         * @param keys 按键数组
         */
        ShortCutCapture.prototype.checkActivityKeys = function (keys) {
            for (var i = 0; i < keys.length; i++) {
                if (!this.getKeyValue(keys[i]))
                    return false;
            }
            return true;
        };
        /**
         * 获取按键状态（true：按下状态，false：弹起状态）
         */
        ShortCutCapture.prototype.getKeyValue = function (key) {
            var value = this._keyState.getKeyState(key.key);
            if (key.not) {
                value = !value;
            }
            return value;
        };
        /**
         * 获取状态列表
         * @param when		状态字符串
         */
        ShortCutCapture.prototype.getStates = function (when) {
            var states = [];
            if (!when)
                return states;
            var state = when.trim();
            if (state.length == 0) {
                return states;
            }
            var stateStrs = state.split("+");
            for (var i = 0; i < stateStrs.length; i++) {
                states.push(new State(stateStrs[i]));
            }
            return states;
        };
        /**
         * 获取键列表
         * @param key		快捷键
         */
        ShortCutCapture.prototype.getKeys = function (key) {
            var keyStrs = key.split("+");
            var keys = [];
            for (var i = 0; i < keyStrs.length; i++) {
                keys.push(new Key(keyStrs[i]));
            }
            return keys;
        };
        /**
         * 获取命令列表
         * @param command	命令
         */
        ShortCutCapture.prototype.getCommands = function (command) {
            var commands = [];
            if (!command)
                return commands;
            command = command.trim();
            var commandStrs = command.split(",");
            for (var i = 0; i < commandStrs.length; i++) {
                var commandStr = commandStrs[i].trim();
                if (commandStr.length > 0) {
                    commands.push(commandStr);
                }
            }
            return commands;
        };
        /**
         * 获取状态命令列表
         * @param stateCommand	状态命令
         */
        ShortCutCapture.prototype.getStateCommand = function (stateCommand) {
            var stateCommands = [];
            if (!stateCommand)
                return stateCommands;
            stateCommand = stateCommand.trim();
            var stateCommandStrs = stateCommand.split(",");
            for (var i = 0; i < stateCommandStrs.length; i++) {
                var commandStr = stateCommandStrs[i].trim();
                if (commandStr.length > 0) {
                    stateCommands.push(new StateCommand(commandStr));
                }
            }
            return stateCommands;
        };
        /**
         * 销毁
         */
        ShortCutCapture.prototype.destroy = function () {
            for (var i = 0; i < this._keys.length; i++) {
                this._keyState.off(this._keys[i].key, this.onCapture, this);
            }
            this._shortCut = null;
            this._keys = null;
            this._states = null;
        };
        return ShortCutCapture;
    }());
    feng3d.ShortCutCapture = ShortCutCapture;
})(feng3d || (feng3d = {}));
/**
 * 按键
 */
var Key = /** @class */ (function () {
    function Key(key) {
        key = key.trim();
        if (key.charAt(0) == "!") {
            this.not = true;
            key = key.substr(1).trim();
        }
        this.key = key;
    }
    return Key;
}());
/**
 * 状态
 */
var State = /** @class */ (function () {
    function State(state) {
        state = state.trim();
        if (state.charAt(0) == "!") {
            this.not = true;
            state = state.substr(1).trim();
        }
        this.state = state;
    }
    return State;
}());
/**
 * 状态命令
 */
var StateCommand = /** @class */ (function () {
    function StateCommand(state) {
        state = state.trim();
        if (state.charAt(0) == "!") {
            this.not = true;
            state = state.substr(1).trim();
        }
        this.state = state;
    }
    return StateCommand;
}());
var feng3d;
(function (feng3d) {
    /**
     * 初始化快捷键模块
     *
     * <pre>
var shortcuts:Array = [ //
//在按下key1时触发命令command1
    {key: "key1", command: "command1", when: ""}, //
     //在按下key1时触发状态命令改变stateCommand1为激活状态
    {key: "key1", stateCommand: "stateCommand1", when: "state1"}, //
     //处于state1状态时按下key1触发命令command1
    {key: "key1", command: "command1", when: "state1"}, //
    //处于state1状态不处于state2时按下key1与没按下key2触发command1与command2，改变stateCommand1为激活状态，stateCommand2为非激活状态
    {key: "key1+ ! key2", command: "command1,command2", stateCommand: "stateCommand1,!stateCommand2", when: "state1+!state2"}, //
    ];
//添加快捷键
shortCut.addShortCuts(shortcuts);
//监听命令
Event.on(shortCut,<any>"run", function(e:Event):void
{
    trace("接受到命令：" + e.type);
});
     * </pre>
     */
    var ShortCut = /** @class */ (function (_super) {
        __extends(ShortCut, _super);
        /**
         * 初始化快捷键模块
         */
        function ShortCut() {
            var _this = _super.call(this) || this;
            /**
             * 启动
             */
            _this.enable = true;
            _this.keyState = new feng3d.KeyState();
            _this.keyCapture = new feng3d.KeyCapture(_this);
            _this.captureDic = {};
            _this.stateDic = {};
            return _this;
        }
        /**
         * 添加快捷键
         * @param shortcuts		快捷键列表
         */
        ShortCut.prototype.addShortCuts = function (shortcuts) {
            for (var i = 0; i < shortcuts.length; i++) {
                var shortcut = shortcuts[i];
                var shortcutUniqueKey = this.getShortcutUniqueKey(shortcut);
                this.captureDic[shortcutUniqueKey] = this.captureDic[shortcutUniqueKey] || new feng3d.ShortCutCapture(this, shortcut.key, shortcut.command, shortcut.stateCommand, shortcut.when);
            }
        };
        /**
         * 删除快捷键
         * @param shortcuts		快捷键列表
         */
        ShortCut.prototype.removeShortCuts = function (shortcuts) {
            for (var i = 0; i < shortcuts.length; i++) {
                var shortcutUniqueKey = this.getShortcutUniqueKey(shortcuts[i]);
                var shortCutCapture = this.captureDic[shortcutUniqueKey];
                if (feng3d.ShortCutCapture != null) {
                    shortCutCapture.destroy();
                }
                delete this.captureDic[shortcutUniqueKey];
            }
        };
        /**
         * 移除所有快捷键
         */
        ShortCut.prototype.removeAllShortCuts = function () {
            var _this = this;
            var keys = [];
            var key;
            for (key in this.captureDic) {
                keys.push(key);
            }
            keys.forEach(function (key) {
                var shortCutCapture = _this.captureDic[key];
                shortCutCapture.destroy();
                delete _this.captureDic[key];
            });
        };
        /**
         * 激活状态
         * @param state 状态名称
         */
        ShortCut.prototype.activityState = function (state) {
            this.stateDic[state] = true;
        };
        /**
         * 取消激活状态
         * @param state 状态名称
         */
        ShortCut.prototype.deactivityState = function (state) {
            delete this.stateDic[state];
        };
        /**
         * 获取状态
         * @param state 状态名称
         */
        ShortCut.prototype.getState = function (state) {
            return !!this.stateDic[state];
        };
        /**
         * 获取快捷键唯一字符串
         */
        ShortCut.prototype.getShortcutUniqueKey = function (shortcut) {
            return shortcut.key + "," + shortcut.command + "," + shortcut.stateCommand + "," + shortcut.when;
        };
        return ShortCut;
    }(feng3d.EventDispatcher));
    feng3d.ShortCut = ShortCut;
    feng3d.shortcut = new ShortCut();
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 加载类
     */
    var Loader = /** @class */ (function () {
        function Loader() {
        }
        /**
         * 加载文本
         * @param url   路径
         */
        Loader.prototype.loadText = function (url, onCompleted, onRequestProgress, onError) {
            xmlHttpRequestLoad({ url: url, dataFormat: feng3d.LoaderDataFormat.TEXT, onCompleted: onCompleted, onProgress: onRequestProgress, onError: onError });
        };
        /**
         * 加载二进制
         * @param url   路径
         */
        Loader.prototype.loadBinary = function (url, onCompleted, onRequestProgress, onError) {
            xmlHttpRequestLoad({ url: url, dataFormat: feng3d.LoaderDataFormat.BINARY, onCompleted: onCompleted, onProgress: onRequestProgress, onError: onError });
        };
        /**
         * 加载图片
         * @param url   路径
         */
        Loader.prototype.loadImage = function (url, onCompleted, onRequestProgress, onError) {
            var image = new Image();
            image.crossOrigin = "Anonymous";
            image.onload = function (event) {
                onCompleted && onCompleted(image);
            };
            image.onerror = function (event) {
                feng3d.debuger && console.error("Error while trying to load texture: " + url);
                //
                image.src = "data:image/jpg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/4QBmRXhpZgAATU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAAExAAIAAAAQAAAATgAAAAAAAABgAAAAAQAAAGAAAAABcGFpbnQubmV0IDQuMC41AP/bAEMABAIDAwMCBAMDAwQEBAQFCQYFBQUFCwgIBgkNCw0NDQsMDA4QFBEODxMPDAwSGBITFRYXFxcOERkbGRYaFBYXFv/bAEMBBAQEBQUFCgYGChYPDA8WFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFv/AABEIAQABAAMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/APH6KKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76P//Z";
                //
                var err = new Error(url + " 加载失败！");
                onError && onError(err);
            };
            image.src = url;
        };
        return Loader;
    }());
    feng3d.Loader = Loader;
    feng3d.loader = new Loader();
    /**
     * 使用XMLHttpRequest加载
     * @param url           加载路径
     * @param dataFormat    数据类型
     */
    function xmlHttpRequestLoad(loadItem) {
        var request = new XMLHttpRequest();
        request.open('Get', loadItem.url, true);
        request.setRequestHeader("Access-Control-Allow-Origin", "*");
        request.responseType = loadItem.dataFormat == feng3d.LoaderDataFormat.BINARY ? "arraybuffer" : "";
        request.onreadystatechange = onRequestReadystatechange(request, loadItem);
        request.onprogress = onRequestProgress(request, loadItem);
        request.send();
    }
    /**
     * 请求进度回调
     */
    function onRequestProgress(request, loadItem) {
        return function (event) {
            loadItem.onProgress && loadItem.onProgress(event.loaded, event.total);
        };
    }
    /**
     * 请求状态变化回调
     */
    function onRequestReadystatechange(request, loadItem) {
        return function (ev) {
            if (request.readyState == 4) { // 4 = "loaded"
                request.onreadystatechange = null;
                if (request.status >= 200 && request.status < 300) {
                    var content = loadItem.dataFormat == feng3d.LoaderDataFormat.TEXT ? request.responseText : request.response;
                    loadItem.onCompleted && loadItem.onCompleted(content);
                }
                else {
                    var err = new Error(loadItem.url + " 加载失败！");
                    loadItem.onError && loadItem.onError(err);
                    loadItem.onCompleted && loadItem.onCompleted(null);
                }
            }
        };
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 加载数据类型

     */
    var LoaderDataFormat = /** @class */ (function () {
        function LoaderDataFormat() {
        }
        /**
         * 以原始二进制数据形式接收下载的数据。
         */
        LoaderDataFormat.BINARY = "binary";
        /**
         * 以文本形式接收已下载的数据。
         */
        LoaderDataFormat.TEXT = "text";
        /**
         * 图片数据
         */
        LoaderDataFormat.IMAGE = "image";
        return LoaderDataFormat;
    }());
    feng3d.LoaderDataFormat = LoaderDataFormat;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 渲染模式
     * A GLenum specifying the type primitive to render. Possible values are:
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/drawElements

     */
    var RenderMode;
    (function (RenderMode) {
        /**
         * 点渲染
         * gl.POINTS: Draws a single dot.
         */
        RenderMode["POINTS"] = "POINTS";
        /**
         * gl.LINE_LOOP: Draws a straight line to the next vertex, and connects the last vertex back to the first.
         */
        RenderMode["LINE_LOOP"] = "LINE_LOOP";
        /**
         * gl.LINE_STRIP: Draws a straight line to the next vertex.
         */
        RenderMode["LINE_STRIP"] = "LINE_STRIP";
        /**
         * gl.LINES: Draws a line between a pair of vertices.
         */
        RenderMode["LINES"] = "LINES";
        /**
         * gl.TRIANGLES: Draws a triangle for a group of three vertices.
         */
        RenderMode["TRIANGLES"] = "TRIANGLES";
        /**
         * gl.TRIANGLE_STRIP
         * @see https://en.wikipedia.org/wiki/Triangle_strip
         */
        RenderMode["TRIANGLE_STRIP"] = "TRIANGLE_STRIP";
        /**
         * gl.TRIANGLE_FAN
         * @see https://en.wikipedia.org/wiki/Triangle_fan
         */
        RenderMode["TRIANGLE_FAN"] = "TRIANGLE_FAN";
    })(RenderMode = feng3d.RenderMode || (feng3d.RenderMode = {}));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 纹理类型
     * A GLenum specifying the binding point (target). Possible values:
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindTexture
     */
    var TextureType;
    (function (TextureType) {
        /**
         * gl.TEXTURE_2D: A two-dimensional texture.
         */
        TextureType["TEXTURE_2D"] = "TEXTURE_2D";
        /**
         * gl.TEXTURE_CUBE_MAP: A cube-mapped texture.
         */
        TextureType["TEXTURE_CUBE_MAP"] = "TEXTURE_CUBE_MAP";
        // /**
        //  * using a WebGL 2 context
        //  * gl.TEXTURE_3D: A three-dimensional texture.
        //  */
        // TEXTURE_3D = "TEXTURE_3D",
        // /**
        //  * using a WebGL 2 context
        //  * gl.TEXTURE_2D_ARRAY: A two-dimensional array texture.
        //  */
        // TEXTURE_2D_ARRAY = "TEXTURE_2D_ARRAY",
    })(TextureType = feng3d.TextureType || (feng3d.TextureType = {}));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 混合方法
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/blendEquation
     */
    var BlendEquation;
    (function (BlendEquation) {
        /**
         *  source + destination
         */
        BlendEquation["FUNC_ADD"] = "FUNC_ADD";
        /**
         * source - destination
         */
        BlendEquation["FUNC_SUBTRACT"] = "FUNC_SUBTRACT";
        /**
         * destination - source
         */
        BlendEquation["FUNC_REVERSE_SUBTRACT"] = "FUNC_REVERSE_SUBTRACT";
        // /**
        //  * When using the EXT_blend_minmax extension:
        //  * Minimum of source and destination
        //  */
        // MIN_EXT = "MIN_EXT",
        // /**
        //  * When using the EXT_blend_minmax extension:
        //  * Maximum of source and destination.
        //  */
        // MAX_EXT = "MAX_EXT",
        // /**
        //  * using a WebGL 2 context
        //  * Minimum of source and destination
        //  */
        // MIN = "MIN",
        // /**
        //  * using a WebGL 2 context
        //  * Maximum of source and destination.
        //  */
        // MAX = "MAX",
    })(BlendEquation = feng3d.BlendEquation || (feng3d.BlendEquation = {}));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 混合因子（R分量系数，G分量系数，B分量系数）
     */
    var BlendFactor;
    (function (BlendFactor) {
        /**
         * 0.0  0.0 0.0
         */
        BlendFactor["ZERO"] = "ZERO";
        /**
         * 1.0  1.0 1.0
         */
        BlendFactor["ONE"] = "ONE";
        /**
         * Rs   Gs  Bs
         */
        BlendFactor["SRC_COLOR"] = "SRC_COLOR";
        /**
         * 1-Rs   1-Gs  1-Bs
         */
        BlendFactor["ONE_MINUS_SRC_COLOR"] = "ONE_MINUS_SRC_COLOR";
        /**
         * Rd   Gd  Bd
         */
        BlendFactor["DST_COLOR"] = "DST_COLOR";
        /**
         * 1-Rd   1-Gd  1-Bd
         */
        BlendFactor["ONE_MINUS_DST_COLOR"] = "ONE_MINUS_DST_COLOR";
        /**
         * As   As  As
         */
        BlendFactor["SRC_ALPHA"] = "SRC_ALPHA";
        /**
         * 1-As   1-As  1-As
         */
        BlendFactor["ONE_MINUS_SRC_ALPHA"] = "ONE_MINUS_SRC_ALPHA";
        /**
         * Ad   Ad  Ad
         */
        BlendFactor["DST_ALPHA"] = "DST_ALPHA";
        /**
         * 1-Ad   1-Ad  1-Ad
         */
        BlendFactor["ONE_MINUS_DST_ALPHA"] = "ONE_MINUS_DST_ALPHA";
        /**
         * min(As-Ad)   min(As-Ad)  min(As-Ad)
         */
        BlendFactor["SRC_ALPHA_SATURATE"] = "SRC_ALPHA_SATURATE";
    })(BlendFactor = feng3d.BlendFactor || (feng3d.BlendFactor = {}));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 裁剪面枚举
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/cullFace
     */
    var CullFace;
    (function (CullFace) {
        /**
         * 关闭裁剪面
         */
        CullFace["NONE"] = "NONE";
        /**
         * 正面
         */
        CullFace["FRONT"] = "FRONT";
        /**
         * 背面
         */
        CullFace["BACK"] = "BACK";
        /**
         * 正面与背面
         */
        CullFace["FRONT_AND_BACK"] = "FRONT_AND_BACK";
    })(CullFace = feng3d.CullFace || (feng3d.CullFace = {}));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 正面方向枚举
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/frontFace
     */
    var FrontFace;
    (function (FrontFace) {
        /**
         * Clock-wise winding.
         */
        FrontFace["CW"] = "CW";
        /**
         *  Counter-clock-wise winding.
         */
        FrontFace["CCW"] = "CCW";
    })(FrontFace = feng3d.FrontFace || (feng3d.FrontFace = {}));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 纹理颜色格式
     * A GLint specifying the color components in the texture
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D
     */
    var TextureFormat;
    (function (TextureFormat) {
        /**
         * Discards the red, green and blue components and reads the alpha component.
         */
        TextureFormat["ALPHA"] = "ALPHA";
        /**
         *  Discards the alpha components and reads the red, green and blue components.
         */
        TextureFormat["RGB"] = "RGB";
        /**
         * Red, green, blue and alpha components are read from the color buffer.
         */
        TextureFormat["RGBA"] = "RGBA";
        /**
         * Each color component is a luminance component, alpha is 1.0.
         */
        TextureFormat["LUMINANCE"] = "LUMINANCE";
        /**
         * Each component is a luminance/alpha component.
         */
        TextureFormat["LUMINANCE_ALPHA"] = "LUMINANCE_ALPHA";
        // /**
        //  * When using the WEBGL_depth_texture extension:
        //  */
        // DEPTH_COMPONENT = "DEPTH_COMPONENT",
        // /**
        //  * When using the WEBGL_depth_texture extension:
        //  */
        // DEPTH_STENCIL = "DEPTH_STENCIL",
        // /**
        //  * When using the EXT_sRGB extension:
        //  */
        // SRGB_EXT = "SRGB_EXT",
        // /**
        //  * When using the EXT_sRGB extension:
        //  */
        // SRGB_ALPHA_EXT = "SRGB_ALPHA_EXT",
        // /**
        //  * using a WebGL 2 context
        //  */
        // R8 = "R8",
        // /**
        //  * using a WebGL 2 context
        //  */
        // R16F = "R16F",
        // /**
        //  * using a WebGL 2 context
        //  */
        // R32F = "R32F",
        // /**
        //  * using a WebGL 2 context
        //  */
        // R8UI = "R8UI",
        // /**
        //  * using a WebGL 2 context
        //  */
        // RG8 = "RG8",
        // /**
        //  * using a WebGL 2 context
        //  */
        // RG16F = "RG16F",
        // /**
        //  * using a WebGL 2 context
        //  */
        // RG32F = "RG32F",
        // /**
        //  * using a WebGL 2 context
        //  */
        // RG8UI = "RG8UI",
        // /**
        //  * using a WebGL 2 context
        //  */
        // RG16UI = "RG16UI",
        // /**
        //  * using a WebGL 2 context
        //  */
        // RG32UI = "RG32UI",
        // /**
        //  * using a WebGL 2 context
        //  */
        // RGB8 = "RGB8",
        // /**
        //  * using a WebGL 2 context
        //  */
        // SRGB8 = "SRGB8",
        // /**
        //  * using a WebGL 2 context
        //  */
        // RGB565 = "RGB565",
        // /**
        //  * using a WebGL 2 context
        //  */
        // R11F_G11F_B10F = "R11F_G11F_B10F",
        // /**
        //  * using a WebGL 2 context
        //  */
        // RGB9_E5 = "RGB9_E5",
        // /**
        //  * using a WebGL 2 context
        //  */
        // RGB16F = "RGB16F",
        // /**
        //  * using a WebGL 2 context
        //  */
        // RGB32F = "RGB32F",
        // /**
        //  * using a WebGL 2 context
        //  */
        // RGB8UI = "RGB8UI",
        // /**
        //  * using a WebGL 2 context
        //  */
        // RGBA8 = "RGBA8",
        // /**
        //  * using a WebGL 2 context
        //  */
        // // SRGB8_APLHA8,
        // /**
        //  * using a WebGL 2 context
        //  */
        // RGB5_A1 = "RGB5_A1",
        // /**
        //  * using a WebGL 2 context
        //  */
        // RGB10_A2 = "RGB10_A2",
        // /**
        //  * using a WebGL 2 context
        //  */
        // RGBA4 = "RGBA4",
        // /**
        //  * using a WebGL 2 context
        //  */
        // RGBA16F = "RGBA16F",
        // /**
        //  * using a WebGL 2 context
        //  */
        // RGBA32F = "RGBA32F",
        // /**
        //  * using a WebGL 2 context
        //  */
        // RGBA8UI = "RGBA8UI",
    })(TextureFormat = feng3d.TextureFormat || (feng3d.TextureFormat = {}));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 纹理数据类型
     * A GLenum specifying the data type of the texel data
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D
     */
    var TextureDataType;
    (function (TextureDataType) {
        /**
         * 8 bits per channel for gl.RGBA
         */
        TextureDataType["UNSIGNED_BYTE"] = "UNSIGNED_BYTE";
        /**
         * 5 red bits, 6 green bits, 5 blue bits.
         */
        TextureDataType["UNSIGNED_SHORT_5_6_5"] = "UNSIGNED_SHORT_5_6_5";
        /**
         * 4 red bits, 4 green bits, 4 blue bits, 4 alpha bits.
         */
        TextureDataType["UNSIGNED_SHORT_4_4_4_4"] = "UNSIGNED_SHORT_4_4_4_4";
        /**
         * 5 red bits, 5 green bits, 5 blue bits, 1 alpha bit.
         */
        TextureDataType["UNSIGNED_SHORT_5_5_5_1"] = "UNSIGNED_SHORT_5_5_5_1";
        // /**
        //  * When using the WEBGL_depth_texture extension:
        //  */
        // UNSIGNED_SHORT = "UNSIGNED_SHORT",
        // /**
        //  * When using the WEBGL_depth_texture extension:
        //  */
        // UNSIGNED_INT = "UNSIGNED_INT",
        // /**
        //  * When using the WEBGL_depth_texture extension:
        //  *  (constant provided by the extension)
        //  */
        // UNSIGNED_INT_24_8_WEBGL = "UNSIGNED_INT_24_8_WEBGL",
        // //When using the OES_texture_half_float extension:
        // /**
        //  * When using the OES_texture_float extension:
        //  */
        // FLOAT = "FLOAT",
        // /**
        //  * When using the OES_texture_half_float extension:
        //  *  (constant provided by the extension)
        //  */
        // HALF_FLOAT_OES = "HALF_FLOAT_OES",
        // // When using a WebGL 2 context, the following values are available additionally:
        // /**
        //  * using a WebGL 2 context
        //  */
        // BYTE = "BYTE",
        // // UNSIGNED_SHORT   // 与上面合并处理
        // /**
        //  * using a WebGL 2 context
        //  */
        // SHORT = "SHORT",
        // // UNSIGNED_INT     // 与上面合并处理
        // /**
        //  * using a WebGL 2 context
        //  */
        // INT = "INT",
        // /**
        //  * using a WebGL 2 context
        //  */
        // HALF_FLOAT = "HALF_FLOAT",
        // // FLOAT               // 与上面合并处理
        // /**
        //  * using a WebGL 2 context
        //  */
        // UNSIGNED_INT_2_10_10_10_REV = "UNSIGNED_INT_2_10_10_10_REV",
        // /**
        //  * using a WebGL 2 context
        //  */
        // UNSIGNED_INT_10F_11F_11F_REV = "UNSIGNED_INT_10F_11F_11F_REV",
        // /**
        //  * using a WebGL 2 context
        //  */
        // UNSIGNED_INT_5_9_9_9_REV = "UNSIGNED_INT_5_9_9_9_REV",
        // /**
        //  * using a WebGL 2 context
        //  */
        // UNSIGNED_INT_24_8 = "UNSIGNED_INT_24_8",
        // /**
        //  * using a WebGL 2 context
        //  *  (pixels must be null)
        //  */
        // FLOAT_32_UNSIGNED_INT_24_8_REV = "FLOAT_32_UNSIGNED_INT_24_8_REV",
    })(TextureDataType = feng3d.TextureDataType || (feng3d.TextureDataType = {}));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 纹理缩小过滤器
     * Texture minification filter
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texParameter
     */
    var TextureMinFilter;
    (function (TextureMinFilter) {
        TextureMinFilter["LINEAR"] = "LINEAR";
        TextureMinFilter["NEAREST"] = "NEAREST";
        TextureMinFilter["NEAREST_MIPMAP_NEAREST"] = "NEAREST_MIPMAP_NEAREST";
        TextureMinFilter["LINEAR_MIPMAP_NEAREST"] = "LINEAR_MIPMAP_NEAREST";
        /**
         *  (default value)
         */
        TextureMinFilter["NEAREST_MIPMAP_LINEAR"] = "NEAREST_MIPMAP_LINEAR";
        TextureMinFilter["LINEAR_MIPMAP_LINEAR"] = "LINEAR_MIPMAP_LINEAR";
    })(TextureMinFilter = feng3d.TextureMinFilter || (feng3d.TextureMinFilter = {}));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 纹理放大滤波器
     * Texture magnification filter
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texParameter
     */
    var TextureMagFilter;
    (function (TextureMagFilter) {
        /**
         *  (default value)
         */
        TextureMagFilter["LINEAR"] = "LINEAR";
        TextureMagFilter["NEAREST"] = "NEAREST";
    })(TextureMagFilter = feng3d.TextureMagFilter || (feng3d.TextureMagFilter = {}));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 纹理坐标s包装函数枚举
     * Wrapping function for texture coordinate s
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texParameter
     */
    var TextureWrap;
    (function (TextureWrap) {
        /**
         * (default value)
         */
        TextureWrap["REPEAT"] = "REPEAT";
        TextureWrap["CLAMP_TO_EDGE"] = "CLAMP_TO_EDGE";
        TextureWrap["MIRRORED_REPEAT"] = "MIRRORED_REPEAT";
    })(TextureWrap = feng3d.TextureWrap || (feng3d.TextureWrap = {}));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * GL 数组数据类型
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer
     */
    var GLArrayType;
    (function (GLArrayType) {
        /**
         * signed 8-bit integer, with values in [-128, 127]
         */
        GLArrayType["BYTE"] = "BYTE";
        /**
         *  signed 16-bit integer, with values in [-32768, 32767]
         */
        GLArrayType["SHORT"] = "SHORT";
        /**
         * unsigned 8-bit integer, with values in [0, 255]
         */
        GLArrayType["UNSIGNED_BYTE"] = "UNSIGNED_BYTE";
        /**
         * unsigned 16-bit integer, with values in [0, 65535]
         */
        GLArrayType["UNSIGNED_SHORT"] = "UNSIGNED_SHORT";
        /**
         * 32-bit floating point number
         */
        GLArrayType["FLOAT"] = "FLOAT";
        // /**
        //  * using a WebGL 2 context
        //  * 16-bit floating point number
        //  */
        // HALF_FLOAT = "HALF_FLOAT",
    })(GLArrayType = feng3d.GLArrayType || (feng3d.GLArrayType = {}));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 深度检测方法枚举
     * A GLenum specifying the depth comparison function, which sets the conditions under which the pixel will be drawn. The default value is gl.LESS.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/depthFunc
     */
    var DepthFunc;
    (function (DepthFunc) {
        /**
         * (never pass)
         */
        DepthFunc["NEVER"] = "NEVER";
        /**
         *  (pass if the incoming value is less than the depth buffer value)
         */
        DepthFunc["LESS"] = "LESS";
        /**
         *  (pass if the incoming value equals the the depth buffer value)
         */
        DepthFunc["EQUAL"] = "EQUAL";
        /**
         *  (pass if the incoming value is less than or equal to the depth buffer value)
         */
        DepthFunc["LEQUAL"] = "LEQUAL";
        /**
         * (pass if the incoming value is greater than the depth buffer value)
         */
        DepthFunc["GREATER"] = "GREATER";
        /**
         * (pass if the incoming value is not equal to the depth buffer value)
         */
        DepthFunc["NOTEQUAL"] = "NOTEQUAL";
        /**
         * (pass if the incoming value is greater than or equal to the depth buffer value)
         */
        DepthFunc["GEQUAL"] = "GEQUAL";
        /**
         *  (always pass)
         */
        DepthFunc["ALWAYS"] = "ALWAYS";
    })(DepthFunc = feng3d.DepthFunc || (feng3d.DepthFunc = {}));
})(feng3d || (feng3d = {}));
// Type definitions for WebGL Extensions
// Project: http://webgl.org/
// Definitions by: Arthur Langereis <https://github.com/zenmumbler/>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped/webgl-ext
var feng3d;
(function (feng3d) {
    var GL = /** @class */ (function () {
        function GL() {
        }
        /**
         * 获取 GL 实例
         * @param canvas 画布
         * @param contextAttributes
         */
        GL.getGL = function (canvas, contextAttributes) {
            // var names = ["webgl2", "webgl"];
            var contextIds = ["webgl"];
            var gl = null;
            for (var i = 0; i < contextIds.length; ++i) {
                try {
                    gl = canvas.getContext(contextIds[i], contextAttributes);
                    gl.contextId = contextIds[i];
                    gl.contextAttributes = contextAttributes;
                    break;
                }
                catch (e) { }
            }
            if (!gl)
                throw "无法初始化WEBGL";
            //
            if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext)
                gl.webgl2 = true;
            //
            gl.capabilities = new feng3d.WebGLCapabilities(gl);
            //
            new feng3d.GLExtension(gl);
            new feng3d.Renderer(gl);
            gl.clearColor(0.0, 0.0, 0.0, 1.0); // Clear to black, fully opaque
            gl.clearDepth(1.0); // Clear everything
            gl.enable(gl.DEPTH_TEST); // Enable depth testing
            gl.depthFunc(gl.LEQUAL); // Near things obscure far things
            this.glList.push(gl);
            return gl;
        };
        GL.getToolGL = function () {
            if (!this._toolGL) {
                var canvas = document.createElement("canvas");
                this._toolGL = this.getGL(canvas);
            }
            return this._toolGL;
        };
        GL.glList = [];
        return GL;
    }());
    feng3d.GL = GL;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * GL扩展
     */
    var GLExtension = /** @class */ (function () {
        function GLExtension(gl) {
            feng3d.debuger && console.assert(!gl.extensions, gl + " " + gl.extensions + " \u5B58\u5728\uFF01");
            gl.extensions = this;
            this.initExtensions(gl);
            this.cacheGLQuery(gl);
        }
        GLExtension.prototype.initExtensions = function (gl) {
            this.aNGLEInstancedArrays = gl.getExtension("ANGLE_instanced_arrays");
            this.eXTBlendMinMax = gl.getExtension("EXT_blend_minmax");
            this.eXTColorBufferHalfFloat = gl.getExtension("EXT_color_buffer_half_float");
            this.eXTFragDepth = gl.getExtension("EXT_frag_depth");
            this.eXTsRGB = gl.getExtension("EXT_sRGB");
            this.eXTShaderTextureLOD = gl.getExtension("EXT_shader_texture_lod");
            this.eXTTextureFilterAnisotropic = gl.getExtension("EXT_texture_filter_anisotropic");
            this.oESElementIndexUint = gl.getExtension("OES_element_index_uint");
            this.oESStandardDerivatives = gl.getExtension("OES_standard_derivatives");
            this.oESTextureFloat = gl.getExtension("OES_texture_float");
            this.oESTextureFloatLinear = gl.getExtension("OES_texture_float_linear");
            this.oESTextureHalfFloat = gl.getExtension("OES_texture_half_float");
            this.oESTextureHalfFloatLinear = gl.getExtension("OES_texture_half_float_linear");
            this.oESVertexArrayObject = gl.getExtension("OES_vertex_array_object");
            this.webGLColorBufferFloat = gl.getExtension("WEBGL_color_buffer_float");
            this.webGLCompressedTextureATC = gl.getExtension("WEBGL_compressed_texture_atc");
            this.webGLCompressedTextureETC1 = gl.getExtension("WEBGL_compressed_texture_etc1");
            this.webGLCompressedTexturePVRTC = gl.getExtension("WEBGL_compressed_texture_pvrtc");
            this.webGLCompressedTextureS3TC = gl.getExtension("WEBGL_compressed_texture_s3tc");
            this.webGLDebugRendererInfo = gl.getExtension("WEBGL_debug_renderer_info");
            this.webGLDebugShaders = gl.getExtension("WEBGL_debug_shaders");
            this.webGLDepthTexture = gl.getExtension("WEBGL_depth_texture");
            this.webGLDrawBuffers = gl.getExtension("WEBGL_draw_buffers");
            this.webGLLoseContext = gl.getExtension("WEBGL_lose_context");
            // Prefixed versions appearing in the wild as per September 2015
            this.eXTTextureFilterAnisotropic = this.eXTTextureFilterAnisotropic || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            this.webGLCompressedTextureATC = this.webGLCompressedTextureATC || gl.getExtension("WEBKIT_WEBGL_compressed_texture_atc");
            this.webGLCompressedTexturePVRTC = this.webGLCompressedTexturePVRTC || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            this.webGLCompressedTextureS3TC = this.webGLCompressedTextureS3TC || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            this.webGLDepthTexture = this.webGLDepthTexture || gl.getExtension("WEBKIT_WEBGL_depth_texture");
            this.webGLLoseContext = this.webGLLoseContext || gl.getExtension("WEBKIT_WEBGL_lose_context");
            this.webGLCompressedTextureS3TC = this.webGLCompressedTextureS3TC || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc");
            this.webGLDepthTexture = this.webGLDepthTexture || gl.getExtension("MOZ_WEBGL_depth_texture");
            this.webGLLoseContext = this.webGLLoseContext || gl.getExtension("MOZ_WEBGL_lose_context");
        };
        /**
         * 缓存GL查询
         * @param gl GL实例
         */
        GLExtension.prototype.cacheGLQuery = function (gl) {
            var extensions = {};
            var oldGetExtension = gl.getExtension;
            gl.getExtension = function (name) {
                extensions[name] = extensions[name] || oldGetExtension.apply(gl, arguments);
                return extensions[name];
            };
            //
            var oldGetParameter = gl.getParameter;
            var parameters = {};
            gl.getParameter = function (pname) {
                parameters[pname] = parameters[pname] || oldGetParameter.apply(gl, arguments);
                return parameters[pname];
            };
        };
        return GLExtension;
    }());
    feng3d.GLExtension = GLExtension;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * WEBGL 功能
     */
    var WebGLCapabilities = /** @class */ (function () {
        function WebGLCapabilities(gl) {
            var maxAnisotropy;
            function getMaxAnisotropy() {
                if (maxAnisotropy !== undefined)
                    return maxAnisotropy;
                var extension = gl.getExtension('EXT_texture_filter_anisotropic');
                if (extension !== null) {
                    maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
                }
                else {
                    maxAnisotropy = 0;
                }
                return maxAnisotropy;
            }
            function getMaxPrecision(precision) {
                if (precision === 'highp') {
                    if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 &&
                        gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
                        return 'highp';
                    }
                    precision = 'mediump';
                }
                if (precision === 'mediump') {
                    if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 &&
                        gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
                        return 'mediump';
                    }
                }
                return 'lowp';
            }
            var maxPrecision = getMaxPrecision('highp');
            var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
            var maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
            var maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
            var maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
            var maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
            var maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
            var maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
            var maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
            var vertexTextures = maxVertexTextures > 0;
            var floatFragmentTextures = !!gl.getExtension('OES_texture_float');
            var floatVertexTextures = vertexTextures && floatFragmentTextures;
            this.maxTextures = maxTextures;
            this.maxVertexTextures = maxVertexTextures;
            this.maxTextureSize = maxTextureSize;
            this.maxCubemapSize = maxCubemapSize;
            this.maxAttributes = maxAttributes;
            this.maxVertexUniforms = maxVertexUniforms;
            this.maxVaryings = maxVaryings;
            this.maxFragmentUniforms = maxFragmentUniforms;
            this.vertexTextures = vertexTextures;
            this.floatFragmentTextures = floatFragmentTextures;
            this.floatVertexTextures = floatVertexTextures;
        }
        return WebGLCapabilities;
    }());
    feng3d.WebGLCapabilities = WebGLCapabilities;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * shader
     */
    var Shader = /** @class */ (function () {
        function Shader(shaderName) {
            /**
             * shader 中的 宏
             */
            this.shaderMacro = {};
            this.macroValues = {};
            this.macroInvalid = true;
            this.map = new Map();
            this.shaderName = shaderName;
            feng3d.dispatcher.on("asset.shaderChanged", this.onShaderChanged, this);
        }
        /**
         * 激活渲染程序
         */
        Shader.prototype.activeShaderProgram = function (gl) {
            this.updateShaderCode();
            //渲染程序
            if (this.map.has(gl))
                return this.map.get(gl);
            try {
                var result = this.compileShaderProgram(gl, this.vertex, this.fragment);
                this.map.set(gl, result);
            }
            catch (error) {
                console.error(this.shaderName + " \u7F16\u8BD1\u5931\u8D25\uFF01\n" + error);
                return null;
            }
            return result;
        };
        Shader.prototype.onShaderChanged = function () {
            this.macroInvalid = true;
        };
        /**
         * 更新渲染代码
         */
        Shader.prototype.updateShaderCode = function () {
            // 获取着色器代码
            var result = feng3d.shaderlib.getShader(this.shaderName);
            var macroVariables = result.vertexMacroVariables.concat(result.fragmentMacroVariables);
            for (var i = 0; i < macroVariables.length; i++) {
                var macroVariable = macroVariables[i];
                var value = this.shaderMacro[macroVariable];
                if (this.macroValues[macroVariable] != value) {
                    this.macroValues[macroVariable] = value;
                    this.macroInvalid = true;
                }
            }
            if (this.macroInvalid) {
                this.clear();
                var vMacroCode = this.getMacroCode(result.vertexMacroVariables, this.macroValues);
                this.vertex = vMacroCode + result.vertex;
                var fMacroCode = this.getMacroCode(result.fragmentMacroVariables, this.macroValues);
                this.fragment = fMacroCode + result.fragment;
                this.macroInvalid = false;
            }
        };
        /**
         * 编译着色器代码
         * @param gl GL上下文
         * @param type 着色器类型
         * @param code 着色器代码
         * @return 编译后的着色器对象
         */
        Shader.prototype.compileShaderCode = function (gl, type, code) {
            var shader = gl.createShader(type);
            if (shader == null) {
                debugger;
                throw 'unable to create shader';
            }
            gl.shaderSource(shader, code);
            gl.compileShader(shader);
            // 检查编译结果
            var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
            if (!compiled) {
                var error = gl.getShaderInfoLog(shader);
                gl.deleteShader(shader);
                debugger;
                throw 'Failed to compile shader: ' + error;
            }
            return shader;
        };
        Shader.prototype.createLinkProgram = function (gl, vertexShader, fragmentShader) {
            // 创建程序对象
            var program = gl.createProgram();
            if (!program) {
                debugger;
                throw "创建 WebGLProgram 失败！";
            }
            // 添加着色器
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            // 链接程序
            gl.linkProgram(program);
            // 检查结果
            var linked = gl.getProgramParameter(program, gl.LINK_STATUS);
            if (!linked) {
                var error = gl.getProgramInfoLog(program);
                gl.deleteProgram(program);
                gl.deleteShader(fragmentShader);
                gl.deleteShader(vertexShader);
                debugger;
                throw 'Failed to link program: ' + error;
            }
            return program;
        };
        Shader.prototype.compileShaderProgram = function (gl, vshader, fshader) {
            // 创建着色器程序
            // 编译顶点着色器
            var vertexShader = this.compileShaderCode(gl, gl.VERTEX_SHADER, vshader);
            // 编译片段着色器
            var fragmentShader = this.compileShaderCode(gl, gl.FRAGMENT_SHADER, fshader);
            // 创建着色器程序
            var shaderProgram = this.createLinkProgram(gl, vertexShader, fragmentShader);
            //获取属性信息
            var numAttributes = gl.getProgramParameter(shaderProgram, gl.ACTIVE_ATTRIBUTES);
            var attributes = {};
            var i = 0;
            while (i < numAttributes) {
                var activeInfo = gl.getActiveAttrib(shaderProgram, i++);
                attributes[activeInfo.name] = { name: activeInfo.name, size: activeInfo.size, type: activeInfo.type, location: gl.getAttribLocation(shaderProgram, activeInfo.name) };
            }
            //获取uniform信息
            var numUniforms = gl.getProgramParameter(shaderProgram, gl.ACTIVE_UNIFORMS);
            var uniforms = {};
            var i = 0;
            var textureID = 0;
            while (i < numUniforms) {
                var activeInfo = gl.getActiveUniform(shaderProgram, i++);
                var reg = /(\w+)/g;
                var name = activeInfo.name;
                var names = [name];
                if (activeInfo.size > 1) {
                    feng3d.debuger && console.assert(name.substr(-3, 3) == "[0]");
                    var baseName = name.substring(0, name.length - 3);
                    for (var j = 1; j < activeInfo.size; j++) {
                        names[j] = baseName + ("[" + j + "]");
                    }
                }
                for (var j_1 = 0; j_1 < names.length; j_1++) {
                    name = names[j_1];
                    var result;
                    var paths = [];
                    while (result = reg.exec(name)) {
                        paths.push(result[1]);
                    }
                    uniforms[name] = { name: paths[0], paths: paths, size: activeInfo.size, type: activeInfo.type, location: gl.getUniformLocation(shaderProgram, name), textureID: textureID };
                    if (activeInfo.type == gl.SAMPLER_2D || activeInfo.type == gl.SAMPLER_CUBE) {
                        textureID++;
                    }
                }
            }
            return { program: shaderProgram, vertex: vertexShader, fragment: fragmentShader, attributes: attributes, uniforms: uniforms };
        };
        Shader.prototype.getMacroCode = function (variables, valueObj) {
            var macroHeader = "";
            variables.forEach(function (macroName) {
                var value = valueObj[macroName];
                if (typeof value == "boolean") {
                    value && (macroHeader += "#define " + macroName + "\n");
                }
                else if (typeof value == "number") {
                    macroHeader += "#define " + macroName + " " + value + "\n";
                }
            });
            return macroHeader + "\n";
        };
        Shader.prototype.clear = function () {
            this.map.forEach(function (value, gl) {
                gl.deleteProgram(value.program);
                gl.deleteShader(value.vertex);
                gl.deleteShader(value.fragment);
            });
            this.map.clear();
        };
        return Shader;
    }());
    feng3d.Shader = Shader;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 渲染参数
     */
    var RenderParams = /** @class */ (function () {
        function RenderParams(raw) {
            /**
            * 渲染模式，默认RenderMode.TRIANGLES
            */
            this.renderMode = feng3d.RenderMode.TRIANGLES;
            /**
             * 剔除面
             * 参考：http://www.jianshu.com/p/ee04165f2a02
             * 默认情况下，逆时针的顶点连接顺序被定义为三角形的正面。
             * 使用gl.frontFace(gl.CW);调整顺时针为正面
             */
            this.cullFace = feng3d.CullFace.BACK;
            this.frontFace = feng3d.FrontFace.CW;
            /**
             * 是否开启混合
             * <混合后的颜色> = <源颜色>*sfactor + <目标颜色>*dfactor
             */
            this.enableBlend = false;
            /**
             * 混合方式，默认BlendEquation.FUNC_ADD
             */
            this.blendEquation = feng3d.BlendEquation.FUNC_ADD;
            /**
             * 源混合因子，默认BlendFactor.SRC_ALPHA
             */
            this.sfactor = feng3d.BlendFactor.SRC_ALPHA;
            /**
             * 目标混合因子，默认BlendFactor.ONE_MINUS_SRC_ALPHA
             */
            this.dfactor = feng3d.BlendFactor.ONE_MINUS_SRC_ALPHA;
            /**
             * 是否开启深度检查
             */
            this.depthtest = true;
            this.depthFunc = feng3d.DepthFunc.LESS;
            /**
             * 是否开启深度标记
             */
            this.depthMask = true;
            /**
             * 绘制在画布上的区域
             */
            this.viewRect = new feng3d.Rectangle(0, 0, 100, 100);
            /**
             * 是否使用 viewRect
             */
            this.useViewRect = false;
            Object.assign(this, raw);
        }
        __decorate([
            feng3d.serialize,
            feng3d.oav({ component: "OAVEnum", tooltip: "渲染模式，默认RenderMode.TRIANGLES", componentParam: { enumClass: feng3d.RenderMode } })
        ], RenderParams.prototype, "renderMode", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ component: "OAVEnum", tooltip: "剔除面", componentParam: { enumClass: feng3d.CullFace } })
        ], RenderParams.prototype, "cullFace", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ component: "OAVEnum", tooltip: "正面方向，默认FrontFace.CW 顺时针为正面", componentParam: { enumClass: feng3d.FrontFace } })
        ], RenderParams.prototype, "frontFace", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ tooltip: "是否开启混合" })
        ], RenderParams.prototype, "enableBlend", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ component: "OAVEnum", tooltip: "混合方式，默认BlendEquation.FUNC_ADD", componentParam: { enumClass: feng3d.BlendEquation } })
        ], RenderParams.prototype, "blendEquation", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ component: "OAVEnum", tooltip: "源混合因子，默认BlendFactor.SRC_ALPHA", componentParam: { enumClass: feng3d.BlendFactor } })
        ], RenderParams.prototype, "sfactor", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ component: "OAVEnum", tooltip: "目标混合因子，默认BlendFactor.ONE_MINUS_SRC_ALPHA", componentParam: { enumClass: feng3d.BlendFactor } })
        ], RenderParams.prototype, "dfactor", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ tooltip: "是否开启深度检查" })
        ], RenderParams.prototype, "depthtest", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ component: "OAVEnum", tooltip: "深度检测方法", componentParam: { enumClass: feng3d.DepthFunc } })
        ], RenderParams.prototype, "depthFunc", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ tooltip: "是否开启深度标记" })
        ], RenderParams.prototype, "depthMask", void 0);
        __decorate([
            feng3d.oav({ tooltip: "绘制在画布上的区域" }),
            feng3d.serialize
        ], RenderParams.prototype, "viewRect", void 0);
        __decorate([
            feng3d.oav({ tooltip: "是否使用 viewRect" }),
            feng3d.serialize
        ], RenderParams.prototype, "useViewRect", void 0);
        return RenderParams;
    }());
    feng3d.RenderParams = RenderParams;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 渲染原子（该对象会收集一切渲染所需数据以及参数）
     */
    var RenderAtomic = /** @class */ (function () {
        function RenderAtomic() {
            /**
             * 属性数据列表
             */
            this.attributes = {};
            /**
             * Uniform渲染数据
             */
            this.uniforms = {};
            /**
             * shader 中的 宏
             */
            this.shaderMacro = {};
            /**
             * 渲染参数
             */
            this.renderParams = {};
        }
        RenderAtomic.prototype.getIndexBuffer = function () {
            if (this.indexBuffer != undefined)
                return this.indexBuffer;
            return (this.next && this.next.getIndexBuffer());
        };
        RenderAtomic.prototype.getAttributes = function (attributes) {
            if (attributes === void 0) { attributes = {}; }
            this.next && this.next.getAttributes(attributes);
            Object.assign(attributes, this.attributes);
            return attributes;
        };
        RenderAtomic.prototype.getAttributeByKey = function (key) {
            if (this.attributes[key] != undefined)
                return this.attributes[key];
            return (this.next && this.next.getAttributeByKey(key));
        };
        RenderAtomic.prototype.getUniforms = function (uniforms) {
            if (uniforms === void 0) { uniforms = {}; }
            this.next && this.next.getUniforms(uniforms);
            Object.assign(uniforms, this.uniforms);
            return uniforms;
        };
        RenderAtomic.prototype.getUniformByKey = function (key) {
            if (this.uniforms[key] != undefined)
                return feng3d.lazy.getvalue(this.uniforms[key]);
            return (this.next && this.next.getUniformByKey(key));
        };
        RenderAtomic.prototype.getInstanceCount = function () {
            if (this.instanceCount != undefined)
                return feng3d.lazy.getvalue(this.instanceCount);
            return this.next && this.next.getInstanceCount();
        };
        RenderAtomic.prototype.getShader = function () {
            if (this.shader != undefined)
                return this.shader;
            return this.next && this.next.getShader();
        };
        RenderAtomic.prototype.getRenderParams = function (renderParams) {
            if (renderParams === void 0) { renderParams = new feng3d.RenderParams(); }
            this.next && this.next.getRenderParams(renderParams);
            Object.assign(renderParams, this.renderParams);
            return renderParams;
        };
        RenderAtomic.prototype.getShaderMacro = function (shaderMacro) {
            if (shaderMacro === void 0) { shaderMacro = {}; }
            this.next && this.next.getShaderMacro(shaderMacro);
            Object.assign(shaderMacro, this.shaderMacro);
            return shaderMacro;
        };
        return RenderAtomic;
    }());
    feng3d.RenderAtomic = RenderAtomic;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 索引渲染数据

     */
    var Index = /** @class */ (function () {
        function Index() {
            /**
             * 数据类型，gl.UNSIGNED_BYTE、gl.UNSIGNED_SHORT
             */
            this.type = feng3d.GLArrayType.UNSIGNED_SHORT;
            /**
             * 索引偏移
             */
            this.offset = 0;
            /**
             * 缓冲
             */
            this._indexBufferMap = new Map();
            /**
             * 是否失效
             */
            this.invalid = true;
        }
        Object.defineProperty(Index.prototype, "indices", {
            /**
             * 索引数据
             */
            get: function () {
                return this._indices;
            },
            set: function (v) {
                if (this._indices == v)
                    return;
                this._indices = v;
                this.invalidate();
            },
            enumerable: true,
            configurable: true
        });
        Index.prototype.invalidate = function () {
            this.invalid = true;
        };
        Object.defineProperty(Index.prototype, "count", {
            /**
             * 渲染数量
             */
            get: function () {
                if (!this.indices)
                    return 0;
                return this.indices.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 激活缓冲
         * @param gl
         */
        Index.prototype.active = function (gl) {
            if (this.invalid) {
                this.clear();
                this.invalid = false;
            }
            var buffer = this.getBuffer(gl);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
        };
        /**
         * 获取缓冲
         */
        Index.prototype.getBuffer = function (gl) {
            var buffer = this._indexBufferMap.get(gl);
            if (!buffer) {
                buffer = gl.createBuffer();
                if (!buffer) {
                    console.error("createBuffer 失败！");
                    throw "";
                }
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(this.indices), gl.STATIC_DRAW);
                this._indexBufferMap.set(gl, buffer);
            }
            return buffer;
        };
        /**
         * 清理缓冲
         */
        Index.prototype.clear = function () {
            this._indexBufferMap.forEach(function (value, key) {
                key.deleteBuffer(value);
            });
            this._indexBufferMap.clear();
        };
        return Index;
    }());
    feng3d.Index = Index;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 属性渲染数据

     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer}
     */
    var Attribute = /** @class */ (function () {
        function Attribute(name, data, size, divisor) {
            if (size === void 0) { size = 3; }
            if (divisor === void 0) { divisor = 0; }
            /**
             * 数据尺寸
             *
             * A GLint specifying the number of components per vertex attribute. Must be 1, 2, 3, or 4.
             */
            this.size = 3;
            /**
             *  A GLenum specifying the data type of each component in the array. Possible values:
                    - gl.BYTE: signed 8-bit integer, with values in [-128, 127]
                    - gl.SHORT: signed 16-bit integer, with values in [-32768, 32767]
                    - gl.UNSIGNED_BYTE: unsigned 8-bit integer, with values in [0, 255]
                    - gl.UNSIGNED_SHORT: unsigned 16-bit integer, with values in [0, 65535]
                    - gl.FLOAT: 32-bit floating point number
                When using a WebGL 2 context, the following values are available additionally:
                   - gl.HALF_FLOAT: 16-bit floating point number
             */
            this.type = feng3d.GLArrayType.FLOAT;
            /**
             * A GLboolean specifying whether integer data values should be normalized when being casted to a float.
                  -  If true, signed integers are normalized to [-1, 1].
                  -  If true, unsigned integers are normalized to [0, 1].
                  -  For types gl.FLOAT and gl.HALF_FLOAT, this parameter has no effect.
             */
            this.normalized = false;
            /**
             * A GLsizei specifying the offset in bytes between the beginning of consecutive vertex attributes. Cannot be larger than 255.
             */
            this.stride = 0;
            /**
             * A GLintptr specifying an offset in bytes of the first component in the vertex attribute array. Must be a multiple of type.
             */
            this.offset = 0;
            /**
             * drawElementsInstanced时将会用到的因子，表示divisor个geometry共用一个数据
             *
             * A GLuint specifying the number of instances that will pass between updates of the generic attribute.
             * @see https://developer.mozilla.org/en-US/docs/Web/API/ANGLE_instanced_arrays/vertexAttribDivisorANGLE
             */
            this.divisor = 0;
            /**
             * 是否失效
             */
            this.invalid = true;
            /**
             * 顶点数据缓冲
             */
            this._indexBufferMap = new Map();
            this.name = name;
            this.data = data;
            this.size = size;
            this.divisor = divisor;
        }
        Object.defineProperty(Attribute.prototype, "data", {
            /**
             * 属性数据
             */
            get: function () {
                return this._data;
            },
            set: function (v) {
                this._data = v;
                this.invalidate();
            },
            enumerable: true,
            configurable: true
        });
        /**
         *
         * @param gl
         * @param location A GLuint specifying the index of the vertex attribute that is to be modified.
         */
        Attribute.prototype.active = function (gl, location) {
            if (this.invalid) {
                this.clear();
                this.invalid = false;
            }
            var type = gl[this.type];
            gl.enableVertexAttribArray(location);
            var buffer = this.getBuffer(gl);
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.vertexAttribPointer(location, this.size, type, this.normalized, this.stride, this.offset);
            if (gl.webgl2) {
                var gl2 = gl;
                gl2.vertexAttribDivisor(location, this.divisor);
            }
            else if (!!gl.extensions.aNGLEInstancedArrays) {
                gl.extensions.aNGLEInstancedArrays.vertexAttribDivisorANGLE(location, this.divisor);
            }
            else {
                console.warn("\u6D4F\u89C8\u5668 \u4E0D\u652F\u6301 vertexAttribDivisor \uFF01");
            }
        };
        Attribute.prototype.invalidate = function () {
            this.invalid = true;
        };
        /**
         * 获取缓冲
         */
        Attribute.prototype.getBuffer = function (gl) {
            var buffer = this._indexBufferMap.get(gl);
            if (!buffer) {
                var newbuffer = gl.createBuffer();
                if (!newbuffer) {
                    console.error("createBuffer 失败！");
                    throw "";
                }
                buffer = newbuffer;
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.data), gl.STATIC_DRAW);
                this._indexBufferMap.set(gl, buffer);
            }
            return buffer;
        };
        /**
         * 清理缓冲
         */
        Attribute.prototype.clear = function () {
            this._indexBufferMap.forEach(function (value, key, map) {
                key.deleteBuffer(value);
            });
            this._indexBufferMap.clear();
        };
        return Attribute;
    }());
    feng3d.Attribute = Attribute;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 纹理信息
     */
    var TextureInfo = /** @class */ (function (_super) {
        __extends(TextureInfo, _super);
        function TextureInfo() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._format = feng3d.TextureFormat.RGB;
            _this._type = feng3d.TextureDataType.UNSIGNED_BYTE;
            _this._generateMipmap = false;
            _this._flipY = false;
            _this._premulAlpha = false;
            _this.minFilter = feng3d.TextureMinFilter.LINEAR;
            _this.magFilter = feng3d.TextureMagFilter.LINEAR;
            /**
             * 表示x轴的纹理的回环方式，就是当纹理的宽度小于需要贴图的平面的宽度的时候，平面剩下的部分应该p以何种方式贴图的问题。
             */
            _this.wrapS = feng3d.TextureWrap.REPEAT;
            /**
             * 表示y轴的纹理回环方式。 magFilter和minFilter表示过滤的方式，这是OpenGL的基本概念，我将在下面讲一下，目前你不用担心它的使用。当您不设置的时候，它会取默认值，所以，我们这里暂时不理睬他。
             */
            _this.wrapT = feng3d.TextureWrap.REPEAT;
            /**
             * 各向异性过滤。使用各向异性过滤能够使纹理的效果更好，但是会消耗更多的内存、CPU、GPU时间。默认为0。
             */
            _this.anisotropy = 0;
            /**
             * 是否为渲染目标纹理
             */
            _this._isRenderTarget = false;
            _this._OFFSCREEN_WIDTH = 1024;
            _this._OFFSCREEN_HEIGHT = 1024;
            /**
             * 纹理缓冲
             */
            _this._textureMap = new Map();
            /**
             * 是否失效
             */
            _this._invalid = true;
            _this._isPowerOfTwo = false;
            return _this;
        }
        Object.defineProperty(TextureInfo.prototype, "format", {
            /**
             * 格式
             */
            get: function () {
                return this._format;
            },
            set: function (v) {
                if (this._format == v)
                    return;
                this._format = v;
                this.invalidate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextureInfo.prototype, "type", {
            /**
             * 数据类型
             */
            get: function () {
                return this._type;
            },
            set: function (v) {
                if (this._type == v)
                    return;
                this._type = v;
                this.invalidate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextureInfo.prototype, "generateMipmap", {
            /**
             * 是否生成mipmap
             */
            get: function () {
                return this._generateMipmap;
            },
            set: function (v) {
                if (this._generateMipmap == v)
                    return;
                this._generateMipmap = v;
                this.invalidate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextureInfo.prototype, "flipY", {
            /**
             * 对图像进行Y轴反转。默认值为false
             */
            get: function () {
                return this._flipY;
            },
            set: function (v) {
                if (this._flipY == v)
                    return;
                this._flipY = v;
                this.invalidate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextureInfo.prototype, "premulAlpha", {
            /**
             * 将图像RGB颜色值得每一个分量乘以A。默认为false
             */
            get: function () {
                return this._premulAlpha;
            },
            set: function (v) {
                if (this._premulAlpha == v)
                    return;
                this._premulAlpha = v;
                this.invalidate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextureInfo.prototype, "OFFSCREEN_WIDTH", {
            get: function () {
                return this._OFFSCREEN_WIDTH;
            },
            set: function (v) {
                if (this._OFFSCREEN_WIDTH == v)
                    return;
                this._OFFSCREEN_WIDTH = v;
                this.invalidate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextureInfo.prototype, "OFFSCREEN_HEIGHT", {
            get: function () {
                return this._OFFSCREEN_HEIGHT;
            },
            set: function (v) {
                if (this._OFFSCREEN_HEIGHT == v)
                    return;
                this._OFFSCREEN_HEIGHT = v;
                this.invalidate();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 是否为2的幂贴图
         */
        TextureInfo.prototype.isPowerOfTwo = function (pixels) {
            if (this._isRenderTarget) {
                if (this.OFFSCREEN_WIDTH == 0 || !Math.isPowerOfTwo(this.OFFSCREEN_WIDTH))
                    return false;
                if (this.OFFSCREEN_HEIGHT == 0 || !Math.isPowerOfTwo(this.OFFSCREEN_HEIGHT))
                    return false;
                return true;
            }
            if (!pixels)
                return false;
            if (!Array.isArray(pixels))
                pixels = [pixels];
            for (var i = 0; i < pixels.length; i++) {
                var element = pixels[i];
                if (element.width == 0 || !Math.isPowerOfTwo(element.width))
                    return false;
                if (element.height == 0 || !Math.isPowerOfTwo(element.height))
                    return false;
            }
            return true;
        };
        /**
         * 纹理尺寸
         */
        TextureInfo.prototype.getSize = function () {
            if (this._isRenderTarget) {
                return new feng3d.Vector2(this.OFFSCREEN_WIDTH, this.OFFSCREEN_HEIGHT);
            }
            var pixels = this._activePixels;
            if (!pixels)
                new feng3d.Vector2(1, 1);
            if (!Array.isArray(pixels))
                pixels = [pixels];
            if (pixels.length == 0)
                return new feng3d.Vector2(1, 1);
            var pixel = pixels[0];
            return new feng3d.Vector2(pixel.width, pixel.height);
        };
        /**
         * 判断数据是否满足渲染需求
         */
        TextureInfo.prototype.checkRenderData = function (pixels) {
            if (!pixels)
                return false;
            if (!Array.isArray(pixels))
                pixels = [pixels];
            if (pixels.length == 0)
                return false;
            for (var i = 0; i < pixels.length; i++) {
                var element = pixels[i];
                if (!element)
                    return false;
                if (element.width == 0)
                    return false;
                if (element.height == 0)
                    return false;
            }
            return true;
        };
        /**
         * 使纹理失效
         */
        TextureInfo.prototype.invalidate = function () {
            this._invalid = true;
        };
        Object.defineProperty(TextureInfo.prototype, "activePixels", {
            get: function () {
                this.updateActivePixels();
                return this._activePixels;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextureInfo.prototype, "dataURL", {
            /**
             *
             */
            get: function () {
                this.updateActivePixels();
                if (!this._dataURL) {
                    if (this._activePixels instanceof ImageData)
                        this._dataURL = feng3d.dataTransform.imageDataToDataURL(this._activePixels);
                    else if (this._activePixels instanceof HTMLImageElement)
                        this._dataURL = feng3d.dataTransform.imageToDataURL(this._activePixels);
                    else if (this._activePixels instanceof HTMLCanvasElement)
                        this._dataURL = feng3d.dataTransform.canvasToDataURL(this._activePixels);
                }
                return this._dataURL;
            },
            enumerable: true,
            configurable: true
        });
        TextureInfo.prototype.updateActivePixels = function () {
            var old = this._activePixels;
            if (this.checkRenderData(this._pixels)) {
                this._activePixels = this._pixels;
            }
            else {
                if (Array.isArray(this.noPixels)) {
                    this._activePixels = this.noPixels.map(function (v) { return feng3d.imageDatas[v]; });
                }
                else {
                    this._activePixels = feng3d.imageDatas[this.noPixels];
                }
            }
            if (old != this._activePixels)
                this._dataURL = null;
        };
        /**
         * 激活纹理
         * @param gl
         */
        TextureInfo.prototype.active = function (gl) {
            if (this._invalid) {
                this.clear();
                this._invalid = false;
                this.updateActivePixels();
                this._isPowerOfTwo = this.isPowerOfTwo(this._activePixels);
            }
            var texture = this.getTexture(gl);
            var textureType = gl[this._textureType];
            var minFilter = gl[this.minFilter];
            var magFilter = gl[this.magFilter];
            var wrapS = gl[this.wrapS];
            var wrapT = gl[this.wrapT];
            if (!this._isPowerOfTwo) {
                wrapS = gl.CLAMP_TO_EDGE;
                wrapT = gl.CLAMP_TO_EDGE;
            }
            //绑定纹理
            gl.bindTexture(textureType, texture);
            //设置纹理参数
            gl.texParameteri(textureType, gl.TEXTURE_MIN_FILTER, minFilter);
            gl.texParameteri(textureType, gl.TEXTURE_MAG_FILTER, magFilter);
            gl.texParameteri(textureType, gl.TEXTURE_WRAP_S, wrapS);
            gl.texParameteri(textureType, gl.TEXTURE_WRAP_T, wrapT);
            //
            if (this.anisotropy) {
                var eXTTextureFilterAnisotropic = gl.extensions.eXTTextureFilterAnisotropic;
                if (eXTTextureFilterAnisotropic) {
                    if (this.anisotropy > gl.maxAnisotropy) {
                        this.anisotropy = gl.maxAnisotropy;
                        console.warn(this.anisotropy + " \u8D85\u51FA maxAnisotropy \u7684\u6700\u5927\u503C " + gl.maxAnisotropy + " \uFF01,\u4F7F\u7528\u6700\u5927\u503C\u66FF\u6362\u3002");
                    }
                    gl.texParameterf(textureType, eXTTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this.anisotropy);
                }
                else {
                    feng3d.debuger && alert("浏览器不支持各向异性过滤（anisotropy）特性！");
                }
            }
            return texture;
        };
        /**
         * 获取顶点属性缓冲
         * @param data  数据
         */
        TextureInfo.prototype.getTexture = function (gl) {
            var texture = this._textureMap.get(gl);
            if (!texture) {
                var newtexture = gl.createTexture(); // Create a texture object
                if (!newtexture) {
                    console.error("createTexture 失败！");
                    throw "";
                }
                texture = newtexture;
                var textureType = gl[this._textureType];
                var format = gl[this.format];
                var type = gl[this.type];
                //设置图片y轴方向
                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, this.flipY ? 1 : 0);
                gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premulAlpha ? 1 : 0);
                //绑定纹理
                gl.bindTexture(textureType, texture);
                //设置纹理图片
                switch (textureType) {
                    case gl.TEXTURE_CUBE_MAP:
                        var pixels = this._activePixels;
                        var faces = [
                            gl.TEXTURE_CUBE_MAP_POSITIVE_X, gl.TEXTURE_CUBE_MAP_POSITIVE_Y, gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
                            gl.TEXTURE_CUBE_MAP_NEGATIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z
                        ];
                        for (var i = 0; i < faces.length; i++) {
                            if (this._isRenderTarget) {
                                gl.texImage2D(faces[i], 0, format, this.OFFSCREEN_WIDTH, this.OFFSCREEN_HEIGHT, 0, format, type, null);
                            }
                            else {
                                gl.texImage2D(faces[i], 0, format, format, type, this._activePixels[i]);
                            }
                        }
                        break;
                    case gl.TEXTURE_2D:
                        var _pixel = this._activePixels;
                        var textureType = gl[this._textureType];
                        if (this._isRenderTarget) {
                            gl.texImage2D(textureType, 0, format, this.OFFSCREEN_WIDTH, this.OFFSCREEN_HEIGHT, 0, format, type, null);
                        }
                        else {
                            gl.texImage2D(textureType, 0, format, format, type, _pixel);
                        }
                        break;
                    default:
                        throw "";
                }
                if (this.generateMipmap && this._isPowerOfTwo) {
                    gl.generateMipmap(textureType);
                }
                this._textureMap.set(gl, texture);
            }
            return texture;
        };
        /**
         * 清理纹理
         */
        TextureInfo.prototype.clear = function () {
            this._textureMap.forEach(function (v, k) {
                k.deleteTexture(v);
            });
            this._textureMap.clear();
        };
        __decorate([
            feng3d.serialize,
            feng3d.oav({ component: "OAVEnum", componentParam: { enumClass: feng3d.TextureFormat } })
        ], TextureInfo.prototype, "format", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ component: "OAVEnum", componentParam: { enumClass: feng3d.TextureDataType } })
        ], TextureInfo.prototype, "type", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], TextureInfo.prototype, "generateMipmap", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], TextureInfo.prototype, "flipY", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], TextureInfo.prototype, "premulAlpha", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ component: "OAVEnum", componentParam: { enumClass: feng3d.TextureMinFilter } })
        ], TextureInfo.prototype, "minFilter", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ component: "OAVEnum", componentParam: { enumClass: feng3d.TextureMagFilter } })
        ], TextureInfo.prototype, "magFilter", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ component: "OAVEnum", componentParam: { enumClass: feng3d.TextureWrap } })
        ], TextureInfo.prototype, "wrapS", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ component: "OAVEnum", componentParam: { enumClass: feng3d.TextureWrap } })
        ], TextureInfo.prototype, "wrapT", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], TextureInfo.prototype, "anisotropy", void 0);
        return TextureInfo;
    }(feng3d.AssetData));
    feng3d.TextureInfo = TextureInfo;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var FrameBuffer = /** @class */ (function () {
        function FrameBuffer() {
            this._framebufferMap = new Map();
            /**
             * 是否失效
             */
            this._invalid = true;
        }
        FrameBuffer.prototype.active = function (gl) {
            if (this._invalid) {
                this._invalid = false;
                this.clear();
            }
            // Create a framebuffer object (FBO)
            var framebuffer = this._framebufferMap.get(gl);
            if (!framebuffer) {
                framebuffer = gl.createFramebuffer();
                if (!framebuffer) {
                    feng3d.debuger && alert('Failed to create frame buffer object');
                    return null;
                }
                this._framebufferMap.set(gl, framebuffer);
            }
            return framebuffer;
        };
        /**
         * 清理缓存
         */
        FrameBuffer.prototype.clear = function () {
            this._framebufferMap.forEach(function (v, k) {
                k.deleteFramebuffer(v);
            });
            this._framebufferMap.clear();
        };
        return FrameBuffer;
    }());
    feng3d.FrameBuffer = FrameBuffer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 帧缓冲对象

     */
    var FrameBufferObject = /** @class */ (function () {
        function FrameBufferObject(width, height) {
            if (width === void 0) { width = 1024; }
            if (height === void 0) { height = 1024; }
            this._OFFSCREEN_WIDTH = 1024;
            this._OFFSCREEN_HEIGHT = 1024;
            /**
             * 是否失效
             */
            this._invalid = true;
            this._map = new Map();
            this.frameBuffer = new feng3d.FrameBuffer();
            this.texture = new feng3d.RenderTargetTexture2D();
            this.depthBuffer = new feng3d.RenderBuffer();
            this.OFFSCREEN_WIDTH = width;
            this.OFFSCREEN_HEIGHT = height;
        }
        Object.defineProperty(FrameBufferObject.prototype, "OFFSCREEN_WIDTH", {
            get: function () {
                return this._OFFSCREEN_WIDTH;
            },
            set: function (v) {
                if (this._OFFSCREEN_WIDTH == v)
                    return;
                this._OFFSCREEN_WIDTH = v;
                this.invalidateSize();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FrameBufferObject.prototype, "OFFSCREEN_HEIGHT", {
            get: function () {
                return this._OFFSCREEN_HEIGHT;
            },
            set: function (v) {
                if (this._OFFSCREEN_HEIGHT == v)
                    return;
                this._OFFSCREEN_HEIGHT = v;
                this.invalidateSize();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FrameBufferObject.prototype, "frameBuffer", {
            get: function () {
                return this._frameBuffer;
            },
            set: function (v) {
                if (this._frameBuffer == v)
                    return;
                this._frameBuffer = v;
                this.invalidate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FrameBufferObject.prototype, "texture", {
            get: function () {
                return this._texture;
            },
            set: function (v) {
                if (this._texture == v)
                    return;
                this._texture = v;
                this.invalidate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FrameBufferObject.prototype, "depthBuffer", {
            get: function () {
                return this._depthBuffer;
            },
            set: function (v) {
                if (this._depthBuffer == v)
                    return;
                this._depthBuffer = v;
                this.invalidate();
            },
            enumerable: true,
            configurable: true
        });
        FrameBufferObject.prototype.active = function (gl) {
            if (this._invalid) {
                this._invalid = false;
                this.clear();
            }
            var obj = this._map.get(gl);
            if (!obj) {
                var framebuffer = this.frameBuffer.active(gl);
                var texture = this.texture.active(gl);
                var depthBuffer = this.depthBuffer.active(gl);
                // 绑定帧缓冲区对象
                gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
                // 设置颜色关联对象
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
                // 设置深度关联对象
                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthBuffer);
                // 检查Framebuffer状态
                var e = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
                if (gl.FRAMEBUFFER_COMPLETE !== e) {
                    feng3d.debuger && alert('Frame buffer object is incomplete: ' + e.toString());
                    return null;
                }
                gl.bindTexture(gl.TEXTURE_2D, null);
                gl.bindRenderbuffer(gl.RENDERBUFFER, null);
                obj = { framebuffer: framebuffer, texture: texture, depthBuffer: depthBuffer };
                this._map.set(gl, obj);
            }
            else {
                gl.bindFramebuffer(gl.FRAMEBUFFER, obj.framebuffer);
            }
            return obj;
        };
        FrameBufferObject.prototype.deactive = function (gl) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        };
        /**
         * 使失效
         */
        FrameBufferObject.prototype.invalidate = function () {
            this._invalid = true;
        };
        FrameBufferObject.prototype.invalidateSize = function () {
            if (this.texture) {
                this.texture.OFFSCREEN_WIDTH = this.OFFSCREEN_WIDTH;
                this.texture.OFFSCREEN_HEIGHT = this.OFFSCREEN_HEIGHT;
            }
            if (this.depthBuffer) {
                this.depthBuffer.OFFSCREEN_WIDTH = this.OFFSCREEN_WIDTH;
                this.depthBuffer.OFFSCREEN_HEIGHT = this.OFFSCREEN_HEIGHT;
            }
            this._invalid = true;
        };
        FrameBufferObject.prototype.clear = function () {
            this._map.clear();
        };
        return FrameBufferObject;
    }());
    feng3d.FrameBufferObject = FrameBufferObject;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var RenderBuffer = /** @class */ (function () {
        function RenderBuffer() {
            this._OFFSCREEN_WIDTH = 1024;
            this._OFFSCREEN_HEIGHT = 1024;
            this._depthBufferMap = new Map();
            /**
             * 是否失效
             */
            this._invalid = true;
        }
        Object.defineProperty(RenderBuffer.prototype, "OFFSCREEN_WIDTH", {
            get: function () {
                return this._OFFSCREEN_WIDTH;
            },
            set: function (v) {
                if (this._OFFSCREEN_WIDTH == v)
                    return;
                this._OFFSCREEN_WIDTH = v;
                this.invalidate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RenderBuffer.prototype, "OFFSCREEN_HEIGHT", {
            get: function () {
                return this._OFFSCREEN_HEIGHT;
            },
            set: function (v) {
                if (this._OFFSCREEN_HEIGHT == v)
                    return;
                this._OFFSCREEN_HEIGHT = v;
                this.invalidate();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 使失效
         */
        RenderBuffer.prototype.invalidate = function () {
            this._invalid = true;
        };
        /**
         * 激活
         * @param gl
         */
        RenderBuffer.prototype.active = function (gl) {
            if (this._invalid) {
                this.clear();
                this._invalid = false;
            }
            var depthBuffer = this._depthBufferMap.get(gl);
            if (!depthBuffer) {
                // Create a renderbuffer object and Set its size and parameters
                depthBuffer = gl.createRenderbuffer(); // Create a renderbuffer object
                if (!depthBuffer) {
                    feng3d.debuger && alert('Failed to create renderbuffer object');
                    return;
                }
                this._depthBufferMap.set(gl, depthBuffer);
                gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer);
                gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this.OFFSCREEN_WIDTH, this.OFFSCREEN_HEIGHT);
            }
            return depthBuffer;
        };
        /**
         * 清理纹理
         */
        RenderBuffer.prototype.clear = function () {
            this._depthBufferMap.forEach(function (v, k) {
                k.deleteRenderbuffer(v);
            });
            this._depthBufferMap.clear();
        };
        return RenderBuffer;
    }());
    feng3d.RenderBuffer = RenderBuffer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var shaderMacroKeys = ["if", "ifdef", "defined"];
    var ShaderMacroUtils = /** @class */ (function () {
        function ShaderMacroUtils() {
        }
        /**
         * 从着色器代码中获取宏变量列表
         * @param vertex
         * @param fragment
         */
        ShaderMacroUtils.prototype.getMacroVariablesFromShaderCode = function (vertex, fragment) {
            var variables0 = this.getMacroVariablesFromCode(vertex);
            var variables1 = this.getMacroVariablesFromCode(fragment);
            for (var i = 0; i < variables1.length; i++) {
                var element = variables1[i];
                if (variables0.indexOf(element) == -1)
                    variables0.push(element);
            }
            return variables0;
        };
        /**
         * 从着色器代码中获取宏变量列表
         * @param code
         */
        ShaderMacroUtils.prototype.getMacroVariablesFromCode = function (code) {
            var variables = [];
            var lines = code.split("\n");
            for (var i = 0; i < lines.length; i++) {
                var line = lines[i];
                if (line.indexOf("#if") != -1) {
                    var reg = /(\w+)/g;
                    var result;
                    while (result = reg.exec(line)) {
                        var key = result[1];
                        if (key != null && isNaN(Number(key)) && shaderMacroKeys.indexOf(key) == -1 && variables.indexOf(key) == -1)
                            variables.push(key);
                    }
                }
            }
            return variables;
        };
        return ShaderMacroUtils;
    }());
    feng3d.ShaderMacroUtils = ShaderMacroUtils;
    feng3d.shaderMacroUtils = new ShaderMacroUtils();
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 渲染代码库

     */
    var ShaderLib = /** @class */ (function () {
        function ShaderLib() {
            this._shaderCache = {};
            feng3d.dispatcher.on("asset.shaderChanged", this.onShaderChanged, this);
        }
        Object.defineProperty(ShaderLib.prototype, "shaderConfig", {
            get: function () {
                this._shaderConfig = this._shaderConfig || feng3d.shaderConfig;
                return this._shaderConfig;
            },
            set: function (v) {
                this._shaderConfig = v;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 获取shaderCode
         */
        ShaderLib.prototype.getShader = function (shaderName) {
            if (this._shaderCache[shaderName])
                return this._shaderCache[shaderName];
            var shader = feng3d.shaderlib.shaderConfig.shaders[shaderName];
            //
            var vertex = feng3d.shaderlib.uninclude(shader.vertex);
            //
            var fragment = feng3d.shaderlib.uninclude(shader.fragment);
            var vertexMacroVariables = feng3d.shaderMacroUtils.getMacroVariablesFromCode(vertex);
            var fragmentMacroVariables = feng3d.shaderMacroUtils.getMacroVariablesFromCode(fragment);
            this._shaderCache[shaderName] = { vertex: vertex, fragment: fragment, vertexMacroVariables: vertexMacroVariables, fragmentMacroVariables: fragmentMacroVariables };
            return this._shaderCache[shaderName];
        };
        /**
         * 展开 include
         */
        ShaderLib.prototype.uninclude = function (shaderCode) {
            //#include 正则表达式
            var includeRegExp = /#include<(.+)>/g;
            //
            var match = includeRegExp.exec(shaderCode);
            while (match != null) {
                var moduleshader = this.shaderConfig.modules[match[1]];
                if (!moduleshader) {
                    debugger;
                    console.error("\u65E0\u6CD5\u627E\u5230\u7740\u8272\u5668 " + match[1]);
                }
                moduleshader = this.uninclude(moduleshader);
                shaderCode = shaderCode.replace(match[0], moduleshader);
                includeRegExp.lastIndex = 0;
                match = includeRegExp.exec(shaderCode);
            }
            return shaderCode;
        };
        ShaderLib.prototype.onShaderChanged = function () {
            this._shaderCache = {};
        };
        /**
         * 获取shader列表
         */
        ShaderLib.prototype.getShaderNames = function () {
            return Object.keys(this.shaderConfig.shaders);
        };
        return ShaderLib;
    }());
    feng3d.ShaderLib = ShaderLib;
    feng3d.shaderlib = new ShaderLib();
    //ShaderLib1
    var ShaderLib1 = /** @class */ (function () {
        function ShaderLib1() {
        }
        return ShaderLib1;
    }());
    feng3d.ShaderLib1 = ShaderLib1;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 渲染器
     * 所有渲染都由该渲染器执行
     */
    var Renderer = /** @class */ (function () {
        function Renderer(gl) {
            feng3d.debuger && console.assert(!gl.renderer, gl + " " + gl.renderer + " \u5B58\u5728\uFF01");
            gl.renderer = this;
            this.draw = function (renderAtomic1) {
                var instanceCount = renderAtomic1.getInstanceCount();
                if (instanceCount == 0)
                    return;
                var shaderMacro = renderAtomic1.getShaderMacro();
                var shader = renderAtomic1.getShader();
                shader.shaderMacro = shaderMacro;
                var shaderResult = shader.activeShaderProgram(gl);
                if (!shaderResult)
                    return;
                //
                renderAtomic1.uniforms.u_mvMatrix = function () {
                    return feng3d.lazy.getvalue(renderAtomic1.uniforms.u_modelMatrix).clone().append(feng3d.lazy.getvalue(renderAtomic1.uniforms.u_viewMatrix));
                };
                renderAtomic1.uniforms.u_ITMVMatrix = function () {
                    return feng3d.lazy.getvalue(renderAtomic1.uniforms.u_mvMatrix).clone().invert().transpose();
                };
                //
                var renderAtomic = checkRenderData(renderAtomic1);
                if (!renderAtomic)
                    return;
                //
                gl.useProgram(shaderResult.program);
                activeShaderParams(renderAtomic.renderParams);
                activeAttributes(renderAtomic, shaderResult.attributes);
                activeUniforms(renderAtomic, shaderResult.uniforms);
                dodraw(renderAtomic, gl[renderAtomic.renderParams.renderMode]);
                disableAttributes(shaderResult.attributes);
            };
            function checkRenderData(renderAtomic) {
                var shader = renderAtomic.getShader();
                var shaderResult = shader.activeShaderProgram(gl);
                if (!shaderResult) {
                    console.warn("\u7F3A\u5C11\u7740\u8272\u5668\uFF0C\u65E0\u6CD5\u6E32\u67D3!");
                    return null;
                }
                var attributes = {};
                for (var key_1 in shaderResult.attributes) {
                    var attribute = renderAtomic.getAttributeByKey(key_1);
                    if (attribute == undefined) {
                        console.warn("\u7F3A\u5C11\u9876\u70B9 attribute \u6570\u636E " + key_1 + " \uFF0C\u65E0\u6CD5\u6E32\u67D3!");
                        return null;
                    }
                    attributes[key_1] = attribute;
                }
                var uniforms = {};
                for (var key in shaderResult.uniforms) {
                    var activeInfo = shaderResult.uniforms[key];
                    if (activeInfo.name) {
                        key = activeInfo.name;
                    }
                    var uniform = renderAtomic.getUniformByKey(key);
                    if (uniform == undefined) {
                        console.warn("\u7F3A\u5C11 uniform \u6570\u636E " + key + " ,\u65E0\u6CD5\u6E32\u67D3\uFF01");
                        return null;
                    }
                    uniforms[key] = uniform;
                }
                var indexBuffer = renderAtomic.getIndexBuffer();
                if (!indexBuffer) {
                    console.warn("\u786E\u5B9E\u9876\u70B9\u7D22\u5F15\u6570\u636E\uFF0C\u65E0\u6CD5\u6E32\u67D3\uFF01");
                    return null;
                }
                return {
                    shader: shader,
                    attributes: attributes,
                    uniforms: uniforms,
                    renderParams: renderAtomic.getRenderParams(),
                    indexBuffer: indexBuffer,
                    instanceCount: renderAtomic.getInstanceCount(),
                };
            }
            function activeShaderParams(shaderParams) {
                var cullfaceEnum = shaderParams.cullFace;
                var blendEquation = gl[shaderParams.blendEquation];
                var sfactor = gl[shaderParams.sfactor];
                var dfactor = gl[shaderParams.dfactor];
                var cullFace = gl[shaderParams.cullFace];
                var frontFace = gl[shaderParams.frontFace];
                var enableBlend = shaderParams.enableBlend;
                var depthtest = shaderParams.depthtest;
                var depthMask = shaderParams.depthMask;
                var depthFunc = gl[shaderParams.depthFunc];
                var viewRect = shaderParams.viewRect;
                var useViewRect = shaderParams.useViewRect;
                if (!useViewRect) {
                    viewRect = new feng3d.Rectangle(0, 0, gl.canvas.width, gl.canvas.height);
                }
                if (cullfaceEnum != feng3d.CullFace.NONE) {
                    gl.enable(gl.CULL_FACE);
                    gl.cullFace(cullFace);
                    gl.frontFace(frontFace);
                }
                else {
                    gl.disable(gl.CULL_FACE);
                }
                if (enableBlend) {
                    //
                    gl.enable(gl.BLEND);
                    gl.blendEquation(blendEquation);
                    gl.blendFunc(sfactor, dfactor);
                }
                else {
                    gl.disable(gl.BLEND);
                }
                if (depthtest) {
                    gl.enable(gl.DEPTH_TEST);
                    gl.depthFunc(depthFunc);
                }
                else
                    gl.disable(gl.DEPTH_TEST);
                gl.depthMask(depthMask);
                gl.viewport(viewRect.x, viewRect.y, viewRect.width, viewRect.height);
            }
            /**
             * 激活属性
             */
            function activeAttributes(renderAtomic, attributeInfos) {
                for (var name in attributeInfos) {
                    var activeInfo = attributeInfos[name];
                    var buffer = renderAtomic.attributes[name];
                    buffer.active(gl, activeInfo.location);
                }
            }
            /**
             * 激活属性
             */
            function disableAttributes(attributeInfos) {
                for (var name in attributeInfos) {
                    var activeInfo = attributeInfos[name];
                    gl.disableVertexAttribArray(activeInfo.location);
                }
            }
            /**
             * 激活常量
             */
            function activeUniforms(renderAtomic, uniformInfos) {
                var uniforms = renderAtomic.uniforms;
                for (var name in uniformInfos) {
                    var activeInfo = uniformInfos[name];
                    var paths = activeInfo.paths;
                    var uniformData = uniforms[paths[0]];
                    for (var i = 1; i < paths.length; i++) {
                        uniformData = uniformData[paths[i]];
                    }
                    setContext3DUniform(activeInfo, uniformData);
                }
            }
            /**
             * 设置环境Uniform数据
             */
            function setContext3DUniform(activeInfo, data) {
                var location = activeInfo.location;
                switch (activeInfo.type) {
                    case gl.INT:
                        gl.uniform1i(location, data);
                        break;
                    case gl.FLOAT_MAT4:
                        gl.uniformMatrix4fv(location, false, data.rawData);
                        break;
                    case gl.FLOAT:
                        gl.uniform1f(location, data);
                        break;
                    case gl.FLOAT_VEC2:
                        gl.uniform2f(location, data.x, data.y);
                        break;
                    case gl.FLOAT_VEC3:
                        if (data instanceof feng3d.Color3) {
                            gl.uniform3f(location, data.r, data.g, data.b);
                        }
                        else if (data instanceof feng3d.Vector3) {
                            gl.uniform3f(location, data.x, data.y, data.z);
                        }
                        else {
                            console.error("\u65E0\u6CD5\u5904\u7406 uniform\u6570\u636E " + activeInfo.name + " " + data);
                        }
                        break;
                    case gl.FLOAT_VEC4:
                        if (data instanceof feng3d.Color4) {
                            gl.uniform4f(location, data.r, data.g, data.b, data.a);
                        }
                        else if (data instanceof feng3d.Vector4) {
                            gl.uniform4f(location, data.x, data.y, data.z, data.w);
                        }
                        else {
                            console.error("\u65E0\u6CD5\u5904\u7406 uniform\u6570\u636E " + activeInfo.name + " " + data);
                        }
                        break;
                    case gl.SAMPLER_2D:
                    case gl.SAMPLER_CUBE:
                        var textureInfo = data;
                        //激活纹理编号
                        gl.activeTexture(gl["TEXTURE" + activeInfo.textureID]);
                        textureInfo.active(gl);
                        //设置纹理所在采样编号
                        gl.uniform1i(location, activeInfo.textureID);
                        break;
                    default:
                        console.error("\u65E0\u6CD5\u8BC6\u522B\u7684uniform\u7C7B\u578B " + activeInfo.name + " " + data);
                }
            }
            /**
             */
            function dodraw(renderAtomic, renderMode) {
                var instanceCount = ~~feng3d.lazy.getvalue(renderAtomic.instanceCount);
                var indexBuffer = renderAtomic.indexBuffer;
                var vertexNum = 0;
                if (indexBuffer) {
                    indexBuffer.active(gl);
                    var arrayType = gl[indexBuffer.type];
                    if (indexBuffer.count == 0) {
                        console.warn("\u9876\u70B9\u7D22\u5F15\u4E3A0\uFF0C\u4E0D\u8FDB\u884C\u6E32\u67D3\uFF01");
                        return;
                    }
                    if (instanceCount > 1) {
                        if (gl.webgl2) {
                            var gl2 = gl;
                            gl2.drawElementsInstanced(renderMode, indexBuffer.count, arrayType, indexBuffer.offset, instanceCount);
                        }
                        else if (!!gl.extensions.aNGLEInstancedArrays) {
                            gl.extensions.aNGLEInstancedArrays.drawElementsInstancedANGLE(renderMode, indexBuffer.count, arrayType, indexBuffer.offset, instanceCount);
                        }
                        else {
                            console.warn("\u6D4F\u89C8\u5668 \u4E0D\u652F\u6301 drawElementsInstanced \uFF01");
                        }
                    }
                    else {
                        gl.drawElements(renderMode, indexBuffer.count, arrayType, indexBuffer.offset);
                    }
                }
                else {
                    var vertexNum = (function (attributes) {
                        for (var attr in attributes) {
                            if (attributes.hasOwnProperty(attr)) {
                                var attribute = attributes[attr];
                                return attribute.data.length / attribute.size;
                            }
                        }
                        return 0;
                    })(renderAtomic.attributes);
                    if (vertexNum == 0) {
                        console.warn("\u9876\u70B9\u6570\u91CF\u4E3A0\uFF0C\u4E0D\u8FDB\u884C\u6E32\u67D3\uFF01");
                        return;
                    }
                    if (instanceCount > 1) {
                        if (gl.webgl2) {
                            var gl2 = gl;
                            gl2.drawArraysInstanced(renderMode, 0, vertexNum, instanceCount);
                        }
                        else if (!!gl.extensions.aNGLEInstancedArrays) {
                            gl.extensions.aNGLEInstancedArrays.drawArraysInstancedANGLE(renderMode, 0, vertexNum, instanceCount);
                        }
                        else {
                            console.warn("\u6D4F\u89C8\u5668 \u4E0D\u652F\u6301 drawArraysInstanced \uFF01");
                        }
                    }
                    else {
                        gl.drawArrays(renderMode, 0, vertexNum);
                    }
                }
            }
        }
        return Renderer;
    }());
    feng3d.Renderer = Renderer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 前向渲染器

     */
    var ForwardRenderer = /** @class */ (function () {
        function ForwardRenderer() {
        }
        /**
         * 渲染
         */
        ForwardRenderer.prototype.draw = function (gl, scene3d, camera) {
            var blenditems = scene3d.getPickCache(camera).blenditems;
            var unblenditems = scene3d.getPickCache(camera).unblenditems;
            var uniforms = {};
            //
            uniforms.u_projectionMatrix = camera.lens.matrix;
            uniforms.u_viewProjection = camera.viewProjection;
            uniforms.u_viewMatrix = camera.transform.worldToLocalMatrix;
            uniforms.u_cameraMatrix = camera.transform.localToWorldMatrix;
            uniforms.u_cameraPos = camera.transform.scenePosition;
            uniforms.u_skyBoxSize = camera.lens.far / Math.sqrt(3);
            uniforms.u_scaleByDepth = camera.getScaleByDepth(1);
            uniforms.u_sceneAmbientColor = scene3d.ambientColor;
            unblenditems.concat(blenditems).forEach(function (model) {
                //绘制
                var renderAtomic = model.gameObject.renderAtomic;
                for (var key in uniforms) {
                    renderAtomic.uniforms[key] = uniforms[key];
                }
                model.gameObject.beforeRender(gl, renderAtomic, scene3d, camera);
                gl.renderer.draw(renderAtomic);
            });
        };
        return ForwardRenderer;
    }());
    feng3d.ForwardRenderer = ForwardRenderer;
    feng3d.forwardRenderer = new ForwardRenderer();
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 深度渲染器
     */
    var DepthRenderer = /** @class */ (function () {
        function DepthRenderer() {
        }
        /**
         * 渲染
         */
        DepthRenderer.prototype.draw = function (gl, scene3d, camera) {
        };
        return DepthRenderer;
    }());
    feng3d.DepthRenderer = DepthRenderer;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 鼠标拾取渲染器

     */
    var MouseRenderer = /** @class */ (function (_super) {
        __extends(MouseRenderer, _super);
        function MouseRenderer() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.objects = [];
            return _this;
        }
        /**
         * 渲染
         */
        MouseRenderer.prototype.draw = function (gl, viewRect) {
            var mouseX = feng3d.windowEventProxy.clientX;
            var mouseY = feng3d.windowEventProxy.clientY;
            var offsetX = -(mouseX - viewRect.x);
            var offsetY = -(viewRect.height - (mouseY - viewRect.y)); //y轴与window中坐标反向，所以需要 h = (maxHeight - h)
            gl.clearColor(0, 0, 0, 0);
            gl.clearDepth(1);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.viewport(offsetX, offsetY, viewRect.width, viewRect.height);
            this.objects.length = 1;
            //启动裁剪，只绘制一个像素
            gl.enable(gl.SCISSOR_TEST);
            gl.scissor(0, 0, 1, 1);
            // super.draw(renderContext);
            gl.disable(gl.SCISSOR_TEST);
            //读取鼠标拾取索引
            // this.frameBufferObject.readBuffer(gl, "objectID");
            var data = new Uint8Array(4);
            gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, data);
            var id = data[0] + data[1] * 255 + data[2] * 255 * 255 + data[3] * 255 * 255 * 255 - data[3]; //最后（- data[3]）表示很奇怪，不过data[3]一般情况下为0
            // log(`选中索引3D对象${id}`, data.toString());
            return this.objects[id];
        };
        MouseRenderer.prototype.drawRenderables = function (gl, model) {
            if (model.gameObject.mouseEnabled) {
                var object = model.gameObject;
                var u_objectID = this.objects.length;
                this.objects[u_objectID] = object;
                var renderAtomic = object.renderAtomic;
                renderAtomic.uniforms.u_objectID = u_objectID;
                // super.drawRenderables(renderContext, model);
            }
        };
        /**
         * 绘制3D对象
         */
        MouseRenderer.prototype.drawGameObject = function (gl, renderAtomic) {
            // var shader = new Shader();
            // shader.vertexCode = shaderlib.getShader("mouse").vertex;
            // shader.fragmentCode = shaderlib.getShader("mouse").fragment;
            // super.drawGameObject(gl, renderAtomic, shader);
        };
        return MouseRenderer;
    }(feng3d.EventDispatcher));
    feng3d.MouseRenderer = MouseRenderer;
    feng3d.mouseRenderer = new MouseRenderer();
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var ShadowRenderer = /** @class */ (function () {
        function ShadowRenderer() {
            this.renderAtomic = new feng3d.RenderAtomic();
        }
        /**
         * 渲染
         */
        ShadowRenderer.prototype.draw = function (gl, scene3d, camera) {
            var pointLights = scene3d.activePointLights.filter(function (i) { return i.shadowType != feng3d.ShadowType.No_Shadows; });
            for (var i = 0; i < pointLights.length; i++) {
                pointLights[i].updateDebugShadowMap(scene3d, camera);
                this.drawForPointLight(gl, pointLights[i], scene3d, camera);
            }
            var spotLights = scene3d.activeSpotLights.filter(function (i) { return i.shadowType != feng3d.ShadowType.No_Shadows; });
            for (var i = 0; i < spotLights.length; i++) {
                spotLights[i].updateDebugShadowMap(scene3d, camera);
                this.drawForSpotLight(gl, spotLights[i], scene3d, camera);
            }
            var directionalLights = scene3d.activeDirectionalLights.filter(function (i) { return i.shadowType != feng3d.ShadowType.No_Shadows; });
            for (var i = 0; i < directionalLights.length; i++) {
                directionalLights[i].updateDebugShadowMap(scene3d, camera);
                this.drawForDirectionalLight(gl, directionalLights[i], scene3d, camera);
            }
        };
        ShadowRenderer.prototype.drawForSpotLight = function (gl, light, scene3d, camera) {
            var _this = this;
            light.frameBufferObject.active(gl);
            //
            gl.viewport(0, 0, light.frameBufferObject.OFFSCREEN_WIDTH, light.frameBufferObject.OFFSCREEN_HEIGHT);
            gl.clearColor(1.0, 1.0, 1.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            var shadowCamera = light.shadowCamera;
            shadowCamera.transform.localToWorldMatrix = light.transform.localToWorldMatrix;
            var renderAtomic = this.renderAtomic;
            // 获取影响阴影图的渲染对象
            var models = scene3d.getModelsByCamera(shadowCamera);
            // 筛选投射阴影的渲染对象
            var castShadowsModels = models.filter(function (i) { return i.castShadows; });
            //
            renderAtomic.renderParams.useViewRect = true;
            renderAtomic.renderParams.viewRect = new feng3d.Rectangle(0, 0, light.frameBufferObject.OFFSCREEN_WIDTH, light.frameBufferObject.OFFSCREEN_HEIGHT);
            //
            renderAtomic.uniforms.u_projectionMatrix = shadowCamera.lens.matrix;
            renderAtomic.uniforms.u_viewProjection = shadowCamera.viewProjection;
            renderAtomic.uniforms.u_viewMatrix = shadowCamera.transform.worldToLocalMatrix;
            renderAtomic.uniforms.u_cameraMatrix = shadowCamera.transform.localToWorldMatrix;
            renderAtomic.uniforms.u_cameraPos = shadowCamera.transform.scenePosition;
            //
            renderAtomic.uniforms.u_lightType = light.lightType;
            renderAtomic.uniforms.u_lightPosition = light.position;
            renderAtomic.uniforms.u_shadowCameraNear = light.shadowCameraNear;
            renderAtomic.uniforms.u_shadowCameraFar = light.shadowCameraFar;
            castShadowsModels.forEach(function (element) {
                _this.drawGameObject(gl, element.gameObject, scene3d, camera);
            });
            light.frameBufferObject.deactive(gl);
        };
        ShadowRenderer.prototype.drawForPointLight = function (gl, light, scene3d, camera) {
            var _this = this;
            light.frameBufferObject.active(gl);
            //
            gl.viewport(0, 0, light.frameBufferObject.OFFSCREEN_WIDTH, light.frameBufferObject.OFFSCREEN_HEIGHT);
            gl.clearColor(1.0, 1.0, 1.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            var vpWidth = light.shadowMapSize.x;
            var vpHeight = light.shadowMapSize.y;
            // These viewports map a cube-map onto a 2D texture with the
            // following orientation:
            //
            //  xzXZ
            //   y Y
            //
            // X - Positive x direction
            // x - Negative x direction
            // Y - Positive y direction
            // y - Negative y direction
            // Z - Positive z direction
            // z - Negative z direction
            // positive X
            cube2DViewPorts[0].init(vpWidth * 2, vpHeight, vpWidth, vpHeight);
            // negative X
            cube2DViewPorts[1].init(0, vpHeight, vpWidth, vpHeight);
            // positive Z
            cube2DViewPorts[2].init(vpWidth * 3, vpHeight, vpWidth, vpHeight);
            // negative Z
            cube2DViewPorts[3].init(vpWidth, vpHeight, vpWidth, vpHeight);
            // positive Y
            cube2DViewPorts[4].init(vpWidth * 3, 0, vpWidth, vpHeight);
            // negative Y
            cube2DViewPorts[5].init(vpWidth, 0, vpWidth, vpHeight);
            var shadowCamera = light.shadowCamera;
            shadowCamera.transform.position = light.transform.position;
            var renderAtomic = this.renderAtomic;
            for (var face = 0; face < 6; face++) {
                shadowCamera.transform.lookAt(light.position.addTo(cubeDirections[face]), cubeUps[face]);
                // 获取影响阴影图的渲染对象
                var models = scene3d.getModelsByCamera(shadowCamera);
                // 筛选投射阴影的渲染对象
                var castShadowsModels = models.filter(function (i) { return i.castShadows; });
                //
                renderAtomic.renderParams.useViewRect = true;
                renderAtomic.renderParams.viewRect = cube2DViewPorts[face];
                //
                renderAtomic.uniforms.u_projectionMatrix = shadowCamera.lens.matrix;
                renderAtomic.uniforms.u_viewProjection = shadowCamera.viewProjection;
                renderAtomic.uniforms.u_viewMatrix = shadowCamera.transform.worldToLocalMatrix;
                renderAtomic.uniforms.u_cameraMatrix = shadowCamera.transform.localToWorldMatrix;
                renderAtomic.uniforms.u_cameraPos = shadowCamera.transform.scenePosition;
                //
                renderAtomic.uniforms.u_lightType = light.lightType;
                renderAtomic.uniforms.u_lightPosition = light.position;
                renderAtomic.uniforms.u_shadowCameraNear = light.shadowCameraNear;
                renderAtomic.uniforms.u_shadowCameraFar = light.shadowCameraFar;
                castShadowsModels.forEach(function (element) {
                    _this.drawGameObject(gl, element.gameObject, scene3d, camera);
                });
            }
            light.frameBufferObject.deactive(gl);
        };
        ShadowRenderer.prototype.drawForDirectionalLight = function (gl, light, scene3d, camera) {
            var _this = this;
            // 获取影响阴影图的渲染对象
            var models = scene3d.getPickByDirectionalLight(light);
            // 筛选投射阴影的渲染对象
            var castShadowsModels = models.filter(function (i) { return i.castShadows; });
            light.updateShadowByCamera(scene3d, camera, models);
            light.frameBufferObject.active(gl);
            //
            gl.viewport(0, 0, light.frameBufferObject.OFFSCREEN_WIDTH, light.frameBufferObject.OFFSCREEN_HEIGHT);
            gl.clearColor(1.0, 1.0, 1.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            var shadowCamera = light.shadowCamera;
            var renderAtomic = this.renderAtomic;
            //
            renderAtomic.renderParams.useViewRect = true;
            renderAtomic.renderParams.viewRect = new feng3d.Rectangle(0, 0, light.frameBufferObject.OFFSCREEN_WIDTH, light.frameBufferObject.OFFSCREEN_HEIGHT);
            //
            renderAtomic.uniforms.u_projectionMatrix = shadowCamera.lens.matrix;
            renderAtomic.uniforms.u_viewProjection = shadowCamera.viewProjection;
            renderAtomic.uniforms.u_viewMatrix = shadowCamera.transform.worldToLocalMatrix;
            renderAtomic.uniforms.u_cameraMatrix = shadowCamera.transform.localToWorldMatrix;
            renderAtomic.uniforms.u_cameraPos = shadowCamera.transform.scenePosition;
            //
            renderAtomic.uniforms.u_lightType = light.lightType;
            renderAtomic.uniforms.u_lightPosition = shadowCamera.transform.scenePosition;
            renderAtomic.uniforms.u_shadowCameraNear = light.shadowCameraNear;
            renderAtomic.uniforms.u_shadowCameraFar = light.shadowCameraFar;
            //
            castShadowsModels.forEach(function (element) {
                _this.drawGameObject(gl, element.gameObject, scene3d, camera);
            });
            light.frameBufferObject.deactive(gl);
        };
        /**
         * 绘制3D对象
         */
        ShadowRenderer.prototype.drawGameObject = function (gl, gameObject, scene3d, camera) {
            var renderAtomic = gameObject.renderAtomic;
            gameObject.beforeRender(gl, renderAtomic, scene3d, camera);
            renderAtomic.shadowShader = renderAtomic.shadowShader || new feng3d.Shader("shadow");
            //
            this.renderAtomic.next = renderAtomic;
            this.renderAtomic.renderParams.cullFace = renderAtomic.renderParams.cullFace;
            // 使用shadowShader
            this.renderAtomic.shader = renderAtomic.shadowShader;
            gl.renderer.draw(this.renderAtomic);
            this.renderAtomic.shader = null;
        };
        return ShadowRenderer;
    }());
    feng3d.ShadowRenderer = ShadowRenderer;
    feng3d.shadowRenderer = new ShadowRenderer();
    var cube2DViewPorts = [
        new feng3d.Rectangle(), new feng3d.Rectangle(), new feng3d.Rectangle(),
        new feng3d.Rectangle(), new feng3d.Rectangle(), new feng3d.Rectangle()
    ];
    var cubeUps = [
        new feng3d.Vector3(0, 1, 0), new feng3d.Vector3(0, 1, 0), new feng3d.Vector3(0, 1, 0),
        new feng3d.Vector3(0, 1, 0), new feng3d.Vector3(0, 0, 1), new feng3d.Vector3(0, 0, -1)
    ];
    var cubeDirections = [
        new feng3d.Vector3(1, 0, 0), new feng3d.Vector3(-1, 0, 0), new feng3d.Vector3(0, 0, 1),
        new feng3d.Vector3(0, 0, -1), new feng3d.Vector3(0, 1, 0), new feng3d.Vector3(0, -1, 0)
    ];
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 轮廓渲染器
     */
    var OutlineRenderer = /** @class */ (function () {
        function OutlineRenderer() {
        }
        OutlineRenderer.prototype.init = function () {
            if (!this.renderAtomic) {
                this.renderAtomic = new feng3d.RenderAtomic();
                var renderParams = this.renderAtomic.renderParams;
                renderParams.enableBlend = false;
                renderParams.cullFace = feng3d.CullFace.FRONT;
                this.renderAtomic.shader = new feng3d.Shader("outline");
            }
        };
        OutlineRenderer.prototype.draw = function (gl, scene3d, camera) {
            var unblenditems = scene3d.getPickCache(camera).unblenditems;
            this.init();
            for (var i = 0; i < unblenditems.length; i++) {
                var model = unblenditems[i];
                if (model.getComponent(feng3d.OutLineComponent) || model.getComponent(feng3d.CartoonComponent)) {
                    var renderAtomic = model.gameObject.renderAtomic;
                    model.gameObject.beforeRender(gl, renderAtomic, scene3d, camera);
                    this.renderAtomic.next = renderAtomic;
                    gl.renderer.draw(this.renderAtomic);
                }
            }
        };
        return OutlineRenderer;
    }());
    feng3d.OutlineRenderer = OutlineRenderer;
    feng3d.outlineRenderer = new OutlineRenderer();
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var WireframeRenderer = /** @class */ (function () {
        function WireframeRenderer() {
        }
        WireframeRenderer.prototype.init = function () {
            if (!this.renderAtomic) {
                this.renderAtomic = new feng3d.RenderAtomic();
                var renderParams = this.renderAtomic.renderParams;
                renderParams.renderMode = feng3d.RenderMode.LINES;
                // renderParams.depthMask = false;
            }
        };
        /**
         * 渲染
         */
        WireframeRenderer.prototype.draw = function (gl, scene3d, camera) {
            var _this = this;
            var unblenditems = scene3d.getPickCache(camera).unblenditems;
            var wireframes = unblenditems.reduce(function (pv, cv) { var wireframe = cv.getComponent(feng3d.WireframeComponent); if (wireframe)
                pv.push(wireframe); return pv; }, []);
            if (wireframes.length == 0)
                return;
            wireframes.forEach(function (element) {
                _this.drawGameObject(gl, element.gameObject, scene3d, camera, element.color); //
            });
        };
        /**
         * 绘制3D对象
         */
        WireframeRenderer.prototype.drawGameObject = function (gl, gameObject, scene3d, camera, wireframeColor) {
            if (wireframeColor === void 0) { wireframeColor = new feng3d.Color4(); }
            var renderAtomic = gameObject.renderAtomic;
            gameObject.beforeRender(gl, renderAtomic, scene3d, camera);
            var renderMode = feng3d.lazy.getvalue(renderAtomic.renderParams.renderMode);
            if (renderMode == feng3d.RenderMode.POINTS
                || renderMode == feng3d.RenderMode.LINES
                || renderMode == feng3d.RenderMode.LINE_LOOP
                || renderMode == feng3d.RenderMode.LINE_STRIP)
                return;
            this.init();
            var uniforms = this.renderAtomic.uniforms;
            //
            uniforms.u_projectionMatrix = camera.lens.matrix;
            uniforms.u_viewProjection = camera.viewProjection;
            uniforms.u_viewMatrix = camera.transform.worldToLocalMatrix;
            uniforms.u_cameraMatrix = camera.transform.localToWorldMatrix;
            uniforms.u_cameraPos = camera.transform.scenePosition;
            uniforms.u_skyBoxSize = camera.lens.far / Math.sqrt(3);
            uniforms.u_scaleByDepth = camera.getScaleByDepth(1);
            //
            this.renderAtomic.next = renderAtomic;
            //
            var oldIndexBuffer = renderAtomic.indexBuffer;
            if (!renderAtomic.wireframeindexBuffer || renderAtomic.wireframeindexBuffer.count != 2 * oldIndexBuffer.count) {
                var wireframeindices = [];
                var indices = feng3d.lazy.getvalue(oldIndexBuffer.indices);
                for (var i = 0; i < indices.length; i += 3) {
                    wireframeindices.push(indices[i], indices[i + 1], indices[i], indices[i + 2], indices[i + 1], indices[i + 2]);
                }
                renderAtomic.wireframeindexBuffer = new feng3d.Index();
                renderAtomic.wireframeindexBuffer.indices = wireframeindices;
            }
            renderAtomic.wireframeShader = renderAtomic.wireframeShader || new feng3d.Shader("wireframe");
            this.renderAtomic.indexBuffer = renderAtomic.wireframeindexBuffer;
            this.renderAtomic.uniforms.u_wireframeColor = wireframeColor;
            //
            this.renderAtomic.shader = renderAtomic.wireframeShader;
            gl.renderer.draw(this.renderAtomic);
            this.renderAtomic.shader = null;
            //
        };
        return WireframeRenderer;
    }());
    feng3d.WireframeRenderer = WireframeRenderer;
    feng3d.wireframeRenderer = new WireframeRenderer();
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 组件
     *
     * 所有附加到GameObjects的基类。
     *
     * 注意，您的代码永远不会直接创建组件。相反，你可以编写脚本代码，并将脚本附加到GameObject(游戏物体)上。
     */
    var Component = /** @class */ (function (_super) {
        __extends(Component, _super);
        //------------------------------------------
        // Functions
        //------------------------------------------
        /**
         * 创建一个组件容器
         */
        function Component() {
            var _this = _super.call(this) || this;
            _this._disposed = false;
            _this.onAll(_this._onAllListener, _this);
            return _this;
        }
        Object.defineProperty(Component.prototype, "gameObject", {
            //------------------------------------------
            // Variables
            //------------------------------------------
            /**
             * 此组件附加到的游戏对象。组件总是附加到游戏对象上。
             */
            get: function () {
                return this._gameObject;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Component.prototype, "transform", {
            /**
             * The Transform attached to this GameObject (null if there is none attached).
             */
            get: function () {
                return this._gameObject && this._gameObject.transform;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Component.prototype, "single", {
            /**
             * 是否唯一，同类型3D对象组件只允许一个
             */
            get: function () {
                return false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Component.prototype, "disposed", {
            /**
             * 是否已销毁
             */
            get: function () { return this._disposed; },
            enumerable: true,
            configurable: true
        });
        Component.prototype.init = function () {
        };
        /**
         * Returns the component of Type type if the game object has one attached, null if it doesn't.
         * @param type				The type of Component to retrieve.
         * @return                  返回指定类型组件
         */
        Component.prototype.getComponent = function (type) {
            return this.gameObject.getComponent(type);
        };
        /**
         * Returns all components of Type type in the GameObject.
         * @param type		类定义
         * @return			返回与给出类定义一致的组件
         */
        Component.prototype.getComponents = function (type) {
            return this.gameObject.getComponents(type);
        };
        /**
         * Returns all components of Type type in the GameObject.
         * @param type		类定义
         * @return			返回与给出类定义一致的组件
         */
        Component.prototype.getComponentsInChildren = function (type, filter, result) {
            return this.gameObject.getComponentsInChildren(type, filter, result);
        };
        /**
         * 从父类中获取组件
         * @param type		类定义
         * @return			返回与给出类定义一致的组件
         */
        Component.prototype.getComponentsInParents = function (type, result) {
            return this.gameObject.getComponentsInParents(type, result);
        };
        /**
         * 销毁
         */
        Component.prototype.dispose = function () {
            this._gameObject = null;
            this._disposed = true;
        };
        Component.prototype.beforeRender = function (gl, renderAtomic, scene3d, camera) {
        };
        /**
         * 监听对象的所有事件并且传播到所有组件中
         */
        Component.prototype._onAllListener = function (e) {
            if (this._gameObject)
                this._gameObject.dispatchEvent(e);
        };
        /**
         * 该方法仅在GameObject中使用
         * @private
         *
         * @param gameObject 游戏对象
         */
        Component.prototype.setGameObject = function (gameObject) {
            this._gameObject = gameObject;
        };
        __decorate([
            feng3d.serialize
        ], Component.prototype, "tag", void 0);
        return Component;
    }(feng3d.Feng3dObject));
    feng3d.Component = Component;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Graphics 类包含一组可用来创建矢量形状的方法。
     */
    var Graphics = /** @class */ (function (_super) {
        __extends(Graphics, _super);
        function Graphics() {
            var _this = _super.call(this) || this;
            _this.__class__ = "feng3d.Graphics";
            _this.canvas = document.createElement("canvas");
            _this.canvas.width = _this.width;
            _this.canvas.height = _this.height;
            _this.context2D = _this.canvas.getContext('2d');
            //
            watchContext2D(_this.context2D);
            return _this;
        }
        Graphics.prototype.draw = function (width, height, callback) {
            var _this = this;
            var canvas = document.createElement("canvas");
            canvas.width = width;
            canvas.height = height;
            var ctxt = canvas.getContext('2d');
            callback(ctxt);
            feng3d.dataTransform.canvasToImage(canvas, "png", function (img) {
                _this.image = img;
            });
            return this;
        };
        return Graphics;
    }(feng3d.Component));
    feng3d.Graphics = Graphics;
    function watchContext2D(context2D, watchFuncs) {
        if (watchFuncs === void 0) { watchFuncs = ["rect"]; }
        watchFuncs.forEach(function (v) {
            var oldFunc = context2D[v];
            context2D[v] = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                oldFunc.apply(context2D, args);
                // 标记更改
                context2D["__changed"] = true;
            };
        });
    }
    feng3d.watchContext2D = watchContext2D;
})(feng3d || (feng3d = {}));
// var ctxts = [];
// var num = 100;
// for (var i = 0; i < num; i++)
// {
//     var canvas = document.createElement("canvas");
//     canvas.width = 100;
//     canvas.height = 100;
//     var ctxt = canvas.getContext('2d');
//     ctxts.push(ctxt);
// }
var feng3d;
(function (feng3d) {
    /**
     * 行为
     *
     * 可以控制开关的组件
     */
    var Behaviour = /** @class */ (function (_super) {
        __extends(Behaviour, _super);
        function Behaviour() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 是否启用update方法
             */
            _this.enabled = true;
            /**
             * 可运行环境
             */
            _this.runEnvironment = feng3d.RunEnvironment.all;
            return _this;
        }
        Object.defineProperty(Behaviour.prototype, "isVisibleAndEnabled", {
            /**
             * Has the Behaviour had enabled called.
             * 是否所在GameObject显示且该行为已启动。
             */
            get: function () {
                var v = this.enabled && this.gameObject && this.gameObject.visible;
                return v;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 每帧执行
         */
        Behaviour.prototype.update = function (interval) {
        };
        Behaviour.prototype.dispose = function () {
            this.enabled = false;
            _super.prototype.dispose.call(this);
        };
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], Behaviour.prototype, "enabled", void 0);
        return Behaviour;
    }(feng3d.Component));
    feng3d.Behaviour = Behaviour;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 天空盒组件
     */
    var SkyBox = /** @class */ (function (_super) {
        __extends(SkyBox, _super);
        function SkyBox() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.__class__ = "feng3d.SkyBox";
            _this.s_skyboxTexture = feng3d.TextureCube.default;
            return _this;
        }
        SkyBox.prototype.beforeRender = function (gl, renderAtomic, scene3d, camera) {
            var _this = this;
            renderAtomic.uniforms.s_skyboxTexture = function () { return _this.s_skyboxTexture; };
        };
        __decorate([
            feng3d.serialize,
            feng3d.oav({ component: "OAVPick", componentParam: { accepttype: "texturecube", datatype: "texturecube" } })
        ], SkyBox.prototype, "s_skyboxTexture", void 0);
        return SkyBox;
    }(feng3d.Component));
    feng3d.SkyBox = SkyBox;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 天空盒渲染器
     */
    var SkyboxRenderer = /** @class */ (function () {
        function SkyboxRenderer() {
        }
        SkyboxRenderer.prototype.init = function () {
            if (!this.renderAtomic) {
                var renderAtomic = this.renderAtomic = new feng3d.RenderAtomic();
                //八个顶点，32个number
                var vertexPositionData = [
                    -1, 1, -1,
                    1, 1, -1,
                    1, 1, 1,
                    -1, 1, 1,
                    -1, -1, -1,
                    1, -1, -1,
                    1, -1, 1,
                    -1, -1, 1 //
                ];
                renderAtomic.attributes.a_position = new feng3d.Attribute("a_position", vertexPositionData, 3);
                //6个面，12个三角形，36个顶点索引
                var indices = [
                    0, 1, 2, 2, 3, 0,
                    6, 5, 4, 4, 7, 6,
                    2, 6, 7, 7, 3, 2,
                    4, 5, 1, 1, 0, 4,
                    4, 0, 3, 3, 7, 4,
                    2, 1, 5, 5, 6, 2 //
                ];
                renderAtomic.indexBuffer = new feng3d.Index();
                renderAtomic.indexBuffer.indices = indices;
                //
                var renderParams = renderAtomic.renderParams;
                renderParams.cullFace = feng3d.CullFace.NONE;
                //
                renderAtomic.shader = new feng3d.Shader("skybox");
            }
        };
        /**
         * 绘制场景中天空盒
         * @param gl
         * @param scene3d 场景
         * @param camera 摄像机
         */
        SkyboxRenderer.prototype.draw = function (gl, scene3d, camera) {
            var skybox = scene3d.activeSkyBoxs[0];
            this.drawSkyBox(gl, skybox, scene3d, camera);
        };
        /**
         * 绘制天空盒
         * @param gl
         * @param skybox 天空盒
         * @param camera 摄像机
         */
        SkyboxRenderer.prototype.drawSkyBox = function (gl, skybox, scene3d, camera) {
            if (!skybox)
                return;
            this.init();
            //
            skybox.gameObject.beforeRender(gl, this.renderAtomic, scene3d, camera);
            //
            this.renderAtomic.uniforms.u_viewProjection = camera.viewProjection;
            this.renderAtomic.uniforms.u_viewMatrix = camera.transform.worldToLocalMatrix;
            this.renderAtomic.uniforms.u_cameraMatrix = camera.transform.localToWorldMatrix;
            this.renderAtomic.uniforms.u_cameraPos = camera.transform.scenePosition;
            this.renderAtomic.uniforms.u_skyBoxSize = camera.lens.far / Math.sqrt(3);
            gl.renderer.draw(this.renderAtomic);
        };
        return SkyboxRenderer;
    }());
    feng3d.SkyboxRenderer = SkyboxRenderer;
    feng3d.skyboxRenderer = new SkyboxRenderer();
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 在检查器中控制对象销毁、保存和可见性的位掩码。
     */
    var HideFlags;
    (function (HideFlags) {
        /**
         * 一个正常的,可见对象。这是默认的。
         */
        HideFlags[HideFlags["None"] = 0] = "None";
        /**
         * 不会出现在层次界面中。
         */
        HideFlags[HideFlags["HideInHierarchy"] = 1] = "HideInHierarchy";
        /**
         * 不会出现在检查器界面中。
         */
        HideFlags[HideFlags["HideInInspector"] = 2] = "HideInInspector";
        /**
         * 不会保存到编辑器中的场景中。
         */
        HideFlags[HideFlags["DontSaveInEditor"] = 4] = "DontSaveInEditor";
        /**
         * 在检查器中不可编辑。
         */
        HideFlags[HideFlags["NotEditable"] = 8] = "NotEditable";
        /**
         * 在构建播放器时对象不会被保存。
         */
        HideFlags[HideFlags["DontSaveInBuild"] = 16] = "DontSaveInBuild";
        /**
         * 对象不会被Resources.UnloadUnusedAssets卸载。
         */
        HideFlags[HideFlags["DontUnloadUnusedAsset"] = 32] = "DontUnloadUnusedAsset";
        /**
         * 不能被变换
         */
        HideFlags[HideFlags["DontTransform"] = 64] = "DontTransform";
        /**
         * 隐藏
         */
        HideFlags[HideFlags["Hide"] = 3] = "Hide";
        /**
         * 对象不会保存到场景中。加载新场景时不会被销毁。相当于DontSaveInBuild | HideFlags。DontSaveInEditor | HideFlags.DontUnloadUnusedAsset
         */
        HideFlags[HideFlags["DontSave"] = 20] = "DontSave";
        /**
         * 不显示在层次界面中，不保存到场景中，加载新场景时不会被销毁。
         */
        HideFlags[HideFlags["HideAndDontSave"] = 61] = "HideAndDontSave";
    })(HideFlags = feng3d.HideFlags || (feng3d.HideFlags = {}));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 运行环境枚举
     */
    var RunEnvironment;
    (function (RunEnvironment) {
        /**
         * 在feng3d模式下运行
         */
        RunEnvironment[RunEnvironment["feng3d"] = 1] = "feng3d";
        /**
         * 运行在编辑器中
         */
        RunEnvironment[RunEnvironment["editor"] = 2] = "editor";
        /**
         * 在所有环境中运行
         */
        RunEnvironment[RunEnvironment["all"] = 255] = "all";
    })(RunEnvironment = feng3d.RunEnvironment || (feng3d.RunEnvironment = {}));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var fixedNum = 6;
    /**
     * 变换
     *
     * 物体的位置、旋转和比例。
     *
     * 场景中的每个对象都有一个变换。它用于存储和操作对象的位置、旋转和缩放。每个转换都可以有一个父元素，它允许您分层应用位置、旋转和缩放
     */
    var Transform = /** @class */ (function (_super) {
        __extends(Transform, _super);
        /**
         * 创建一个实体，该类为虚类
         */
        function Transform() {
            var _this = _super.call(this) || this;
            _this.__class__ = "feng3d.Transform";
            _this.renderAtomic = new feng3d.RenderAtomic();
            //------------------------------------------
            // Private Properties
            //------------------------------------------
            _this._position = new feng3d.Vector3();
            _this._rotation = new feng3d.Vector3();
            _this._orientation = new feng3d.Quaternion();
            _this._scale = new feng3d.Vector3(1, 1, 1);
            _this._smallestNumber = 0.0000000000000000000001;
            _this._x = 0;
            _this._y = 0;
            _this._z = 0;
            _this._rx = 0;
            _this._ry = 0;
            _this._rz = 0;
            _this._sx = 1;
            _this._sy = 1;
            _this._sz = 1;
            _this.renderAtomic.uniforms.u_modelMatrix = function () { return _this.localToWorldMatrix; };
            _this.renderAtomic.uniforms.u_ITModelMatrix = function () { return _this.ITlocalToWorldMatrix; };
            return _this;
        }
        Object.defineProperty(Transform.prototype, "single", {
            get: function () { return true; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "scenePosition", {
            get: function () {
                return this.localToWorldMatrix.position;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "parent", {
            get: function () {
                return this.gameObject.parent && this.gameObject.parent.transform;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "localToWorldMatrix", {
            /**
             * 将一个点从局部空间变换到世界空间的矩阵。
             */
            get: function () {
                if (!this._localToWorldMatrix)
                    this._localToWorldMatrix = this.updateLocalToWorldMatrix();
                return this._localToWorldMatrix;
            },
            set: function (value) {
                value = value.clone();
                this.parent && value.append(this.parent.worldToLocalMatrix);
                this.matrix3d = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "ITlocalToWorldMatrix", {
            /**
             * 本地转世界逆转置矩阵
             */
            get: function () {
                if (!this._ITlocalToWorldMatrix) {
                    this._ITlocalToWorldMatrix = this.localToWorldMatrix.clone();
                    this._ITlocalToWorldMatrix.invert().transpose();
                }
                return this._ITlocalToWorldMatrix;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "worldToLocalMatrix", {
            /**
             * 将一个点从世界空间转换为局部空间的矩阵。
             */
            get: function () {
                if (!this._worldToLocalMatrix)
                    this._worldToLocalMatrix = this.localToWorldMatrix.clone().invert();
                return this._worldToLocalMatrix;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "localToWorldRotationMatrix", {
            get: function () {
                if (!this._localToWorldRotationMatrix) {
                    this._localToWorldRotationMatrix = this.rotationMatrix.clone();
                    if (this.parent)
                        this._localToWorldRotationMatrix.append(this.parent.localToWorldRotationMatrix);
                }
                return this._localToWorldRotationMatrix;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "worldToLocalRotationMatrix", {
            get: function () {
                var mat = this.localToWorldRotationMatrix.clone();
                mat.invert();
                return mat;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 将方向从局部空间转换到世界空间。
         */
        Transform.prototype.transformDirection = function (direction) {
            if (!this.parent)
                return direction.clone();
            var matrix3d = this.parent.localToWorldRotationMatrix;
            direction = matrix3d.transformVector(direction);
            return direction;
        };
        /**
         * 将位置从局部空间转换为世界空间。
         */
        Transform.prototype.transformPoint = function (position) {
            if (!this.parent)
                return position.clone();
            var matrix3d = this.parent.localToWorldMatrix;
            position = matrix3d.transformVector(position);
            return position;
        };
        /**
         * 将向量从局部空间变换到世界空间。
         */
        Transform.prototype.transformVector = function (vector) {
            if (!this.parent)
                return vector.clone();
            var matrix3d = this.parent.localToWorldMatrix;
            vector = matrix3d.deltaTransformVector(vector);
            return vector;
        };
        /**
         * 将一个方向从世界空间转换到局部空间。
         */
        Transform.prototype.inverseTransformDirection = function (direction) {
            if (!this.parent)
                return direction.clone();
            var matrix3d = this.parent.localToWorldRotationMatrix.clone().invert();
            direction = matrix3d.transformVector(direction);
            return direction;
        };
        /**
         * 将位置从世界空间转换为局部空间。
         */
        Transform.prototype.inverseTransformPoint = function (position) {
            if (!this.parent)
                return position.clone();
            var matrix3d = this.parent.localToWorldMatrix.clone().invert();
            position = matrix3d.transformVector(position);
            return position;
        };
        /**
         * 将向量从世界空间转换为局部空间
         */
        Transform.prototype.inverseTransformVector = function (vector) {
            if (!this.parent)
                return vector.clone();
            var matrix3d = this.parent.localToWorldMatrix.clone().invert();
            vector = matrix3d.deltaTransformVector(vector);
            return vector;
        };
        Transform.prototype.beforeRender = function (gl, renderAtomic, scene3d, camera) {
            Object.assign(renderAtomic.uniforms, this.renderAtomic.uniforms);
        };
        Transform.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
        };
        //------------------------------------------
        // Protected Properties
        //------------------------------------------
        //------------------------------------------
        // Protected Functions
        //------------------------------------------
        Transform.prototype.updateLocalToWorldMatrix = function () {
            this._localToWorldMatrix = this.matrix3d.clone();
            if (this.parent)
                this._localToWorldMatrix.append(this.parent.localToWorldMatrix);
            this.dispatch("updateLocalToWorldMatrix");
            feng3d.debuger && console.assert(!isNaN(this._localToWorldMatrix.rawData[0]));
            return this._localToWorldMatrix;
        };
        //------------------------------------------
        // Private Properties
        //------------------------------------------
        //------------------------------------------
        // Private Methods
        //------------------------------------------
        Transform.prototype.invalidateSceneTransform = function () {
            if (!this._localToWorldMatrix)
                return;
            this._localToWorldMatrix = null;
            this._ITlocalToWorldMatrix = null;
            this._worldToLocalMatrix = null;
            this.dispatch("scenetransformChanged", this);
            //
            for (var i = 0, n = this.gameObject.numChildren; i < n; i++) {
                this.gameObject.getChildAt(i).transform.invalidateSceneTransform();
            }
        };
        Object.defineProperty(Transform.prototype, "x", {
            //------------------------------------------
            // Variables
            //------------------------------------------
            get: function () {
                return this._x;
            },
            set: function (val) {
                val = Number(val.toFixed(fixedNum));
                feng3d.debuger && console.
                    assert(!isNaN(val));
                if (this._x == val)
                    return;
                this._x = val;
                this.invalidatePosition();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "y", {
            get: function () {
                return this._y;
            },
            set: function (val) {
                val = Number(val.toFixed(fixedNum));
                feng3d.debuger && console.assert(!isNaN(val));
                if (this._y == val)
                    return;
                this._y = val;
                this.invalidatePosition();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "z", {
            get: function () {
                return this._z;
            },
            set: function (val) {
                val = Number(val.toFixed(fixedNum));
                feng3d.debuger && console.assert(!isNaN(val));
                if (this._z == val)
                    return;
                this._z = val;
                this.invalidatePosition();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "rx", {
            get: function () {
                return this._rx;
            },
            set: function (val) {
                val = Number(val.toFixed(fixedNum));
                feng3d.debuger && console.assert(!isNaN(val));
                if (this.rx == val)
                    return;
                this._rx = val;
                this.invalidateRotation();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "ry", {
            get: function () {
                return this._ry;
            },
            set: function (val) {
                val = Number(val.toFixed(fixedNum));
                feng3d.debuger && console.assert(!isNaN(val));
                if (this.ry == val)
                    return;
                this._ry = val;
                this.invalidateRotation();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "rz", {
            get: function () {
                return this._rz;
            },
            set: function (val) {
                val = Number(val.toFixed(fixedNum));
                feng3d.debuger && console.assert(!isNaN(val));
                if (this.rz == val)
                    return;
                this._rz = val;
                this.invalidateRotation();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "sx", {
            get: function () {
                return this._sx;
            },
            set: function (val) {
                val = Number(val.toFixed(fixedNum));
                feng3d.debuger && console.assert(!isNaN(val) && val != 0);
                if (this._sx == val)
                    return;
                this._sx = val;
                this.invalidateScale();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "sy", {
            get: function () {
                return this._sy;
            },
            set: function (val) {
                val = Number(val.toFixed(fixedNum));
                feng3d.debuger && console.assert(!isNaN(val) && val != 0);
                if (this._sy == val)
                    return;
                this._sy = val;
                this.invalidateScale();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "sz", {
            get: function () {
                return this._sz;
            },
            set: function (val) {
                val = Number(val.toFixed(fixedNum));
                feng3d.debuger && console.assert(!isNaN(val) && val != 0);
                if (this._sz == val)
                    return;
                this._sz = val;
                this.invalidateScale();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "matrix3d", {
            /**
             * @private
             */
            get: function () {
                if (!this._matrix3d)
                    this.updateMatrix3D();
                return this._matrix3d;
            },
            set: function (val) {
                var raw = feng3d.Matrix4x4.RAW_DATA_CONTAINER;
                val.copyRawDataTo(raw);
                if (!raw[0]) {
                    raw[0] = this._smallestNumber;
                    val.copyRawDataFrom(raw);
                }
                val.decompose(feng3d.Orientation3D.EULER_ANGLES, elements);
                this.position = elements[0];
                this.rotation = elements[1].scaleNumber(Math.RAD2DEG);
                this.scale = elements[2];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "rotationMatrix", {
            /**
             * 旋转矩阵
             */
            get: function () {
                if (!this._rotationMatrix3d)
                    this._rotationMatrix3d = feng3d.Matrix4x4.fromRotation(this._rx, this._ry, this._rz);
                return this._rotationMatrix3d;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "position", {
            /**
             * 返回保存位置数据的Vector3D对象
             */
            get: function () {
                this._position.init(this._x, this._y, this._z);
                return this._position;
            },
            set: function (_a) {
                var _b = _a.x, x = _b === void 0 ? 1 : _b, _c = _a.y, y = _c === void 0 ? 1 : _c, _d = _a.z, z = _d === void 0 ? 1 : _d;
                x = Number(x.toFixed(fixedNum));
                y = Number(y.toFixed(fixedNum));
                z = Number(z.toFixed(fixedNum));
                feng3d.debuger && console.assert(!isNaN(x));
                feng3d.debuger && console.assert(!isNaN(y));
                feng3d.debuger && console.assert(!isNaN(z));
                if (this._x != x || this._y != y || this._z != z) {
                    this._x = x;
                    this._y = y;
                    this._z = z;
                    this.invalidatePosition();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "rotation", {
            get: function () {
                this._rotation.init(this._rx, this._ry, this._rz);
                return this._rotation;
            },
            set: function (_a) {
                var _b = _a.x, x = _b === void 0 ? 0 : _b, _c = _a.y, y = _c === void 0 ? 0 : _c, _d = _a.z, z = _d === void 0 ? 0 : _d;
                x = Number(x.toFixed(fixedNum));
                y = Number(y.toFixed(fixedNum));
                z = Number(z.toFixed(fixedNum));
                feng3d.debuger && console.assert(!isNaN(x));
                feng3d.debuger && console.assert(!isNaN(y));
                feng3d.debuger && console.assert(!isNaN(z));
                if (this._rx != x || this._ry != y || this._rz != z) {
                    this._rx = x;
                    this._ry = y;
                    this._rz = z;
                    this.invalidateRotation();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "orientation", {
            /**
             * 四元素旋转
             */
            get: function () {
                this._orientation.fromMatrix(this.matrix3d);
                return this._orientation;
            },
            set: function (value) {
                var angles = value.toEulerAngles();
                angles.scaleNumber(Math.RAD2DEG);
                this.rotation = angles;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "scale", {
            get: function () {
                this._scale.init(this._sx, this._sy, this._sz);
                return this._scale;
            },
            set: function (_a) {
                var _b = _a.x, x = _b === void 0 ? 1 : _b, _c = _a.y, y = _c === void 0 ? 1 : _c, _d = _a.z, z = _d === void 0 ? 1 : _d;
                x = Number(x.toFixed(fixedNum));
                y = Number(y.toFixed(fixedNum));
                z = Number(z.toFixed(fixedNum));
                feng3d.debuger && console.assert(!isNaN(x) && x != 0);
                feng3d.debuger && console.assert(!isNaN(y) && y != 0);
                feng3d.debuger && console.assert(!isNaN(z) && z != 0);
                if (this._sx != x || this._sy != y || this._sz != z) {
                    this._sx = x;
                    this._sy = y;
                    this._sz = z;
                    this.invalidateScale();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "forwardVector", {
            get: function () {
                return this.matrix3d.forward;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "rightVector", {
            get: function () {
                return this.matrix3d.right;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "upVector", {
            get: function () {
                return this.matrix3d.up;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "backVector", {
            get: function () {
                var director = this.matrix3d.forward;
                director.negate();
                return director;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "leftVector", {
            get: function () {
                var director = this.matrix3d.left;
                director.negate();
                return director;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "downVector", {
            get: function () {
                var director = this.matrix3d.up;
                director.negate();
                return director;
            },
            enumerable: true,
            configurable: true
        });
        Transform.prototype.moveForward = function (distance) {
            this.translateLocal(feng3d.Vector3.Z_AXIS, distance);
        };
        Transform.prototype.moveBackward = function (distance) {
            this.translateLocal(feng3d.Vector3.Z_AXIS, -distance);
        };
        Transform.prototype.moveLeft = function (distance) {
            this.translateLocal(feng3d.Vector3.X_AXIS, -distance);
        };
        Transform.prototype.moveRight = function (distance) {
            this.translateLocal(feng3d.Vector3.X_AXIS, distance);
        };
        Transform.prototype.moveUp = function (distance) {
            this.translateLocal(feng3d.Vector3.Y_AXIS, distance);
        };
        Transform.prototype.moveDown = function (distance) {
            this.translateLocal(feng3d.Vector3.Y_AXIS, -distance);
        };
        Transform.prototype.translate = function (axis, distance) {
            var x = axis.x, y = axis.y, z = axis.z;
            var len = distance / Math.sqrt(x * x + y * y + z * z);
            this._x += x * len;
            this._y += y * len;
            this._z += z * len;
            this.invalidatePosition();
        };
        Transform.prototype.translateLocal = function (axis, distance) {
            var x = axis.x, y = axis.y, z = axis.z;
            var len = distance / Math.sqrt(x * x + y * y + z * z);
            var matrix3d = this.matrix3d.clone();
            matrix3d.prependTranslation(x * len, y * len, z * len);
            this._x = matrix3d.position.x;
            this._y = matrix3d.position.y;
            this._z = matrix3d.position.z;
            this.invalidatePosition();
            this.invalidateSceneTransform();
        };
        Transform.prototype.pitch = function (angle) {
            this.rotate(feng3d.Vector3.X_AXIS, angle);
        };
        Transform.prototype.yaw = function (angle) {
            this.rotate(feng3d.Vector3.Y_AXIS, angle);
        };
        Transform.prototype.roll = function (angle) {
            this.rotate(feng3d.Vector3.Z_AXIS, angle);
        };
        Transform.prototype.rotateTo = function (ax, ay, az) {
            this._rx = ax;
            this._ry = ay;
            this._rz = az;
            this.invalidateRotation();
        };
        /**
         * 绕指定轴旋转，不受位移与缩放影响
         * @param    axis               旋转轴
         * @param    angle              旋转角度
         * @param    pivotPoint         旋转中心点
         *
         */
        Transform.prototype.rotate = function (axis, angle, pivotPoint) {
            //转换位移
            var positionMatrix3d = feng3d.Matrix4x4.fromPosition(this.position.x, this.position.y, this.position.z);
            positionMatrix3d.appendRotation(axis, angle, pivotPoint);
            this.position = positionMatrix3d.position;
            //转换旋转
            var rotationMatrix3d = feng3d.Matrix4x4.fromRotation(this.rx, this.ry, this.rz);
            rotationMatrix3d.appendRotation(axis, angle, pivotPoint);
            var newrotation = rotationMatrix3d.decompose()[1];
            newrotation.scaleNumber(180 / Math.PI);
            var v = Math.round((newrotation.x - this.rx) / 180);
            if (v % 2 != 0) {
                newrotation.x += 180;
                newrotation.y = 180 - newrotation.y;
                newrotation.z += 180;
            }
            //
            var toRound = function (a, b, c) {
                if (c === void 0) { c = 360; }
                return Math.round((b - a) / c) * c + a;
            };
            newrotation.x = toRound(newrotation.x, this.rx);
            newrotation.y = toRound(newrotation.y, this.ry);
            newrotation.z = toRound(newrotation.z, this.rz);
            this.rotation = newrotation;
            this.invalidateSceneTransform();
        };
        Transform.prototype.lookAt = function (target, upAxis) {
            var xAxis = new feng3d.Vector3();
            var yAxis = new feng3d.Vector3();
            var zAxis = new feng3d.Vector3();
            var raw;
            upAxis = upAxis || feng3d.Vector3.Y_AXIS;
            if (!this._matrix3d) {
                this.updateMatrix3D();
            }
            zAxis.x = target.x - this._x;
            zAxis.y = target.y - this._y;
            zAxis.z = target.z - this._z;
            zAxis.normalize();
            xAxis.x = upAxis.y * zAxis.z - upAxis.z * zAxis.y;
            xAxis.y = upAxis.z * zAxis.x - upAxis.x * zAxis.z;
            xAxis.z = upAxis.x * zAxis.y - upAxis.y * zAxis.x;
            xAxis.normalize();
            if (xAxis.length < .05) {
                xAxis.x = upAxis.y;
                xAxis.y = upAxis.x;
                xAxis.z = 0;
                xAxis.normalize();
            }
            yAxis.x = zAxis.y * xAxis.z - zAxis.z * xAxis.y;
            yAxis.y = zAxis.z * xAxis.x - zAxis.x * xAxis.z;
            yAxis.z = zAxis.x * xAxis.y - zAxis.y * xAxis.x;
            raw = feng3d.Matrix4x4.RAW_DATA_CONTAINER;
            raw[0] = this._sx * xAxis.x;
            raw[1] = this._sx * xAxis.y;
            raw[2] = this._sx * xAxis.z;
            raw[3] = 0;
            raw[4] = this._sy * yAxis.x;
            raw[5] = this._sy * yAxis.y;
            raw[6] = this._sy * yAxis.z;
            raw[7] = 0;
            raw[8] = this._sz * zAxis.x;
            raw[9] = this._sz * zAxis.y;
            raw[10] = this._sz * zAxis.z;
            raw[11] = 0;
            raw[12] = this._x;
            raw[13] = this._y;
            raw[14] = this._z;
            raw[15] = 1;
            this._matrix3d.copyRawDataFrom(raw);
            this.matrix3d = this.matrix3d;
            if (zAxis.z < 0) {
                this.ry = (180 - this.ry);
                this.rx -= 180;
                this.rz -= 180;
            }
            this.invalidateSceneTransform();
        };
        Transform.prototype.disposeAsset = function () {
            this.dispose();
        };
        Transform.prototype.invalidateTransform = function () {
            if (!this._matrix3d)
                return;
            this._matrix3d = null;
            this.dispatch("transformChanged", this);
            this.invalidateSceneTransform();
        };
        //------------------------------------------
        // Protected Properties
        //------------------------------------------
        //------------------------------------------
        // Protected Functions
        //------------------------------------------
        Transform.prototype.updateMatrix3D = function () {
            tempComponents[0].init(this._x, this._y, this._z);
            tempComponents[1].init(this._rx * Math.DEG2RAD, this._ry * Math.DEG2RAD, this._rz * Math.DEG2RAD);
            tempComponents[2].init(this._sx, this._sy, this._sz);
            this._matrix3d = new feng3d.Matrix4x4().recompose(tempComponents);
        };
        //------------------------------------------
        // Private Methods
        //------------------------------------------
        Transform.prototype.invalidateRotation = function () {
            if (!this._rotation)
                return;
            this._rotationMatrix3d = null;
            this._localToWorldRotationMatrix = null;
            this.invalidateTransform();
        };
        Transform.prototype.invalidateScale = function () {
            if (!this._scale)
                return;
            this.invalidateTransform();
        };
        Transform.prototype.invalidatePosition = function () {
            if (!this._position)
                return;
            this.invalidateTransform();
        };
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], Transform.prototype, "x", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], Transform.prototype, "y", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], Transform.prototype, "z", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], Transform.prototype, "rx", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], Transform.prototype, "ry", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], Transform.prototype, "rz", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], Transform.prototype, "sx", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], Transform.prototype, "sy", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], Transform.prototype, "sz", null);
        Transform = __decorate([
            feng3d.ov({ component: "OVTransform" })
        ], Transform);
        return Transform;
    }(feng3d.Component));
    feng3d.Transform = Transform;
    var tempComponents = [new feng3d.Vector3(), new feng3d.Vector3(), new feng3d.Vector3()];
    var elements = [new feng3d.Vector3(), new feng3d.Vector3(), new feng3d.Vector3()];
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 游戏对象，场景唯一存在的对象类型
     */
    var GameObject = /** @class */ (function (_super) {
        __extends(GameObject, _super);
        //------------------------------------------
        // Functions
        //------------------------------------------
        /**
         * 构建3D对象
         */
        function GameObject() {
            var _this = _super.call(this) || this;
            _this.__class__ = "feng3d.GameObject";
            _this.assetType = feng3d.AssetType.gameobject;
            _this.renderAtomic = new feng3d.RenderAtomic();
            /**
             * 是否显示
             */
            _this.visible = true;
            /**
             * 自身以及子对象是否支持鼠标拾取
             */
            _this.mouseEnabled = true;
            /**
             * 模型生成的导航网格类型
             */
            _this.navigationArea = -1;
            /**
             * 用户自定义数据
             */
            _this.userData = {};
            //------------------------------------------
            // Protected Properties
            //------------------------------------------
            /**
             * 组件列表
             */
            _this._components = [];
            _this._children = [];
            _this.name = "GameObject";
            _this.addComponent(feng3d.Transform);
            _this.onAll(_this._onAllListener, _this);
            return _this;
        }
        Object.defineProperty(GameObject.prototype, "transform", {
            //------------------------------------------
            // Variables
            //------------------------------------------
            /**
             * 变换
             */
            get: function () {
                if (!this._transform)
                    this._transform = this.getComponent(feng3d.Transform);
                return this._transform;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "parent", {
            get: function () {
                return this._parent;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "children", {
            /**
             * 子对象
             */
            get: function () {
                return this._children.concat();
            },
            set: function (value) {
                if (!value)
                    return;
                for (var i = this._children.length - 1; i >= 0; i--) {
                    this.removeChildAt(i);
                }
                for (var i = 0; i < value.length; i++) {
                    this.addChild(value[i]);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "numChildren", {
            get: function () {
                return this._children.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "numComponents", {
            /**
             * 子组件个数
             */
            get: function () {
                return this._components.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "globalVisible", {
            /**
             * 全局是否可见
             */
            get: function () {
                if (this.parent)
                    return this.visible && this.parent.globalVisible;
                return this.visible;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "scene", {
            get: function () {
                return this._scene;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "components", {
            get: function () {
                return this._components.concat();
            },
            set: function (value) {
                if (!value)
                    return;
                this._transform = null;
                for (var i = 0, n = value.length; i < n; i++) {
                    var compnent = value[i];
                    if (!compnent)
                        continue;
                    if (compnent.single)
                        this.removeComponentsByType(compnent.constructor);
                    this.addComponentAt(value[i], this.numComponents);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 根据名称查找对象
         *
         * @param name 对象名称
         */
        GameObject.prototype.find = function (name) {
            if (this.name == name)
                return this;
            for (var i = 0; i < this._children.length; i++) {
                var target = this._children[i].find(name);
                if (target)
                    return target;
            }
            return null;
        };
        /**
         * 是否包含指定对象
         *
         * @param child 可能的子孙对象
         */
        GameObject.prototype.contains = function (child) {
            var checkitem = child;
            do {
                if (checkitem == this)
                    return true;
                checkitem = checkitem.parent;
            } while (checkitem);
            return false;
        };
        /**
         * 添加子对象
         *
         * @param child 子对象
         */
        GameObject.prototype.addChild = function (child) {
            if (child == null)
                return;
            if (child.parent == this) {
                // 把子对象移动到最后
                var childIndex = this._children.indexOf(child);
                if (childIndex != -1)
                    this._children.splice(childIndex, 1);
                this._children.push(child);
            }
            else {
                if (child.contains(this)) {
                    console.error("无法添加到自身中!");
                    return;
                }
                if (child._parent)
                    child._parent.removeChild(child);
                child._setParent(this);
                this._children.push(child);
                this.dispatch("addChild", child, true);
            }
            return child;
        };
        /**
         * 添加子对象
         *
         * @param childarray 子对象
         */
        GameObject.prototype.addChildren = function () {
            var childarray = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                childarray[_i] = arguments[_i];
            }
            for (var child_key_a in childarray) {
                var child = childarray[child_key_a];
                this.addChild(child);
            }
        };
        /**
         * 移除自身
         */
        GameObject.prototype.remove = function () {
            if (this.parent)
                this.parent.removeChild(this);
        };
        /**
         * 移除所有子对象
         */
        GameObject.prototype.removeChildren = function () {
            for (var i = this.numChildren - 1; i >= 0; i--) {
                this.removeChildAt(i);
            }
        };
        /**
         * 移除子对象
         *
         * @param child 子对象
         */
        GameObject.prototype.removeChild = function (child) {
            if (child == null)
                return;
            var childIndex = this._children.indexOf(child);
            if (childIndex != -1)
                this.removeChildInternal(childIndex, child);
        };
        /**
         * 删除指定位置的子对象
         *
         * @param index 需要删除子对象的所有
         */
        GameObject.prototype.removeChildAt = function (index) {
            var child = this._children[index];
            return this.removeChildInternal(index, child);
        };
        /**
         * 获取指定位置的子对象
         *
         * @param index
         */
        GameObject.prototype.getChildAt = function (index) {
            index = index;
            return this._children[index];
        };
        /**
         * 获取子对象列表（备份）
         */
        GameObject.prototype.getChildren = function () {
            return this._children.concat();
        };
        /**
         * 获取指定位置索引的子组件
         * @param index			位置索引
         * @return				子组件
         */
        GameObject.prototype.getComponentAt = function (index) {
            feng3d.debuger && console.assert(index < this.numComponents, "给出索引超出范围");
            return this._components[index];
        };
        /**
         * 添加指定组件类型到游戏对象
         *
         * @param param 被添加组件
         */
        GameObject.prototype.addComponent = function (param, callback) {
            if (callback === void 0) { callback = null; }
            var component = this.getComponent(param);
            if (component && component.single) {
                // alert(`The compnent ${param["name"]} can't be added because ${this.name} already contains the same component.`);
                return component;
            }
            component = new param();
            this.addComponentAt(component, this._components.length);
            callback && callback(component);
            return component;
        };
        /**
         * 添加脚本
         * @param script   脚本路径
         */
        GameObject.prototype.addScript = function (scriptName) {
            var scriptComponent = new feng3d.ScriptComponent();
            scriptComponent.scriptName = scriptName;
            this.addComponentAt(scriptComponent, this._components.length);
            return scriptComponent;
        };
        /**
         * 获取游戏对象上第一个指定类型的组件，不存在时返回null
         *
         * @param type				类定义
         * @return                  返回指定类型组件
         */
        GameObject.prototype.getComponent = function (type) {
            var component = this.getComponents(type)[0];
            return component;
        };
        /**
         * 获取游戏对象上所有指定类型的组件数组
         *
         * @param type		类定义
         * @return			返回与给出类定义一致的组件
         */
        GameObject.prototype.getComponents = function (type) {
            var filterResult;
            if (!type) {
                filterResult = this._components.concat();
            }
            else {
                filterResult = this._components.filter(function (v) { return v instanceof type; });
            }
            return filterResult;
        };
        /**
         * 从自身与子代（孩子，孩子的孩子，...）游戏对象中获取所有指定类型的组件
         *
         * @param type		类定义
         * @return			返回与给出类定义一致的组件
         */
        GameObject.prototype.getComponentsInChildren = function (type, filter, result) {
            result = result || [];
            var findchildren = true;
            for (var i = 0, n = this._components.length; i < n; i++) {
                var item = this._components[i];
                if (!type) {
                    result.push(item);
                }
                else if (item instanceof type) {
                    if (filter) {
                        var filterresult = filter(item);
                        filterresult && filterresult.value && result.push(item);
                        findchildren = filterresult ? (filterresult && filterresult.findchildren) : false;
                    }
                    else {
                        result.push(item);
                    }
                }
            }
            if (findchildren) {
                for (var i = 0, n = this.numChildren; i < n; i++) {
                    this.getChildAt(i).getComponentsInChildren(type, filter, result);
                }
            }
            return result;
        };
        /**
         * 从父代（父亲，父亲的父亲，...）中获取组件
         *
         * @param type		类定义
         * @return			返回与给出类定义一致的组件
         */
        GameObject.prototype.getComponentsInParents = function (type, result) {
            result = result || [];
            var parent = this.parent;
            while (parent) {
                var compnent = parent.getComponent(type);
                compnent && result.push(compnent);
                parent = parent.parent;
            }
            return result;
        };
        /**
         * 设置子组件的位置
         * @param component				子组件
         * @param index				位置索引
         */
        GameObject.prototype.setComponentIndex = function (component, index) {
            feng3d.debuger && console.assert(index >= 0 && index < this.numComponents, "给出索引超出范围");
            var oldIndex = this._components.indexOf(component);
            feng3d.debuger && console.assert(oldIndex >= 0 && oldIndex < this.numComponents, "子组件不在容器内");
            this._components.splice(oldIndex, 1);
            this._components.splice(index, 0, component);
        };
        /**
         * 设置组件到指定位置
         * @param component		被设置的组件
         * @param index			索引
         */
        GameObject.prototype.setComponentAt = function (component, index) {
            if (this._components[index]) {
                this.removeComponentAt(index);
            }
            this.addComponentAt(component, index);
        };
        /**
         * 移除组件
         * @param component 被移除组件
         */
        GameObject.prototype.removeComponent = function (component) {
            feng3d.debuger && console.assert(this.hasComponent(component), "只能移除在容器中的组件");
            var index = this.getComponentIndex(component);
            this.removeComponentAt(index);
        };
        /**
         * 获取组件在容器的索引位置
         * @param component			查询的组件
         * @return				    组件在容器的索引位置
         */
        GameObject.prototype.getComponentIndex = function (component) {
            feng3d.debuger && console.assert(this._components.indexOf(component) != -1, "组件不在容器中");
            var index = this._components.indexOf(component);
            return index;
        };
        /**
         * 移除组件
         * @param index		要删除的 Component 的子索引。
         */
        GameObject.prototype.removeComponentAt = function (index) {
            feng3d.debuger && console.assert(index >= 0 && index < this.numComponents, "给出索引超出范围");
            var component = this._components.splice(index, 1)[0];
            //派发移除组件事件
            this.dispatch("removeComponent", component, true);
            component.dispose();
            return component;
        };
        /**
         * 交换子组件位置
         * @param index1		第一个子组件的索引位置
         * @param index2		第二个子组件的索引位置
         */
        GameObject.prototype.swapComponentsAt = function (index1, index2) {
            feng3d.debuger && console.assert(index1 >= 0 && index1 < this.numComponents, "第一个子组件的索引位置超出范围");
            feng3d.debuger && console.assert(index2 >= 0 && index2 < this.numComponents, "第二个子组件的索引位置超出范围");
            var temp = this._components[index1];
            this._components[index1] = this._components[index2];
            this._components[index2] = temp;
        };
        /**
         * 交换子组件位置
         * @param a		第一个子组件
         * @param b		第二个子组件
         */
        GameObject.prototype.swapComponents = function (a, b) {
            feng3d.debuger && console.assert(this.hasComponent(a), "第一个子组件不在容器中");
            feng3d.debuger && console.assert(this.hasComponent(b), "第二个子组件不在容器中");
            this.swapComponentsAt(this.getComponentIndex(a), this.getComponentIndex(b));
        };
        /**
         * 移除指定类型组件
         * @param type 组件类型
         */
        GameObject.prototype.removeComponentsByType = function (type) {
            var removeComponents = [];
            for (var i = this._components.length - 1; i >= 0; i--) {
                if (this._components[i].constructor == type)
                    removeComponents.push(this.removeComponentAt(i));
            }
            return removeComponents;
        };
        Object.defineProperty(GameObject.prototype, "worldBounds", {
            /**
             * 世界包围盒
             */
            get: function () {
                var model = this.getComponent(feng3d.Model);
                var box = model ? model.selfWorldBounds : new feng3d.AABB(this.transform.scenePosition, this.transform.scenePosition);
                this.children.forEach(function (element) {
                    var ebox = element.worldBounds;
                    box.union(ebox);
                });
                return box;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 监听对象的所有事件并且传播到所有组件中
         */
        GameObject.prototype._onAllListener = function (e) {
            this.components.forEach(function (element) {
                element.dispatchEvent(e);
            });
        };
        /**
         * 销毁
         */
        GameObject.prototype.dispose = function () {
            if (this.parent)
                this.parent.removeChild(this);
            for (var i = this._children.length - 1; i >= 0; i--) {
                this.removeChildAt(i);
            }
            for (var i = this._components.length - 1; i >= 0; i--) {
                this.removeComponentAt(i);
            }
            _super.prototype.dispose.call(this);
        };
        GameObject.prototype.disposeWithChildren = function () {
            this.dispose();
            while (this.numChildren > 0)
                this.getChildAt(0).dispose();
        };
        Object.defineProperty(GameObject.prototype, "isSelfLoaded", {
            /**
             * 是否加载完成
             */
            get: function () {
                var model = this.getComponent(feng3d.Model);
                if (model)
                    return model.isLoaded;
                return true;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 已加载完成或者加载完成时立即调用
         * @param callback 完成回调
         */
        GameObject.prototype.onSelfLoadCompleted = function (callback) {
            if (this.isSelfLoaded) {
                callback();
                return;
            }
            var model = this.getComponent(feng3d.Model);
            if (model) {
                model.onLoadCompleted(callback);
            }
            else
                callback();
        };
        Object.defineProperty(GameObject.prototype, "isLoaded", {
            /**
             * 是否加载完成
             */
            get: function () {
                if (!this.isSelfLoaded)
                    return false;
                for (var i = 0; i < this.children.length; i++) {
                    var element = this.children[i];
                    if (!element.isLoaded)
                        return false;
                }
                return true;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 已加载完成或者加载完成时立即调用
         * @param callback 完成回调
         */
        GameObject.prototype.onLoadCompleted = function (callback) {
            var loadingNum = 0;
            if (!this.isSelfLoaded) {
                loadingNum++;
                this.onSelfLoadCompleted(function () {
                    loadingNum--;
                    if (loadingNum == 0)
                        callback();
                });
            }
            for (var i = 0; i < this.children.length; i++) {
                var element = this.children[i];
                if (!element.isLoaded) {
                    loadingNum++;
                    element.onLoadCompleted(function () {
                        loadingNum--;
                        if (loadingNum == 0)
                            callback();
                    });
                }
            }
            if (loadingNum == 0)
                callback();
        };
        /**
         * 渲染前执行函数
         *
         * 可用于渲染前收集渲染数据，或者更新显示效果等
         *
         * @param gl
         * @param renderAtomic
         * @param scene3d
         * @param camera
         */
        GameObject.prototype.beforeRender = function (gl, renderAtomic, scene3d, camera) {
            this._components.forEach(function (element) {
                element.beforeRender(gl, renderAtomic, scene3d, camera);
            });
        };
        //------------------------------------------
        // Static Functions
        //------------------------------------------
        /**
         * 查找指定名称的游戏对象
         *
         * @param name
         */
        GameObject.find = function (name) {
            var gameobjects = feng3d.Feng3dObject.getObjects(GameObject);
            var result = gameobjects.filter(function (v) { return !v.disposed && (v.name == name); });
            return result[0];
        };
        //------------------------------------------
        // Protected Functions
        //------------------------------------------
        //------------------------------------------
        // Private Properties
        //------------------------------------------
        //------------------------------------------
        // Private Methods
        //------------------------------------------
        GameObject.prototype._setParent = function (value) {
            this._parent = value;
            this.updateScene();
            this.transform["invalidateSceneTransform"]();
        };
        GameObject.prototype.updateScene = function () {
            var newScene = this._parent ? this._parent._scene : null;
            if (this._scene == newScene)
                return;
            if (this._scene) {
                this.dispatch("removedFromScene", this);
            }
            this._scene = newScene;
            if (this._scene) {
                this.dispatch("addedToScene", this);
            }
            this.updateChildrenScene();
        };
        GameObject.prototype.updateChildrenScene = function () {
            for (var i = 0, n = this._children.length; i < n; i++) {
                this._children[i].updateScene();
            }
        };
        GameObject.prototype.removeChildInternal = function (childIndex, child) {
            childIndex = childIndex;
            this._children.splice(childIndex, 1);
            child._setParent(null);
            this.dispatch("removeChild", child, true);
        };
        /**
         * 判断是否拥有组件
         * @param com	被检测的组件
         * @return		true：拥有该组件；false：不拥有该组件。
         */
        GameObject.prototype.hasComponent = function (com) {
            return this._components.indexOf(com) != -1;
        };
        /**
         * 添加组件到指定位置
         * @param component		被添加的组件
         * @param index			插入的位置
         */
        GameObject.prototype.addComponentAt = function (component, index) {
            if (component == null)
                return;
            feng3d.debuger && console.assert(index >= 0 && index <= this.numComponents, "给出索引超出范围");
            if (this.hasComponent(component)) {
                index = Math.min(index, this._components.length - 1);
                this.setComponentIndex(component, index);
                return;
            }
            //组件唯一时移除同类型的组件
            if (component.single)
                this.removeComponentsByType(component.constructor);
            this._components.splice(index, 0, component);
            component.setGameObject(this);
            component.init();
            //派发添加组件事件
            this.dispatch("addComponent", component, true);
        };
        __decorate([
            feng3d.serialize
        ], GameObject.prototype, "prefabId", void 0);
        __decorate([
            feng3d.serialize
        ], GameObject.prototype, "assetId", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ component: "OAVGameObjectName" })
        ], GameObject.prototype, "name", void 0);
        __decorate([
            feng3d.serialize
        ], GameObject.prototype, "visible", void 0);
        __decorate([
            feng3d.serialize
        ], GameObject.prototype, "mouseEnabled", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], GameObject.prototype, "navigationArea", void 0);
        __decorate([
            feng3d.serialize
        ], GameObject.prototype, "children", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ component: "OAVComponentList" })
        ], GameObject.prototype, "components", null);
        return GameObject;
    }(feng3d.AssetData));
    feng3d.GameObject = GameObject;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3D视图
     */
    var Engine = /** @class */ (function (_super) {
        __extends(Engine, _super);
        /**
         * 构建3D视图
         * @param canvas    画布
         * @param scene     3D场景
         * @param camera    摄像机
         */
        function Engine(canvas, scene, camera) {
            var _this = _super.call(this) || this;
            _this.contextLost = false;
            if (!canvas) {
                canvas = document.createElement("canvas");
                canvas.id = "glcanvas";
                canvas.style.position = "fixed";
                canvas.style.left = "0px";
                canvas.style.top = "0px";
                canvas.style.width = "100%";
                canvas.style.height = "100%";
                document.body.appendChild(canvas);
            }
            feng3d.debuger && console.assert(canvas instanceof HTMLCanvasElement, "canvas\u53C2\u6570\u5FC5\u987B\u4E3A HTMLCanvasElement \u7C7B\u578B\uFF01");
            _this.canvas = canvas;
            canvas.addEventListener("webglcontextlost", function (event) {
                event.preventDefault();
                _this.contextLost = true;
                // #ifdef DEBUG
                console.log('pc.GraphicsDevice: WebGL context lost.');
                // #endif
            }, false);
            canvas.addEventListener("webglcontextrestored", function () {
                _this.contextLost = false;
                // #ifdef DEBUG
                console.log('pc.GraphicsDevice: WebGL context restored.');
                // #endif
            }, false);
            _this.scene = scene || feng3d.serialization.setValue(new feng3d.GameObject(), { name: "scene" }).addComponent(feng3d.Scene3D);
            _this.camera = camera;
            _this.start();
            _this.mouse3DManager = new feng3d.Mouse3DManager(new feng3d.WindowMouseInput(), function () { return _this.viewRect; });
            return _this;
        }
        Object.defineProperty(Engine.prototype, "camera", {
            /**
             * 摄像机
             */
            get: function () {
                if (!this._camera) {
                    var cameras = this.scene.getComponentsInChildren(feng3d.Camera);
                    if (cameras.length == 0) {
                        this._camera = feng3d.serialization.setValue(new feng3d.GameObject(), { name: "defaultCamera" }).addComponent(feng3d.Camera);
                        this.scene.gameObject.addChild(this._camera.gameObject);
                    }
                    else {
                        this._camera = cameras[0];
                    }
                }
                return this._camera;
            },
            set: function (v) {
                this._camera = v;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Engine.prototype, "root", {
            /**
             * 根结点
             */
            get: function () {
                return this.scene.gameObject;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Engine.prototype, "gl", {
            get: function () {
                if (!this.canvas.gl)
                    this.canvas.gl = feng3d.GL.getGL(this.canvas);
                return this.canvas.gl;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Engine.prototype, "mousePos", {
            /**
             * 鼠标在3D视图中的位置
             */
            get: function () {
                return new feng3d.Vector2(feng3d.windowEventProxy.clientX - this.canvas.clientLeft, feng3d.windowEventProxy.clientY - this.canvas.clientTop);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Engine.prototype, "viewRect", {
            get: function () {
                var clientRect = this.canvas.getBoundingClientRect();
                var viewRect = new feng3d.Rectangle(clientRect.left, clientRect.top, clientRect.width, clientRect.height);
                return viewRect;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 修改canvas尺寸
         * @param width 宽度
         * @param height 高度
         */
        Engine.prototype.setSize = function (width, height) {
            this.canvas.width = width;
            this.canvas.height = height;
            this.canvas.style.width = width + 'px';
            this.canvas.style.height = height + 'px';
        };
        Engine.prototype.start = function () {
            feng3d.ticker.onframe(this.update, this);
        };
        Engine.prototype.stop = function () {
            feng3d.ticker.offframe(this.update, this);
        };
        Engine.prototype.update = function (interval) {
            this.render(interval);
            this.mouse3DManager.selectedGameObject = this.selectedObject;
        };
        /**
         * 绘制场景
         */
        Engine.prototype.render = function (interval) {
            if (!this.scene)
                return;
            if (this.contextLost)
                return;
            this.scene.update(interval);
            this.canvas.width = this.canvas.clientWidth;
            this.canvas.height = this.canvas.clientHeight;
            if (this.canvas.width * this.canvas.height == 0)
                return;
            var viewRect = this.viewRect;
            this.camera.lens.aspect = viewRect.width / viewRect.height;
            // 设置鼠标射线
            this.scene.mouseRay3D = this.getMouseRay3D();
            this.scene.camera = this.camera;
            // 默认渲染
            this.gl.clearColor(this.scene.background.r, this.scene.background.g, this.scene.background.b, this.scene.background.a);
            this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
            this.gl.enable(this.gl.DEPTH_TEST);
            //鼠标拾取渲染
            this.selectedObject = this.mouse3DManager.pick(this, this.scene, this.camera);
            //绘制阴影图
            feng3d.shadowRenderer.draw(this.gl, this.scene, this.camera);
            feng3d.skyboxRenderer.draw(this.gl, this.scene, this.camera);
            // 默认渲染
            feng3d.forwardRenderer.draw(this.gl, this.scene, this.camera);
            feng3d.outlineRenderer.draw(this.gl, this.scene, this.camera);
            feng3d.wireframeRenderer.draw(this.gl, this.scene, this.camera);
        };
        /**
         * 屏幕坐标转GPU坐标
         * @param screenPos 屏幕坐标 (x: [0-width], y: [0 - height])
         * @return GPU坐标 (x: [-1, 1], y: [-1, 1])
         */
        Engine.prototype.screenToGpuPosition = function (screenPos) {
            var gpuPos = new feng3d.Vector2();
            gpuPos.x = (screenPos.x * 2 - this.viewRect.width) / this.viewRect.width;
            // 屏幕坐标与gpu中使用的坐标Y轴方向相反
            gpuPos.y = -(screenPos.y * 2 - this.viewRect.height) / this.viewRect.height;
            return gpuPos;
        };
        /**
         * 投影坐标（世界坐标转换为3D视图坐标）
         * @param point3d 世界坐标
         * @return 屏幕的绝对坐标
         */
        Engine.prototype.project = function (point3d) {
            var v = this.camera.project(point3d);
            v.x = (v.x + 1.0) * this.viewRect.width / 2.0;
            v.y = (1.0 - v.y) * this.viewRect.height / 2.0;
            return v;
        };
        /**
         * 屏幕坐标投影到场景坐标
         * @param nX 屏幕坐标X ([0-width])
         * @param nY 屏幕坐标Y ([0-height])
         * @param sZ 到屏幕的距离
         * @param v 场景坐标（输出）
         * @return 场景坐标
         */
        Engine.prototype.unproject = function (sX, sY, sZ, v) {
            if (v === void 0) { v = new feng3d.Vector3(); }
            var gpuPos = this.screenToGpuPosition(new feng3d.Vector2(sX, sY));
            return this.camera.unproject(gpuPos.x, gpuPos.y, sZ, v);
        };
        /**
         * 获取单位像素在指定深度映射的大小
         * @param   depth   深度
         */
        Engine.prototype.getScaleByDepth = function (depth, dir) {
            if (dir === void 0) { dir = new feng3d.Vector2(0, 1); }
            var scale = this.camera.getScaleByDepth(depth, dir);
            scale = scale / new feng3d.Vector2(this.viewRect.width * dir.x, this.viewRect.height * dir.y).length;
            return scale;
        };
        /**
         * 获取鼠标射线（与鼠标重叠的摄像机射线）
         */
        Engine.prototype.getMouseRay3D = function () {
            var gpuPos = this.screenToGpuPosition(new feng3d.Vector2(feng3d.windowEventProxy.clientX - this.viewRect.x, feng3d.windowEventProxy.clientY - this.viewRect.y));
            return this.camera.getRay3D(gpuPos.x, gpuPos.y);
        };
        /**
         * 获取屏幕区域内所有游戏对象
         * @param start 起点
         * @param end 终点
         */
        Engine.prototype.getObjectsInGlobalArea = function (start, end) {
            var _this = this;
            var s = this.viewRect.clampPoint(start);
            var e = this.viewRect.clampPoint(end);
            s.sub(this.viewRect.topLeft);
            e.sub(this.viewRect.topLeft);
            var min = s.clone().min(e);
            var max = s.clone().max(e);
            var rect = new feng3d.Rectangle(min.x, min.y, max.x - min.x, max.y - min.y);
            //
            var gs = this.scene.getComponentsInChildren(feng3d.Transform).filter(function (t) {
                if (t == _this.scene.transform)
                    return false;
                var m = t.getComponent(feng3d.Model);
                if (m) {
                    var include = m.selfWorldBounds.toPoints().every(function (pos) {
                        var p = _this.project(pos);
                        return rect.contains(p.x, p.y);
                    });
                    return include;
                }
                var p = _this.project(t.scenePosition);
                return rect.contains(p.x, p.y);
            }).map(function (t) { return t.gameObject; });
            return gs;
        };
        return Engine;
    }(feng3d.Feng3dObject));
    feng3d.Engine = Engine;
})(feng3d || (feng3d = {}));
// var viewRect0 = { x: 0, y: 0, w: 400, h: 300 };
var feng3d;
(function (feng3d) {
    var HoldSizeComponent = /** @class */ (function (_super) {
        __extends(HoldSizeComponent, _super);
        function HoldSizeComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.__class__ = "feng3d.HoldSizeComponent";
            _this._holdSize = 1;
            return _this;
        }
        Object.defineProperty(HoldSizeComponent.prototype, "holdSize", {
            /**
             * 保持缩放尺寸
             */
            get: function () {
                return this._holdSize;
            },
            set: function (v) {
                if (this._holdSize == v)
                    return;
                this._holdSize = v;
                this.onHoldSizeChanged();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoldSizeComponent.prototype, "camera", {
            /**
             * 相机
             */
            get: function () {
                return this._camera;
            },
            set: function (v) {
                if (this._camera == v)
                    return;
                if (this._camera)
                    this._camera.off("scenetransformChanged", this.invalidateSceneTransform, this);
                this._camera = v;
                if (this._camera)
                    this._camera.on("scenetransformChanged", this.invalidateSceneTransform, this);
                this.invalidateSceneTransform();
            },
            enumerable: true,
            configurable: true
        });
        HoldSizeComponent.prototype.init = function () {
            this.transform.on("updateLocalToWorldMatrix", this.updateLocalToWorldMatrix, this);
        };
        HoldSizeComponent.prototype.dispose = function () {
            this.camera = null;
            this.transform.off("updateLocalToWorldMatrix", this.updateLocalToWorldMatrix, this);
            _super.prototype.dispose.call(this);
        };
        HoldSizeComponent.prototype.onHoldSizeChanged = function () {
            this.invalidateSceneTransform();
        };
        HoldSizeComponent.prototype.invalidateSceneTransform = function () {
            if (this._gameObject)
                this.transform["invalidateSceneTransform"]();
        };
        HoldSizeComponent.prototype.updateLocalToWorldMatrix = function () {
            var _localToWorldMatrix = this.transform["_localToWorldMatrix"];
            if (this.holdSize && this.camera && _localToWorldMatrix) {
                var depthScale = this.getDepthScale(this.camera);
                var vec = _localToWorldMatrix.decompose();
                vec[2].scaleNumber(depthScale * this.holdSize);
                _localToWorldMatrix.recompose(vec);
                feng3d.debuger && console.assert(!isNaN(_localToWorldMatrix.rawData[0]));
            }
        };
        HoldSizeComponent.prototype.getDepthScale = function (camera) {
            var cameraTranform = camera.transform.localToWorldMatrix;
            var distance = this.transform.scenePosition.subTo(cameraTranform.position);
            if (distance.length == 0)
                distance.x = 1;
            var depth = distance.dot(cameraTranform.forward);
            var scale = camera.getScaleByDepth(depth);
            //限制在放大缩小100倍之间，否则容易出现矩阵不可逆问题
            scale = Math.max(Math.min(100, scale), 0.01);
            return scale;
        };
        __decorate([
            feng3d.oav()
        ], HoldSizeComponent.prototype, "holdSize", null);
        __decorate([
            feng3d.oav()
        ], HoldSizeComponent.prototype, "camera", null);
        return HoldSizeComponent;
    }(feng3d.Component));
    feng3d.HoldSizeComponent = HoldSizeComponent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var BillboardComponent = /** @class */ (function (_super) {
        __extends(BillboardComponent, _super);
        function BillboardComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.__class__ = "feng3d.BillboardComponent";
            return _this;
        }
        Object.defineProperty(BillboardComponent.prototype, "camera", {
            /**
             * 相机
             */
            get: function () {
                return this._camera;
            },
            set: function (v) {
                if (this._camera == v)
                    return;
                if (this._camera)
                    this._camera.off("scenetransformChanged", this.invalidHoldSizeMatrix, this);
                this._camera = v;
                if (this._camera)
                    this._camera.on("scenetransformChanged", this.invalidHoldSizeMatrix, this);
                this.invalidHoldSizeMatrix();
            },
            enumerable: true,
            configurable: true
        });
        BillboardComponent.prototype.init = function () {
            _super.prototype.init.call(this);
            this.transform.on("updateLocalToWorldMatrix", this.updateLocalToWorldMatrix, this);
            this.invalidHoldSizeMatrix();
        };
        BillboardComponent.prototype.invalidHoldSizeMatrix = function () {
            if (this._gameObject)
                this.transform["invalidateSceneTransform"]();
        };
        BillboardComponent.prototype.updateLocalToWorldMatrix = function () {
            var _localToWorldMatrix = this.transform["_localToWorldMatrix"];
            if (_localToWorldMatrix && this.camera) {
                var camera = this.camera;
                var cameraPos = camera.transform.scenePosition;
                var yAxis = camera.transform.localToWorldMatrix.up;
                _localToWorldMatrix.lookAt(cameraPos, yAxis);
            }
        };
        BillboardComponent.prototype.dispose = function () {
            this.camera = null;
            this.transform.off("updateLocalToWorldMatrix", this.updateLocalToWorldMatrix, this);
            _super.prototype.dispose.call(this);
        };
        __decorate([
            feng3d.oav()
        ], BillboardComponent.prototype, "camera", null);
        return BillboardComponent;
    }(feng3d.Component));
    feng3d.BillboardComponent = BillboardComponent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 线框组件，将会对拥有该组件的对象绘制线框
     */
    var WireframeComponent = /** @class */ (function (_super) {
        __extends(WireframeComponent, _super);
        function WireframeComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.__class__ = "feng3d.WireframeComponent";
            _this.color = new feng3d.Color4(125 / 255, 176 / 255, 250 / 255);
            return _this;
        }
        __decorate([
            feng3d.oav()
        ], WireframeComponent.prototype, "color", void 0);
        return WireframeComponent;
    }(feng3d.Component));
    feng3d.WireframeComponent = WireframeComponent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 参考
     */
    var CartoonComponent = /** @class */ (function (_super) {
        __extends(CartoonComponent, _super);
        function CartoonComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.__class__ = "feng3d.CartoonComponent";
            _this.outlineSize = 1;
            _this.outlineColor = new feng3d.Color4(0.2, 0.2, 0.2, 1.0);
            _this.outlineMorphFactor = 0.0;
            /**
             * 半兰伯特值diff，分段值 4个(0.0,1.0)
             */
            _this.diffuseSegment = new feng3d.Vector4(0.1, 0.3, 0.6, 1.0);
            /**
             * 半兰伯特值diff，替换分段值 4个(0.0,1.0)
             */
            _this.diffuseSegmentValue = new feng3d.Vector4(0.1, 0.3, 0.6, 1.0);
            _this.specularSegment = 0.5;
            _this._cartoon_Anti_aliasing = false;
            return _this;
        }
        Object.defineProperty(CartoonComponent.prototype, "cartoon_Anti_aliasing", {
            get: function () {
                return this._cartoon_Anti_aliasing;
            },
            set: function (value) {
                this._cartoon_Anti_aliasing = value;
            },
            enumerable: true,
            configurable: true
        });
        CartoonComponent.prototype.beforeRender = function (gl, renderAtomic, scene3d, camera) {
            renderAtomic.uniforms.u_diffuseSegment = this.diffuseSegment;
            renderAtomic.uniforms.u_diffuseSegmentValue = this.diffuseSegmentValue;
            renderAtomic.uniforms.u_specularSegment = this.specularSegment;
            //
            renderAtomic.uniforms.u_outlineSize = this.outlineSize;
            renderAtomic.uniforms.u_outlineColor = this.outlineColor;
            renderAtomic.uniforms.u_outlineMorphFactor = this.outlineMorphFactor;
        };
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], CartoonComponent.prototype, "outlineSize", void 0);
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], CartoonComponent.prototype, "outlineColor", void 0);
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], CartoonComponent.prototype, "outlineMorphFactor", void 0);
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], CartoonComponent.prototype, "diffuseSegment", void 0);
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], CartoonComponent.prototype, "diffuseSegmentValue", void 0);
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], CartoonComponent.prototype, "specularSegment", void 0);
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], CartoonComponent.prototype, "cartoon_Anti_aliasing", null);
        return CartoonComponent;
    }(feng3d.Component));
    feng3d.CartoonComponent = CartoonComponent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var OutLineComponent = /** @class */ (function (_super) {
        __extends(OutLineComponent, _super);
        function OutLineComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.__class__ = "feng3d.OutLineComponent";
            _this.size = 1;
            _this.color = new feng3d.Color4(0.2, 0.2, 0.2, 1.0);
            _this.outlineMorphFactor = 0.0;
            return _this;
        }
        OutLineComponent.prototype.beforeRender = function (gl, renderAtomic, scene3d, camera) {
            renderAtomic.uniforms.u_outlineSize = this.size;
            renderAtomic.uniforms.u_outlineColor = this.color;
            renderAtomic.uniforms.u_outlineMorphFactor = this.outlineMorphFactor;
        };
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], OutLineComponent.prototype, "size", void 0);
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], OutLineComponent.prototype, "color", void 0);
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], OutLineComponent.prototype, "outlineMorphFactor", void 0);
        return OutLineComponent;
    }(feng3d.Component));
    feng3d.OutLineComponent = OutLineComponent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var Model = /** @class */ (function (_super) {
        __extends(Model, _super);
        function Model() {
            var _this = _super.call(this) || this;
            _this._geometry = feng3d.Geometry.cube;
            _this._material = feng3d.Material.default;
            _this.castShadows = true;
            _this.receiveShadows = true;
            _this._lightPicker = new feng3d.LightPicker(_this);
            return _this;
        }
        Object.defineProperty(Model.prototype, "single", {
            get: function () { return true; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Model.prototype, "geometry", {
            /**
             * 几何体
             */
            get: function () {
                return this._geometry;
            },
            set: function (v) {
                if (this._geometry == v)
                    return;
                if (this._geometry) {
                    this._geometry.off("boundsInvalid", this.onBoundsInvalid, this);
                }
                this._geometry = v;
                if (this._geometry) {
                    this._geometry.on("boundsInvalid", this.onBoundsInvalid, this);
                }
                this.geometry = this.geometry || feng3d.Geometry.cube;
                this.onBoundsInvalid();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Model.prototype, "material", {
            /**
             * 材质
             */
            get: function () {
                return this._material;
            },
            set: function (v) {
                this._material = v;
                this._material = this._material || feng3d.Material.default;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Model.prototype, "selfLocalBounds", {
            /**
             * 自身局部包围盒
             */
            get: function () {
                if (!this._selfLocalBounds)
                    this.updateBounds();
                return this._selfLocalBounds;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Model.prototype, "selfWorldBounds", {
            /**
             * 自身世界包围盒
             */
            get: function () {
                if (!this._selfWorldBounds)
                    this.updateWorldBounds();
                return this._selfWorldBounds;
            },
            enumerable: true,
            configurable: true
        });
        Model.prototype.init = function () {
            _super.prototype.init.call(this);
            this.on("scenetransformChanged", this.onScenetransformChanged, this);
        };
        Model.prototype.beforeRender = function (gl, renderAtomic, scene3d, camera) {
            //
            this.geometry.beforeRender(renderAtomic);
            this.material.beforeRender(renderAtomic);
            this._lightPicker.beforeRender(renderAtomic);
        };
        /**
          * 判断射线是否穿过对象
          * @param ray3D
          * @return
          */
        Model.prototype.isIntersectingRay = function (ray3D) {
            var localNormal = new feng3d.Vector3();
            //转换到当前实体坐标系空间
            var localRay = new feng3d.Ray3D();
            this.transform.worldToLocalMatrix.transformVector(ray3D.position, localRay.position);
            this.transform.worldToLocalMatrix.deltaTransformVector(ray3D.direction, localRay.direction);
            //检测射线与边界的碰撞
            var rayEntryDistance = this.selfLocalBounds.rayIntersection(localRay.position, localRay.direction, localNormal);
            if (rayEntryDistance < 0)
                return null;
            //保存碰撞数据
            var pickingCollisionVO = {
                gameObject: this.gameObject,
                localNormal: localNormal,
                localRay: localRay,
                rayEntryDistance: rayEntryDistance,
                ray3D: ray3D,
                rayOriginIsInsideBounds: rayEntryDistance == 0,
                geometry: this.geometry,
                cullFace: this.material.renderParams.cullFace,
            };
            return pickingCollisionVO;
        };
        Object.defineProperty(Model.prototype, "isLoaded", {
            /**
             * 是否加载完成
             */
            get: function () {
                return this.material.isLoaded;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 已加载完成或者加载完成时立即调用
         * @param callback 完成回调
         */
        Model.prototype.onLoadCompleted = function (callback) {
            if (this.isLoaded)
                callback();
            this.material.onLoadCompleted(callback);
        };
        /**
         * 销毁
         */
        Model.prototype.dispose = function () {
            this.geometry = null;
            this.material = null;
            _super.prototype.dispose.call(this);
        };
        Model.prototype.onScenetransformChanged = function () {
            this._selfWorldBounds = null;
        };
        /**
         * 更新世界边界
         */
        Model.prototype.updateWorldBounds = function () {
            this._selfWorldBounds = this.selfLocalBounds.applyMatrix3DTo(this.transform.localToWorldMatrix);
        };
        /**
         * 处理包围盒变换事件
         */
        Model.prototype.onBoundsInvalid = function () {
            this._selfLocalBounds = null;
            this._selfWorldBounds = null;
        };
        /**
         * @inheritDoc
         */
        Model.prototype.updateBounds = function () {
            this._selfLocalBounds = this.geometry.bounding;
        };
        __decorate([
            feng3d.oav({ component: "OAVPick", tooltip: "几何体，提供模型以形状", componentParam: { accepttype: "geometry", datatype: "geometry" } }),
            feng3d.serialize
        ], Model.prototype, "geometry", null);
        __decorate([
            feng3d.oav({ component: "OAVPick", tooltip: "材质，提供模型以皮肤", componentParam: { accepttype: "material", datatype: "material" } }),
            feng3d.serialize
        ], Model.prototype, "material", null);
        __decorate([
            feng3d.oav({ tooltip: "是否投射阴影" }),
            feng3d.serialize
        ], Model.prototype, "castShadows", void 0);
        __decorate([
            feng3d.oav({ tooltip: "是否接受阴影" }),
            feng3d.serialize
        ], Model.prototype, "receiveShadows", void 0);
        return Model;
    }(feng3d.Behaviour));
    feng3d.Model = Model;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var MeshModel = /** @class */ (function (_super) {
        __extends(MeshModel, _super);
        function MeshModel() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.__class__ = "feng3d.MeshModel";
            return _this;
        }
        return MeshModel;
    }(feng3d.Model));
    feng3d.MeshModel = MeshModel;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3d对象脚本
     */
    var ScriptComponent = /** @class */ (function (_super) {
        __extends(ScriptComponent, _super);
        function ScriptComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.runEnvironment = feng3d.RunEnvironment.feng3d;
            _this._invalid = true;
            _this.scriptInit = false;
            return _this;
        }
        Object.defineProperty(ScriptComponent.prototype, "scriptName", {
            get: function () {
                return this._scriptName;
            },
            set: function (v) {
                if (this._scriptName == v)
                    return;
                this._scriptName = v;
                this.invalidateScriptInstance();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ScriptComponent.prototype, "scriptInstance", {
            /**
             * 脚本对象
             */
            get: function () {
                if (this._invalid)
                    this.updateScriptInstance();
                return this._scriptInstance;
            },
            enumerable: true,
            configurable: true
        });
        ScriptComponent.prototype.init = function () {
            _super.prototype.init.call(this);
            feng3d.dispatcher.on("asset.scriptChanged", this.invalidateScriptInstance, this);
        };
        ScriptComponent.prototype.updateScriptInstance = function () {
            var oldInstance = this._scriptInstance;
            this._scriptInstance = null;
            if (!this.scriptName)
                return;
            var cls = feng3d.classUtils.getDefinitionByName(this.scriptName, false);
            if (cls)
                this._scriptInstance = new cls();
            else
                console.warn("\u65E0\u6CD5\u521D\u59CB\u5316\u811A\u672C " + this.scriptName);
            this.scriptInit = false;
            // 移除旧实例
            if (oldInstance) {
                // 如果两个类定义名称相同，则保留上个对象数据
                if (feng3d.classUtils.getQualifiedClassName(oldInstance) == this.scriptName) {
                    feng3d.serialization.setValue(this._scriptInstance, oldInstance);
                }
                oldInstance.component = null;
                oldInstance.dispose();
            }
            this._invalid = false;
        };
        ScriptComponent.prototype.invalidateScriptInstance = function () {
            this._invalid = true;
        };
        /**
         * 每帧执行
         */
        ScriptComponent.prototype.update = function () {
            if (this.scriptInstance && !this.scriptInit) {
                this.scriptInstance.component = this;
                this.scriptInstance.init();
                this.scriptInit = true;
            }
            this.scriptInstance && this.scriptInstance.update();
        };
        /**
         * 销毁
         */
        ScriptComponent.prototype.dispose = function () {
            this.enabled = false;
            if (this._scriptInstance) {
                this._scriptInstance.component = null;
                this._scriptInstance.dispose();
                this._scriptInstance = null;
            }
            _super.prototype.dispose.call(this);
            feng3d.dispatcher.off("asset.scriptChanged", this.invalidateScriptInstance, this);
        };
        __decorate([
            feng3d.serialize,
            feng3d.oav({ component: "OAVPick", componentParam: { accepttype: "file_script" } })
        ], ScriptComponent.prototype, "scriptName", null);
        __decorate([
            feng3d.serialize
        ], ScriptComponent.prototype, "scriptInstance", null);
        return ScriptComponent;
    }(feng3d.Behaviour));
    feng3d.ScriptComponent = ScriptComponent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3d对象脚本
     */
    var Script = /** @class */ (function () {
        function Script() {
        }
        Object.defineProperty(Script.prototype, "gameObject", {
            /**
             * The game object this component is attached to. A component is always attached to a game object.
             */
            get: function () {
                return this.component.gameObject;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Script.prototype, "transform", {
            /**
             * The Transform attached to this GameObject (null if there is none attached).
             */
            get: function () {
                return this.gameObject.transform;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Use this for initialization
         */
        Script.prototype.init = function () {
        };
        /**
         * Update is called once per frame
         * 每帧执行一次
         */
        Script.prototype.update = function () {
        };
        /**
         * 销毁
         */
        Script.prototype.dispose = function () {
        };
        return Script;
    }());
    feng3d.Script = Script;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 3D场景
     */
    var Scene3D = /** @class */ (function (_super) {
        __extends(Scene3D, _super);
        function Scene3D() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.__class__ = "feng3d.Scene3D";
            /**
             * 背景颜色
             */
            _this.background = new feng3d.Color4(0, 0, 0, 1);
            /**
             * 环境光强度
             */
            _this.ambientColor = new feng3d.Color4();
            /**
             * 重力加速度
             */
            _this.gravity = new feng3d.Vector3(0, -9.82, 0);
            /**
             * 指定所运行环境
             *
             * 控制运行符合指定环境场景中所有 Behaviour.update 方法
             *
             * 用于处理某些脚本只在在feng3d引擎或者编辑器中运行的问题。例如 FPSController 默认只在feng3d中运行，在编辑器模式下不会运行。
             */
            _this.runEnvironment = feng3d.RunEnvironment.feng3d;
            _this._pickMap = new Map();
            return _this;
        }
        /**
         * 构造3D场景
         */
        Scene3D.prototype.init = function () {
            var _this = this;
            _super.prototype.init.call(this);
            this.transform.hideFlags = this.transform.hideFlags | feng3d.HideFlags.Hide;
            this.gameObject.hideFlags = this.gameObject.hideFlags | feng3d.HideFlags.DontTransform;
            //
            this._gameObject["_scene"] = this;
            this._gameObject["updateChildrenScene"]();
            this.world = new CANNON.World();
            this.world.gravity = new CANNON.Vec3(this.gravity.x, this.gravity.y, this.gravity.z);
            var bodys = this.getComponentsInChildren(feng3d.Rigidbody).map(function (c) { return c.body; });
            bodys.forEach(function (v) {
                _this.world.addBody(v);
            });
            //
            this.on("addChild", this.onAddChild, this);
            this.on("removeChild", this.onRemoveChild, this);
            this.on("addComponent", this.onAddComponent, this);
            this.on("removeComponent", this.onRemovedComponent, this);
        };
        Scene3D.prototype.onAddComponent = function (e) {
            if (e.data instanceof feng3d.Rigidbody) {
                this.world.addBody(e.data.body);
            }
        };
        Scene3D.prototype.onRemovedComponent = function (e) {
            if (e.data instanceof feng3d.Rigidbody) {
                this.world.removeBody(e.data.body);
            }
        };
        Scene3D.prototype.onAddChild = function (e) {
            var bodyComponent = e.data.getComponent(feng3d.Rigidbody);
            if (bodyComponent) {
                this.world.addBody(bodyComponent.body);
            }
        };
        Scene3D.prototype.onRemoveChild = function (e) {
            var bodyComponent = e.data.getComponent(feng3d.Rigidbody);
            if (bodyComponent) {
                this.world.removeBody(bodyComponent.body);
            }
        };
        Scene3D.prototype.update = function (interval) {
            var _this = this;
            interval = interval || (1000 / feng3d.ticker.frameRate);
            this._mouseCheckObjects = null;
            this._models = null;
            this._visibleAndEnabledModels = null;
            this._skyBoxs = null;
            this._activeSkyBoxs = null;
            this._directionalLights = null;
            this._activeDirectionalLights = null;
            this._pointLights = null;
            this._activePointLights = null;
            this._spotLights = null;
            this._activeSpotLights = null;
            this._animations = null;
            this._activeAnimations = null;
            this._behaviours = null;
            this._activeBehaviours = null;
            // 每帧清理拾取缓存
            this._pickMap.forEach(function (item) { return item.clear(); });
            this.behaviours.forEach(function (element) {
                if (element.isVisibleAndEnabled && Boolean(_this.runEnvironment & element.runEnvironment))
                    element.update(interval);
            });
            // 只在
            if (this.runEnvironment == feng3d.RunEnvironment.feng3d)
                this.world.step(1.0 / 60.0, interval / 1000, 3);
        };
        Object.defineProperty(Scene3D.prototype, "models", {
            /**
             * 所有 Model
             */
            get: function () {
                return this._models = this._models || this.getComponentsInChildren(feng3d.Model);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Scene3D.prototype, "visibleAndEnabledModels", {
            /**
             * 所有 可见且开启的 Model
             */
            get: function () {
                return this._visibleAndEnabledModels = this._visibleAndEnabledModels || this.models.filter(function (i) { return i.isVisibleAndEnabled; });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Scene3D.prototype, "skyBoxs", {
            /**
             * 所有 SkyBox
             */
            get: function () {
                return this._skyBoxs = this._skyBoxs || this.getComponentsInChildren(feng3d.SkyBox);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Scene3D.prototype, "activeSkyBoxs", {
            get: function () {
                return this._activeSkyBoxs = this._activeSkyBoxs || this.skyBoxs.filter(function (i) { return i.gameObject.globalVisible; });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Scene3D.prototype, "directionalLights", {
            get: function () {
                return this._directionalLights = this._directionalLights || this.getComponentsInChildren(feng3d.DirectionalLight);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Scene3D.prototype, "activeDirectionalLights", {
            get: function () {
                return this._activeDirectionalLights = this._activeDirectionalLights || this.directionalLights.filter(function (i) { return i.isVisibleAndEnabled; });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Scene3D.prototype, "pointLights", {
            get: function () {
                return this._pointLights = this._pointLights || this.getComponentsInChildren(feng3d.PointLight);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Scene3D.prototype, "activePointLights", {
            get: function () {
                return this._activePointLights = this._activePointLights || this.pointLights.filter(function (i) { return i.isVisibleAndEnabled; });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Scene3D.prototype, "spotLights", {
            get: function () {
                return this._spotLights = this._spotLights || this.getComponentsInChildren(feng3d.SpotLight);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Scene3D.prototype, "activeSpotLights", {
            get: function () {
                return this._activeSpotLights = this._activeSpotLights || this.spotLights.filter(function (i) { return i.isVisibleAndEnabled; });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Scene3D.prototype, "animations", {
            get: function () {
                return this._animations = this._animations || this.getComponentsInChildren(feng3d.Animation);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Scene3D.prototype, "activeAnimations", {
            get: function () {
                return this._activeAnimations = this._activeAnimations || this.animations.filter(function (i) { return i.isVisibleAndEnabled; });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Scene3D.prototype, "behaviours", {
            get: function () {
                return this._behaviours = this._behaviours || this.getComponentsInChildren(feng3d.Behaviour);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Scene3D.prototype, "activeBehaviours", {
            get: function () {
                return this._activeBehaviours = this._activeBehaviours || this.behaviours.filter(function (i) { return i.isVisibleAndEnabled; });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Scene3D.prototype, "mouseCheckObjects", {
            get: function () {
                if (this._mouseCheckObjects)
                    return this._mouseCheckObjects;
                var checkList = this.gameObject.getChildren();
                this._mouseCheckObjects = [];
                var i = 0;
                //获取所有需要拾取的对象并分层存储
                while (i < checkList.length) {
                    var checkObject = checkList[i++];
                    if (checkObject.mouseEnabled) {
                        if (checkObject.getComponents(feng3d.Model)) {
                            this._mouseCheckObjects.push(checkObject);
                        }
                        checkList = checkList.concat(checkObject.getChildren());
                    }
                }
                return this._mouseCheckObjects;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 获取拾取缓存
         * @param camera
         */
        Scene3D.prototype.getPickCache = function (camera) {
            if (this._pickMap.get(camera))
                return this._pickMap.get(camera);
            var pick = new feng3d.ScenePickCache(this, camera);
            this._pickMap.set(camera, pick);
            return pick;
        };
        /**
         * 获取接收光照渲染对象列表
         * @param light
         */
        Scene3D.prototype.getPickByDirectionalLight = function (light) {
            var openlist = [this.gameObject];
            var targets = [];
            while (openlist.length > 0) {
                var item = openlist.shift();
                if (!item.visible)
                    continue;
                var model = item.getComponent(feng3d.Model);
                if (model && (model.castShadows || model.receiveShadows)
                    && !model.material.renderParams.enableBlend
                    && model.material.renderParams.renderMode == feng3d.RenderMode.TRIANGLES) {
                    targets.push(model);
                }
                item.children.forEach(function (element) {
                    openlist.push(element);
                });
            }
            return targets;
        };
        /**
         * 获取 可被摄像机看见的 Model 列表
         * @param camera
         */
        Scene3D.prototype.getModelsByCamera = function (camera) {
            var results = this.visibleAndEnabledModels.filter(function (i) {
                var model = i.getComponent(feng3d.Model);
                if (model.selfWorldBounds) {
                    if (camera.intersectsBox(model.selfWorldBounds))
                        return true;
                }
                return false;
            });
            return results;
        };
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], Scene3D.prototype, "background", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], Scene3D.prototype, "ambientColor", void 0);
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], Scene3D.prototype, "gravity", void 0);
        return Scene3D;
    }(feng3d.Component));
    feng3d.Scene3D = Scene3D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 场景拾取缓存
     */
    var ScenePickCache = /** @class */ (function () {
        function ScenePickCache(scene, camera) {
            this.scene = scene;
            this.camera = camera;
        }
        Object.defineProperty(ScenePickCache.prototype, "activeModels", {
            /**
             * 获取需要渲染的对象
             *
             * #### 渲染需求条件
             * 1. visible == true
             * 1. 在摄像机视锥内
             * 1. model.enabled == true
             *
             * @param gameObject
             * @param camera
             */
            get: function () {
                if (this._activeModels)
                    return this._activeModels;
                var models = this._activeModels = [];
                var gameObjects = [this.scene.gameObject];
                while (gameObjects.length > 0) {
                    var gameObject = gameObjects.pop();
                    if (!gameObject.visible)
                        continue;
                    var model = gameObject.getComponent(feng3d.Model);
                    if (model && model.enabled) {
                        if (model.selfWorldBounds) {
                            if (this.camera.intersectsBox(model.selfWorldBounds))
                                models.push(model);
                        }
                    }
                    gameObjects = gameObjects.concat(gameObject.children);
                }
                return models;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ScenePickCache.prototype, "blenditems", {
            /**
             * 半透明渲染对象
             */
            get: function () {
                if (this._blenditems)
                    return this._blenditems;
                var models = this.activeModels;
                var camerapos = this.camera.transform.scenePosition;
                var blenditems = this._blenditems = models.filter(function (item) {
                    return item.material.renderParams.enableBlend;
                }).sort(function (b, a) { return a.transform.scenePosition.subTo(camerapos).lengthSquared - b.transform.scenePosition.subTo(camerapos).lengthSquared; });
                return blenditems;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ScenePickCache.prototype, "unblenditems", {
            /**
             * 半透明渲染对象
             */
            get: function () {
                if (this._unblenditems)
                    return this._unblenditems;
                var models = this.activeModels;
                var camerapos = this.camera.transform.scenePosition;
                var unblenditems = this._unblenditems = models.filter(function (item) {
                    return !item.material.renderParams.enableBlend;
                }).sort(function (a, b) { return a.transform.scenePosition.subTo(camerapos).lengthSquared - b.transform.scenePosition.subTo(camerapos).lengthSquared; });
                return unblenditems;
            },
            enumerable: true,
            configurable: true
        });
        ScenePickCache.prototype.clear = function () {
            this._blenditems = null;
            this._unblenditems = null;
            this._activeModels = null;
        };
        return ScenePickCache;
    }());
    feng3d.ScenePickCache = ScenePickCache;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 几何体
     */
    var Geometry = /** @class */ (function (_super) {
        __extends(Geometry, _super);
        /**
         * 创建一个几何体
         */
        function Geometry() {
            var _this = _super.call(this) || this;
            _this.preview = "";
            _this.assetType = feng3d.AssetType.geometry;
            /**
             * 纹理U缩放，默认为1。
             */
            _this.scaleU = 1;
            /**
             * 纹理V缩放，默认为1。
             */
            _this.scaleV = 1;
            /**
             * 属性数据列表
             */
            _this._attributes = {};
            _this._geometryInvalid = true;
            _this._useFaceWeights = false;
            _this._autoAttributeDatas = {};
            _this._invalids = { index: true, a_uv: true, a_normal: true, a_tangent: true };
            return _this;
        }
        Object.defineProperty(Geometry.prototype, "geometryInfo", {
            /**
             * 几何体信息
             */
            get: function () {
                var str = [
                    "Geometry Info",
                    "  Vertices    " + this.numVertex,
                    "  Triangles    " + this.numTriangles,
                    "  Attributes    " + Object.keys(this._attributes).join(","),
                ].join("\n");
                return str;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Geometry.prototype, "indices", {
            /**
             * 索引数据
             */
            get: function () {
                this.updateGrometry();
                if (!this._indices && this._invalids.index) {
                    this._invalids.index = false;
                    this._autoIndices = feng3d.geometryUtils.createIndices(this.positions);
                }
                return this._indices || this._autoIndices;
            },
            /**
             * 更新顶点索引数据
             */
            set: function (value) {
                this._indices = value;
                if (!this._attributes.a_normal)
                    this._invalids.a_normal = true;
                if (!this._attributes.a_tangent)
                    this._invalids.a_tangent = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Geometry.prototype, "positions", {
            /**
             * 坐标数据
             */
            get: function () {
                return this.getVAData1("a_position");
            },
            set: function (value) {
                if (!this._indices)
                    this._invalids.index = true;
                this.setVAData("a_position", value, 3);
                if (!this._attributes.a_uv)
                    this._invalids.a_uv = true;
                if (!this._attributes.a_normal)
                    this._invalids.a_normal = true;
                if (!this._attributes.a_tangent)
                    this._invalids.a_tangent = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Geometry.prototype, "uvs", {
            /**
             * uv数据
             */
            get: function () {
                return this.getVAData1("a_uv");
            },
            set: function (value) {
                this.setVAData("a_uv", value, 2);
                if (!this._attributes.a_tangent)
                    this._invalids.a_tangent = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Geometry.prototype, "normals", {
            /**
             * 法线数据
             */
            get: function () {
                return this.getVAData1("a_normal");
            },
            set: function (value) {
                this.setVAData("a_normal", value, 3);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Geometry.prototype, "tangents", {
            /**
             * 切线数据
             */
            get: function () {
                return this.getVAData1("a_tangent");
            },
            set: function (value) {
                this.setVAData("a_tangent", value, 3);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 几何体变脏
         */
        Geometry.prototype.invalidateGeometry = function () {
            this._geometryInvalid = true;
            this.invalidateBounds();
        };
        /**
         * 更新几何体
         */
        Geometry.prototype.updateGrometry = function () {
            if (this._geometryInvalid) {
                this._geometryInvalid = false;
                this.buildGeometry();
            }
        };
        /**
         * 构建几何体
         */
        Geometry.prototype.buildGeometry = function () {
        };
        /**
         * 设置顶点属性数据
         * @param vaId                  顶点属性编号
         * @param data                  顶点属性数据
         * @param size                  顶点数据尺寸
         * @param autogenerate          是否自动生成数据
         */
        Geometry.prototype.setVAData = function (vaId, data, size) {
            if (data) {
                this._attributes[vaId] = this._attributes[vaId] || { data: data, size: size };
                this._attributes[vaId].data = data;
            }
            else {
                delete this._attributes[vaId];
            }
        };
        /**
         * 获取顶点属性数据
         * @param vaId 数据类型编号
         * @return 顶点属性数据
         */
        Geometry.prototype.getVAData1 = function (vaId) {
            this.updateGrometry();
            if (vaId == "a_uv") {
                if (!this._attributes.a_uv && this._invalids.a_uv) {
                    this._invalids.a_uv = false;
                    var uvs = feng3d.geometryUtils.createUVs(this.positions);
                    this._autoAttributeDatas[vaId] = { data: uvs, size: 2 };
                }
            }
            if (vaId == "a_normal") {
                if (!this._attributes.a_normal && this._invalids.a_normal) {
                    this._invalids.a_normal = false;
                    var normals = feng3d.geometryUtils.createVertexNormals(this.indices, this.positions, this._useFaceWeights);
                    this._autoAttributeDatas[vaId] = { data: normals, size: 3 };
                }
            }
            if (vaId == "a_tangent") {
                if (!this._attributes.a_tangent && this._invalids.a_tangent) {
                    this._invalids.a_tangent = false;
                    var tangents = feng3d.geometryUtils.createVertexTangents(this.indices, this.positions, this.uvs, this._useFaceWeights);
                    this._autoAttributeDatas[vaId] = { data: tangents, size: 3 };
                }
            }
            var attributeRenderData = this._attributes[vaId] || this._autoAttributeDatas[vaId];
            return attributeRenderData && attributeRenderData.data;
        };
        Object.defineProperty(Geometry.prototype, "numVertex", {
            /**
             * 顶点数量
             */
            get: function () {
                var numVertex = 0;
                for (var attributeName in this._attributes) {
                    var attributeRenderData = this._attributes[attributeName];
                    numVertex = attributeRenderData.data.length / attributeRenderData.size;
                    break;
                }
                return numVertex;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Geometry.prototype, "numTriangles", {
            /**
             * 三角形数量
             */
            get: function () {
                return this.indices.length / 3;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 添加几何体
         * @param geometry          被添加的几何体
         * @param transform         变换矩阵，把克隆被添加几何体的数据变换后再添加到该几何体中
         */
        Geometry.prototype.addGeometry = function (geometry, transform) {
            //更新几何体
            this.updateGrometry();
            geometry.updateGrometry();
            //变换被添加的几何体
            if (transform != null) {
                geometry = geometry.clone();
                geometry.applyTransformation(transform);
            }
            //如果自身为空几何体
            if (!this._indices) {
                this.cloneFrom(geometry);
                return;
            }
            //
            var attributes = this._attributes;
            var addAttributes = geometry._attributes;
            //当前顶点数量
            var oldNumVertex = this.numVertex;
            //合并索引
            var indices = this._indices;
            var targetIndices = geometry._indices;
            var totalIndices = indices.concat();
            for (var i = 0; i < targetIndices.length; i++) {
                totalIndices[indices.length + i] = targetIndices[i] + oldNumVertex;
            }
            this.indices = totalIndices;
            //合并后顶点数量
            var totalVertex = oldNumVertex + geometry.numVertex;
            //合并属性数据
            for (var attributeName in attributes) {
                var stride = attributes[attributeName].size;
                var attributeData = attributes[attributeName].data;
                var addAttributeData = addAttributes[attributeName].data;
                var data = attributeData.concat(addAttributeData);
                this.setVAData(attributeName, data, stride);
            }
        };
        /**
         * 应用变换矩阵
         * @param transform 变换矩阵
         */
        Geometry.prototype.applyTransformation = function (transform) {
            this.updateGrometry();
            var vertices = this.positions;
            var normals = this.normals;
            var tangents = this.tangents;
            feng3d.geometryUtils.applyTransformation(transform, vertices, normals, tangents);
            this.positions = vertices;
            this.normals = normals;
            this.tangents = tangents;
        };
        /**
         * 包围盒失效
         */
        Geometry.prototype.invalidateBounds = function () {
            this._bounding = null;
            this.dispatch("boundsInvalid", this);
        };
        Object.defineProperty(Geometry.prototype, "bounding", {
            get: function () {
                this.updateGrometry();
                if (!this._bounding) {
                    var positions = this.positions;
                    if (!positions || positions.length == 0)
                        return new feng3d.AABB();
                    this._bounding = feng3d.AABB.formPositions(this.positions);
                }
                return this._bounding;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 射线投影几何体
         * @param ray                           射线
         * @param shortestCollisionDistance     当前最短碰撞距离
         * @param cullFace                      裁剪面枚举
         */
        Geometry.prototype.raycast = function (ray, shortestCollisionDistance, cullFace) {
            if (shortestCollisionDistance === void 0) { shortestCollisionDistance = Number.MAX_VALUE; }
            if (cullFace === void 0) { cullFace = feng3d.CullFace.NONE; }
            var result = feng3d.geometryUtils.raycast(ray, this.indices, this.positions, this.uvs, shortestCollisionDistance, cullFace);
            return result;
        };
        /**
         * 获取顶点列表
         *
         * @param result
         */
        Geometry.prototype.getVertices = function (result) {
            if (result === void 0) { result = []; }
            var positions = this.positions;
            var result = [];
            for (var i = 0, n = positions.length; i < n; i += 3) {
                result.push(new feng3d.Vector3(positions[i], positions[i + 1], positions[i + 2]));
            }
            return result;
        };
        Geometry.prototype.getFaces = function (result) {
            if (result === void 0) { result = []; }
            var indices = this.indices;
            for (var i = 0, n = indices.length; i < n; i += 3) {
                result.push([indices[i], indices[i + 1], indices[i + 2]]);
            }
            return result;
        };
        /**
         * 克隆一个几何体
         */
        Geometry.prototype.clone = function () {
            var geometry = new feng3d.CustomGeometry();
            geometry.cloneFrom(this);
            return geometry;
        };
        /**
         * 从一个几何体中克隆数据
         */
        Geometry.prototype.cloneFrom = function (geometry) {
            geometry.updateGrometry();
            this.indices = geometry.indices.concat();
            this._attributes = {};
            for (var key in geometry._attributes) {
                var attributeRenderData = geometry._attributes[key];
                this.setVAData(key, attributeRenderData.data, attributeRenderData.size);
            }
        };
        Geometry.prototype.beforeRender = function (renderAtomic) {
            renderAtomic.indexBuffer = renderAtomic.indexBuffer || new feng3d.Index();
            renderAtomic.indexBuffer.indices = this.indices;
            var attributes = renderAtomic.attributes;
            this.uvs;
            this.normals;
            this.tangents;
            for (var vaId in this._autoAttributeDatas) {
                if (this._autoAttributeDatas.hasOwnProperty(vaId)) {
                    var element = this._autoAttributeDatas[vaId];
                    //
                    var attributeRenderData = attributes[vaId] = attributes[vaId] || new feng3d.Attribute(vaId, element.data);
                    if (attributeRenderData.data != element.data)
                        attributeRenderData.data = element.data;
                    attributeRenderData.size = element.size;
                    attributeRenderData.divisor = 0;
                    //
                    renderAtomic.shaderMacro["HSA_" + vaId] = true;
                }
            }
            for (var vaId in this._attributes) {
                if (this._attributes.hasOwnProperty(vaId)) {
                    var element = this._attributes[vaId];
                    //
                    var attributeRenderData = attributes[vaId] = attributes[vaId] || new feng3d.Attribute(vaId, element.data);
                    if (attributeRenderData.data != element.data)
                        attributeRenderData.data = element.data;
                    attributeRenderData.size = element.size;
                    attributeRenderData.divisor = 0;
                    //
                    renderAtomic.shaderMacro["HSA_" + vaId] = true;
                }
            }
            renderAtomic.shaderMacro.SCALEU = this.scaleU;
            renderAtomic.shaderMacro.SCALEV = this.scaleV;
        };
        __decorate([
            feng3d.oav({ component: "OAVFeng3dPreView" })
        ], Geometry.prototype, "preview", void 0);
        __decorate([
            feng3d.oav()
        ], Geometry.prototype, "name", void 0);
        __decorate([
            feng3d.oav({ component: "OAVMultiText", priority: 10 })
        ], Geometry.prototype, "geometryInfo", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], Geometry.prototype, "scaleU", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], Geometry.prototype, "scaleV", void 0);
        return Geometry;
    }(feng3d.AssetData));
    feng3d.Geometry = Geometry;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var CustomGeometry = /** @class */ (function (_super) {
        __extends(CustomGeometry, _super);
        function CustomGeometry() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.__class__ = "feng3d.CustomGeometry";
            return _this;
        }
        Object.defineProperty(CustomGeometry.prototype, "indicesBase", {
            /**
             * 顶点索引缓冲
             */
            get: function () {
                return this._indices;
            },
            set: function (value) {
                this.indices = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CustomGeometry.prototype, "attributes", {
            /**
             * 属性数据列表
             */
            get: function () {
                return this._attributes;
            },
            set: function (value) {
                this._attributes = {};
                for (var key in value) {
                    this.setVAData(key, value[key].data, value[key].size);
                }
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            feng3d.serialize
        ], CustomGeometry.prototype, "indicesBase", null);
        __decorate([
            feng3d.serialize
        ], CustomGeometry.prototype, "attributes", null);
        return CustomGeometry;
    }(feng3d.Geometry));
    feng3d.CustomGeometry = CustomGeometry;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var GeometryUtils = /** @class */ (function () {
        function GeometryUtils() {
        }
        /**
         * 根据顶点数量按顺序创建顶点索引
         * @param positions 顶点数据
         */
        GeometryUtils.prototype.createIndices = function (positions) {
            var vertexNum = positions.length / 3;
            var indices = [];
            for (var i = 0; i < vertexNum; i++) {
                indices[i] = i;
            }
            return indices;
        };
        /**
         * 创建循环uv数据
         * @param positions 顶点数据
         */
        GeometryUtils.prototype.createUVs = function (positions) {
            var idx = 0, uvIdx = 0;
            var target = [];
            var len = positions.length / 3 * 2;
            while (idx < len) {
                target[idx++] = uvIdx * .5;
                target[idx++] = 1.0 - (uvIdx & 1);
                if (++uvIdx == 3)
                    uvIdx = 0;
            }
            return target;
        };
        /**
         * 计算顶点法线数据
         * @param indices 顶点索引
         * @param positions 顶点数据
         * @param useFaceWeights 是否使用面权重计算法线
         */
        GeometryUtils.prototype.createVertexNormals = function (indices, positions, useFaceWeights) {
            if (useFaceWeights === void 0) { useFaceWeights = false; }
            var faceNormalsResult = this.createFaceNormals(indices, positions, useFaceWeights);
            var faceWeights = faceNormalsResult.faceWeights;
            var faceNormals = faceNormalsResult.faceNormals;
            var v1 = 0;
            var f1 = 0, f2 = 1, f3 = 2;
            var lenV = positions.length;
            var normalStride = 3;
            var normalOffset = 0;
            var normals = new Array(lenV);
            v1 = 0;
            while (v1 < lenV) {
                normals[v1] = 0.0;
                normals[v1 + 1] = 0.0;
                normals[v1 + 2] = 0.0;
                v1 += normalStride;
            }
            var i = 0, k = 0;
            var lenI = indices.length;
            var index = 0;
            var weight = 0;
            while (i < lenI) {
                weight = useFaceWeights ? faceWeights[k++] : 1;
                index = normalOffset + indices[i++] * normalStride;
                normals[index++] += faceNormals[f1] * weight;
                normals[index++] += faceNormals[f2] * weight;
                normals[index] += faceNormals[f3] * weight;
                index = normalOffset + indices[i++] * normalStride;
                normals[index++] += faceNormals[f1] * weight;
                normals[index++] += faceNormals[f2] * weight;
                normals[index] += faceNormals[f3] * weight;
                index = normalOffset + indices[i++] * normalStride;
                normals[index++] += faceNormals[f1] * weight;
                normals[index++] += faceNormals[f2] * weight;
                normals[index] += faceNormals[f3] * weight;
                f1 += 3;
                f2 += 3;
                f3 += 3;
            }
            v1 = normalOffset;
            while (v1 < lenV) {
                var vx = normals[v1];
                var vy = normals[v1 + 1];
                var vz = normals[v1 + 2];
                var d = 1.0 / Math.sqrt(vx * vx + vy * vy + vz * vz);
                normals[v1] = vx * d;
                normals[v1 + 1] = vy * d;
                normals[v1 + 2] = vz * d;
                v1 += normalStride;
            }
            return normals;
        };
        /**
         * 计算顶点切线数据
         * @param indices 顶点索引
         * @param positions 顶点数据
         * @param uvs uv数据
         * @param useFaceWeights 是否使用面权重计算切线数据
         */
        GeometryUtils.prototype.createVertexTangents = function (indices, positions, uvs, useFaceWeights) {
            if (useFaceWeights === void 0) { useFaceWeights = false; }
            var faceTangentsResult = this.createFaceTangents(indices, positions, uvs, useFaceWeights);
            var faceWeights = faceTangentsResult.faceWeights;
            var faceTangents = faceTangentsResult.faceTangents;
            var i = 0;
            var lenV = positions.length;
            var tangentStride = 3;
            var tangentOffset = 0;
            var target = new Array(lenV);
            i = tangentOffset;
            while (i < lenV) {
                target[i] = 0.0;
                target[i + 1] = 0.0;
                target[i + 2] = 0.0;
                i += tangentStride;
            }
            var k = 0;
            var lenI = indices.length;
            var index = 0;
            var weight = 0;
            var f1 = 0, f2 = 1, f3 = 2;
            i = 0;
            while (i < lenI) {
                weight = useFaceWeights ? faceWeights[k++] : 1;
                index = tangentOffset + indices[i++] * tangentStride;
                target[index++] += faceTangents[f1] * weight;
                target[index++] += faceTangents[f2] * weight;
                target[index] += faceTangents[f3] * weight;
                index = tangentOffset + indices[i++] * tangentStride;
                target[index++] += faceTangents[f1] * weight;
                target[index++] += faceTangents[f2] * weight;
                target[index] += faceTangents[f3] * weight;
                index = tangentOffset + indices[i++] * tangentStride;
                target[index++] += faceTangents[f1] * weight;
                target[index++] += faceTangents[f2] * weight;
                target[index] += faceTangents[f3] * weight;
                f1 += 3;
                f2 += 3;
                f3 += 3;
            }
            i = tangentOffset;
            while (i < lenV) {
                var vx = target[i];
                var vy = target[i + 1];
                var vz = target[i + 2];
                var d = 1.0 / Math.sqrt(vx * vx + vy * vy + vz * vz);
                target[i] = vx * d;
                target[i + 1] = vy * d;
                target[i + 2] = vz * d;
                i += tangentStride;
            }
            return target;
        };
        /**
         * 计算面切线数据
         * @param indices 顶点索引数据
         * @param positions 顶点数据
         * @param uvs uv数据
         * @param useFaceWeights 是否计算面权重
         */
        GeometryUtils.prototype.createFaceTangents = function (indices, positions, uvs, useFaceWeights) {
            if (useFaceWeights === void 0) { useFaceWeights = false; }
            var i = 0, k = 0;
            var index1 = 0, index2 = 0, index3 = 0;
            var len = indices.length;
            var ui = 0, vi = 0;
            var v0 = 0;
            var dv1 = 0, dv2 = 0;
            var denom = 0;
            var x0 = 0, y0 = 0, z0 = 0;
            var dx1 = 0, dy1 = 0, dz1 = 0;
            var dx2 = 0, dy2 = 0, dz2 = 0;
            var cx = 0, cy = 0, cz = 0;
            var posStride = 3;
            var posOffset = 0;
            var texStride = 2;
            var texOffset = 0;
            var faceTangents = new Array(indices.length);
            var faceWeights = [];
            while (i < len) {
                index1 = indices[i];
                index2 = indices[i + 1];
                index3 = indices[i + 2];
                ui = texOffset + index1 * texStride + 1;
                v0 = uvs[ui];
                ui = texOffset + index2 * texStride + 1;
                dv1 = uvs[ui] - v0;
                ui = texOffset + index3 * texStride + 1;
                dv2 = uvs[ui] - v0;
                vi = posOffset + index1 * posStride;
                x0 = positions[vi];
                y0 = positions[vi + 1];
                z0 = positions[vi + 2];
                vi = posOffset + index2 * posStride;
                dx1 = positions[vi] - x0;
                dy1 = positions[vi + 1] - y0;
                dz1 = positions[vi + 2] - z0;
                vi = posOffset + index3 * posStride;
                dx2 = positions[vi] - x0;
                dy2 = positions[vi + 1] - y0;
                dz2 = positions[vi + 2] - z0;
                cx = dv2 * dx1 - dv1 * dx2;
                cy = dv2 * dy1 - dv1 * dy2;
                cz = dv2 * dz1 - dv1 * dz2;
                denom = Math.sqrt(cx * cx + cy * cy + cz * cz);
                if (useFaceWeights) {
                    var w = denom * 10000;
                    if (w < 1)
                        w = 1;
                    faceWeights[k++] = w;
                }
                denom = 1 / denom;
                faceTangents[i++] = denom * cx;
                faceTangents[i++] = denom * cy;
                faceTangents[i++] = denom * cz;
            }
            return { faceTangents: faceTangents, faceWeights: faceWeights };
        };
        /**
         * 计算面法线数据
         * @param indices 顶点索引数据
         * @param positions 顶点数据
         * @param useFaceWeights 是否计算面权重
         */
        GeometryUtils.prototype.createFaceNormals = function (indices, positions, useFaceWeights) {
            if (useFaceWeights === void 0) { useFaceWeights = false; }
            var i = 0, j = 0, k = 0;
            var index = 0;
            var len = indices.length;
            var x1 = 0, x2 = 0, x3 = 0;
            var y1 = 0, y2 = 0, y3 = 0;
            var z1 = 0, z2 = 0, z3 = 0;
            var dx1 = 0, dy1 = 0, dz1 = 0;
            var dx2 = 0, dy2 = 0, dz2 = 0;
            var cx = 0, cy = 0, cz = 0;
            var d = 0;
            var posStride = 3;
            var faceNormals = new Array(len);
            var faceWeights = [];
            while (i < len) {
                index = indices[i++] * posStride;
                x1 = positions[index];
                y1 = positions[index + 1];
                z1 = positions[index + 2];
                index = indices[i++] * posStride;
                x2 = positions[index];
                y2 = positions[index + 1];
                z2 = positions[index + 2];
                index = indices[i++] * posStride;
                x3 = positions[index];
                y3 = positions[index + 1];
                z3 = positions[index + 2];
                dx1 = x3 - x1;
                dy1 = y3 - y1;
                dz1 = z3 - z1;
                dx2 = x2 - x1;
                dy2 = y2 - y1;
                dz2 = z2 - z1;
                cx = dz1 * dy2 - dy1 * dz2;
                cy = dx1 * dz2 - dz1 * dx2;
                cz = dy1 * dx2 - dx1 * dy2;
                d = Math.sqrt(cx * cx + cy * cy + cz * cz);
                if (useFaceWeights) {
                    var w = d * 10000;
                    if (w < 1)
                        w = 1;
                    faceWeights[k++] = w;
                }
                d = 1 / d;
                faceNormals[j++] = cx * d;
                faceNormals[j++] = cy * d;
                faceNormals[j++] = cz * d;
            }
            return { faceNormals: faceNormals, faceWeights: faceWeights };
        };
        /**
         * 应用变换矩阵
         * @param transform 变换矩阵
         * @param positions 顶点数据
         * @param normals 顶点法线数据
         * @param tangents 顶点切线数据
         */
        GeometryUtils.prototype.applyTransformation = function (transform, positions, normals, tangents) {
            var posStride = 3;
            var normalStride = 3;
            var tangentStride = 3;
            var len = positions.length / posStride;
            var i, i1, i2;
            var vector = new feng3d.Vector3();
            var bakeNormals = normals != null;
            var bakeTangents = tangents != null;
            var invTranspose = new feng3d.Matrix4x4();
            if (bakeNormals || bakeTangents) {
                invTranspose.copyFrom(transform);
                invTranspose.invert();
                invTranspose.transpose();
            }
            var vi0 = 0;
            var ni0 = 0;
            var ti0 = 0;
            for (i = 0; i < len; ++i) {
                i1 = vi0 + 1;
                i2 = vi0 + 2;
                // bake position
                vector.x = positions[vi0];
                vector.y = positions[i1];
                vector.z = positions[i2];
                vector = transform.transformVector(vector);
                positions[vi0] = vector.x;
                positions[i1] = vector.y;
                positions[i2] = vector.z;
                vi0 += posStride;
                // bake normal
                if (bakeNormals) {
                    i1 = ni0 + 1;
                    i2 = ni0 + 2;
                    vector.x = normals[ni0];
                    vector.y = normals[i1];
                    vector.z = normals[i2];
                    vector = invTranspose.deltaTransformVector(vector);
                    vector.normalize();
                    normals[ni0] = vector.x;
                    normals[i1] = vector.y;
                    normals[i2] = vector.z;
                    ni0 += normalStride;
                }
                // bake tangent
                if (bakeTangents) {
                    i1 = ti0 + 1;
                    i2 = ti0 + 2;
                    vector.x = tangents[ti0];
                    vector.y = tangents[i1];
                    vector.z = tangents[i2];
                    vector = invTranspose.deltaTransformVector(vector);
                    vector.normalize();
                    tangents[ti0] = vector.x;
                    tangents[i1] = vector.y;
                    tangents[i2] = vector.z;
                    ti0 += tangentStride;
                }
            }
        };
        /**
         * 合并几何体
         * @param geometrys 几何体列表
         */
        GeometryUtils.prototype.mergeGeometry = function (geometrys) {
            // 此处存在隐患。
            // 优化方案，遍历所有几何体，找到所有共有属性后进行合并。
            var result = {};
            for (var i = 0; i < geometrys.length; i++) {
                var geometry = geometrys[i];
                if (i == 0) {
                    result.indices = geometry.indices.concat();
                    result.positions = geometry.positions.concat();
                    geometry.uvs && (result.uvs = geometry.uvs.concat());
                    geometry.normals && (result.normals = geometry.normals.concat());
                    geometry.tangents && (result.tangents = geometry.tangents.concat());
                }
                else {
                    var startIndex = result.positions.length / 3;
                    geometry.indices.forEach(function (v) { return result.indices.push(v + startIndex); });
                    geometry.positions.forEach(function (v) { return result.positions.push(v); });
                    result.uvs && geometry.uvs.forEach(function (v) { return result.uvs.push(v); });
                    result.normals && geometry.normals.forEach(function (v) { return result.normals.push(v); });
                    result.tangents && geometry.tangents.forEach(function (v) { return result.tangents.push(v); });
                }
            }
            return result;
        };
        /**
         * 射线投影几何体
         * @param ray                           射线
         * @param shortestCollisionDistance     当前最短碰撞距离
         * @param cullFace                      裁剪面枚举
         */
        GeometryUtils.prototype.raycast = function (ray, indices, positions, uvs, shortestCollisionDistance, cullFace) {
            if (shortestCollisionDistance === void 0) { shortestCollisionDistance = Number.MAX_VALUE; }
            if (cullFace === void 0) { cullFace = feng3d.CullFace.NONE; }
            if (cullFace == feng3d.CullFace.FRONT_AND_BACK)
                return null;
            var t = 0;
            var i0 = 0, i1 = 0, i2 = 0;
            var rx = 0, ry = 0, rz = 0;
            var nx = 0, ny = 0, nz = 0;
            var cx = 0, cy = 0, cz = 0;
            var coeff = 0, u = 0, v = 0, w = 0;
            var p0x = 0, p0y = 0, p0z = 0;
            var p1x = 0, p1y = 0, p1z = 0;
            var p2x = 0, p2y = 0, p2z = 0;
            var s0x = 0, s0y = 0, s0z = 0;
            var s1x = 0, s1y = 0, s1z = 0;
            var nl = 0, nDotV = 0, D = 0, disToPlane = 0;
            var Q1Q2 = 0, Q1Q1 = 0, Q2Q2 = 0, RQ1 = 0, RQ2 = 0;
            var collisionTriangleIndex = -1;
            var numIndices = indices.length;
            var result = {};
            //遍历每个三角形 检测碰撞
            for (var index = 0; index < numIndices; index += 3) { // sweep all triangles
                //三角形三个顶点索引
                i0 = indices[index] * 3;
                i1 = indices[index + 1] * 3;
                i2 = indices[index + 2] * 3;
                //三角形三个顶点数据
                p0x = positions[i0];
                p0y = positions[i0 + 1];
                p0z = positions[i0 + 2];
                p1x = positions[i1];
                p1y = positions[i1 + 1];
                p1z = positions[i1 + 2];
                p2x = positions[i2];
                p2y = positions[i2 + 1];
                p2z = positions[i2 + 2];
                //计算出三角面的法线
                s0x = p1x - p0x; // s0 = p1 - p0
                s0y = p1y - p0y;
                s0z = p1z - p0z;
                s1x = p2x - p0x; // s1 = p2 - p0
                s1y = p2y - p0y;
                s1z = p2z - p0z;
                nx = s0y * s1z - s0z * s1y; // n = s0 x s1
                ny = s0z * s1x - s0x * s1z;
                nz = s0x * s1y - s0y * s1x;
                nl = 1 / Math.sqrt(nx * nx + ny * ny + nz * nz); // normalize n
                nx *= nl;
                ny *= nl;
                nz *= nl;
                //初始化射线数据
                var rayPosition = ray.position;
                var rayDirection = ray.direction;
                //计算射线与法线的点积，不等于零表示射线所在直线与三角面相交
                nDotV = nx * rayDirection.x + ny * +rayDirection.y + nz * rayDirection.z; // rayDirection . normal
                //判断射线是否与三角面相交
                if ((cullFace == feng3d.CullFace.FRONT && nDotV > 0.0) || (cullFace == feng3d.CullFace.BACK && nDotV < 0.0) || (cullFace == feng3d.CullFace.NONE && nDotV != 0.0)) { // an intersection must exist
                    //计算平面方程D值，参考Plane3D
                    D = -(nx * p0x + ny * p0y + nz * p0z);
                    //射线点到平面的距离
                    disToPlane = -(nx * rayPosition.x + ny * rayPosition.y + nz * rayPosition.z + D);
                    t = disToPlane / nDotV;
                    //得到交点
                    cx = rayPosition.x + t * rayDirection.x;
                    cy = rayPosition.y + t * rayDirection.y;
                    cz = rayPosition.z + t * rayDirection.z;
                    //判断交点是否在三角形内( using barycentric coordinates )
                    Q1Q2 = s0x * s1x + s0y * s1y + s0z * s1z;
                    Q1Q1 = s0x * s0x + s0y * s0y + s0z * s0z;
                    Q2Q2 = s1x * s1x + s1y * s1y + s1z * s1z;
                    rx = cx - p0x;
                    ry = cy - p0y;
                    rz = cz - p0z;
                    RQ1 = rx * s0x + ry * s0y + rz * s0z;
                    RQ2 = rx * s1x + ry * s1y + rz * s1z;
                    coeff = 1 / (Q1Q1 * Q2Q2 - Q1Q2 * Q1Q2);
                    v = coeff * (Q2Q2 * RQ1 - Q1Q2 * RQ2);
                    w = coeff * (-Q1Q2 * RQ1 + Q1Q1 * RQ2);
                    if (v < 0)
                        continue;
                    if (w < 0)
                        continue;
                    u = 1 - v - w;
                    //u v w都大于0表示点在三角形内 射线的坐标t大于0表示射线朝向三角面
                    if (!(u < 0) && t > 0 && t < shortestCollisionDistance) {
                        shortestCollisionDistance = t;
                        collisionTriangleIndex = index / 3;
                        result.rayEntryDistance = t;
                        result.localPosition = new feng3d.Vector3(cx, cy, cz);
                        result.localNormal = new feng3d.Vector3(nx, ny, nz);
                        if (uvs) {
                            result.uv = getCollisionUV(indices, uvs, index, v, w, u);
                        }
                        result.localNormal = getCollisionNormal(indices, positions, index);
                        result.index = index;
                    }
                }
            }
            if (collisionTriangleIndex >= 0)
                return result;
            return null;
            /**
             * 获取碰撞法线
             * @param indices 顶点索引数据
             * @param positions 顶点数据
             * @param triangleIndex 三角形索引
             * @return 碰撞法线
             */
            function getCollisionNormal(indices, positions, triangleIndex) {
                if (triangleIndex === void 0) { triangleIndex = 0; }
                var i0 = indices[triangleIndex] * 3;
                var i1 = indices[triangleIndex + 1] * 3;
                var i2 = indices[triangleIndex + 2] * 3;
                var side0x = positions[i1] - positions[i0];
                var side0y = positions[i1 + 1] - positions[i0 + 1];
                var side0z = positions[i1 + 2] - positions[i0 + 2];
                var side1x = positions[i2] - positions[i0];
                var side1y = positions[i2 + 1] - positions[i0 + 1];
                var side1z = positions[i2 + 2] - positions[i0 + 2];
                var normal = new feng3d.Vector3();
                normal.x = side0y * side1z - side0z * side1y;
                normal.y = side0z * side1x - side0x * side1z;
                normal.z = side0x * side1y - side0y * side1x;
                normal.normalize();
                return normal;
            }
            /**
             * 获取碰撞uv
             * @param indices 顶点数据
             * @param uvs uv数据
             * @param triangleIndex 三角形所有
             * @param v
             * @param w
             * @param u
             * @param uvOffset
             * @param uvStride
             * @return 碰撞uv
             */
            function getCollisionUV(indices, uvs, triangleIndex, v, w, u) {
                var uIndex = indices[triangleIndex] * 2;
                var uv0x = uvs[uIndex];
                var uv0y = uvs[uIndex + 1];
                uIndex = indices[triangleIndex + 1] * 2;
                var uv1x = uvs[uIndex];
                var uv1y = uvs[uIndex + 1];
                uIndex = indices[triangleIndex + 2] * 2;
                var uv2x = uvs[uIndex];
                var uv2y = uvs[uIndex + 1];
                var uv = new feng3d.Vector2();
                uv.x = u * uv0x + v * uv1x + w * uv2x;
                uv.y = u * uv0y + v * uv1y + w * uv2y;
                return uv;
            }
        };
        /**
         * 获取包围盒
         * @param positions 顶点数据
         */
        GeometryUtils.prototype.getAABB = function (positions) {
            return feng3d.AABB.formPositions(positions);
        };
        return GeometryUtils;
    }());
    feng3d.GeometryUtils = GeometryUtils;
    feng3d.geometryUtils = new GeometryUtils();
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 点几何体
     */
    var PointGeometry = /** @class */ (function (_super) {
        __extends(PointGeometry, _super);
        function PointGeometry() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.__class__ = "feng3d.PointGeometry";
            _this._points = [];
            return _this;
        }
        Object.defineProperty(PointGeometry.prototype, "points", {
            /**
             * 点数据列表
             * 修改数组内数据时需要手动调用 invalidateGeometry();
             */
            get: function () {
                return this._points;
            },
            set: function (v) {
                if (this._points == v)
                    return;
                this._points = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 构建几何体
         */
        PointGeometry.prototype.buildGeometry = function () {
            var numPoints = this.points.length;
            var indices = [];
            var positionData = [];
            var normalData = [];
            var uvData = [];
            var colors = [];
            numPoints = Math.max(1, numPoints);
            for (var i = 0; i < numPoints; i++) {
                var element = this.points[i];
                var position = (element && element.position) || feng3d.Vector3.ZERO;
                var color = (element && element.color) || feng3d.Color4.WHITE;
                var normal = (element && element.normal) || feng3d.Vector3.ZERO;
                var uv = (element && element.uv) || feng3d.Vector2.ZERO;
                indices[i] = i;
                positionData.push(position.x, position.y, position.z);
                normalData.push(normal.x, normal.y, normal.z);
                uvData.push(uv.x, uv.y);
                colors.push(color.r, color.g, color.b, color.a);
            }
            this.positions = positionData;
            this.uvs = uvData;
            this.normals = normalData;
            this.indices = indices;
            this.setVAData("a_color", colors, 4);
        };
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], PointGeometry.prototype, "points", null);
        return PointGeometry;
    }(feng3d.Geometry));
    feng3d.PointGeometry = PointGeometry;
    feng3d.AssetData.addAssetData("PointGeometry", feng3d.Geometry.point = feng3d.serialization.setValue(new PointGeometry(), { name: "PointGeometry", assetId: "PointGeometry", points: [], hideFlags: feng3d.HideFlags.NotEditable }));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 线段组件
     */
    var SegmentGeometry = /** @class */ (function (_super) {
        __extends(SegmentGeometry, _super);
        function SegmentGeometry() {
            var _this = _super.call(this) || this;
            _this.__class__ = "feng3d.SegmentGeometry";
            _this._segments = [];
            return _this;
        }
        Object.defineProperty(SegmentGeometry.prototype, "segments", {
            /**
             * 线段列表
             * 修改数组内数据时需要手动调用 invalidateGeometry();
             */
            get: function () {
                return this._segments;
            },
            set: function (v) {
                if (this._segments == v)
                    return;
                this._segments = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 更新几何体
         */
        SegmentGeometry.prototype.buildGeometry = function () {
            var numSegments = this.segments.length;
            var indices = [];
            var positionData = [];
            var colorData = [];
            for (var i = 0; i < numSegments; i++) {
                var element = this.segments[i];
                var start = element.start || feng3d.Vector3.ZERO;
                var end = element.end || feng3d.Vector3.ZERO;
                ;
                var startColor = element.startColor || feng3d.Color4.WHITE;
                var endColor = element.endColor || feng3d.Color4.WHITE;
                indices.push(i * 2, i * 2 + 1);
                positionData.push(start.x, start.y, start.z, end.x, end.y, end.z);
                colorData.push(startColor.r, startColor.g, startColor.b, startColor.a, endColor.r, endColor.g, endColor.b, endColor.a);
            }
            this.setVAData("a_position", positionData, 3);
            this.setVAData("a_color", colorData, 4);
            this.indices = indices;
        };
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], SegmentGeometry.prototype, "segments", null);
        return SegmentGeometry;
    }(feng3d.Geometry));
    feng3d.SegmentGeometry = SegmentGeometry;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 坐标系统类型

     */
    var CoordinateSystem = /** @class */ (function () {
        function CoordinateSystem() {
        }
        /**
         * 默认坐标系统，左手坐标系统
         */
        CoordinateSystem.LEFT_HANDED = 0;
        /**
         * 右手坐标系统
         */
        CoordinateSystem.RIGHT_HANDED = 1;
        return CoordinateSystem;
    }());
    feng3d.CoordinateSystem = CoordinateSystem;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 摄像机镜头
     *
     * 镜头主要作用是投影以及逆投影。
     * 投影指的是从摄像机空间可视区域内的坐标投影至GPU空间可视区域内的坐标。
     *
     * 摄像机可视区域：由近、远，上，下，左，右组成的四棱柱
     * GPU空间可视区域：立方体 [(-1, -1, -1), (1, 1, 1)]
     *
     */
    var LensBase = /** @class */ (function (_super) {
        __extends(LensBase, _super);
        /**
         * 创建一个摄像机镜头
         */
        function LensBase(aspectRatio, near, far) {
            if (aspectRatio === void 0) { aspectRatio = 1; }
            if (near === void 0) { near = 0.3; }
            if (far === void 0) { far = 1000; }
            var _this = _super.call(this) || this;
            //
            _this._matrixInvalid = true;
            _this._invertMatrixInvalid = true;
            _this._inverseMatrix = new feng3d.Matrix4x4();
            _this._viewBoxInvalid = true;
            //
            _this._viewBox = new feng3d.AABB();
            _this._matrix = new feng3d.Matrix4x4();
            _this.aspect = aspectRatio;
            _this.near = near;
            _this.far = far;
            return _this;
        }
        Object.defineProperty(LensBase.prototype, "near", {
            /**
             * 最近距离
             */
            get: function () {
                return this._near;
            },
            set: function (v) {
                if (this._near == v)
                    return;
                this._near = v;
                this.invalidate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LensBase.prototype, "far", {
            /**
             * 最远距离
             */
            get: function () {
                return this._far;
            },
            set: function (v) {
                if (this._far == v)
                    return;
                this._far = v;
                this.invalidate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LensBase.prototype, "aspect", {
            /**
             * 视窗缩放比例(width/height)，在渲染器中设置
             */
            get: function () {
                return this._aspect;
            },
            set: function (v) {
                if (this._aspect == v)
                    return;
                this._aspect = v;
                this.invalidate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LensBase.prototype, "matrix", {
            /**
             * 投影矩阵
             */
            get: function () {
                if (this._matrixInvalid) {
                    this.updateMatrix();
                    this._matrixInvalid = false;
                }
                return this._matrix;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LensBase.prototype, "inverseMatrix", {
            /**
             * 逆矩阵
             */
            get: function () {
                if (this._invertMatrixInvalid) {
                    this._inverseMatrix.copyFrom(this.matrix);
                    this._inverseMatrix.invert();
                    this._matrixInvalid = false;
                }
                return this._inverseMatrix;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LensBase.prototype, "viewBox", {
            /**
             * 可视包围盒
             *
             * 一个包含可视空间的最小包围盒
             */
            get: function () {
                if (this._viewBoxInvalid) {
                    this.updateViewBox();
                    this._viewBoxInvalid = false;
                }
                return this._viewBox;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 摄像机空间坐标投影到GPU空间坐标
         * @param point3d 摄像机空间坐标
         * @param v GPU空间坐标
         * @return GPU空间坐标
         */
        LensBase.prototype.project = function (point3d, v) {
            if (v === void 0) { v = new feng3d.Vector3(); }
            var v4 = this.matrix.transformVector4(feng3d.Vector4.fromVector3(point3d, 1));
            v4.toVector3(v);
            return v;
        };
        /**
         * GPU空间坐标投影到摄像机空间坐标
         * @param point3d GPU空间坐标
         * @param v 摄像机空间坐标（输出）
         * @returns 摄像机空间坐标
         */
        LensBase.prototype.unproject = function (point3d, v) {
            if (v === void 0) { v = new feng3d.Vector3(); }
            var v4 = this.inverseMatrix.transformVector4(feng3d.Vector4.fromVector3(point3d, 1));
            v4.toVector3(v);
            return v;
        };
        /**
         * 逆投影求射线
         *
         * 通过GPU空间坐标x与y值求出摄像机空间坐标的射线
         *
         * @param x GPU空间坐标x值
         * @param y GPU空间坐标y值
         */
        LensBase.prototype.unprojectRay = function (x, y, ray) {
            if (ray === void 0) { ray = new feng3d.Ray3D(); }
            var p0 = this.unproject(new feng3d.Vector3(x, y, 0));
            var p1 = this.unproject(new feng3d.Vector3(x, y, 1));
            // 初始化射线
            ray.fromPosAndDir(p0, p1.sub(p0));
            // 获取z==0的点
            var sp = ray.getPointWithZ(0);
            ray.position = sp;
            return ray;
        };
        /**
         * 指定深度逆投影
         *
         * 获取投影在指定GPU坐标且摄像机前方（深度）sZ处的点的3D坐标
         *
         * @param nX GPU空间坐标X
         * @param nY GPU空间坐标Y
         * @param sZ 到摄像机的距离
         * @param v 摄像机空间坐标（输出）
         * @return 摄像机空间坐标
         */
        LensBase.prototype.unprojectWithDepth = function (nX, nY, sZ, v) {
            if (v === void 0) { v = new feng3d.Vector3(); }
            return this.unprojectRay(nX, nY).getPointWithZ(sZ, v);
        };
        /**
         * 投影矩阵失效
         */
        LensBase.prototype.invalidate = function () {
            feng3d.debuger && console.assert(!isNaN(this.aspect));
            this._matrixInvalid = true;
            this._invertMatrixInvalid = true;
            this._viewBoxInvalid = true;
            this.dispatch("lensChanged", this);
        };
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], LensBase.prototype, "near", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], LensBase.prototype, "far", null);
        return LensBase;
    }(feng3d.Feng3dObject));
    feng3d.LensBase = LensBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 正射投影镜头
     */
    var OrthographicLens = /** @class */ (function (_super) {
        __extends(OrthographicLens, _super);
        /**
         * 构建正射投影镜头
         * @param size 尺寸
         */
        function OrthographicLens(size, aspect, near, far) {
            if (size === void 0) { size = 1; }
            if (aspect === void 0) { aspect = 1; }
            if (near === void 0) { near = 0.3; }
            if (far === void 0) { far = 1000; }
            var _this = _super.call(this, aspect, near, far) || this;
            _this.size = size;
            return _this;
        }
        Object.defineProperty(OrthographicLens.prototype, "size", {
            /**
             * 尺寸
             */
            get: function () {
                return this._size;
            },
            set: function (v) {
                if (this._size == v)
                    return;
                this._size = v;
                this.invalidate();
            },
            enumerable: true,
            configurable: true
        });
        OrthographicLens.prototype.updateMatrix = function () {
            this._matrix.setOrtho(-this._size, this._size, this._size, -this._size, this.near, this.far);
        };
        OrthographicLens.prototype.updateViewBox = function () {
            var left = -this._size * this.aspect;
            var right = this._size * this.aspect;
            var top = this._size;
            var bottom = -this._size;
            var near = this.near;
            var far = this.far;
            this._viewBox.fromPoints([
                new feng3d.Vector3(left, bottom, near),
                new feng3d.Vector3(left, bottom, far),
                new feng3d.Vector3(left, top, near),
                new feng3d.Vector3(left, top, far),
                new feng3d.Vector3(right, bottom, near),
                new feng3d.Vector3(right, bottom, far),
                new feng3d.Vector3(right, top, near),
                new feng3d.Vector3(right, top, far),
            ]);
        };
        OrthographicLens.prototype.clone = function () {
            return new OrthographicLens(this._size, this.aspect, this.near, this.far);
        };
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], OrthographicLens.prototype, "size", null);
        return OrthographicLens;
    }(feng3d.LensBase));
    feng3d.OrthographicLens = OrthographicLens;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 透视摄像机镜头

     */
    var PerspectiveLens = /** @class */ (function (_super) {
        __extends(PerspectiveLens, _super);
        /**
         * 创建一个透视摄像机镜头
         * @param fov 垂直视角，视锥体顶面和底面间的夹角；单位为角度，取值范围 [1,179]
         *
         */
        function PerspectiveLens(fov, aspect, near, far) {
            if (fov === void 0) { fov = 60; }
            if (aspect === void 0) { aspect = 1; }
            if (near === void 0) { near = 0.3; }
            if (far === void 0) { far = 1000; }
            var _this = _super.call(this, aspect, near, far) || this;
            _this.fov = fov;
            return _this;
        }
        Object.defineProperty(PerspectiveLens.prototype, "fov", {
            /**
             * 垂直视角，视锥体顶面和底面间的夹角；单位为角度，取值范围 [1,179]
             */
            get: function () {
                return this._fov;
            },
            set: function (v) {
                if (this._fov == v)
                    return;
                this._fov = v;
                this.invalidate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PerspectiveLens.prototype, "focalLength", {
            /**
             * 焦距
             */
            get: function () {
                return 1 / Math.tan(this._fov * Math.PI / 360);
            },
            set: function (value) {
                this.fov = Math.atan(1 / value) * 360 / Math.PI;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 投影
         *
         * 摄像机空间坐标投影到GPU空间坐标
         *
         * @param point3d 摄像机空间坐标
         * @param v GPU空间坐标
         * @return GPU空间坐标
         */
        PerspectiveLens.prototype.project = function (point3d, v) {
            if (v === void 0) { v = new feng3d.Vector3(); }
            var v4 = this.matrix.transformVector4(feng3d.Vector4.fromVector3(point3d, 1));
            // 透视投影结果中w!=1，需要标准化齐次坐标
            v4.scale(1 / v4.w);
            v4.toVector3(v);
            return v;
        };
        /**
         * 逆投影
         *
         * GPU空间坐标投影到摄像机空间坐标
         *
         * @param point3d GPU空间坐标
         * @param v 摄像机空间坐标（输出）
         * @returns 摄像机空间坐标
         */
        PerspectiveLens.prototype.unproject = function (point3d, v) {
            if (v === void 0) { v = new feng3d.Vector3(); }
            // ！！该计算过程需要参考或者研究透视投影矩阵
            // 初始化齐次坐标
            var p4 = feng3d.Vector4.fromVector3(point3d, 1);
            // 逆投影求出深度值
            var v4 = this.inverseMatrix.transformVector4(p4);
            var sZ = 1 / v4.w;
            // 齐次坐标乘以深度值获取真实的投影结果
            var p44 = p4.scaleTo(sZ);
            // 计算逆投影
            var v44 = this.inverseMatrix.transformVector4(p44);
            // 输出3维坐标
            v44.toVector3(v);
            return v;
        };
        PerspectiveLens.prototype.updateMatrix = function () {
            this._matrix.setPerspectiveFromFOV(this._fov, this.aspect, this.near, this.far);
        };
        PerspectiveLens.prototype.updateViewBox = function () {
            var fov = this._fov;
            var aspect = this.aspect;
            var near = this.near;
            var far = this.far;
            var tan = Math.tan(fov * Math.PI / 360);
            this._viewBox.fromPoints([
                new feng3d.Vector3(-tan * near * aspect, -tan * near, near),
                new feng3d.Vector3(-tan * far * aspect, -tan * far, far),
                new feng3d.Vector3(-tan * near * aspect, tan * near, near),
                new feng3d.Vector3(-tan * far * aspect, tan * far, far),
                new feng3d.Vector3(tan * near * aspect, -tan * near, near),
                new feng3d.Vector3(tan * far * aspect, -tan * far, far),
                new feng3d.Vector3(tan * near * aspect, tan * near, near),
                new feng3d.Vector3(tan * far * aspect, tan * far, far)
            ]);
        };
        PerspectiveLens.prototype.clone = function () {
            return new PerspectiveLens(this._fov, this._aspect, this._near, this._far);
        };
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], PerspectiveLens.prototype, "fov", null);
        return PerspectiveLens;
    }(feng3d.LensBase));
    feng3d.PerspectiveLens = PerspectiveLens;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 摄像机投影类型
     */
    var Projection;
    (function (Projection) {
        /**
         * 透视投影
         */
        Projection[Projection["Perspective"] = 0] = "Perspective";
        /**
         * 正交投影
         */
        Projection[Projection["Orthographic"] = 1] = "Orthographic";
    })(Projection = feng3d.Projection || (feng3d.Projection = {}));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 摄像机
     */
    var Camera = /** @class */ (function (_super) {
        __extends(Camera, _super);
        function Camera() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.__class__ = "feng3d.Camera";
            _this._projection = feng3d.Projection.Perspective;
            _this._viewProjection = new feng3d.Matrix4x4();
            _this._viewProjectionInvalid = true;
            _this._viewBox = new feng3d.AABB();
            _this._viewBoxInvalid = true;
            _this._backups = { fov: 60, size: 1 };
            return _this;
        }
        Object.defineProperty(Camera.prototype, "single", {
            get: function () { return true; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "projection", {
            get: function () {
                return this._projection;
            },
            set: function (v) {
                if (this._projection == v)
                    return;
                this._projection = v;
                this.onProjectionChanged();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "lens", {
            /**
             * 镜头
             */
            get: function () {
                return this._lens;
            },
            set: function (v) {
                if (this._lens == v)
                    return;
                if (this._lens)
                    this._lens.off("lensChanged", this.onLensChanged, this);
                this._lens = v;
                if (this._lens)
                    this._lens.on("lensChanged", this.onLensChanged, this);
                this.onLensChanged();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "viewProjection", {
            /**
             * 场景投影矩阵，世界空间转投影空间
             */
            get: function () {
                if (this._viewProjectionInvalid) {
                    //场景空间转摄像机空间
                    this._viewProjection.copyFrom(this.transform.worldToLocalMatrix);
                    //+摄像机空间转投影空间 = 场景空间转投影空间
                    this._viewProjection.append(this._lens.matrix);
                    this._viewProjectionInvalid = false;
                }
                return this._viewProjection;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "viewBox", {
            /**
             * 可视包围盒
             */
            get: function () {
                if (this._viewBoxInvalid) {
                    this.updateViewBox();
                    this._viewBoxInvalid = false;
                }
                return this._viewBox;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 创建一个摄像机
         */
        Camera.prototype.init = function () {
            _super.prototype.init.call(this);
            this.lens = this.lens || new feng3d.PerspectiveLens();
            //
            this.on("scenetransformChanged", this.onScenetransformChanged, this);
            this._viewProjectionInvalid = true;
        };
        /**
         * 获取与坐标重叠的射线
         * @param x view3D上的X坐标
         * @param y view3D上的X坐标
         * @return
         */
        Camera.prototype.getRay3D = function (x, y, ray3D) {
            if (ray3D === void 0) { ray3D = new feng3d.Ray3D(); }
            return this.lens.unprojectRay(x, y, ray3D).applyMatri4x4(this.transform.localToWorldMatrix);
        };
        /**
         * 投影坐标（世界坐标转换为3D视图坐标）
         * @param point3d 世界坐标
         * @return 屏幕的绝对坐标
         */
        Camera.prototype.project = function (point3d) {
            var v = this.lens.project(this.transform.worldToLocalMatrix.transformVector(point3d));
            return v;
        };
        /**
         * 屏幕坐标投影到场景坐标
         * @param nX 屏幕坐标X ([0-width])
         * @param nY 屏幕坐标Y ([0-height])
         * @param sZ 到屏幕的距离
         * @param v 场景坐标（输出）
         * @return 场景坐标
         */
        Camera.prototype.unproject = function (sX, sY, sZ, v) {
            if (v === void 0) { v = new feng3d.Vector3(); }
            return this.transform.localToWorldMatrix.transformVector(this.lens.unprojectWithDepth(sX, sY, sZ, v), v);
        };
        /**
         * 获取摄像机能够在指定深度处的视野；镜头在指定深度的尺寸。
         *
         * @param   depth   深度
         */
        Camera.prototype.getScaleByDepth = function (depth, dir) {
            if (dir === void 0) { dir = new feng3d.Vector2(0, 1); }
            var lt = this.unproject(-0.5 * dir.x, -0.5 * dir.y, depth);
            var rb = this.unproject(+0.5 * dir.x, +0.5 * dir.y, depth);
            var scale = lt.subTo(rb).length;
            return scale;
        };
        /**
         * 是否与盒子相交
         * @param box 盒子
         */
        Camera.prototype.intersectsBox = function (box) {
            var _this = this;
            // 投影后的包围盒
            var box0 = feng3d.AABB.fromPoints(box.toPoints().map(function (v) { return _this.lens.project(_this.transform.worldToLocalMatrix.transformVector(v)); }));
            var intersects = box0.intersects(visibleBox);
            return intersects;
        };
        /**
         * 处理场景变换改变事件
         */
        Camera.prototype.onScenetransformChanged = function () {
            this._viewProjectionInvalid = true;
        };
        /**
         * 更新可视区域顶点
         */
        Camera.prototype.updateViewBox = function () {
            this._viewBox.copy(this.lens.viewBox);
            this._viewBox.applyMatrix3D(this.transform.localToWorldMatrix);
        };
        /**
         * 处理镜头变化事件
         */
        Camera.prototype.onLensChanged = function () {
            this._viewProjectionInvalid = true;
            if (this.lens instanceof feng3d.PerspectiveLens) {
                this.projection = feng3d.Projection.Perspective;
            }
            else if (this.lens instanceof feng3d.OrthographicLens) {
                this.projection = feng3d.Projection.Orthographic;
            }
            this.dispatch("refreshView");
            this.dispatch("lensChanged");
        };
        Camera.prototype.onProjectionChanged = function () {
            var aspect = 1;
            var near = 0.3;
            var far = 1000;
            if (this.lens) {
                aspect = this.lens.aspect;
                near = this.lens.near;
                far = this.lens.far;
                feng3d.serialization.setValue(this._backups, this.lens);
            }
            var fov = this._backups ? this._backups.fov : 60;
            var size = this._backups ? this._backups.size : 1;
            if (this.projection == feng3d.Projection.Perspective) {
                if (!(this.lens instanceof feng3d.PerspectiveLens)) {
                    this.lens = new feng3d.PerspectiveLens(fov, aspect, near, far);
                }
            }
            else if (this.projection == feng3d.Projection.Orthographic) {
                if (!(this.lens instanceof feng3d.OrthographicLens)) {
                    this.lens = new feng3d.OrthographicLens(size, aspect, near, far);
                }
            }
        };
        __decorate([
            feng3d.oav({ component: "OAVEnum", componentParam: { enumClass: feng3d.Projection } })
        ], Camera.prototype, "projection", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ component: "OAVObjectView" })
        ], Camera.prototype, "lens", null);
        return Camera;
    }(feng3d.Component));
    feng3d.Camera = Camera;
    // 投影后可视区域
    var visibleBox = new feng3d.AABB(new feng3d.Vector3(-1, -1, -1), new feng3d.Vector3(1, 1, 1));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 平面几何体
     */
    var PlaneGeometry = /** @class */ (function (_super) {
        __extends(PlaneGeometry, _super);
        function PlaneGeometry() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.__class__ = "feng3d.PlaneGeometry";
            _this._width = 1;
            _this._height = 1;
            _this._segmentsW = 1;
            _this._segmentsH = 1;
            _this._yUp = true;
            _this.name = "Plane";
            return _this;
        }
        Object.defineProperty(PlaneGeometry.prototype, "width", {
            /**
             * 宽度
             */
            get: function () {
                return this._width;
            },
            set: function (v) {
                if (this._width == v)
                    return;
                this._width = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PlaneGeometry.prototype, "height", {
            /**
             * 高度
             */
            get: function () {
                return this._height;
            },
            set: function (v) {
                if (this._height == v)
                    return;
                this._height = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PlaneGeometry.prototype, "segmentsW", {
            /**
             * 横向分割数
             */
            get: function () {
                return this._segmentsW;
            },
            set: function (v) {
                if (this._segmentsW == v)
                    return;
                this._segmentsW = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PlaneGeometry.prototype, "segmentsH", {
            /**
             * 纵向分割数
             */
            get: function () {
                return this._segmentsH;
            },
            set: function (v) {
                if (this._segmentsH == v)
                    return;
                this._segmentsH = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PlaneGeometry.prototype, "yUp", {
            /**
             * 是否朝上
             */
            get: function () {
                return this._yUp;
            },
            set: function (v) {
                if (this._yUp == v)
                    return;
                this._yUp = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 构建几何体数据
         */
        PlaneGeometry.prototype.buildGeometry = function () {
            var vertexPositionData = this.buildPosition();
            this.setVAData("a_position", vertexPositionData, 3);
            var vertexNormalData = this.buildNormal();
            this.setVAData("a_normal", vertexNormalData, 3);
            var vertexTangentData = this.buildTangent();
            this.setVAData("a_tangent", vertexTangentData, 3);
            var uvData = this.buildUVs();
            this.setVAData("a_uv", uvData, 2);
            var indices = this.buildIndices();
            this.indices = indices;
        };
        /**
         * 构建顶点坐标
         * @param this.width 宽度
         * @param this.height 高度
         * @param this.segmentsW 横向分割数
         * @param this.segmentsH 纵向分割数
         * @param this.yUp 正面朝向 true:Y+ false:Z+
         */
        PlaneGeometry.prototype.buildPosition = function () {
            var vertexPositionData = [];
            var x, y;
            var positionIndex = 0;
            for (var yi = 0; yi <= this.segmentsH; ++yi) {
                for (var xi = 0; xi <= this.segmentsW; ++xi) {
                    x = (xi / this.segmentsW - .5) * this.width;
                    y = (yi / this.segmentsH - .5) * this.height;
                    //设置坐标数据
                    vertexPositionData[positionIndex++] = x;
                    if (this.yUp) {
                        vertexPositionData[positionIndex++] = 0;
                        vertexPositionData[positionIndex++] = y;
                    }
                    else {
                        vertexPositionData[positionIndex++] = y;
                        vertexPositionData[positionIndex++] = 0;
                    }
                }
            }
            return vertexPositionData;
        };
        /**
         * 构建顶点法线
         * @param this.segmentsW 横向分割数
         * @param this.segmentsH 纵向分割数
         * @param this.yUp 正面朝向 true:Y+ false:Z+
         */
        PlaneGeometry.prototype.buildNormal = function () {
            var vertexNormalData = [];
            var normalIndex = 0;
            for (var yi = 0; yi <= this.segmentsH; ++yi) {
                for (var xi = 0; xi <= this.segmentsW; ++xi) {
                    //设置法线数据
                    vertexNormalData[normalIndex++] = 0;
                    if (this.yUp) {
                        vertexNormalData[normalIndex++] = 1;
                        vertexNormalData[normalIndex++] = 0;
                    }
                    else {
                        vertexNormalData[normalIndex++] = 0;
                        vertexNormalData[normalIndex++] = 1;
                    }
                }
            }
            return vertexNormalData;
        };
        /**
         * 构建顶点切线
         * @param this.segmentsW 横向分割数
         * @param this.segmentsH 纵向分割数
         * @param this.yUp 正面朝向 true:Y+ false:Z+
         */
        PlaneGeometry.prototype.buildTangent = function () {
            var vertexTangentData = [];
            var tangentIndex = 0;
            for (var yi = 0; yi <= this.segmentsH; ++yi) {
                for (var xi = 0; xi <= this.segmentsW; ++xi) {
                    if (this.yUp) {
                        vertexTangentData[tangentIndex++] = 1;
                        vertexTangentData[tangentIndex++] = 0;
                        vertexTangentData[tangentIndex++] = 0;
                    }
                    else {
                        vertexTangentData[tangentIndex++] = -1;
                        vertexTangentData[tangentIndex++] = 0;
                        vertexTangentData[tangentIndex++] = 0;
                    }
                }
            }
            return vertexTangentData;
        };
        /**
         * 构建顶点索引
         * @param this.segmentsW 横向分割数
         * @param this.segmentsH 纵向分割数
         * @param this.yUp 正面朝向 true:Y+ false:Z+
         */
        PlaneGeometry.prototype.buildIndices = function () {
            var indices = [];
            var tw = this.segmentsW + 1;
            var numIndices = 0;
            var base;
            for (var yi = 0; yi <= this.segmentsH; ++yi) {
                for (var xi = 0; xi <= this.segmentsW; ++xi) {
                    //生成索引数据
                    if (xi != this.segmentsW && yi != this.segmentsH) {
                        base = xi + yi * tw;
                        if (this.yUp) {
                            indices[numIndices++] = base;
                            indices[numIndices++] = base + tw;
                            indices[numIndices++] = base + tw + 1;
                            indices[numIndices++] = base;
                            indices[numIndices++] = base + tw + 1;
                            indices[numIndices++] = base + 1;
                        }
                        else {
                            indices[numIndices++] = base;
                            indices[numIndices++] = base + tw + 1;
                            indices[numIndices++] = base + tw;
                            indices[numIndices++] = base;
                            indices[numIndices++] = base + 1;
                            indices[numIndices++] = base + tw + 1;
                        }
                    }
                }
            }
            return indices;
        };
        /**
         * 构建uv
         * @param this.segmentsW 横向分割数
         * @param this.segmentsH 纵向分割数
         */
        PlaneGeometry.prototype.buildUVs = function () {
            var data = [];
            var index = 0;
            for (var yi = 0; yi <= this.segmentsH; ++yi) {
                for (var xi = 0; xi <= this.segmentsW; ++xi) {
                    if (this.yUp) {
                        data[index++] = xi / this.segmentsW;
                        data[index++] = 1 - yi / this.segmentsH;
                    }
                    else {
                        data[index++] = 1 - xi / this.segmentsW;
                        data[index++] = 1 - yi / this.segmentsH;
                    }
                }
            }
            return data;
        };
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], PlaneGeometry.prototype, "width", null);
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], PlaneGeometry.prototype, "height", null);
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], PlaneGeometry.prototype, "segmentsW", null);
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], PlaneGeometry.prototype, "segmentsH", null);
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], PlaneGeometry.prototype, "yUp", null);
        return PlaneGeometry;
    }(feng3d.Geometry));
    feng3d.PlaneGeometry = PlaneGeometry;
    feng3d.AssetData.addAssetData("Plane", feng3d.Geometry.plane = feng3d.serialization.setValue(new PlaneGeometry(), { name: "Plane", assetId: "Plane", width: 10, height: 10, hideFlags: feng3d.HideFlags.NotEditable }));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 立（长）方体几何体
     */
    var CubeGeometry = /** @class */ (function (_super) {
        __extends(CubeGeometry, _super);
        function CubeGeometry() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.__class__ = "feng3d.CubeGeometry";
            _this.name = "Cube";
            _this._width = 1;
            _this._height = 1;
            _this._depth = 1;
            _this._segmentsW = 1;
            _this._segmentsH = 1;
            _this._segmentsD = 1;
            _this._tile6 = false;
            return _this;
        }
        Object.defineProperty(CubeGeometry.prototype, "width", {
            /**
             * 宽度
             */
            get: function () {
                return this._width;
            },
            set: function (v) {
                if (this._width == v)
                    return;
                this._width = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CubeGeometry.prototype, "height", {
            /**
             * 高度
             */
            get: function () {
                return this._height;
            },
            set: function (v) {
                if (this._height == v)
                    return;
                this._height = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CubeGeometry.prototype, "depth", {
            /**
             * 深度
             */
            get: function () {
                return this._depth;
            },
            set: function (v) {
                if (this._depth == v)
                    return;
                this._depth = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CubeGeometry.prototype, "segmentsW", {
            /**
             * 宽度方向分割数
             */
            get: function () {
                return this._segmentsW;
            },
            set: function (v) {
                if (this._segmentsW == v)
                    return;
                this._segmentsW = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CubeGeometry.prototype, "segmentsH", {
            /**
             * 高度方向分割数
             */
            get: function () {
                return this._segmentsH;
            },
            set: function (v) {
                if (this._segmentsH == v)
                    return;
                this._segmentsH = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CubeGeometry.prototype, "segmentsD", {
            /**
             * 深度方向分割数
             */
            get: function () {
                return this._segmentsD;
            },
            set: function (v) {
                if (this._segmentsD == v)
                    return;
                this._segmentsD = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CubeGeometry.prototype, "tile6", {
            /**
             * 是否为6块贴图，默认true。
             */
            get: function () {
                return this._tile6;
            },
            set: function (v) {
                if (this._tile6 == v)
                    return;
                this._tile6 = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        CubeGeometry.prototype.buildGeometry = function () {
            var vertexPositionData = this.buildPosition();
            this.setVAData("a_position", vertexPositionData, 3);
            var vertexNormalData = this.buildNormal();
            this.setVAData("a_normal", vertexNormalData, 3);
            var vertexTangentData = this.buildTangent();
            this.setVAData("a_tangent", vertexTangentData, 3);
            var uvData = this.buildUVs();
            this.setVAData("a_uv", uvData, 2);
            var indices = this.buildIndices();
            this.indices = indices;
        };
        /**
         * 构建坐标
         * @param   width           宽度
         * @param   height          高度
         * @param   depth           深度
         * @param   segmentsW       宽度方向分割
         * @param   segmentsH       高度方向分割
         * @param   segmentsD       深度方向分割
         */
        CubeGeometry.prototype.buildPosition = function () {
            var vertexPositionData = [];
            var i, j;
            var hw, hh, hd; // halves
            var dw, dh, dd; // deltas
            var outer_pos;
            // Indices
            var positionIndex = 0;
            // half cube dimensions
            hw = this.width / 2;
            hh = this.height / 2;
            hd = this.depth / 2;
            // Segment dimensions
            dw = this.width / this.segmentsW;
            dh = this.height / this.segmentsH;
            dd = this.depth / this.segmentsD;
            for (i = 0; i <= this.segmentsW; i++) {
                outer_pos = -hw + i * dw;
                for (j = 0; j <= this.segmentsH; j++) {
                    // front
                    vertexPositionData[positionIndex++] = outer_pos;
                    vertexPositionData[positionIndex++] = -hh + j * dh;
                    vertexPositionData[positionIndex++] = -hd;
                    // back
                    vertexPositionData[positionIndex++] = outer_pos;
                    vertexPositionData[positionIndex++] = -hh + j * dh;
                    vertexPositionData[positionIndex++] = hd;
                }
            }
            for (i = 0; i <= this.segmentsW; i++) {
                outer_pos = -hw + i * dw;
                for (j = 0; j <= this.segmentsD; j++) {
                    // top
                    vertexPositionData[positionIndex++] = outer_pos;
                    vertexPositionData[positionIndex++] = hh;
                    vertexPositionData[positionIndex++] = -hd + j * dd;
                    // bottom
                    vertexPositionData[positionIndex++] = outer_pos;
                    vertexPositionData[positionIndex++] = -hh;
                    vertexPositionData[positionIndex++] = -hd + j * dd;
                }
            }
            for (i = 0; i <= this.segmentsD; i++) {
                outer_pos = hd - i * dd;
                for (j = 0; j <= this.segmentsH; j++) {
                    // left
                    vertexPositionData[positionIndex++] = -hw;
                    vertexPositionData[positionIndex++] = -hh + j * dh;
                    vertexPositionData[positionIndex++] = outer_pos;
                    // right
                    vertexPositionData[positionIndex++] = hw;
                    vertexPositionData[positionIndex++] = -hh + j * dh;
                    vertexPositionData[positionIndex++] = outer_pos;
                }
            }
            return vertexPositionData;
        };
        /**
         * 构建法线
         * @param   segmentsW       宽度方向分割
         * @param   segmentsH       高度方向分割
         * @param   segmentsD       深度方向分割
         */
        CubeGeometry.prototype.buildNormal = function () {
            var vertexNormalData = [];
            var i, j;
            // Indices
            var normalIndex = 0;
            for (i = 0; i <= this.segmentsW; i++) {
                for (j = 0; j <= this.segmentsH; j++) {
                    // front
                    vertexNormalData[normalIndex++] = 0;
                    vertexNormalData[normalIndex++] = 0;
                    vertexNormalData[normalIndex++] = -1;
                    // back
                    vertexNormalData[normalIndex++] = 0;
                    vertexNormalData[normalIndex++] = 0;
                    vertexNormalData[normalIndex++] = 1;
                }
            }
            for (i = 0; i <= this.segmentsW; i++) {
                for (j = 0; j <= this.segmentsD; j++) {
                    // top
                    vertexNormalData[normalIndex++] = 0;
                    vertexNormalData[normalIndex++] = 1;
                    vertexNormalData[normalIndex++] = 0;
                    // bottom
                    vertexNormalData[normalIndex++] = 0;
                    vertexNormalData[normalIndex++] = -1;
                    vertexNormalData[normalIndex++] = 0;
                }
            }
            for (i = 0; i <= this.segmentsD; i++) {
                for (j = 0; j <= this.segmentsH; j++) {
                    // left
                    vertexNormalData[normalIndex++] = -1;
                    vertexNormalData[normalIndex++] = 0;
                    vertexNormalData[normalIndex++] = 0;
                    // right
                    vertexNormalData[normalIndex++] = 1;
                    vertexNormalData[normalIndex++] = 0;
                    vertexNormalData[normalIndex++] = 0;
                }
            }
            return vertexNormalData;
        };
        /**
         * 构建切线
         * @param   segmentsW       宽度方向分割
         * @param   segmentsH       高度方向分割
         * @param   segmentsD       深度方向分割
         */
        CubeGeometry.prototype.buildTangent = function () {
            var vertexTangentData = [];
            var i, j;
            // Indices
            var tangentIndex = 0;
            for (i = 0; i <= this.segmentsW; i++) {
                for (j = 0; j <= this.segmentsH; j++) {
                    // front
                    vertexTangentData[tangentIndex++] = 1;
                    vertexTangentData[tangentIndex++] = 0;
                    vertexTangentData[tangentIndex++] = 0;
                    // back
                    vertexTangentData[tangentIndex++] = -1;
                    vertexTangentData[tangentIndex++] = 0;
                    vertexTangentData[tangentIndex++] = 0;
                }
            }
            for (i = 0; i <= this.segmentsW; i++) {
                for (j = 0; j <= this.segmentsD; j++) {
                    // top
                    vertexTangentData[tangentIndex++] = 1;
                    vertexTangentData[tangentIndex++] = 0;
                    vertexTangentData[tangentIndex++] = 0;
                    // bottom
                    vertexTangentData[tangentIndex++] = 1;
                    vertexTangentData[tangentIndex++] = 0;
                    vertexTangentData[tangentIndex++] = 0;
                }
            }
            for (i = 0; i <= this.segmentsD; i++) {
                for (j = 0; j <= this.segmentsH; j++) {
                    // left
                    vertexTangentData[tangentIndex++] = 0;
                    vertexTangentData[tangentIndex++] = 0;
                    vertexTangentData[tangentIndex++] = -1;
                    // right
                    vertexTangentData[tangentIndex++] = 0;
                    vertexTangentData[tangentIndex++] = 0;
                    vertexTangentData[tangentIndex++] = 1;
                }
            }
            return vertexTangentData;
        };
        /**
         * 构建索引
         * @param   segmentsW       宽度方向分割
         * @param   segmentsH       高度方向分割
         * @param   segmentsD       深度方向分割
         */
        CubeGeometry.prototype.buildIndices = function () {
            var indices = [];
            var tl, tr, bl, br;
            var i, j, inc = 0;
            var fidx = 0;
            for (i = 0; i <= this.segmentsW; i++) {
                for (j = 0; j <= this.segmentsH; j++) {
                    // front
                    // back
                    if (i && j) {
                        tl = 2 * ((i - 1) * (this.segmentsH + 1) + (j - 1));
                        tr = 2 * (i * (this.segmentsH + 1) + (j - 1));
                        bl = tl + 2;
                        br = tr + 2;
                        indices[fidx++] = tl;
                        indices[fidx++] = bl;
                        indices[fidx++] = br;
                        indices[fidx++] = tl;
                        indices[fidx++] = br;
                        indices[fidx++] = tr;
                        indices[fidx++] = tr + 1;
                        indices[fidx++] = br + 1;
                        indices[fidx++] = bl + 1;
                        indices[fidx++] = tr + 1;
                        indices[fidx++] = bl + 1;
                        indices[fidx++] = tl + 1;
                    }
                }
            }
            inc += 2 * (this.segmentsW + 1) * (this.segmentsH + 1);
            for (i = 0; i <= this.segmentsW; i++) {
                for (j = 0; j <= this.segmentsD; j++) {
                    // top
                    // bottom
                    if (i && j) {
                        tl = inc + 2 * ((i - 1) * (this.segmentsD + 1) + (j - 1));
                        tr = inc + 2 * (i * (this.segmentsD + 1) + (j - 1));
                        bl = tl + 2;
                        br = tr + 2;
                        indices[fidx++] = tl;
                        indices[fidx++] = bl;
                        indices[fidx++] = br;
                        indices[fidx++] = tl;
                        indices[fidx++] = br;
                        indices[fidx++] = tr;
                        indices[fidx++] = tr + 1;
                        indices[fidx++] = br + 1;
                        indices[fidx++] = bl + 1;
                        indices[fidx++] = tr + 1;
                        indices[fidx++] = bl + 1;
                        indices[fidx++] = tl + 1;
                    }
                }
            }
            inc += 2 * (this.segmentsW + 1) * (this.segmentsD + 1);
            for (i = 0; i <= this.segmentsD; i++) {
                for (j = 0; j <= this.segmentsH; j++) {
                    // left
                    // right
                    if (i && j) {
                        tl = inc + 2 * ((i - 1) * (this.segmentsH + 1) + (j - 1));
                        tr = inc + 2 * (i * (this.segmentsH + 1) + (j - 1));
                        bl = tl + 2;
                        br = tr + 2;
                        indices[fidx++] = tl;
                        indices[fidx++] = bl;
                        indices[fidx++] = br;
                        indices[fidx++] = tl;
                        indices[fidx++] = br;
                        indices[fidx++] = tr;
                        indices[fidx++] = tr + 1;
                        indices[fidx++] = br + 1;
                        indices[fidx++] = bl + 1;
                        indices[fidx++] = tr + 1;
                        indices[fidx++] = bl + 1;
                        indices[fidx++] = tl + 1;
                    }
                }
            }
            return indices;
        };
        /**
         * 构建uv
         * @param   segmentsW       宽度方向分割
         * @param   segmentsH       高度方向分割
         * @param   segmentsD       深度方向分割
         * @param   tile6           是否为6块贴图
         */
        CubeGeometry.prototype.buildUVs = function () {
            var i, j, uidx;
            var data = [];
            var u_tile_dim, v_tile_dim;
            var u_tile_step, v_tile_step;
            var tl0u, tl0v;
            var tl1u, tl1v;
            var du, dv;
            if (this.tile6) {
                u_tile_dim = u_tile_step = 1 / 3;
                v_tile_dim = v_tile_step = 1 / 2;
            }
            else {
                u_tile_dim = v_tile_dim = 1;
                u_tile_step = v_tile_step = 0;
            }
            // Create planes two and two, the same way that they were
            // constructed in the this.buildGeometry() function. First calculate
            // the top-left UV coordinate for both planes, and then loop
            // over the points, calculating the UVs from these numbers.
            // When this.tile6 is true, the layout is as follows:
            //       .-----.-----.-----. (1,1)
            //       | Bot |  T  | Bak |
            //       |-----+-----+-----|
            //       |  L  |  F  |  R  |
            // (0,0)'-----'-----'-----'
            uidx = 0;
            // FRONT / BACK
            tl0u = 1 * u_tile_step;
            tl0v = 1 * v_tile_step;
            tl1u = 2 * u_tile_step;
            tl1v = 0 * v_tile_step;
            du = u_tile_dim / this.segmentsW;
            dv = v_tile_dim / this.segmentsH;
            for (i = 0; i <= this.segmentsW; i++) {
                for (j = 0; j <= this.segmentsH; j++) {
                    data[uidx++] = tl0u + i * du;
                    data[uidx++] = tl0v + (v_tile_dim - j * dv);
                    data[uidx++] = tl1u + (u_tile_dim - i * du);
                    data[uidx++] = tl1v + (v_tile_dim - j * dv);
                }
            }
            // TOP / BOTTOM
            tl0u = 1 * u_tile_step;
            tl0v = 0 * v_tile_step;
            tl1u = 0 * u_tile_step;
            tl1v = 0 * v_tile_step;
            du = u_tile_dim / this.segmentsW;
            dv = v_tile_dim / this.segmentsD;
            for (i = 0; i <= this.segmentsW; i++) {
                for (j = 0; j <= this.segmentsD; j++) {
                    data[uidx++] = tl0u + i * du;
                    data[uidx++] = tl0v + (v_tile_dim - j * dv);
                    data[uidx++] = tl1u + i * du;
                    data[uidx++] = tl1v + j * dv;
                }
            }
            // LEFT / RIGHT
            tl0u = 0 * u_tile_step;
            tl0v = 1 * v_tile_step;
            tl1u = 2 * u_tile_step;
            tl1v = 1 * v_tile_step;
            du = u_tile_dim / this.segmentsD;
            dv = v_tile_dim / this.segmentsH;
            for (i = 0; i <= this.segmentsD; i++) {
                for (j = 0; j <= this.segmentsH; j++) {
                    data[uidx++] = tl0u + i * du;
                    data[uidx++] = tl0v + (v_tile_dim - j * dv);
                    data[uidx++] = tl1u + (u_tile_dim - i * du);
                    data[uidx++] = tl1v + (v_tile_dim - j * dv);
                }
            }
            return data;
        };
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], CubeGeometry.prototype, "width", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], CubeGeometry.prototype, "height", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], CubeGeometry.prototype, "depth", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], CubeGeometry.prototype, "segmentsW", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], CubeGeometry.prototype, "segmentsH", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], CubeGeometry.prototype, "segmentsD", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], CubeGeometry.prototype, "tile6", null);
        return CubeGeometry;
    }(feng3d.Geometry));
    feng3d.CubeGeometry = CubeGeometry;
    feng3d.AssetData.addAssetData("Cube", feng3d.Geometry.cube = feng3d.serialization.setValue(new CubeGeometry(), { name: "Cube", assetId: "Cube", hideFlags: feng3d.HideFlags.NotEditable }));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 球体几何体
     * @author DawnKing 2016-09-12
     */
    var SphereGeometry = /** @class */ (function (_super) {
        __extends(SphereGeometry, _super);
        function SphereGeometry() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.__class__ = "feng3d.SphereGeometry";
            _this._radius = 0.5;
            _this._segmentsW = 16;
            _this._segmentsH = 12;
            _this._yUp = true;
            _this.name = "Sphere";
            return _this;
        }
        Object.defineProperty(SphereGeometry.prototype, "radius", {
            /**
             * 球体半径
             */
            get: function () {
                return this._radius;
            },
            set: function (v) {
                if (this._radius == v)
                    return;
                this._radius = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SphereGeometry.prototype, "segmentsW", {
            /**
             * 横向分割数
             */
            get: function () {
                return this._segmentsW;
            },
            set: function (v) {
                if (this._segmentsW == v)
                    return;
                this._segmentsW = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SphereGeometry.prototype, "segmentsH", {
            /**
             * 纵向分割数
             */
            get: function () {
                return this._segmentsH;
            },
            set: function (v) {
                if (this._segmentsH == v)
                    return;
                this._segmentsH = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SphereGeometry.prototype, "yUp", {
            /**
             * 是否朝上
             */
            get: function () {
                return this._yUp;
            },
            set: function (v) {
                if (this._yUp == v)
                    return;
                this._yUp = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 构建几何体数据
         * @param this.radius 球体半径
         * @param this.segmentsW 横向分割数
         * @param this.segmentsH 纵向分割数
         * @param this.yUp 正面朝向 true:Y+ false:Z+
         */
        SphereGeometry.prototype.buildGeometry = function () {
            var vertexPositionData = [];
            var vertexNormalData = [];
            var vertexTangentData = [];
            var startIndex;
            var index = 0;
            var comp1, comp2, t1, t2;
            for (var yi = 0; yi <= this.segmentsH; ++yi) {
                startIndex = index;
                var horangle = Math.PI * yi / this.segmentsH;
                var z = -this.radius * Math.cos(horangle);
                var ringradius = this.radius * Math.sin(horangle);
                for (var xi = 0; xi <= this.segmentsW; ++xi) {
                    var verangle = 2 * Math.PI * xi / this.segmentsW;
                    var x = ringradius * Math.cos(verangle);
                    var y = ringradius * Math.sin(verangle);
                    var normLen = 1 / Math.sqrt(x * x + y * y + z * z);
                    var tanLen = Math.sqrt(y * y + x * x);
                    if (this.yUp) {
                        t1 = 0;
                        t2 = tanLen > .007 ? x / tanLen : 0;
                        comp1 = -z;
                        comp2 = y;
                    }
                    else {
                        t1 = tanLen > .007 ? x / tanLen : 0;
                        t2 = 0;
                        comp1 = y;
                        comp2 = z;
                    }
                    if (xi == this.segmentsW) {
                        vertexPositionData[index] = vertexPositionData[startIndex];
                        vertexPositionData[index + 1] = vertexPositionData[startIndex + 1];
                        vertexPositionData[index + 2] = vertexPositionData[startIndex + 2];
                        vertexNormalData[index] = vertexNormalData[startIndex] + x * normLen * 0.5;
                        vertexNormalData[index + 1] = vertexNormalData[startIndex + 1] + comp1 * normLen * 0.5;
                        vertexNormalData[index + 2] = vertexNormalData[startIndex + 2] + comp2 * normLen * 0.5;
                        vertexTangentData[index] = tanLen > .007 ? -y / tanLen : 1;
                        vertexTangentData[index + 1] = t1;
                        vertexTangentData[index + 2] = t2;
                    }
                    else {
                        vertexPositionData[index] = x;
                        vertexPositionData[index + 1] = comp1;
                        vertexPositionData[index + 2] = comp2;
                        vertexNormalData[index] = x * normLen;
                        vertexNormalData[index + 1] = comp1 * normLen;
                        vertexNormalData[index + 2] = comp2 * normLen;
                        vertexTangentData[index] = tanLen > .007 ? -y / tanLen : 1;
                        vertexTangentData[index + 1] = t1;
                        vertexTangentData[index + 2] = t2;
                    }
                    if (xi > 0 && yi > 0) {
                        if (yi == this.segmentsH) {
                            vertexPositionData[index] = vertexPositionData[startIndex];
                            vertexPositionData[index + 1] = vertexPositionData[startIndex + 1];
                            vertexPositionData[index + 2] = vertexPositionData[startIndex + 2];
                        }
                    }
                    index += 3;
                }
            }
            this.setVAData("a_position", vertexPositionData, 3);
            this.setVAData("a_normal", vertexNormalData, 3);
            this.setVAData("a_tangent", vertexTangentData, 3);
            var uvData = this.buildUVs();
            this.setVAData("a_uv", uvData, 2);
            var indices = this.buildIndices();
            this.indices = indices;
        };
        /**
         * 构建顶点索引
         * @param this.segmentsW 横向分割数
         * @param this.segmentsH 纵向分割数
         * @param this.yUp 正面朝向 true:Y+ false:Z+
         */
        SphereGeometry.prototype.buildIndices = function () {
            var indices = [];
            var numIndices = 0;
            for (var yi = 0; yi <= this.segmentsH; ++yi) {
                for (var xi = 0; xi <= this.segmentsW; ++xi) {
                    if (xi > 0 && yi > 0) {
                        var a = (this.segmentsW + 1) * yi + xi;
                        var b = (this.segmentsW + 1) * yi + xi - 1;
                        var c = (this.segmentsW + 1) * (yi - 1) + xi - 1;
                        var d = (this.segmentsW + 1) * (yi - 1) + xi;
                        if (yi == this.segmentsH) {
                            indices[numIndices++] = a;
                            indices[numIndices++] = c;
                            indices[numIndices++] = d;
                        }
                        else if (yi == 1) {
                            indices[numIndices++] = a;
                            indices[numIndices++] = b;
                            indices[numIndices++] = c;
                        }
                        else {
                            indices[numIndices++] = a;
                            indices[numIndices++] = b;
                            indices[numIndices++] = c;
                            indices[numIndices++] = a;
                            indices[numIndices++] = c;
                            indices[numIndices++] = d;
                        }
                    }
                }
            }
            return indices;
        };
        /**
         * 构建uv
         * @param this.segmentsW 横向分割数
         * @param this.segmentsH 纵向分割数
         */
        SphereGeometry.prototype.buildUVs = function () {
            var data = [];
            var index = 0;
            for (var yi = 0; yi <= this.segmentsH; ++yi) {
                for (var xi = 0; xi <= this.segmentsW; ++xi) {
                    data[index++] = xi / this.segmentsW;
                    data[index++] = yi / this.segmentsH;
                }
            }
            return data;
        };
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], SphereGeometry.prototype, "radius", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], SphereGeometry.prototype, "segmentsW", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], SphereGeometry.prototype, "segmentsH", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], SphereGeometry.prototype, "yUp", null);
        return SphereGeometry;
    }(feng3d.Geometry));
    feng3d.SphereGeometry = SphereGeometry;
    feng3d.AssetData.addAssetData("Sphere", feng3d.Geometry.sphere = feng3d.serialization.setValue(new SphereGeometry(), { name: "Sphere", assetId: "Sphere", hideFlags: feng3d.HideFlags.NotEditable }));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 胶囊体几何体
     */
    var CapsuleGeometry = /** @class */ (function (_super) {
        __extends(CapsuleGeometry, _super);
        function CapsuleGeometry() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.__class__ = "feng3d.CapsuleGeometry";
            _this._radius = 0.5;
            _this._height = 1;
            _this._segmentsW = 16;
            _this._segmentsH = 15;
            _this._yUp = true;
            _this.name = "Capsule";
            return _this;
        }
        Object.defineProperty(CapsuleGeometry.prototype, "radius", {
            /**
             * 胶囊体半径
             */
            get: function () {
                return this._radius;
            },
            set: function (v) {
                if (this._radius == v)
                    return;
                this._radius = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CapsuleGeometry.prototype, "height", {
            /**
             * 胶囊体高度
             */
            get: function () {
                return this._height;
            },
            set: function (v) {
                if (this._height == v)
                    return;
                this._height = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CapsuleGeometry.prototype, "segmentsW", {
            /**
             * 横向分割数
             */
            get: function () {
                return this._segmentsW;
            },
            set: function (v) {
                if (this._segmentsW == v)
                    return;
                this._segmentsW = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CapsuleGeometry.prototype, "segmentsH", {
            /**
             * 纵向分割数
             */
            get: function () {
                return this._segmentsH;
            },
            set: function (v) {
                if (this._segmentsH == v)
                    return;
                this._segmentsH = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CapsuleGeometry.prototype, "yUp", {
            /**
             * 正面朝向 true:Y+ false:Z+
             */
            get: function () {
                return this._yUp;
            },
            set: function (v) {
                if (this._yUp == v)
                    return;
                this._yUp = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 构建几何体数据
         * @param radius 胶囊体半径
         * @param height 胶囊体高度
         * @param segmentsW 横向分割数
         * @param segmentsH 纵向分割数
         * @param yUp 正面朝向 true:Y+ false:Z+
         */
        CapsuleGeometry.prototype.buildGeometry = function () {
            var vertexPositionData = [];
            var vertexNormalData = [];
            var vertexTangentData = [];
            var startIndex;
            var index = 0;
            var comp1, comp2, t1, t2;
            for (var yi = 0; yi <= this.segmentsH; ++yi) {
                startIndex = index;
                var horangle = Math.PI * yi / this.segmentsH;
                var z = -this.radius * Math.cos(horangle);
                var ringradius = this.radius * Math.sin(horangle);
                for (var xi = 0; xi <= this.segmentsW; ++xi) {
                    var verangle = 2 * Math.PI * xi / this.segmentsW;
                    var x = ringradius * Math.cos(verangle);
                    var y = ringradius * Math.sin(verangle);
                    var normLen = 1 / Math.sqrt(x * x + y * y + z * z);
                    var tanLen = Math.sqrt(y * y + x * x);
                    var offset = yi > this.segmentsH / 2 ? this.height / 2 : -this.height / 2;
                    if (this.yUp) {
                        t1 = 0;
                        t2 = tanLen > .007 ? x / tanLen : 0;
                        comp1 = -z;
                        comp2 = y;
                    }
                    else {
                        t1 = tanLen > .007 ? x / tanLen : 0;
                        t2 = 0;
                        comp1 = y;
                        comp2 = z;
                    }
                    if (xi == this.segmentsW) {
                        vertexPositionData[index] = vertexPositionData[startIndex];
                        vertexPositionData[index + 1] = vertexPositionData[startIndex + 1];
                        vertexPositionData[index + 2] = vertexPositionData[startIndex + 2];
                        vertexNormalData[index] = (vertexNormalData[startIndex] + x * normLen) * 0.5;
                        vertexNormalData[index + 1] = (vertexNormalData[startIndex + 1] + comp1 * normLen) * 0.5;
                        vertexNormalData[index + 2] = (vertexNormalData[startIndex + 2] + comp2 * normLen) * 0.5;
                        vertexTangentData[index] = (vertexTangentData[startIndex] + tanLen > .007 ? -y / tanLen : 1) * 0.5;
                        vertexTangentData[index + 1] = (vertexTangentData[startIndex + 1] + t1) * 0.5;
                        vertexTangentData[index + 2] = (vertexTangentData[startIndex + 2] + t2) * 0.5;
                    }
                    else {
                        vertexPositionData[index] = x;
                        vertexPositionData[index + 1] = this.yUp ? comp1 - offset : comp1;
                        vertexPositionData[index + 2] = this.yUp ? comp2 : comp2 + offset;
                        vertexNormalData[index] = x * normLen;
                        vertexNormalData[index + 1] = comp1 * normLen;
                        vertexNormalData[index + 2] = comp2 * normLen;
                        vertexTangentData[index] = tanLen > .007 ? -y / tanLen : 1;
                        vertexTangentData[index + 1] = t1;
                        vertexTangentData[index + 2] = t2;
                    }
                    if (xi > 0 && yi > 0) {
                        if (yi == this.segmentsH) {
                            vertexPositionData[index] = vertexPositionData[startIndex];
                            vertexPositionData[index + 1] = vertexPositionData[startIndex + 1];
                            vertexPositionData[index + 2] = vertexPositionData[startIndex + 2];
                        }
                    }
                    index += 3;
                }
            }
            this.setVAData("a_position", vertexPositionData, 3);
            this.setVAData("a_normal", vertexNormalData, 3);
            this.setVAData("a_tangent", vertexTangentData, 3);
            var uvData = this.buildUVs();
            this.setVAData("a_uv", uvData, 2);
            this.buildIndices();
        };
        /**
         * 构建顶点索引
         * @param segmentsW 横向分割数
         * @param segmentsH 纵向分割数
         * @param yUp 正面朝向 true:Y+ false:Z+
         */
        CapsuleGeometry.prototype.buildIndices = function () {
            var indices = [];
            var numIndices = 0;
            for (var yi = 0; yi <= this.segmentsH; ++yi) {
                for (var xi = 0; xi <= this.segmentsW; ++xi) {
                    if (xi > 0 && yi > 0) {
                        var a = (this.segmentsW + 1) * yi + xi;
                        var b = (this.segmentsW + 1) * yi + xi - 1;
                        var c = (this.segmentsW + 1) * (yi - 1) + xi - 1;
                        var d = (this.segmentsW + 1) * (yi - 1) + xi;
                        if (yi == this.segmentsH) {
                            indices[numIndices++] = a;
                            indices[numIndices++] = c;
                            indices[numIndices++] = d;
                        }
                        else if (yi == 1) {
                            indices[numIndices++] = a;
                            indices[numIndices++] = b;
                            indices[numIndices++] = c;
                        }
                        else {
                            indices[numIndices++] = a;
                            indices[numIndices++] = b;
                            indices[numIndices++] = c;
                            indices[numIndices++] = a;
                            indices[numIndices++] = c;
                            indices[numIndices++] = d;
                        }
                    }
                }
            }
            this.indices = indices;
        };
        /**
         * 构建uv
         * @param segmentsW 横向分割数
         * @param segmentsH 纵向分割数
         */
        CapsuleGeometry.prototype.buildUVs = function () {
            var data = [];
            var index = 0;
            for (var yi = 0; yi <= this.segmentsH; ++yi) {
                for (var xi = 0; xi <= this.segmentsW; ++xi) {
                    data[index++] = xi / this.segmentsW;
                    data[index++] = yi / this.segmentsH;
                }
            }
            return data;
        };
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], CapsuleGeometry.prototype, "radius", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], CapsuleGeometry.prototype, "height", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], CapsuleGeometry.prototype, "segmentsW", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], CapsuleGeometry.prototype, "segmentsH", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], CapsuleGeometry.prototype, "yUp", null);
        return CapsuleGeometry;
    }(feng3d.Geometry));
    feng3d.CapsuleGeometry = CapsuleGeometry;
    feng3d.AssetData.addAssetData("Capsule", feng3d.Geometry.capsule = feng3d.serialization.setValue(new CapsuleGeometry(), { name: "Capsule", assetId: "Capsule", hideFlags: feng3d.HideFlags.NotEditable }));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 圆柱体几何体
     * @author DawnKing 2016-09-12
     */
    var CylinderGeometry = /** @class */ (function (_super) {
        __extends(CylinderGeometry, _super);
        function CylinderGeometry() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.__class__ = "feng3d.CylinderGeometry";
            _this._topRadius = 0.5;
            _this._bottomRadius = 0.5;
            _this._height = 2;
            _this._segmentsW = 16;
            _this._segmentsH = 1;
            _this._topClosed = true;
            _this._bottomClosed = true;
            _this._surfaceClosed = true;
            _this._yUp = true;
            _this.name = "Cylinder";
            return _this;
        }
        Object.defineProperty(CylinderGeometry.prototype, "topRadius", {
            /**
             * 顶部半径
             */
            get: function () {
                return this._topRadius;
            },
            set: function (v) {
                if (this._topRadius == v)
                    return;
                this._topRadius = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CylinderGeometry.prototype, "bottomRadius", {
            /**
             * 底部半径
             */
            get: function () {
                return this._bottomRadius;
            },
            set: function (v) {
                if (this._bottomRadius == v)
                    return;
                this._bottomRadius = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CylinderGeometry.prototype, "height", {
            /**
             * 高度
             */
            get: function () {
                return this._height;
            },
            set: function (v) {
                if (this._height == v)
                    return;
                this._height = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CylinderGeometry.prototype, "segmentsW", {
            /**
             * 横向分割数
             */
            get: function () {
                return this._segmentsW;
            },
            set: function (v) {
                if (this._segmentsW == v)
                    return;
                this._segmentsW = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CylinderGeometry.prototype, "segmentsH", {
            /**
             * 纵向分割数
             */
            get: function () {
                return this._segmentsH;
            },
            set: function (v) {
                if (this._segmentsH == v)
                    return;
                this._segmentsH = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CylinderGeometry.prototype, "topClosed", {
            /**
             * 顶部是否封口
             */
            get: function () {
                return this._topClosed;
            },
            set: function (v) {
                if (this._topClosed == v)
                    return;
                this._topClosed = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CylinderGeometry.prototype, "bottomClosed", {
            /**
             * 底部是否封口
             */
            get: function () {
                return this._bottomClosed;
            },
            set: function (v) {
                if (this._bottomClosed == v)
                    return;
                this._bottomClosed = v;
                this.invalidateGeometry;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CylinderGeometry.prototype, "surfaceClosed", {
            /**
             * 侧面是否封口
             */
            get: function () {
                return this._surfaceClosed;
            },
            set: function (v) {
                if (this._surfaceClosed == v)
                    return;
                this._surfaceClosed = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CylinderGeometry.prototype, "yUp", {
            /**
             * 是否朝上
             */
            get: function () {
                return this._yUp;
            },
            set: function (v) {
                if (this._yUp == v)
                    return;
                this._yUp = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 构建几何体数据
         */
        CylinderGeometry.prototype.buildGeometry = function () {
            var i, j, index = 0;
            var x, y, z, radius, revolutionAngle = 0;
            var dr, latNormElev, latNormBase;
            var comp1, comp2;
            var startIndex = 0;
            var t1, t2;
            var vertexPositionData = [];
            var vertexNormalData = [];
            var vertexTangentData = [];
            var revolutionAngleDelta = 2 * Math.PI / this.segmentsW;
            // 顶部
            if (this.topClosed && this.topRadius > 0) {
                z = -0.5 * this.height;
                for (i = 0; i <= this.segmentsW; ++i) {
                    // 中心顶点
                    if (this.yUp) {
                        t1 = 1;
                        t2 = 0;
                        comp1 = -z;
                        comp2 = 0;
                    }
                    else {
                        t1 = 0;
                        t2 = -1;
                        comp1 = 0;
                        comp2 = z;
                    }
                    addVertex(0, comp1, comp2, 0, t1, t2, 1, 0, 0);
                    // 旋转顶点
                    revolutionAngle = i * revolutionAngleDelta;
                    x = this.topRadius * Math.cos(revolutionAngle);
                    y = this.topRadius * Math.sin(revolutionAngle);
                    if (this.yUp) {
                        comp1 = -z;
                        comp2 = y;
                    }
                    else {
                        comp1 = y;
                        comp2 = z;
                    }
                    if (i == this.segmentsW) {
                        addVertex(vertexPositionData[startIndex + 3], vertexPositionData[startIndex + 4], vertexPositionData[startIndex + 5], 0, t1, t2, 1, 0, 0);
                    }
                    else {
                        addVertex(x, comp1, comp2, 0, t1, t2, 1, 0, 0);
                    }
                }
            }
            // 底部
            if (this.bottomClosed && this.bottomRadius > 0) {
                z = 0.5 * this.height;
                startIndex = index;
                for (i = 0; i <= this.segmentsW; ++i) {
                    // 中心顶点
                    if (this.yUp) {
                        t1 = -1;
                        t2 = 0;
                        comp1 = -z;
                        comp2 = 0;
                    }
                    else {
                        t1 = 0;
                        t2 = 1;
                        comp1 = 0;
                        comp2 = z;
                    }
                    addVertex(0, comp1, comp2, 0, t1, t2, 1, 0, 0);
                    // 旋转顶点
                    revolutionAngle = i * revolutionAngleDelta;
                    x = this.bottomRadius * Math.cos(revolutionAngle);
                    y = this.bottomRadius * Math.sin(revolutionAngle);
                    if (this.yUp) {
                        comp1 = -z;
                        comp2 = y;
                    }
                    else {
                        comp1 = y;
                        comp2 = z;
                    }
                    if (i == this.segmentsW) {
                        addVertex(x, vertexPositionData[startIndex + 1], vertexPositionData[startIndex + 2], 0, t1, t2, 1, 0, 0);
                    }
                    else {
                        addVertex(x, comp1, comp2, 0, t1, t2, 1, 0, 0);
                    }
                }
            }
            // 侧面
            dr = this.bottomRadius - this.topRadius;
            latNormElev = dr / this.height;
            latNormBase = (latNormElev == 0) ? 1 : this.height / dr;
            if (this.surfaceClosed) {
                var a, b, c, d;
                var na0, na1, naComp1, naComp2;
                for (j = 0; j <= this.segmentsH; ++j) {
                    radius = this.topRadius - ((j / this.segmentsH) * (this.topRadius - this.bottomRadius));
                    z = -(this.height / 2) + (j / this.segmentsH * this.height);
                    startIndex = index;
                    for (i = 0; i <= this.segmentsW; ++i) {
                        revolutionAngle = i * revolutionAngleDelta;
                        x = radius * Math.cos(revolutionAngle);
                        y = radius * Math.sin(revolutionAngle);
                        na0 = latNormBase * Math.cos(revolutionAngle);
                        na1 = latNormBase * Math.sin(revolutionAngle);
                        if (this.yUp) {
                            t1 = 0;
                            t2 = -na0;
                            comp1 = -z;
                            comp2 = y;
                            naComp1 = latNormElev;
                            naComp2 = na1;
                        }
                        else {
                            t1 = -na0;
                            t2 = 0;
                            comp1 = y;
                            comp2 = z;
                            naComp1 = na1;
                            naComp2 = latNormElev;
                        }
                        if (i == this.segmentsW) {
                            addVertex(vertexPositionData[startIndex], vertexPositionData[startIndex + 1], vertexPositionData[startIndex + 2], na0, latNormElev, na1, na1, t1, t2);
                        }
                        else {
                            addVertex(x, comp1, comp2, na0, naComp1, naComp2, -na1, t1, t2);
                        }
                    }
                }
            }
            this.setVAData("a_position", vertexPositionData, 3);
            this.setVAData("a_normal", vertexNormalData, 3);
            this.setVAData("a_tangent", vertexTangentData, 3);
            function addVertex(px, py, pz, nx, ny, nz, tx, ty, tz) {
                vertexPositionData[index] = px;
                vertexPositionData[index + 1] = py;
                vertexPositionData[index + 2] = pz;
                vertexNormalData[index] = nx;
                vertexNormalData[index + 1] = ny;
                vertexNormalData[index + 2] = nz;
                vertexTangentData[index] = tx;
                vertexTangentData[index + 1] = ty;
                vertexTangentData[index + 2] = tz;
                index += 3;
            }
            //
            var uvData = this.buildUVs();
            this.setVAData("a_uv", uvData, 2);
            var indices = this.buildIndices();
            this.indices = indices;
        };
        /**
         * 构建顶点索引
         * @param segmentsW 横向分割数
         * @param segmentsH 纵向分割数
         * @param yUp 正面朝向 true:Y+ false:Z+
         */
        CylinderGeometry.prototype.buildIndices = function () {
            var i, j, index = 0;
            var indices = [];
            var numIndices = 0;
            // 顶部
            if (this.topClosed && this.topRadius > 0) {
                for (i = 0; i <= this.segmentsW; ++i) {
                    index += 2;
                    if (i > 0)
                        addTriangleClockWise(index - 1, index - 3, index - 2);
                }
            }
            // 底部
            if (this.bottomClosed && this.bottomRadius > 0) {
                for (i = 0; i <= this.segmentsW; ++i) {
                    index += 2;
                    if (i > 0)
                        addTriangleClockWise(index - 2, index - 3, index - 1);
                }
            }
            // 侧面
            if (this.surfaceClosed) {
                var a, b, c, d;
                for (j = 0; j <= this.segmentsH; ++j) {
                    for (i = 0; i <= this.segmentsW; ++i) {
                        index++;
                        if (i > 0 && j > 0) {
                            a = index - 1;
                            b = index - 2;
                            c = b - this.segmentsW - 1;
                            d = a - this.segmentsW - 1;
                            addTriangleClockWise(a, b, c);
                            addTriangleClockWise(a, c, d);
                        }
                    }
                }
            }
            return indices;
            function addTriangleClockWise(cwVertexIndex0, cwVertexIndex1, cwVertexIndex2) {
                indices[numIndices++] = cwVertexIndex0;
                indices[numIndices++] = cwVertexIndex1;
                indices[numIndices++] = cwVertexIndex2;
            }
        };
        /**
         * 构建uv
         * @param segmentsW 横向分割数
         * @param segmentsH 纵向分割数
         */
        CylinderGeometry.prototype.buildUVs = function () {
            var i, j;
            var x, y, revolutionAngle;
            var data = [];
            var revolutionAngleDelta = 2 * Math.PI / this.segmentsW;
            var index = 0;
            // 顶部
            if (this.topClosed) {
                for (i = 0; i <= this.segmentsW; ++i) {
                    revolutionAngle = i * revolutionAngleDelta;
                    x = 0.5 + 0.5 * -Math.cos(revolutionAngle);
                    y = 0.5 + 0.5 * Math.sin(revolutionAngle);
                    // 中心顶点
                    data[index++] = 0.5;
                    data[index++] = 0.5;
                    // 旋转顶点
                    data[index++] = x;
                    data[index++] = y;
                }
            }
            // 底部
            if (this.bottomClosed) {
                for (i = 0; i <= this.segmentsW; ++i) {
                    revolutionAngle = i * revolutionAngleDelta;
                    x = 0.5 + 0.5 * Math.cos(revolutionAngle);
                    y = 0.5 + 0.5 * Math.sin(revolutionAngle);
                    // 中心顶点
                    data[index++] = 0.5;
                    data[index++] = 0.5;
                    // 旋转顶点
                    data[index++] = x;
                    data[index++] = y;
                }
            }
            // 侧面
            if (this.surfaceClosed) {
                for (j = 0; j <= this.segmentsH; ++j) {
                    for (i = 0; i <= this.segmentsW; ++i) {
                        // 旋转顶点
                        data[index++] = (i / this.segmentsW);
                        data[index++] = (j / this.segmentsH);
                    }
                }
            }
            return data;
        };
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], CylinderGeometry.prototype, "topRadius", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], CylinderGeometry.prototype, "bottomRadius", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], CylinderGeometry.prototype, "height", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], CylinderGeometry.prototype, "segmentsW", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], CylinderGeometry.prototype, "segmentsH", null);
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], CylinderGeometry.prototype, "topClosed", null);
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], CylinderGeometry.prototype, "bottomClosed", null);
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], CylinderGeometry.prototype, "surfaceClosed", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], CylinderGeometry.prototype, "yUp", null);
        return CylinderGeometry;
    }(feng3d.Geometry));
    feng3d.CylinderGeometry = CylinderGeometry;
    feng3d.AssetData.addAssetData("Cylinder", feng3d.Geometry.cylinder = feng3d.serialization.setValue(new CylinderGeometry(), { name: "Cylinder", assetId: "Cylinder", hideFlags: feng3d.HideFlags.NotEditable }));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 圆锥体

     */
    var ConeGeometry = /** @class */ (function (_super) {
        __extends(ConeGeometry, _super);
        function ConeGeometry() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.__class__ = "feng3d.ConeGeometry";
            _this.name = "Cone";
            /**
             * 底部半径 private
             */
            _this.topRadius = 0;
            /**
             * 顶部是否封口 private
             */
            _this.topClosed = false;
            /**
             * 侧面是否封口 private
             */
            _this.surfaceClosed = true;
            return _this;
        }
        return ConeGeometry;
    }(feng3d.CylinderGeometry));
    feng3d.ConeGeometry = ConeGeometry;
    feng3d.AssetData.addAssetData("Cone", feng3d.Geometry.cone = feng3d.serialization.setValue(new ConeGeometry(), { name: "Cone", assetId: "Cone", hideFlags: feng3d.HideFlags.NotEditable }));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 圆环几何体
     */
    var TorusGeometry = /** @class */ (function (_super) {
        __extends(TorusGeometry, _super);
        function TorusGeometry() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.__class__ = "feng3d.TorusGeometry";
            _this._radius = 0.5;
            _this._tubeRadius = 0.1;
            _this._segmentsR = 16;
            _this._segmentsT = 8;
            _this._yUp = true;
            _this.name = "Torus";
            _this._vertexPositionStride = 3;
            _this._vertexNormalStride = 3;
            _this._vertexTangentStride = 3;
            return _this;
        }
        Object.defineProperty(TorusGeometry.prototype, "radius", {
            /**
             * 半径
             */
            get: function () {
                return this._radius;
            },
            set: function (v) {
                if (this._radius == v)
                    return;
                this._radius = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TorusGeometry.prototype, "tubeRadius", {
            /**
             * 管道半径
             */
            get: function () {
                return this._tubeRadius;
            },
            set: function (v) {
                if (this._tubeRadius == v)
                    return;
                this._tubeRadius = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TorusGeometry.prototype, "segmentsR", {
            /**
             * 半径方向分割数
             */
            get: function () {
                return this._segmentsR;
            },
            set: function (v) {
                if (this._segmentsR == v)
                    return;
                this._segmentsR = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TorusGeometry.prototype, "segmentsT", {
            /**
             * 管道方向分割数
             */
            get: function () {
                return this._segmentsT;
            },
            set: function (v) {
                if (this._segmentsT == v)
                    return;
                this._segmentsT = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TorusGeometry.prototype, "yUp", {
            /**
             * 是否朝上
             */
            get: function () {
                return this._yUp;
            },
            set: function (v) {
                if (this._yUp == v)
                    return;
                this._yUp = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 添加顶点数据
         */
        TorusGeometry.prototype.addVertex = function (vertexIndex, px, py, pz, nx, ny, nz, tx, ty, tz) {
            this._vertexPositionData[vertexIndex * this._vertexPositionStride] = px;
            this._vertexPositionData[vertexIndex * this._vertexPositionStride + 1] = py;
            this._vertexPositionData[vertexIndex * this._vertexPositionStride + 2] = pz;
            this._vertexNormalData[vertexIndex * this._vertexNormalStride] = nx;
            this._vertexNormalData[vertexIndex * this._vertexNormalStride + 1] = ny;
            this._vertexNormalData[vertexIndex * this._vertexNormalStride + 2] = nz;
            this._vertexTangentData[vertexIndex * this._vertexTangentStride] = tx;
            this._vertexTangentData[vertexIndex * this._vertexTangentStride + 1] = ty;
            this._vertexTangentData[vertexIndex * this._vertexTangentStride + 2] = tz;
        };
        /**
         * 添加三角形索引数据
         * @param currentTriangleIndex		当前三角形索引
         * @param cwVertexIndex0			索引0
         * @param cwVertexIndex1			索引1
         * @param cwVertexIndex2			索引2
         */
        TorusGeometry.prototype.addTriangleClockWise = function (currentTriangleIndex, cwVertexIndex0, cwVertexIndex1, cwVertexIndex2) {
            this._rawIndices[currentTriangleIndex * 3] = cwVertexIndex0;
            this._rawIndices[currentTriangleIndex * 3 + 1] = cwVertexIndex1;
            this._rawIndices[currentTriangleIndex * 3 + 2] = cwVertexIndex2;
        };
        /**
         * @inheritDoc
         */
        TorusGeometry.prototype.buildGeometry = function () {
            var i, j;
            var x, y, z, nx, ny, nz, revolutionAngleR, revolutionAngleT;
            var numTriangles;
            // reset utility variables
            this._numVertices = 0;
            this._vertexIndex = 0;
            this._currentTriangleIndex = 0;
            // evaluate target number of vertices, triangles and indices
            this._numVertices = (this.segmentsT + 1) * (this.segmentsR + 1); // this.segmentsT + 1 because of closure, this.segmentsR + 1 because of closure
            numTriangles = this.segmentsT * this.segmentsR * 2; // each level has segmentsR quads, each of 2 triangles
            this._vertexPositionData = [];
            this._vertexNormalData = [];
            this._vertexTangentData = [];
            this._rawIndices = [];
            this.buildUVs();
            // evaluate revolution steps
            var revolutionAngleDeltaR = 2 * Math.PI / this.segmentsR;
            var revolutionAngleDeltaT = 2 * Math.PI / this.segmentsT;
            var comp1, comp2;
            var t1, t2, n1, n2;
            var startPositionIndex;
            // surface
            var a, b, c, d, length;
            for (j = 0; j <= this.segmentsT; ++j) {
                startPositionIndex = j * (this.segmentsR + 1) * this._vertexPositionStride;
                for (i = 0; i <= this.segmentsR; ++i) {
                    this._vertexIndex = j * (this.segmentsR + 1) + i;
                    // revolution vertex
                    revolutionAngleR = i * revolutionAngleDeltaR;
                    revolutionAngleT = j * revolutionAngleDeltaT;
                    length = Math.cos(revolutionAngleT);
                    nx = length * Math.cos(revolutionAngleR);
                    ny = length * Math.sin(revolutionAngleR);
                    nz = Math.sin(revolutionAngleT);
                    x = this.radius * Math.cos(revolutionAngleR) + this.tubeRadius * nx;
                    y = this.radius * Math.sin(revolutionAngleR) + this.tubeRadius * ny;
                    z = (j == this.segmentsT) ? 0 : this.tubeRadius * nz;
                    if (this.yUp) {
                        n1 = -nz;
                        n2 = ny;
                        t1 = 0;
                        t2 = (length ? nx / length : x / this.radius);
                        comp1 = -z;
                        comp2 = y;
                    }
                    else {
                        n1 = ny;
                        n2 = nz;
                        t1 = (length ? nx / length : x / this.radius);
                        t2 = 0;
                        comp1 = y;
                        comp2 = z;
                    }
                    if (i == this.segmentsR) {
                        this.addVertex(this._vertexIndex, x, this._vertexPositionData[startPositionIndex + 1], this._vertexPositionData[startPositionIndex + 2], nx, n1, n2, -(length ? ny / length : y / this.radius), t1, t2);
                    }
                    else {
                        this.addVertex(this._vertexIndex, x, comp1, comp2, nx, n1, n2, -(length ? ny / length : y / this.radius), t1, t2);
                    }
                    // close triangle
                    if (i > 0 && j > 0) {
                        a = this._vertexIndex; // current
                        b = this._vertexIndex - 1; // previous
                        c = b - this.segmentsR - 1; // previous of last level
                        d = a - this.segmentsR - 1; // current of last level
                        this.addTriangleClockWise(this._currentTriangleIndex++, a, b, c);
                        this.addTriangleClockWise(this._currentTriangleIndex++, a, c, d);
                    }
                }
            }
            this.setVAData("a_position", this._vertexPositionData, 3);
            this.setVAData("a_normal", this._vertexNormalData, 3);
            this.setVAData("a_tangent", this._vertexTangentData, 3);
            this.indices = this._rawIndices;
        };
        /**
         * @inheritDoc
         */
        TorusGeometry.prototype.buildUVs = function () {
            var i, j;
            var stride = 2;
            var data = [];
            // evaluate num uvs
            var numUvs = this._numVertices * stride;
            // current uv component index
            var currentUvCompIndex = 0;
            var index = 0;
            // surface
            for (j = 0; j <= this.segmentsT; ++j) {
                for (i = 0; i <= this.segmentsR; ++i) {
                    index = j * (this.segmentsR + 1) + i;
                    // revolution vertex
                    data[index * stride] = i / this.segmentsR;
                    data[index * stride + 1] = j / this.segmentsT;
                }
            }
            // build real data from raw data
            this.setVAData("a_uv", data, 2);
        };
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], TorusGeometry.prototype, "radius", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], TorusGeometry.prototype, "tubeRadius", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], TorusGeometry.prototype, "segmentsR", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], TorusGeometry.prototype, "segmentsT", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], TorusGeometry.prototype, "yUp", null);
        return TorusGeometry;
    }(feng3d.Geometry));
    feng3d.TorusGeometry = TorusGeometry;
    feng3d.AssetData.addAssetData("Torus", feng3d.Geometry.torus = feng3d.serialization.setValue(new TorusGeometry(), { name: "Torus", assetId: "Torus", hideFlags: feng3d.HideFlags.NotEditable }));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var ImageDatas;
    (function (ImageDatas) {
        ImageDatas["black"] = "black";
        ImageDatas["white"] = "white";
        ImageDatas["red"] = "red";
        ImageDatas["green"] = "green";
        ImageDatas["blue"] = "blue";
        ImageDatas["defaultNormal"] = "defaultNormal";
        ImageDatas["defaultParticle"] = "defaultParticle";
    })(ImageDatas = feng3d.ImageDatas || (feng3d.ImageDatas = {}));
    if (typeof document != "undefined") {
        feng3d.imageDatas = {
            black: new feng3d.ImageUtil(1, 1, feng3d.Color4.fromUnit24(feng3d.ColorKeywords.black)).imageData,
            white: new feng3d.ImageUtil(1, 1, feng3d.Color4.fromUnit24(feng3d.ColorKeywords.white)).imageData,
            red: new feng3d.ImageUtil(1, 1, feng3d.Color4.fromUnit24(feng3d.ColorKeywords.red)).imageData,
            green: new feng3d.ImageUtil(1, 1, feng3d.Color4.fromUnit24(feng3d.ColorKeywords.green)).imageData,
            blue: new feng3d.ImageUtil(1, 1, feng3d.Color4.fromUnit24(feng3d.ColorKeywords.blue)).imageData,
            defaultNormal: new feng3d.ImageUtil(1, 1, feng3d.Color4.fromUnit24(0x8080ff)).imageData,
            defaultParticle: new feng3d.ImageUtil().drawDefaultParticle().imageData,
        };
    }
    /**
     * 2D纹理
     */
    var Texture2D = /** @class */ (function (_super) {
        __extends(Texture2D, _super);
        function Texture2D() {
            var _this = _super.call(this) || this;
            _this.__class__ = "feng3d.Texture2D";
            _this.assetType = feng3d.AssetType.texture;
            /**
             * 当贴图数据未加载好等情况时代替使用
             */
            _this.noPixels = ImageDatas.white;
            _this._loadings = [];
            /**
             * 纹理类型
             */
            _this._textureType = feng3d.TextureType.TEXTURE_2D;
            return _this;
        }
        Object.defineProperty(Texture2D.prototype, "isLoaded", {
            /**
             * 是否已加载
             */
            get: function () { return this._loadings.length == 0; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Texture2D.prototype, "image", {
            get: function () {
                return this._pixels;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Texture2D.prototype, "source", {
            /**
             * 用于表示初始化纹理的数据来源
             */
            get: function () {
                return this._source;
            },
            set: function (v) {
                var _this = this;
                if (this.assetId) {
                    // 来源于资源
                    console.error("\u6765\u6E90\u4E8E\u8D44\u6E90\uFF0C\u4E0D\u53EF\u4FEE\u6539\uFF01");
                    return;
                }
                this._source = v;
                if (!v) {
                    this._pixels = null;
                    this.invalidate();
                    return;
                }
                if (v.url) {
                    this._loadings.push(v.url);
                    feng3d.loader.loadImage(v.url, function (img) {
                        _this._pixels = img;
                        _this.invalidate();
                        _this._loadings.delete(v.url);
                        _this.onItemLoadCompleted();
                    }, null, function (e) {
                        console.error(e);
                        _this._loadings.delete(v.url);
                        _this.onItemLoadCompleted();
                    });
                }
            },
            enumerable: true,
            configurable: true
        });
        Texture2D.prototype.onItemLoadCompleted = function () {
            if (this._loadings.length == 0)
                this.dispatch("loadCompleted");
        };
        /**
         * 已加载完成或者加载完成时立即调用
         * @param callback 完成回调
         */
        Texture2D.prototype.onLoadCompleted = function (callback) {
            if (this.isLoaded) {
                callback();
                return;
            }
            this.once("loadCompleted", callback);
        };
        __decorate([
            feng3d.serialize
        ], Texture2D.prototype, "source", null);
        return Texture2D;
    }(feng3d.TextureInfo));
    feng3d.Texture2D = Texture2D;
    feng3d.AssetData.addAssetData("Default-Texture", Texture2D.default = feng3d.serialization.setValue(new Texture2D(), { name: "Default-Texture", assetId: "Default-Texture", hideFlags: feng3d.HideFlags.NotEditable }));
    feng3d.AssetData.addAssetData("Default-NormalTexture", Texture2D.defaultNormal = feng3d.serialization.setValue(new Texture2D(), { name: "Default-NormalTexture", assetId: "Default-NormalTexture", noPixels: ImageDatas.defaultNormal, hideFlags: feng3d.HideFlags.NotEditable }));
    feng3d.AssetData.addAssetData("Default-ParticleTexture", Texture2D.defaultParticle = feng3d.serialization.setValue(new Texture2D(), { name: "Default-ParticleTexture", assetId: "Default-ParticleTexture", noPixels: ImageDatas.defaultParticle, format: feng3d.TextureFormat.RGBA, hideFlags: feng3d.HideFlags.NotEditable }));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 2D纹理
     */
    var ImageTexture2D = /** @class */ (function (_super) {
        __extends(ImageTexture2D, _super);
        function ImageTexture2D() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(ImageTexture2D.prototype, "image", {
            // __class__: "feng3d.ImageTexture2D" = "feng3d.ImageTexture2D";
            get: function () {
                return this._image;
            },
            set: function (v) {
                if (this._image == v)
                    return;
                this._image = v;
                this.imageChanged();
            },
            enumerable: true,
            configurable: true
        });
        ImageTexture2D.prototype.imageChanged = function () {
            this._pixels = this.image;
            this.invalidate();
        };
        return ImageTexture2D;
    }(feng3d.Texture2D));
    feng3d.ImageTexture2D = ImageTexture2D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var ImageDataTexture2D = /** @class */ (function (_super) {
        __extends(ImageDataTexture2D, _super);
        function ImageDataTexture2D() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(ImageDataTexture2D.prototype, "imageData", {
            get: function () {
                return this._imageData;
            },
            set: function (v) {
                if (this._imageData == v)
                    return;
                this._imageData = v;
                this.imageDataChanged();
            },
            enumerable: true,
            configurable: true
        });
        ImageDataTexture2D.prototype.imageDataChanged = function () {
            this._pixels = this.imageData;
            this.invalidate();
        };
        return ImageDataTexture2D;
    }(feng3d.Texture2D));
    feng3d.ImageDataTexture2D = ImageDataTexture2D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var CanvasTexture2D = /** @class */ (function (_super) {
        __extends(CanvasTexture2D, _super);
        function CanvasTexture2D() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(CanvasTexture2D.prototype, "canvas", {
            get: function () {
                return this._canvas;
            },
            set: function (v) {
                if (this._canvas == v)
                    return;
                this._canvas = v;
                this.canvasChanged();
            },
            enumerable: true,
            configurable: true
        });
        CanvasTexture2D.prototype.canvasChanged = function () {
            this._pixels = this.canvas;
            this.invalidate();
        };
        return CanvasTexture2D;
    }(feng3d.Texture2D));
    feng3d.CanvasTexture2D = CanvasTexture2D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var VideoTexture2D = /** @class */ (function (_super) {
        __extends(VideoTexture2D, _super);
        function VideoTexture2D() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(VideoTexture2D.prototype, "video", {
            get: function () {
                return this._video;
            },
            set: function (v) {
                if (this._video == v)
                    return;
                this._video = v;
                this.videoChanged();
            },
            enumerable: true,
            configurable: true
        });
        VideoTexture2D.prototype.videoChanged = function () {
            this._pixels = this.video;
            this.invalidate();
        };
        return VideoTexture2D;
    }(feng3d.Texture2D));
    feng3d.VideoTexture2D = VideoTexture2D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 渲染目标纹理
     */
    var RenderTargetTexture2D = /** @class */ (function (_super) {
        __extends(RenderTargetTexture2D, _super);
        function RenderTargetTexture2D() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._OFFSCREEN_WIDTH = 1024;
            _this._OFFSCREEN_HEIGHT = 1024;
            _this.format = feng3d.TextureFormat.RGBA;
            _this.minFilter = feng3d.TextureMinFilter.NEAREST;
            _this.magFilter = feng3d.TextureMagFilter.NEAREST;
            _this._isRenderTarget = true;
            return _this;
        }
        Object.defineProperty(RenderTargetTexture2D.prototype, "OFFSCREEN_WIDTH", {
            get: function () {
                return this._OFFSCREEN_WIDTH;
            },
            set: function (v) {
                if (this._OFFSCREEN_WIDTH == v)
                    return;
                this._OFFSCREEN_WIDTH = v;
                this.invalidate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RenderTargetTexture2D.prototype, "OFFSCREEN_HEIGHT", {
            get: function () {
                return this._OFFSCREEN_HEIGHT;
            },
            set: function (v) {
                if (this._OFFSCREEN_HEIGHT == v)
                    return;
                this._OFFSCREEN_HEIGHT = v;
                this.invalidate();
            },
            enumerable: true,
            configurable: true
        });
        return RenderTargetTexture2D;
    }(feng3d.Texture2D));
    feng3d.RenderTargetTexture2D = RenderTargetTexture2D;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 立方体纹理
     */
    var TextureCube = /** @class */ (function (_super) {
        __extends(TextureCube, _super);
        function TextureCube() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.__class__ = "feng3d.TextureCube";
            _this.assetType = feng3d.AssetType.texturecube;
            _this.OAVCubeMap = "";
            _this.noPixels = [feng3d.ImageDatas.white, feng3d.ImageDatas.white, feng3d.ImageDatas.white, feng3d.ImageDatas.white, feng3d.ImageDatas.white, feng3d.ImageDatas.white];
            _this._pixels = [null, null, null, null, null, null];
            _this._textureType = feng3d.TextureType.TEXTURE_CUBE_MAP;
            _this._loading = [];
            return _this;
        }
        Object.defineProperty(TextureCube.prototype, "rawData", {
            /**
             * 原始数据
             */
            get: function () {
                return this._rawData;
            },
            set: function (v) {
                if (this._rawData == v)
                    return;
                this._rawData = v;
                this._rawDataChanged();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextureCube.prototype, "isLoaded", {
            /**
             * 是否加载完成
             */
            get: function () { return this._loading.length == 0; },
            enumerable: true,
            configurable: true
        });
        TextureCube.prototype.setTexture2D = function (pos, texture) {
            if (this.rawData == null || this.rawData.type != "texture") {
                this.rawData = { type: "texture", textures: [] };
            }
            var index = TextureCube.ImageNames.indexOf(pos);
            this.rawData.textures[index] = texture;
            this._loadItemTexture(texture, index);
        };
        TextureCube.prototype.setTexture2DPath = function (pos, path) {
            if (this.rawData == null || this.rawData.type != "path") {
                this.rawData = { type: "path", paths: [] };
            }
            var index = TextureCube.ImageNames.indexOf(pos);
            this.rawData.paths[index] = path;
            this._loadItemImagePath(path, index);
        };
        TextureCube.prototype.getTextureImage = function (pos, callback) {
            if (!this.rawData) {
                callback();
                return;
            }
            var index = TextureCube.ImageNames.indexOf(pos);
            if (this.rawData.type == "texture") {
                var texture = this.rawData.textures[index];
                if (!texture) {
                    callback();
                    return;
                }
                ;
                texture.onLoadCompleted(function () {
                    callback(texture.image);
                });
            }
            else if (this.rawData.type == "path") {
                var path_1 = this.rawData.paths[index];
                if (!path_1) {
                    callback();
                    return;
                }
                feng3d.fs.readImage(path_1, function (err, img) {
                    callback(img);
                });
            }
        };
        TextureCube.prototype._rawDataChanged = function () {
            var _this = this;
            if (!this.rawData)
                return;
            if (this.rawData.type == "texture") {
                this.rawData.textures.forEach(function (v, index) {
                    _this._loadItemTexture(v, index);
                });
                this.invalidate();
            }
            else if (this.rawData.type == "path") {
                this.rawData.paths.forEach(function (v, index) {
                    _this._loadItemImagePath(v, index);
                });
            }
        };
        /**
         * 加载单个贴图
         *
         * @param texture 贴图
         * @param index 索引
         */
        TextureCube.prototype._loadItemTexture = function (texture, index) {
            var _this = this;
            if (texture == null)
                return;
            this._loading.push(texture);
            texture.onLoadCompleted(function () {
                if (_this.rawData.type == "texture" && _this.rawData.textures[index] == texture) {
                    _this._pixels[index] = texture.image;
                    _this.invalidate();
                }
                _this._loading.delete(texture);
                _this._onItemLoadCompleted();
            });
        };
        /**
         * 加载单个图片
         *
         * @param imagepath 图片路径
         * @param index 索引
         */
        TextureCube.prototype._loadItemImagePath = function (imagepath, index) {
            var _this = this;
            if (imagepath == null)
                return;
            this._loading.push(imagepath);
            feng3d.fs.readImage(imagepath, function (err, img) {
                if (img != null && _this.rawData.type == "path" && _this.rawData.paths[index] == imagepath) {
                    _this._pixels[index] = img;
                    _this.invalidate();
                }
                _this._loading.delete(imagepath);
                _this._onItemLoadCompleted();
            });
        };
        TextureCube.prototype._onItemLoadCompleted = function () {
            if (this._loading.length == 0)
                this.dispatch("loadCompleted");
        };
        /**
         * 已加载完成或者加载完成时立即调用
         * @param callback 完成回调
         */
        TextureCube.prototype.onLoadCompleted = function (callback) {
            if (this.isLoaded) {
                callback();
                return;
            }
            this.once("loadCompleted", callback);
        };
        TextureCube.ImageNames = ["positive_x_url", "positive_y_url", "positive_z_url", "negative_x_url", "negative_y_url", "negative_z_url"];
        __decorate([
            feng3d.oav({ component: "OAVCubeMap", priority: -1 })
        ], TextureCube.prototype, "OAVCubeMap", void 0);
        __decorate([
            feng3d.serialize
        ], TextureCube.prototype, "rawData", null);
        return TextureCube;
    }(feng3d.TextureInfo));
    feng3d.TextureCube = TextureCube;
    feng3d.AssetData.addAssetData("Default-TextureCube", TextureCube.default = feng3d.serialization.setValue(new TextureCube(), { name: "Default-TextureCube", assetId: "Default-TextureCube", hideFlags: feng3d.HideFlags.NotEditable }));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 材质
     */
    var Material = /** @class */ (function (_super) {
        __extends(Material, _super);
        function Material() {
            var _this = _super.call(this) || this;
            _this.__class__ = "feng3d.Material";
            //
            _this.renderAtomic = new feng3d.RenderAtomic();
            _this.preview = "";
            _this.name = "";
            feng3d.dispatcher.on("asset.shaderChanged", _this.onShaderChanged, _this);
            _this.shaderName = "standard";
            _this.uniforms = new feng3d.StandardUniforms();
            _this.renderParams = new feng3d.RenderParams();
            return _this;
        }
        Object.defineProperty(Material.prototype, "shaderName", {
            /**
             * shader名称
             */
            get: function () {
                return this._shaderName;
            },
            set: function (v) {
                if (this._shaderName == v)
                    return;
                this._shaderName = v;
                this.onShaderChanged();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Material.prototype, "uniforms", {
            /**
             * Uniform数据
             */
            get: function () {
                return this._uniforms;
            },
            set: function (v) {
                if (this._uniforms == v)
                    return;
                this._uniforms = v;
                this.onUniformsChanged();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Material.prototype, "renderParams", {
            /**
             * 渲染参数
             */
            get: function () {
                return this._renderParams;
            },
            set: function (v) {
                if (this._renderParams == v)
                    return;
                this._renderParams = v;
                this.onRenderParamsChanged();
            },
            enumerable: true,
            configurable: true
        });
        Material.prototype.beforeRender = function (renderAtomic) {
            Object.assign(renderAtomic.uniforms, this.renderAtomic.uniforms);
            renderAtomic.shader = this.renderAtomic.shader;
            renderAtomic.renderParams = this.renderAtomic.renderParams;
            renderAtomic.shaderMacro.IS_POINTS_MODE = this.renderParams.renderMode == feng3d.RenderMode.POINTS;
        };
        Object.defineProperty(Material.prototype, "isLoaded", {
            /**
             * 是否加载完成
             */
            get: function () {
                var uniforms = this.uniforms;
                for (var key in uniforms) {
                    var texture = uniforms[key];
                    if (texture instanceof feng3d.Texture2D || texture instanceof feng3d.TextureCube) {
                        if (!texture.isLoaded)
                            return false;
                    }
                }
                return true;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 已加载完成或者加载完成时立即调用
         * @param callback 完成回调
         */
        Material.prototype.onLoadCompleted = function (callback) {
            var loadingNum = 0;
            var uniforms = this.uniforms;
            for (var key in uniforms) {
                var texture = uniforms[key];
                if (texture instanceof feng3d.Texture2D || texture instanceof feng3d.TextureCube) {
                    if (!texture.isLoaded) {
                        loadingNum++;
                        texture.on("loadCompleted", function () {
                            loadingNum--;
                            if (loadingNum == 0)
                                callback();
                        });
                    }
                }
            }
            if (loadingNum == 0)
                callback();
        };
        Material.prototype.onShaderChanged = function () {
            var cls = feng3d.shaderConfig.shaders[this.shaderName].cls;
            if (cls) {
                if (this.uniforms == null || this.uniforms.constructor != cls) {
                    var newuniforms = new cls();
                    // Object.assign(newuniforms, this.uniforms);
                    this.uniforms = newuniforms;
                }
            }
            else {
                this.uniforms = {};
            }
            this.renderAtomic.shader = new feng3d.Shader(this.shaderName);
        };
        Material.prototype.onUniformsChanged = function () {
            this.renderAtomic.uniforms = this.uniforms;
        };
        Material.prototype.onRenderParamsChanged = function () {
            this.renderAtomic.renderParams = this.renderParams;
        };
        __decorate([
            feng3d.oav({ component: "OAVFeng3dPreView" })
        ], Material.prototype, "preview", void 0);
        __decorate([
            feng3d.oav({ component: "OAVMaterialName" }),
            feng3d.serialize
        ], Material.prototype, "shaderName", null);
        __decorate([
            feng3d.oav({ editable: false }),
            feng3d.serialize
        ], Material.prototype, "name", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ component: "OAVObjectView" })
        ], Material.prototype, "uniforms", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ block: "渲染参数", component: "OAVObjectView" })
        ], Material.prototype, "renderParams", null);
        return Material;
    }(feng3d.AssetData));
    feng3d.Material = Material;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var PointUniforms = /** @class */ (function () {
        function PointUniforms() {
            this.__class__ = "feng3d.PointUniforms";
            /**
             * 颜色
             */
            this.u_color = new feng3d.Color4();
            /**
             * 点绘制时点的尺寸
             */
            this.u_PointSize = 1;
        }
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], PointUniforms.prototype, "u_color", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], PointUniforms.prototype, "u_PointSize", void 0);
        return PointUniforms;
    }());
    feng3d.PointUniforms = PointUniforms;
    feng3d.shaderConfig.shaders["point"].cls = PointUniforms;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var ColorUniforms = /** @class */ (function () {
        function ColorUniforms() {
            this.__class__ = "feng3d.ColorUniforms";
            /**
             * 颜色
             */
            this.u_diffuseInput = new feng3d.Color4();
        }
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], ColorUniforms.prototype, "u_diffuseInput", void 0);
        return ColorUniforms;
    }());
    feng3d.ColorUniforms = ColorUniforms;
    feng3d.shaderConfig.shaders["color"].cls = ColorUniforms;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 线段材质
     * 目前webgl不支持修改线条宽度，参考：https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/lineWidth
     */
    var SegmentUniforms = /** @class */ (function () {
        function SegmentUniforms() {
            this.__class__ = "feng3d.SegmentUniforms";
            /**
             * 颜色
             */
            this.u_segmentColor = new feng3d.Color4();
        }
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], SegmentUniforms.prototype, "u_segmentColor", void 0);
        return SegmentUniforms;
    }());
    feng3d.SegmentUniforms = SegmentUniforms;
    feng3d.shaderConfig.shaders["segment"].cls = SegmentUniforms;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var TextureUniforms = /** @class */ (function () {
        function TextureUniforms() {
            this.__class__ = "feng3d.TextureUniforms";
            /**
             * 颜色
             */
            this.u_color = new feng3d.Color4();
            /**
             * 纹理数据
             */
            this.s_texture = feng3d.Texture2D.default;
        }
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], TextureUniforms.prototype, "u_color", void 0);
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], TextureUniforms.prototype, "s_texture", void 0);
        return TextureUniforms;
    }());
    feng3d.TextureUniforms = TextureUniforms;
    feng3d.shaderConfig.shaders["texture"].cls = TextureUniforms;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 雾模式
     */
    var FogMode;
    (function (FogMode) {
        FogMode[FogMode["NONE"] = 0] = "NONE";
        FogMode[FogMode["EXP"] = 1] = "EXP";
        FogMode[FogMode["EXP2"] = 2] = "EXP2";
        FogMode[FogMode["LINEAR"] = 3] = "LINEAR";
    })(FogMode = feng3d.FogMode || (feng3d.FogMode = {}));
    var StandardUniforms = /** @class */ (function () {
        function StandardUniforms() {
            this.__class__ = "feng3d.StandardUniforms";
            /**
             * 点绘制时点的尺寸
             */
            this.u_PointSize = 1;
            /**
             * 漫反射纹理
             */
            this.s_diffuse = feng3d.Texture2D.default;
            /**
             * 基本颜色
             */
            this.u_diffuse = new feng3d.Color4(1, 1, 1, 1);
            /**
             * 透明阈值，透明度小于该值的像素被片段着色器丢弃
             */
            this.u_alphaThreshold = 0;
            /**
             * 法线纹理
             */
            this.s_normal = feng3d.Texture2D.defaultNormal;
            /**
             * 镜面反射光泽图
             */
            this.s_specular = feng3d.Texture2D.default;
            /**
             * 镜面反射颜色
             */
            this.u_specular = new feng3d.Color3();
            /**
             * 高光系数
             */
            this.u_glossiness = 50;
            /**
             * 环境纹理
             */
            this.s_ambient = feng3d.Texture2D.default;
            /**
             * 环境光颜色
             */
            this.u_ambient = new feng3d.Color4();
            /**
             * 环境映射贴图
             */
            this.s_envMap = feng3d.TextureCube.default;
            /**
             * 反射率
             */
            this.u_reflectivity = 1;
            /**
             * 出现雾效果的最近距离
             */
            this.u_fogMinDistance = 0;
            /**
             * 最远距离
             */
            this.u_fogMaxDistance = 100;
            /**
             * 雾的颜色
             */
            this.u_fogColor = new feng3d.Color3();
            /**
             * 雾的密度
             */
            this.u_fogDensity = 0.1;
            /**
             * 雾模式
             */
            this.u_fogMode = FogMode.NONE;
        }
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], StandardUniforms.prototype, "u_PointSize", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ block: "diffuse" })
        ], StandardUniforms.prototype, "s_diffuse", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ block: "diffuse" })
        ], StandardUniforms.prototype, "u_diffuse", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ block: "diffuse" })
        ], StandardUniforms.prototype, "u_alphaThreshold", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ block: "normalMethod" })
        ], StandardUniforms.prototype, "s_normal", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ block: "specular" })
        ], StandardUniforms.prototype, "s_specular", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ block: "specular" })
        ], StandardUniforms.prototype, "u_specular", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ block: "specular" })
        ], StandardUniforms.prototype, "u_glossiness", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ block: "ambient" })
        ], StandardUniforms.prototype, "s_ambient", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ block: "ambient" })
        ], StandardUniforms.prototype, "u_ambient", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ component: "OAVPick", block: "envMap", componentParam: { accepttype: "texturecube", datatype: "texturecube" } })
        ], StandardUniforms.prototype, "s_envMap", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ block: "envMap" })
        ], StandardUniforms.prototype, "u_reflectivity", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ block: "fog" })
        ], StandardUniforms.prototype, "u_fogMinDistance", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ block: "fog" })
        ], StandardUniforms.prototype, "u_fogMaxDistance", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ block: "fog" })
        ], StandardUniforms.prototype, "u_fogColor", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ block: "fog" })
        ], StandardUniforms.prototype, "u_fogDensity", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ block: "fog", component: "OAVEnum", componentParam: { enumClass: FogMode } })
        ], StandardUniforms.prototype, "u_fogMode", void 0);
        return StandardUniforms;
    }());
    feng3d.StandardUniforms = StandardUniforms;
    feng3d.shaderConfig.shaders["standard"].cls = StandardUniforms;
    feng3d.AssetData.addAssetData("Default-Material", feng3d.Material.default = feng3d.serialization.setValue(new feng3d.Material(), { name: "Default-Material", assetId: "Default-Material", hideFlags: feng3d.HideFlags.NotEditable }));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 阴影类型
     */
    var ShadowType;
    (function (ShadowType) {
        /**
         * 没有阴影
         */
        ShadowType[ShadowType["No_Shadows"] = 0] = "No_Shadows";
        /**
         * 硬阴影
         */
        ShadowType[ShadowType["Hard_Shadows"] = 1] = "Hard_Shadows";
        /**
         * PCF 阴影
         */
        ShadowType[ShadowType["PCF_Shadows"] = 2] = "PCF_Shadows";
        /**
         * PCF 软阴影
         */
        ShadowType[ShadowType["PCF_Soft_Shadows"] = 3] = "PCF_Soft_Shadows";
    })(ShadowType = feng3d.ShadowType || (feng3d.ShadowType = {}));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 灯光类型

     */
    var LightType;
    (function (LightType) {
        /**
         * 方向光
         */
        LightType[LightType["Directional"] = 0] = "Directional";
        /**
         * 点光
         */
        LightType[LightType["Point"] = 1] = "Point";
        /**
         * 聚光灯
         */
        LightType[LightType["Spot"] = 2] = "Spot";
    })(LightType = feng3d.LightType || (feng3d.LightType = {}));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 灯光
     */
    var Light = /** @class */ (function (_super) {
        __extends(Light, _super);
        function Light() {
            var _this = _super.call(this) || this;
            /**
             * 颜色
             */
            _this.color = new feng3d.Color3();
            /**
             * 光照强度
             */
            _this.intensity = 1;
            /**
             * 阴影类型
             */
            _this.shadowType = feng3d.ShadowType.No_Shadows;
            /**
             * 阴影偏差，用来解决判断是否为阴影时精度问题
             */
            _this.shadowBias = -0.005;
            /**
             * 阴影半径，边缘宽度
             */
            _this.shadowRadius = 1;
            /**
             * 帧缓冲对象，用于处理光照阴影贴图渲染
             */
            _this.frameBufferObject = new feng3d.FrameBufferObject();
            _this.debugShadowMap = false;
            _this.shadowCamera = feng3d.serialization.setValue(new feng3d.GameObject(), { name: "LightShadowCamera" }).addComponent(feng3d.Camera);
            return _this;
        }
        Object.defineProperty(Light.prototype, "position", {
            /**
             * 光源位置
             */
            get: function () {
                return this.transform.scenePosition;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Light.prototype, "direction", {
            /**
             * 光照方向
             */
            get: function () {
                return this.transform.localToWorldMatrix.forward;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Light.prototype, "shadowCameraNear", {
            /**
             * 阴影近平面距离
             */
            get: function () {
                return this.shadowCamera.lens.near;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Light.prototype, "shadowCameraFar", {
            /**
             * 阴影近平面距离
             */
            get: function () {
                return this.shadowCamera.lens.far;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Light.prototype, "shadowMapSize", {
            /**
             * 阴影图尺寸
             */
            get: function () {
                return this.shadowMap.getSize();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Light.prototype, "shadowMap", {
            get: function () {
                return this.frameBufferObject.texture;
            },
            enumerable: true,
            configurable: true
        });
        Light.prototype.updateDebugShadowMap = function (scene3d, viewCamera) {
            var gameObject = this.debugShadowMapObject;
            if (!gameObject) {
                gameObject = this.debugShadowMapObject = feng3d.gameObjectFactory.createPlane("debugShadowMapObject");
                gameObject.hideFlags = feng3d.HideFlags.Hide | feng3d.HideFlags.DontSave;
                gameObject.mouseEnabled = false;
                gameObject.addComponent(feng3d.BillboardComponent);
                //材质
                var model = gameObject.getComponent(feng3d.Model);
                model.geometry = feng3d.serialization.setValue(new feng3d.PlaneGeometry(), { width: this.lightType == feng3d.LightType.Point ? 1 : 0.5, height: 0.5, segmentsW: 1, segmentsH: 1, yUp: false });
                var textureMaterial = model.material = feng3d.serialization.setValue(new feng3d.Material(), { shaderName: "texture", uniforms: { s_texture: this.frameBufferObject.texture } });
                //
                // textureMaterial.uniforms.s_texture.url = 'Assets/pz.jpg';
                // textureMaterial.uniforms.u_color.setTo(1.0, 0.0, 0.0, 1.0);
                textureMaterial.renderParams.enableBlend = true;
                textureMaterial.renderParams.sfactor = feng3d.BlendFactor.ONE;
                textureMaterial.renderParams.dfactor = feng3d.BlendFactor.ZERO;
            }
            var depth = viewCamera.lens.near * 2;
            gameObject.transform.position = viewCamera.transform.scenePosition.addTo(viewCamera.transform.localToWorldMatrix.forward.scaleNumberTo(depth));
            var billboardComponent = gameObject.getComponent(feng3d.BillboardComponent);
            billboardComponent.camera = viewCamera;
            if (this.debugShadowMap) {
                scene3d.gameObject.addChild(gameObject);
            }
            else {
                gameObject.remove();
            }
        };
        __decorate([
            feng3d.serialize
        ], Light.prototype, "lightType", void 0);
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], Light.prototype, "color", void 0);
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], Light.prototype, "intensity", void 0);
        __decorate([
            feng3d.oav({ component: "OAVEnum", componentParam: { enumClass: feng3d.ShadowType } }),
            feng3d.serialize
        ], Light.prototype, "shadowType", void 0);
        __decorate([
            feng3d.oav({ tooltip: "是否调试阴影图" })
        ], Light.prototype, "debugShadowMap", void 0);
        return Light;
    }(feng3d.Behaviour));
    feng3d.Light = Light;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 方向光源
     */
    var DirectionalLight = /** @class */ (function (_super) {
        __extends(DirectionalLight, _super);
        function DirectionalLight() {
            var _this = _super.call(this) || this;
            _this.__class__ = "feng3d.DirectionalLight";
            _this.lightType = feng3d.LightType.Directional;
            return _this;
        }
        Object.defineProperty(DirectionalLight.prototype, "position", {
            /**
             * 光源位置
             */
            get: function () {
                return this.shadowCamera.transform.scenePosition;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 通过视窗摄像机进行更新
         * @param viewCamera 视窗摄像机
         */
        DirectionalLight.prototype.updateShadowByCamera = function (scene3d, viewCamera, models) {
            var worldBounds = models.reduce(function (pre, i) {
                var box = i.gameObject.worldBounds;
                if (!pre)
                    return box.clone();
                pre.union(box);
                return pre;
            }, null) || new feng3d.AABB(new feng3d.Vector3(), new feng3d.Vector3(1, 1, 1));
            // 
            var center = worldBounds.getCenter();
            var radius = worldBounds.getSize().length / 2;
            // 
            this.shadowCamera.transform.position = center.addTo(this.direction.scaleNumberTo(radius + this.shadowCameraNear).negate());
            this.shadowCamera.transform.lookAt(center, this.shadowCamera.transform.upVector);
            //
            if (!this.orthographicLens) {
                this.shadowCamera.lens = this.orthographicLens = new feng3d.OrthographicLens(radius, 1, this.shadowCameraNear, this.shadowCameraNear + radius * 2);
            }
            else {
                feng3d.serialization.setValue(this.orthographicLens, { size: radius, near: this.shadowCameraNear, far: this.shadowCameraNear + radius * 2 });
            }
        };
        return DirectionalLight;
    }(feng3d.Light));
    feng3d.DirectionalLight = DirectionalLight;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 点光源
     */
    var PointLight = /** @class */ (function (_super) {
        __extends(PointLight, _super);
        function PointLight() {
            var _this = _super.call(this) || this;
            _this.__class__ = "feng3d.PointLight";
            _this.lightType = feng3d.LightType.Point;
            _this._range = 10;
            _this.shadowCamera.lens = new feng3d.PerspectiveLens(90, 1, 0.1, _this.range);
            return _this;
        }
        Object.defineProperty(PointLight.prototype, "range", {
            /**
             * 光照范围
             */
            get: function () {
                return this._range;
            },
            set: function (v) {
                if (this._range == v)
                    return;
                this._range = v;
                this.invalidRange();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PointLight.prototype, "shadowMapSize", {
            /**
             * 阴影图尺寸
             */
            get: function () {
                return this.shadowMap.getSize().multiply(new feng3d.Vector2(1 / 4, 1 / 2));
            },
            enumerable: true,
            configurable: true
        });
        PointLight.prototype.invalidRange = function () {
            if (this.shadowCamera)
                this.shadowCamera.lens.far = this.range;
        };
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], PointLight.prototype, "range", null);
        return PointLight;
    }(feng3d.Light));
    feng3d.PointLight = PointLight;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 聚光灯光源
     */
    var SpotLight = /** @class */ (function (_super) {
        __extends(SpotLight, _super);
        function SpotLight() {
            var _this = _super.call(this) || this;
            _this.lightType = feng3d.LightType.Spot;
            _this._range = 10;
            _this._angle = 60;
            /**
             * 半影.
             */
            _this.penumbra = 0;
            _this.perspectiveLens = _this.shadowCamera.lens = new feng3d.PerspectiveLens(_this.angle, 1, 0.1, _this.range);
            return _this;
        }
        Object.defineProperty(SpotLight.prototype, "range", {
            /**
             * 光照范围
             */
            get: function () {
                return this._range;
            },
            set: function (v) {
                if (this._range == v)
                    return;
                this._range = v;
                this.invalidRange();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SpotLight.prototype, "angle", {
            /**
             *
             */
            get: function () {
                return this._angle;
            },
            set: function (v) {
                if (this._angle == v)
                    return;
                this._angle = v;
                this.invalidAngle();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SpotLight.prototype, "coneCos", {
            /**
             * 椎体cos值
             */
            get: function () {
                return Math.cos(this.angle * 0.5 * Math.DEG2RAD);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SpotLight.prototype, "penumbraCos", {
            get: function () {
                return Math.cos(this.angle * 0.5 * Math.DEG2RAD * (1 - this.penumbra));
            },
            enumerable: true,
            configurable: true
        });
        SpotLight.prototype.invalidRange = function () {
            if (this.shadowCamera)
                this.shadowCamera.lens.far = this.range;
        };
        SpotLight.prototype.invalidAngle = function () {
            if (this.perspectiveLens)
                this.perspectiveLens.fov = this.angle;
        };
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], SpotLight.prototype, "range", null);
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], SpotLight.prototype, "angle", null);
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], SpotLight.prototype, "penumbra", void 0);
        return SpotLight;
    }(feng3d.Light));
    feng3d.SpotLight = SpotLight;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var LightPicker = /** @class */ (function () {
        function LightPicker(model) {
            this._model = model;
        }
        LightPicker.prototype.beforeRender = function (renderAtomic) {
            var _this = this;
            var pointLights = [];
            var directionalLights = [];
            var spotLights = [];
            var scene3d = this._model.gameObject.scene;
            if (scene3d) {
                pointLights = scene3d.activePointLights;
                directionalLights = scene3d.activeDirectionalLights;
                spotLights = scene3d.activeSpotLights;
            }
            renderAtomic.shaderMacro.NUM_LIGHT = pointLights.length + directionalLights.length + spotLights.length;
            //设置点光源数据
            var castShadowPointLights = [];
            var unCastShadowPointLights = [];
            var pointShadowMaps = [];
            pointLights.forEach(function (element) {
                if (!element.isVisibleAndEnabled)
                    return;
                if (element.shadowType != feng3d.ShadowType.No_Shadows && _this._model.receiveShadows) {
                    castShadowPointLights.push(element);
                    pointShadowMaps.push(element.shadowMap);
                }
                else {
                    unCastShadowPointLights.push(element);
                }
            });
            renderAtomic.shaderMacro.NUM_POINTLIGHT = unCastShadowPointLights.length;
            renderAtomic.shaderMacro.NUM_POINTLIGHT_CASTSHADOW = castShadowPointLights.length;
            //
            renderAtomic.uniforms.u_pointLights = unCastShadowPointLights;
            renderAtomic.uniforms.u_castShadowPointLights = castShadowPointLights;
            renderAtomic.uniforms.u_pointShadowMaps = pointShadowMaps;
            //设置聚光灯光源数据
            var castShadowSpotLights = [];
            var unCastShadowSpotLights = [];
            var spotShadowMaps = [];
            var spotShadowMatrix = [];
            spotLights.forEach(function (element) {
                if (!element.isVisibleAndEnabled)
                    return;
                if (element.shadowType != feng3d.ShadowType.No_Shadows && _this._model.receiveShadows) {
                    castShadowSpotLights.push(element);
                    spotShadowMatrix.push(element.shadowCamera.viewProjection);
                    spotShadowMaps.push(element.shadowMap);
                }
                else {
                    unCastShadowSpotLights.push(element);
                }
            });
            renderAtomic.shaderMacro.NUM_SPOT_LIGHTS = unCastShadowSpotLights.length;
            renderAtomic.shaderMacro.NUM_SPOT_LIGHTS_CASTSHADOW = castShadowSpotLights.length;
            //
            renderAtomic.uniforms.u_spotLights = unCastShadowSpotLights;
            renderAtomic.uniforms.u_castShadowSpotLights = castShadowSpotLights;
            renderAtomic.uniforms.u_spotShadowMatrix = spotShadowMatrix;
            renderAtomic.uniforms.u_spotShadowMaps = spotShadowMaps;
            // 设置方向光源数据
            var castShadowDirectionalLights = [];
            var unCastShadowDirectionalLights = [];
            var directionalShadowMatrix = [];
            var directionalShadowMaps = [];
            directionalLights.forEach(function (element) {
                if (!element.isVisibleAndEnabled)
                    return;
                if (element.shadowType != feng3d.ShadowType.No_Shadows && _this._model.receiveShadows) {
                    castShadowDirectionalLights.push(element);
                    directionalShadowMatrix.push(element.shadowCamera.viewProjection);
                    directionalShadowMaps.push(element.shadowMap);
                }
                else {
                    unCastShadowDirectionalLights.push(element);
                }
            });
            renderAtomic.shaderMacro.NUM_DIRECTIONALLIGHT = unCastShadowDirectionalLights.length;
            renderAtomic.shaderMacro.NUM_DIRECTIONALLIGHT_CASTSHADOW = castShadowDirectionalLights.length;
            //
            renderAtomic.uniforms.u_directionalLights = unCastShadowDirectionalLights;
            renderAtomic.uniforms.u_castShadowDirectionalLights = castShadowDirectionalLights;
            renderAtomic.uniforms.u_directionalShadowMatrixs = directionalShadowMatrix;
            renderAtomic.uniforms.u_directionalShadowMaps = directionalShadowMaps;
        };
        return LightPicker;
    }());
    feng3d.LightPicker = LightPicker;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var ControllerBase = /** @class */ (function () {
        /**
         * 控制器基类，用于动态调整3D对象的属性
         */
        function ControllerBase(targetObject) {
            this.targetObject = targetObject;
        }
        /**
         * 手动应用更新到目标3D对象
         */
        ControllerBase.prototype.update = function (interpolate) {
            if (interpolate === void 0) { interpolate = true; }
            throw new Error("Abstract method");
        };
        Object.defineProperty(ControllerBase.prototype, "targetObject", {
            get: function () {
                return this._targetObject;
            },
            set: function (val) {
                this._targetObject = val;
            },
            enumerable: true,
            configurable: true
        });
        return ControllerBase;
    }());
    feng3d.ControllerBase = ControllerBase;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var LookAtController = /** @class */ (function (_super) {
        __extends(LookAtController, _super);
        function LookAtController(target, lookAtObject) {
            var _this = _super.call(this, target) || this;
            _this._origin = new feng3d.Vector3(0.0, 0.0, 0.0);
            _this._upAxis = feng3d.Vector3.Y_AXIS;
            _this._pos = new feng3d.Vector3();
            if (lookAtObject)
                _this.lookAtObject = lookAtObject;
            else
                _this.lookAtPosition = new feng3d.Vector3();
            return _this;
        }
        Object.defineProperty(LookAtController.prototype, "upAxis", {
            get: function () {
                return this._upAxis;
            },
            set: function (upAxis) {
                this._upAxis = upAxis;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LookAtController.prototype, "lookAtPosition", {
            get: function () {
                return this._lookAtPosition;
            },
            set: function (val) {
                this._lookAtPosition = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LookAtController.prototype, "lookAtObject", {
            get: function () {
                return this._lookAtObject;
            },
            set: function (value) {
                if (this._lookAtObject == value)
                    return;
                this._lookAtObject = value;
            },
            enumerable: true,
            configurable: true
        });
        LookAtController.prototype.update = function (interpolate) {
            if (interpolate === void 0) { interpolate = true; }
            if (this._targetObject) {
                if (this._lookAtPosition) {
                    this._targetObject.transform.lookAt(this.lookAtPosition, this._upAxis);
                }
                else if (this._lookAtObject) {
                    this._pos = this._lookAtObject.transform.position;
                    this._targetObject.transform.lookAt(this._pos, this._upAxis);
                }
            }
        };
        return LookAtController;
    }(feng3d.ControllerBase));
    feng3d.LookAtController = LookAtController;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var HoverController = /** @class */ (function (_super) {
        __extends(HoverController, _super);
        function HoverController(targetObject, lookAtObject, panAngle, tiltAngle, distance, minTiltAngle, maxTiltAngle, minPanAngle, maxPanAngle, steps, yFactor, wrapPanAngle) {
            if (panAngle === void 0) { panAngle = 0; }
            if (tiltAngle === void 0) { tiltAngle = 90; }
            if (distance === void 0) { distance = 1000; }
            if (minTiltAngle === void 0) { minTiltAngle = -90; }
            if (maxTiltAngle === void 0) { maxTiltAngle = 90; }
            if (minPanAngle === void 0) { minPanAngle = NaN; }
            if (maxPanAngle === void 0) { maxPanAngle = NaN; }
            if (steps === void 0) { steps = 8; }
            if (yFactor === void 0) { yFactor = 2; }
            if (wrapPanAngle === void 0) { wrapPanAngle = false; }
            var _this = _super.call(this, targetObject, lookAtObject) || this;
            _this._currentPanAngle = 0;
            _this._currentTiltAngle = 90;
            _this._panAngle = 0;
            _this._tiltAngle = 90;
            _this._distance = 1000;
            _this._minPanAngle = -Infinity;
            _this._maxPanAngle = Infinity;
            _this._minTiltAngle = -90;
            _this._maxTiltAngle = 90;
            _this._steps = 8;
            _this._yFactor = 2;
            _this._wrapPanAngle = false;
            _this.distance = distance;
            _this.panAngle = panAngle;
            _this.tiltAngle = tiltAngle;
            _this.minPanAngle = minPanAngle || -Infinity;
            _this.maxPanAngle = maxPanAngle || Infinity;
            _this.minTiltAngle = minTiltAngle;
            _this.maxTiltAngle = maxTiltAngle;
            _this.steps = steps;
            _this.yFactor = yFactor;
            _this.wrapPanAngle = wrapPanAngle;
            _this._currentPanAngle = _this._panAngle;
            _this._currentTiltAngle = _this._tiltAngle;
            return _this;
        }
        Object.defineProperty(HoverController.prototype, "steps", {
            get: function () {
                return this._steps;
            },
            set: function (val) {
                val = (val < 1) ? 1 : val;
                if (this._steps == val)
                    return;
                this._steps = val;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "panAngle", {
            get: function () {
                return this._panAngle;
            },
            set: function (val) {
                val = Math.max(this._minPanAngle, Math.min(this._maxPanAngle, val));
                if (this._panAngle == val)
                    return;
                this._panAngle = val;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "tiltAngle", {
            get: function () {
                return this._tiltAngle;
            },
            set: function (val) {
                val = Math.max(this._minTiltAngle, Math.min(this._maxTiltAngle, val));
                if (this._tiltAngle == val)
                    return;
                this._tiltAngle = val;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "distance", {
            get: function () {
                return this._distance;
            },
            set: function (val) {
                if (this._distance == val)
                    return;
                this._distance = val;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "minPanAngle", {
            get: function () {
                return this._minPanAngle;
            },
            set: function (val) {
                if (this._minPanAngle == val)
                    return;
                this._minPanAngle = val;
                this.panAngle = Math.max(this._minPanAngle, Math.min(this._maxPanAngle, this._panAngle));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "maxPanAngle", {
            get: function () {
                return this._maxPanAngle;
            },
            set: function (val) {
                if (this._maxPanAngle == val)
                    return;
                this._maxPanAngle = val;
                this.panAngle = Math.max(this._minPanAngle, Math.min(this._maxPanAngle, this._panAngle));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "minTiltAngle", {
            get: function () {
                return this._minTiltAngle;
            },
            set: function (val) {
                if (this._minTiltAngle == val)
                    return;
                this._minTiltAngle = val;
                this.tiltAngle = Math.max(this._minTiltAngle, Math.min(this._maxTiltAngle, this._tiltAngle));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "maxTiltAngle", {
            get: function () {
                return this._maxTiltAngle;
            },
            set: function (val) {
                if (this._maxTiltAngle == val)
                    return;
                this._maxTiltAngle = val;
                this.tiltAngle = Math.max(this._minTiltAngle, Math.min(this._maxTiltAngle, this._tiltAngle));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "yFactor", {
            get: function () {
                return this._yFactor;
            },
            set: function (val) {
                if (this._yFactor == val)
                    return;
                this._yFactor = val;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "wrapPanAngle", {
            get: function () {
                return this._wrapPanAngle;
            },
            set: function (val) {
                if (this._wrapPanAngle == val)
                    return;
                this._wrapPanAngle = val;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        HoverController.prototype.update = function (interpolate) {
            if (interpolate === void 0) { interpolate = true; }
            if (this._tiltAngle != this._currentTiltAngle || this._panAngle != this._currentPanAngle) {
                if (this._wrapPanAngle) {
                    if (this._panAngle < 0) {
                        this._currentPanAngle += this._panAngle % 360 + 360 - this._panAngle;
                        this._panAngle = this._panAngle % 360 + 360;
                    }
                    else {
                        this._currentPanAngle += this._panAngle % 360 - this._panAngle;
                        this._panAngle = this._panAngle % 360;
                    }
                    while (this._panAngle - this._currentPanAngle < -180)
                        this._currentPanAngle -= 360;
                    while (this._panAngle - this._currentPanAngle > 180)
                        this._currentPanAngle += 360;
                }
                if (interpolate) {
                    this._currentTiltAngle += (this._tiltAngle - this._currentTiltAngle) / (this.steps + 1);
                    this._currentPanAngle += (this._panAngle - this._currentPanAngle) / (this.steps + 1);
                }
                else {
                    this._currentPanAngle = this._panAngle;
                    this._currentTiltAngle = this._tiltAngle;
                }
                if ((Math.abs(this.tiltAngle - this._currentTiltAngle) < 0.01) && (Math.abs(this._panAngle - this._currentPanAngle) < 0.01)) {
                    this._currentTiltAngle = this._tiltAngle;
                    this._currentPanAngle = this._panAngle;
                }
            }
            if (!this._targetObject)
                return;
            if (this._lookAtPosition) {
                this._pos.x = this._lookAtPosition.x;
                this._pos.y = this._lookAtPosition.y;
                this._pos.z = this._lookAtPosition.z;
            }
            else if (this._lookAtObject) {
                if (this._targetObject.transform.parent && this._lookAtObject.transform.parent) {
                    if (this._targetObject.transform.parent != this._lookAtObject.transform.parent) {
                        this._pos.x = this._lookAtObject.transform.scenePosition.x;
                        this._pos.y = this._lookAtObject.transform.scenePosition.y;
                        this._pos.z = this._lookAtObject.transform.scenePosition.z;
                        this._targetObject.transform.parent.worldToLocalMatrix.transformVector(this._pos, this._pos);
                    }
                    else {
                        this._pos.copy(this._lookAtObject.transform.position);
                    }
                }
                else if (this._lookAtObject.scene) {
                    this._pos.x = this._lookAtObject.transform.scenePosition.x;
                    this._pos.y = this._lookAtObject.transform.scenePosition.y;
                    this._pos.z = this._lookAtObject.transform.scenePosition.z;
                }
                else {
                    this._pos.copy(this._lookAtObject.transform.position);
                }
            }
            else {
                this._pos.x = this._origin.x;
                this._pos.y = this._origin.y;
                this._pos.z = this._origin.z;
            }
            this._targetObject.transform.x = this._pos.x + this._distance * Math.sin(this._currentPanAngle * Math.DEG2RAD) * Math.cos(this._currentTiltAngle * Math.DEG2RAD);
            this._targetObject.transform.z = this._pos.z + this._distance * Math.cos(this._currentPanAngle * Math.DEG2RAD) * Math.cos(this._currentTiltAngle * Math.DEG2RAD);
            this._targetObject.transform.y = this._pos.y + this._distance * Math.sin(this._currentTiltAngle * Math.DEG2RAD) * this._yFactor;
            _super.prototype.update.call(this);
        };
        return HoverController;
    }(feng3d.LookAtController));
    feng3d.HoverController = HoverController;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * FPS模式控制器
     */
    var FPSController = /** @class */ (function (_super) {
        __extends(FPSController, _super);
        function FPSController() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 加速度
             */
            _this.acceleration = 0.001;
            _this.runEnvironment = feng3d.RunEnvironment.feng3d;
            _this.ischange = false;
            return _this;
        }
        Object.defineProperty(FPSController.prototype, "auto", {
            get: function () {
                return this._auto;
            },
            set: function (value) {
                if (this._auto == value)
                    return;
                if (this._auto) {
                    feng3d.windowEventProxy.off("mousedown", this.onMousedown, this);
                    feng3d.windowEventProxy.off("mouseup", this.onMouseup, this);
                    this.onMouseup();
                }
                this._auto = value;
                if (this._auto) {
                    feng3d.windowEventProxy.on("mousedown", this.onMousedown, this);
                    feng3d.windowEventProxy.on("mouseup", this.onMouseup, this);
                }
            },
            enumerable: true,
            configurable: true
        });
        FPSController.prototype.init = function () {
            _super.prototype.init.call(this);
            this.keyDirectionDic = {};
            this.keyDirectionDic["a"] = new feng3d.Vector3(-1, 0, 0); //左
            this.keyDirectionDic["d"] = new feng3d.Vector3(1, 0, 0); //右
            this.keyDirectionDic["w"] = new feng3d.Vector3(0, 0, 1); //前
            this.keyDirectionDic["s"] = new feng3d.Vector3(0, 0, -1); //后
            this.keyDirectionDic["e"] = new feng3d.Vector3(0, 1, 0); //上
            this.keyDirectionDic["q"] = new feng3d.Vector3(0, -1, 0); //下
            this.keyDownDic = {};
            this.auto = true;
        };
        FPSController.prototype.onMousedown = function () {
            this.ischange = true;
            this.preMousePoint = null;
            this.mousePoint = null;
            this.velocity = new feng3d.Vector3();
            this.keyDownDic = {};
            feng3d.windowEventProxy.on("keydown", this.onKeydown, this);
            feng3d.windowEventProxy.on("keyup", this.onKeyup, this);
            feng3d.windowEventProxy.on("mousemove", this.onMouseMove, this);
        };
        FPSController.prototype.onMouseup = function () {
            this.ischange = false;
            this.preMousePoint = null;
            this.mousePoint = null;
            feng3d.windowEventProxy.off("keydown", this.onKeydown, this);
            feng3d.windowEventProxy.off("keyup", this.onKeyup, this);
            feng3d.windowEventProxy.off("mousemove", this.onMouseMove, this);
        };
        /**
         * 销毁
         */
        FPSController.prototype.dispose = function () {
            this.auto = false;
        };
        /**
         * 手动应用更新到目标3D对象
         */
        FPSController.prototype.update = function () {
            if (!this.ischange)
                return;
            if (this.mousePoint && this.preMousePoint) {
                //计算旋转
                var offsetPoint = this.mousePoint.subTo(this.preMousePoint);
                offsetPoint.x *= 0.15;
                offsetPoint.y *= 0.15;
                // this.targetObject.transform.rotate(Vector3.X_AXIS, offsetPoint.y, this.targetObject.transform.position);
                // this.targetObject.transform.rotate(Vector3.Y_AXIS, offsetPoint.x, this.targetObject.transform.position);
                var matrix3d = this.transform.localToWorldMatrix;
                matrix3d.appendRotation(matrix3d.right, offsetPoint.y, matrix3d.position);
                var up = feng3d.Vector3.Y_AXIS;
                if (matrix3d.up.dot(up) < 0) {
                    up = up.clone();
                    up.scaleNumber(-1);
                }
                matrix3d.appendRotation(up, offsetPoint.x, matrix3d.position);
                this.transform.localToWorldMatrix = matrix3d;
                //
                this.preMousePoint = this.mousePoint;
                this.mousePoint = null;
            }
            //计算加速度
            var accelerationVec = new feng3d.Vector3();
            for (var key in this.keyDirectionDic) {
                if (this.keyDownDic[key] == true) {
                    var element = this.keyDirectionDic[key];
                    accelerationVec.add(element);
                }
            }
            accelerationVec.scaleNumber(this.acceleration);
            //计算速度
            this.velocity.add(accelerationVec);
            var right = this.transform.rightVector;
            var up = this.transform.upVector;
            var forward = this.transform.forwardVector;
            right.scaleNumber(this.velocity.x);
            up.scaleNumber(this.velocity.y);
            forward.scaleNumber(this.velocity.z);
            //计算位移
            var displacement = right.clone();
            displacement.add(up);
            displacement.add(forward);
            this.transform.x += displacement.x;
            this.transform.y += displacement.y;
            this.transform.z += displacement.z;
        };
        /**
         * 处理鼠标移动事件
         */
        FPSController.prototype.onMouseMove = function (event) {
            this.mousePoint = new feng3d.Vector2(event.clientX, event.clientY);
            if (this.preMousePoint == null) {
                this.preMousePoint = this.mousePoint;
                this.mousePoint = null;
            }
        };
        /**
         * 键盘按下事件
         */
        FPSController.prototype.onKeydown = function (event) {
            var boardKey = String.fromCharCode(event.keyCode).toLocaleLowerCase();
            if (this.keyDirectionDic[boardKey] == null)
                return;
            if (!this.keyDownDic[boardKey])
                this.stopDirectionVelocity(this.keyDirectionDic[boardKey]);
            this.keyDownDic[boardKey] = true;
        };
        /**
         * 键盘弹起事件
         */
        FPSController.prototype.onKeyup = function (event) {
            var boardKey = String.fromCharCode(event.keyCode).toLocaleLowerCase();
            if (this.keyDirectionDic[boardKey] == null)
                return;
            this.keyDownDic[boardKey] = false;
            this.stopDirectionVelocity(this.keyDirectionDic[boardKey]);
        };
        /**
         * 停止xyz方向运动
         * @param direction     停止运动的方向
         */
        FPSController.prototype.stopDirectionVelocity = function (direction) {
            if (direction == null)
                return;
            if (direction.x != 0) {
                this.velocity.x = 0;
            }
            if (direction.y != 0) {
                this.velocity.y = 0;
            }
            if (direction.z != 0) {
                this.velocity.z = 0;
            }
        };
        __decorate([
            feng3d.oav()
        ], FPSController.prototype, "acceleration", void 0);
        return FPSController;
    }(feng3d.Behaviour));
    feng3d.FPSController = FPSController;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 射线投射拾取器
     */
    var Raycaster = /** @class */ (function () {
        function Raycaster() {
        }
        /**
         * 获取射线穿过的实体
         * @param ray3D 射线
         * @param gameObjects 实体列表
         * @return
         */
        Raycaster.prototype.pick = function (ray3D, gameObjects) {
            if (gameObjects.length == 0)
                return null;
            var pickingCollisionVOs = gameObjects.reduce(function (pv, gameObject) {
                var model = gameObject.getComponent(feng3d.Model);
                var pickingCollisionVO = model && model.isIntersectingRay(ray3D);
                if (pickingCollisionVO)
                    pv.push(pickingCollisionVO);
                return pv;
            }, []);
            if (pickingCollisionVOs.length == 0)
                return null;
            // 根据与包围盒距离进行排序
            pickingCollisionVOs.sort(function (a, b) { return a.rayEntryDistance - b.rayEntryDistance; });
            var shortestCollisionDistance = Number.MAX_VALUE;
            var bestCollisionVO = null;
            var collisionVOs = [];
            for (var i = 0; i < pickingCollisionVOs.length; ++i) {
                var pickingCollisionVO = pickingCollisionVOs[i];
                if (bestCollisionVO == null || pickingCollisionVO.rayEntryDistance < bestCollisionVO.rayEntryDistance) {
                    var result = pickingCollisionVO.geometry.raycast(pickingCollisionVO.localRay, shortestCollisionDistance, pickingCollisionVO.cullFace);
                    if (result) {
                        pickingCollisionVO.rayEntryDistance = result.rayEntryDistance;
                        pickingCollisionVO.index = result.index;
                        pickingCollisionVO.localNormal = result.localNormal;
                        pickingCollisionVO.localPosition = result.localPosition;
                        pickingCollisionVO.uv = result.uv;
                        //
                        shortestCollisionDistance = pickingCollisionVO.rayEntryDistance;
                        collisionVOs.push(pickingCollisionVO);
                        bestCollisionVO = pickingCollisionVO;
                    }
                }
            }
            return bestCollisionVO;
        };
        /**
         * 获取射线穿过的实体
         * @param ray3D 射线
         * @param gameObjects 实体列表
         * @return
         */
        Raycaster.prototype.pickAll = function (ray3D, gameObjects) {
            if (gameObjects.length == 0)
                return [];
            var pickingCollisionVOs = gameObjects.reduce(function (pv, gameObject) {
                var model = gameObject.getComponent(feng3d.Model);
                var pickingCollisionVO = model && model.isIntersectingRay(ray3D);
                if (pickingCollisionVO)
                    pv.push(pickingCollisionVO);
                return pv;
            }, []);
            if (pickingCollisionVOs.length == 0)
                return [];
            var collisionVOs = pickingCollisionVOs.filter(function (v) {
                var result = v.geometry.raycast(v.localRay, Number.MAX_VALUE, v.cullFace);
                if (result) {
                    v.rayEntryDistance = result.rayEntryDistance;
                    v.index = result.index;
                    v.localNormal = result.localNormal;
                    v.localPosition = result.localPosition;
                    v.uv = result.uv;
                    return true;
                }
                return false;
            });
            return collisionVOs;
        };
        return Raycaster;
    }());
    feng3d.Raycaster = Raycaster;
    feng3d.raycaster = new Raycaster();
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 声音监听器
     */
    var AudioListener = /** @class */ (function (_super) {
        __extends(AudioListener, _super);
        function AudioListener() {
            var _this = _super.call(this) || this;
            _this._enabled = true;
            _this._volume = 1;
            _this.gain = feng3d.audioCtx.createGain();
            _this.gain.connect(feng3d.audioCtx.destination);
            _this.enabledChanged();
            return _this;
        }
        Object.defineProperty(AudioListener.prototype, "enabled", {
            get: function () {
                return this._enabled;
            },
            set: function (v) {
                if (this._enabled == v)
                    return;
                this._enabled = v;
                this.enabledChanged();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AudioListener.prototype, "volume", {
            /**
             * 音量
             */
            get: function () {
                return this._volume;
            },
            set: function (v) {
                this._volume = v;
                this.gain.gain.setTargetAtTime(v, feng3d.audioCtx.currentTime, 0.01);
            },
            enumerable: true,
            configurable: true
        });
        AudioListener.prototype.init = function () {
            _super.prototype.init.call(this);
            this.on("scenetransformChanged", this.onScenetransformChanged, this);
            this.onScenetransformChanged();
        };
        AudioListener.prototype.onScenetransformChanged = function () {
            var localToWorldMatrix = this.transform.localToWorldMatrix;
            var position = localToWorldMatrix.position;
            var forward = localToWorldMatrix.forward;
            var up = localToWorldMatrix.up;
            //
            var listener = feng3d.audioCtx.listener;
            // feng3d中为左手坐标系，listener中使用的为右手坐标系，参考https://developer.mozilla.org/en-US/docs/Web/API/AudioListener
            listener.positionX.value = position.x;
            listener.positionY.value = position.y;
            listener.positionZ.value = -position.z;
            listener.forwardX.value = forward.x;
            listener.forwardY.value = forward.y;
            listener.forwardZ.value = -forward.z;
            listener.upX.value = up.x;
            listener.upY.value = up.y;
            listener.upZ.value = -up.z;
        };
        AudioListener.prototype.enabledChanged = function () {
            if (!this.gain)
                return;
            if (this.enabled) {
                feng3d.globalGain.connect(this.gain);
            }
            else {
                feng3d.globalGain.disconnect(this.gain);
            }
        };
        AudioListener.prototype.dispose = function () {
            this.off("scenetransformChanged", this.onScenetransformChanged, this);
            _super.prototype.dispose.call(this);
        };
        __decorate([
            feng3d.serialize,
            feng3d.oav({ tooltip: "音量" })
        ], AudioListener.prototype, "volume", null);
        return AudioListener;
    }(feng3d.Behaviour));
    feng3d.AudioListener = AudioListener;
})(feng3d || (feng3d = {}));
(function () {
    if (typeof window == "undefined")
        return;
    window["AudioContext"] = window["AudioContext"] || window["webkitAudioContext"];
    var audioCtx = feng3d.audioCtx = new AudioContext();
    var globalGain = feng3d.globalGain = audioCtx.createGain();
    // 新增无音Gain，避免没有AudioListener组件时暂停声音播放进度
    var zeroGain = audioCtx.createGain();
    zeroGain.connect(audioCtx.destination);
    globalGain.connect(zeroGain);
    zeroGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.01);
    //
    var listener = audioCtx.listener;
    audioCtx.createGain();
    if (listener.forwardX) {
        listener.forwardX.value = 0;
        listener.forwardY.value = 0;
        listener.forwardZ.value = -1;
        listener.upX.value = 0;
        listener.upY.value = 1;
        listener.upZ.value = 0;
    }
    else {
        listener.setOrientation(0, 0, -1, 0, 1, 0);
    }
})();
var feng3d;
(function (feng3d) {
    /**
     * 音量与距离算法
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PannerNode/distanceModel
     * @see https://mdn.github.io/webaudio-examples/panner-node/
     * @see https://github.com/mdn/webaudio-examples
     */
    var DistanceModelType;
    (function (DistanceModelType) {
        /**
         * 1 - rolloffFactor * (distance - refDistance) / (maxDistance - refDistance)
         */
        DistanceModelType["linear"] = "linear";
        /**
         * refDistance / (refDistance + rolloffFactor * (distance - refDistance))
         */
        DistanceModelType["inverse"] = "inverse";
        /**
         * pow(distance / refDistance, -rolloffFactor)
         */
        DistanceModelType["exponential"] = "exponential";
    })(DistanceModelType = feng3d.DistanceModelType || (feng3d.DistanceModelType = {}));
    /**
     * 声源
     * @see https://developer.mozilla.org/en-US/docs/Web/API/AudioContext
     */
    var AudioSource = /** @class */ (function (_super) {
        __extends(AudioSource, _super);
        function AudioSource() {
            var _this = _super.call(this) || this;
            _this._enabled = true;
            _this._url = "";
            _this._loop = true;
            _this._enablePosition = true;
            _this.panner = createPanner();
            _this.panningModel = 'HRTF';
            _this.distanceModel = DistanceModelType.inverse;
            _this.refDistance = 1;
            _this.maxDistance = 10000;
            _this.rolloffFactor = 1;
            _this.coneInnerAngle = 360;
            _this.coneOuterAngle = 0;
            _this.coneOuterGain = 0;
            //
            _this.gain = feng3d.audioCtx.createGain();
            _this.volume = 1;
            //
            _this.enabledChanged();
            _this.connect();
            return _this;
        }
        Object.defineProperty(AudioSource.prototype, "enabled", {
            get: function () {
                return this._enabled;
            },
            set: function (v) {
                if (this._enabled == v)
                    return;
                this._enabled = v;
                this.enabledChanged();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AudioSource.prototype, "url", {
            /**
             * 声音文件路径
             */
            get: function () {
                return this._url;
            },
            set: function (v) {
                if (this._url == v)
                    return;
                this._url = v;
                this.onUrlChanged();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AudioSource.prototype, "loop", {
            /**
             * 是否循环播放
             */
            get: function () {
                return this._loop;
            },
            set: function (v) {
                this._loop = v;
                if (this.source)
                    this.source.loop = v;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AudioSource.prototype, "volume", {
            /**
             * 音量
             */
            get: function () {
                return this._volume;
            },
            set: function (v) {
                this._volume = v;
                this.gain.gain.setTargetAtTime(v, feng3d.audioCtx.currentTime, 0.01);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AudioSource.prototype, "enablePosition", {
            /**
             * 是否启用位置影响声音
             */
            get: function () {
                return this._enablePosition;
            },
            set: function (v) {
                this.disconnect();
                this._enablePosition = v;
                this.connect();
            },
            enumerable: true,
            configurable: true
        });
        ;
        Object.defineProperty(AudioSource.prototype, "coneInnerAngle", {
            // @serialize
            // @oav()
            get: function () {
                return this._coneInnerAngle;
            },
            set: function (v) {
                this._coneInnerAngle = v;
                this.panner.coneInnerAngle = v;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AudioSource.prototype, "coneOuterAngle", {
            // @serialize
            // @oav()
            get: function () {
                return this._coneOuterAngle;
            },
            set: function (v) {
                this._coneOuterAngle = v;
                this.panner.coneOuterAngle = v;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AudioSource.prototype, "coneOuterGain", {
            // @serialize
            // @oav()
            get: function () {
                return this._coneOuterGain;
            },
            set: function (v) {
                this._coneOuterGain = v;
                this.panner.coneOuterGain = v;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AudioSource.prototype, "distanceModel", {
            /**
             * 该接口的distanceModel属性PannerNode是一个枚举值，用于确定在音频源离开收听者时用于减少音频源音量的算法。
             *
             * 可能的值是：
             * * linear：根据以下公式计算由距离引起的增益的线性距离模型：
             *      1 - rolloffFactor * (distance - refDistance) / (maxDistance - refDistance)
             * * inverse：根据以下公式计算由距离引起的增益的反距离模型：
             *      refDistance / (refDistance + rolloffFactor * (distance - refDistance))
             * * exponential：按照下式计算由距离引起的增益的指数距离模型
             *      pow(distance / refDistance, -rolloffFactor)。
             *
             * inverse是的默认值distanceModel。
             */
            get: function () {
                return this._distanceModel;
            },
            set: function (v) {
                this._distanceModel = v;
                this.panner.distanceModel = v;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AudioSource.prototype, "maxDistance", {
            /**
             * 表示音频源和收听者之间的最大距离，之后音量不会再降低。该值仅由linear距离模型使用。默认值是10000。
             */
            get: function () {
                return this._maxDistance;
            },
            set: function (v) {
                this._maxDistance = v;
                this.panner.maxDistance = v;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AudioSource.prototype, "panningModel", {
            // @serialize
            // @oav()
            get: function () {
                return this._panningModel;
            },
            set: function (v) {
                this._panningModel = v;
                this.panner.panningModel = v;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AudioSource.prototype, "refDistance", {
            /**
             * 表示随着音频源远离收听者而减小音量的参考距离。此值由所有距离模型使用。默认值是1。
             */
            get: function () {
                return this._refDistance;
            },
            set: function (v) {
                this._refDistance = v;
                this.panner.refDistance = v;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AudioSource.prototype, "rolloffFactor", {
            /**
             * 描述了音源离开收听者音量降低的速度。此值由所有距离模型使用。默认值是1。
             */
            get: function () {
                return this._rolloffFactor;
            },
            set: function (v) {
                this._rolloffFactor = v;
                this.panner.rolloffFactor = v;
            },
            enumerable: true,
            configurable: true
        });
        AudioSource.prototype.init = function () {
            _super.prototype.init.call(this);
            this.on("scenetransformChanged", this.onScenetransformChanged, this);
        };
        AudioSource.prototype.onScenetransformChanged = function () {
            var localToWorldMatrix = this.transform.localToWorldMatrix;
            var scenePosition = localToWorldMatrix.position;
            //
            var panner = this.panner;
            // feng3d使用左手坐标系，panner使用右手坐标系，参考https://developer.mozilla.org/en-US/docs/Web/API/PannerNode
            panner.positionX.value = scenePosition.x;
            panner.positionY.value = scenePosition.y;
            panner.positionZ.value = -scenePosition.z;
            if (panner.orientationX) {
                panner.orientationX.value = 1;
                panner.orientationY.value = 0;
                panner.orientationZ.value = 0;
            }
            else {
                panner.setOrientation(1, 0, 0);
            }
        };
        AudioSource.prototype.onUrlChanged = function () {
            var _this = this;
            this.stop();
            if (this.url) {
                var url = this.url;
                feng3d.fs.readArrayBuffer(this.url, function (err, data) {
                    if (err) {
                        console.warn(err);
                        return;
                    }
                    if (url != _this.url)
                        return;
                    feng3d.audioCtx.decodeAudioData(data, function (buffer) {
                        _this.buffer = buffer;
                    });
                });
            }
        };
        AudioSource.prototype.play = function () {
            this.stop();
            if (this.buffer) {
                this.source = feng3d.audioCtx.createBufferSource();
                this.source.buffer = this.buffer;
                this.connect();
                this.source.loop = this.loop;
                this.source.start(0);
            }
        };
        AudioSource.prototype.stop = function () {
            if (this.source) {
                this.source.stop(0);
                this.disconnect();
                this.source = null;
            }
        };
        AudioSource.prototype.connect = function () {
            var arr = this.getAudioNodes();
            for (var i = 0; i < arr.length - 1; i++) {
                arr[i + 1].connect(arr[i]);
            }
        };
        AudioSource.prototype.disconnect = function () {
            var arr = this.getAudioNodes();
            for (var i = 0; i < arr.length - 1; i++) {
                arr[i + 1].disconnect(arr[i]);
            }
        };
        AudioSource.prototype.getAudioNodes = function () {
            var arr = [];
            arr.push(this.gain);
            if (this._enablePosition)
                arr.push(this.panner);
            if (this.source)
                arr.push(this.source);
            return arr;
        };
        AudioSource.prototype.enabledChanged = function () {
            if (!this.gain)
                return;
            if (this.enabled)
                this.gain.connect(feng3d.globalGain);
            else
                this.gain.disconnect(feng3d.globalGain);
        };
        AudioSource.prototype.dispose = function () {
            this.off("scenetransformChanged", this.onScenetransformChanged, this);
            this.disconnect();
            _super.prototype.dispose.call(this);
        };
        __decorate([
            feng3d.serialize,
            feng3d.oav({ component: "OAVPick", tooltip: "声音文件路径", componentParam: { accepttype: "audio" } })
        ], AudioSource.prototype, "url", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ tooltip: "是否循环播放" })
        ], AudioSource.prototype, "loop", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ tooltip: "音量" })
        ], AudioSource.prototype, "volume", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ tooltip: "是否启用位置影响声音" })
        ], AudioSource.prototype, "enablePosition", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ component: "OAVEnum", tooltip: "距离模式，距离影响声音的方式", componentParam: { enumClass: DistanceModelType } })
        ], AudioSource.prototype, "distanceModel", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ tooltip: "表示音频源和收听者之间的最大距离，之后音量不会再降低。该值仅由linear距离模型使用。默认值是10000。" })
        ], AudioSource.prototype, "maxDistance", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ tooltip: "表示随着音频源远离收听者而减小音量的参考距离。此值由所有距离模型使用。默认值是1。" })
        ], AudioSource.prototype, "refDistance", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ tooltip: "描述了音源离开收听者音量降低的速度。此值由所有距离模型使用。默认值是1。" })
        ], AudioSource.prototype, "rolloffFactor", null);
        __decorate([
            feng3d.oav()
        ], AudioSource.prototype, "play", null);
        __decorate([
            feng3d.oav()
        ], AudioSource.prototype, "stop", null);
        return AudioSource;
    }(feng3d.Behaviour));
    feng3d.AudioSource = AudioSource;
})(feng3d || (feng3d = {}));
function createPanner() {
    var panner = this.panner = feng3d.audioCtx.createPanner();
    if (panner.orientationX) {
        panner.orientationX.value = 1;
        panner.orientationY.value = 0;
        panner.orientationZ.value = 0;
    }
    else {
        panner.setOrientation(1, 0, 0);
    }
    return panner;
}
var feng3d;
(function (feng3d) {
    /**
     * The Water component renders the terrain.
     */
    var Water = /** @class */ (function (_super) {
        __extends(Water, _super);
        function Water() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.__class__ = "feng3d.Water";
            _this.geometry = feng3d.Geometry.plane;
            _this.material = feng3d.Material.water;
            /**
             * 帧缓冲对象，用于处理水面反射
             */
            _this.frameBufferObject = new feng3d.FrameBufferObject();
            return _this;
        }
        Water.prototype.beforeRender = function (gl, renderAtomic, scene3d, camera) {
            var uniforms = this.material.uniforms;
            var sun = this.gameObject.scene.activeDirectionalLights[0];
            if (sun) {
                uniforms.u_sunColor = sun.color;
                uniforms.u_sunDirection = sun.transform.localToWorldMatrix.forward.clone().negate();
            }
            var clipBias = 0;
            uniforms.u_time += 1.0 / 60.0;
            // this.material.uniforms.s_mirrorSampler.url = "Assets/floor_diffuse.jpg";
            _super.prototype.beforeRender.call(this, gl, renderAtomic, scene3d, camera);
            if (1)
                return;
            //
            var mirrorWorldPosition = this.transform.scenePosition;
            var cameraWorldPosition = camera.transform.scenePosition;
            var rotationMatrix = this.transform.rotationMatrix;
            var normal = rotationMatrix.forward;
            var view = mirrorWorldPosition.subTo(cameraWorldPosition);
            if (view.dot(normal) > 0)
                return;
            view.reflect(normal).negate();
            view.add(mirrorWorldPosition);
            rotationMatrix = camera.transform.rotationMatrix;
            var lookAtPosition = new feng3d.Vector3(0, 0, -1);
            lookAtPosition.applyMatrix4x4(rotationMatrix);
            lookAtPosition.add(cameraWorldPosition);
            var target = mirrorWorldPosition.subTo(lookAtPosition);
            target.reflect(normal).negate();
            target.add(mirrorWorldPosition);
            var mirrorCamera = feng3d.serialization.setValue(new feng3d.GameObject(), { name: "waterMirrorCamera" }).addComponent(feng3d.Camera);
            mirrorCamera.transform.position = view;
            mirrorCamera.transform.lookAt(target, rotationMatrix.up);
            mirrorCamera.lens = camera.lens.clone();
            var textureMatrix = new feng3d.Matrix4x4([
                0.5, 0.0, 0.0, 0.0,
                0.0, 0.5, 0.0, 0.0,
                0.0, 0.0, 0.5, 0.0,
                0.5, 0.5, 0.5, 1.0
            ]);
            textureMatrix.append(mirrorCamera.viewProjection);
            var mirrorPlane = feng3d.Plane3D.fromNormalAndPoint(mirrorCamera.transform.worldToLocalMatrix.deltaTransformVector(normal), mirrorCamera.transform.worldToLocalMatrix.transformVector(mirrorWorldPosition));
            var clipPlane = new feng3d.Vector4(mirrorPlane.a, mirrorPlane.b, mirrorPlane.c, mirrorPlane.d);
            var projectionMatrix = mirrorCamera.lens.matrix;
            var q = new feng3d.Vector4();
            q.x = (clipPlane.x / Math.abs(clipPlane.x) + projectionMatrix.rawData[8]) / projectionMatrix.rawData[0];
            q.y = (clipPlane.y / Math.abs(clipPlane.y) + projectionMatrix.rawData[9]) / projectionMatrix.rawData[5];
            q.z = -1.0;
            q.w = (1.0 + projectionMatrix.rawData[10]) / projectionMatrix.rawData[14];
            clipPlane.scale(2.0 / clipPlane.dot(q));
            projectionMatrix.rawData[2] = clipPlane.x;
            projectionMatrix.rawData[6] = clipPlane.y;
            projectionMatrix.rawData[10] = clipPlane.z + 1.0 - clipBias;
            projectionMatrix.rawData[14] = clipPlane.w;
            var eye = camera.transform.scenePosition;
            // 
            var frameBufferObject = this.frameBufferObject;
            frameBufferObject.active(gl);
            //
            gl.viewport(0, 0, frameBufferObject.OFFSCREEN_WIDTH, frameBufferObject.OFFSCREEN_HEIGHT);
            gl.clearColor(1.0, 1.0, 1.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            feng3d.skyboxRenderer.draw(gl, scene3d, mirrorCamera);
            // forwardRenderer.draw(gl, scene3d, mirrorCamera);
            // forwardRenderer.draw(gl, scene3d, camera);
            frameBufferObject.deactive(gl);
            //
            // this.material.uniforms.s_mirrorSampler = frameBufferObject.texture;
            uniforms.u_textureMatrix = textureMatrix;
        };
        return Water;
    }(feng3d.Model));
    feng3d.Water = Water;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var WaterUniforms = /** @class */ (function () {
        function WaterUniforms() {
            this.__class__ = "feng3d.WaterUniforms";
            this.u_alpha = 1.0;
            /**
             * 水体运动时间，默认自动递增
             */
            // @serialize
            // @oav({ tooltip: "水体运动时间，默认自动递增" })
            this.u_time = 0.0;
            this.u_size = 10.0;
            this.u_distortionScale = 20.0;
            this.u_waterColor = new feng3d.Color3().fromUnit(0x555555);
            this.s_normalSampler = feng3d.Texture2D.default;
            /**
             * 镜面反射贴图
             */
            // s_mirrorSampler = new RenderTargetTexture2D();
            this.s_mirrorSampler = feng3d.Texture2D.default;
            this.u_textureMatrix = new feng3d.Matrix4x4();
            this.u_sunColor = new feng3d.Color3().fromUnit(0x7F7F7F);
            this.u_sunDirection = new feng3d.Vector3(0.70707, 0.70707, 0);
        }
        __decorate([
            feng3d.serialize,
            feng3d.oav({ tooltip: "透明度" })
        ], WaterUniforms.prototype, "u_alpha", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ tooltip: "水体展现的尺寸" })
        ], WaterUniforms.prototype, "u_size", void 0);
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], WaterUniforms.prototype, "u_distortionScale", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ tooltip: "水体颜色" })
        ], WaterUniforms.prototype, "u_waterColor", void 0);
        __decorate([
            feng3d.oav(),
            feng3d.serialize,
            feng3d.oav({ tooltip: "水体法线图" })
        ], WaterUniforms.prototype, "s_normalSampler", void 0);
        __decorate([
            feng3d.oav()
            // s_mirrorSampler = new RenderTargetTexture2D();
        ], WaterUniforms.prototype, "s_mirrorSampler", void 0);
        return WaterUniforms;
    }());
    feng3d.WaterUniforms = WaterUniforms;
    feng3d.shaderConfig.shaders["water"].cls = WaterUniforms;
    feng3d.AssetData.addAssetData("Water-Material", feng3d.Material.water = feng3d.serialization.setValue(new feng3d.Material(), { name: "Water-Material", assetId: "Water-Material", shaderName: "water", hideFlags: feng3d.HideFlags.NotEditable }));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 地形几何体
     */
    var TerrainGeometry = /** @class */ (function (_super) {
        __extends(TerrainGeometry, _super);
        /**
         * 创建高度地形 拥有segmentsW*segmentsH个顶点
         */
        function TerrainGeometry(raw) {
            var _this = _super.call(this) || this;
            _this._heightMap = feng3d.Texture2D.default;
            _this._width = 10;
            _this._height = 1;
            _this._depth = 10;
            _this._segmentsW = 30;
            _this._segmentsH = 30;
            _this._maxElevation = 255;
            _this._minElevation = 0;
            _this._heightImageData = defaultHeightMap;
            _this.name = "terrain";
            feng3d.serialization.setValue(_this, raw);
            return _this;
        }
        Object.defineProperty(TerrainGeometry.prototype, "heightMap", {
            /**
             * 高度图路径
             */
            get: function () {
                return this._heightMap;
            },
            set: function (v) {
                if (this._heightMap == v)
                    return;
                this._heightMap = v;
                this.onHeightMapChanged();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TerrainGeometry.prototype, "width", {
            /**
             * 地形宽度
             */
            get: function () {
                return this._width;
            },
            set: function (v) {
                if (this._width == v)
                    return;
                this._width = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TerrainGeometry.prototype, "height", {
            /**
             * 地形高度
             */
            get: function () {
                return this._height;
            },
            set: function (v) {
                if (this._height == v)
                    return;
                this._height = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TerrainGeometry.prototype, "depth", {
            /**
             * 地形深度
             */
            get: function () {
                return this._depth;
            },
            set: function (v) {
                if (this._depth == v)
                    return;
                this._depth = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TerrainGeometry.prototype, "segmentsW", {
            /**
             * 横向网格段数
             */
            get: function () {
                return this._segmentsW;
            },
            set: function (v) {
                if (this._segmentsW == v)
                    return;
                this._segmentsW = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TerrainGeometry.prototype, "segmentsH", {
            /**
             * 纵向网格段数
             */
            get: function () {
                return this._segmentsH;
            },
            set: function (v) {
                if (this._segmentsH == v)
                    return;
                this._segmentsH = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TerrainGeometry.prototype, "maxElevation", {
            /**
             * 最大地形高度
             */
            get: function () {
                return this._maxElevation;
            },
            set: function (v) {
                if (this._maxElevation == v)
                    return;
                this._maxElevation = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TerrainGeometry.prototype, "minElevation", {
            /**
             * 最小地形高度
             */
            get: function () {
                return this._minElevation;
            },
            set: function (v) {
                if (this._minElevation == v)
                    return;
                this._minElevation = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        TerrainGeometry.prototype.onHeightMapChanged = function () {
            var _this = this;
            if (!this.heightMap["_pixels"]) {
                this._heightImageData = defaultHeightMap;
                this.invalidateGeometry();
                this.heightMap.once("loadCompleted", function () {
                    var img = _this.heightMap["_pixels"];
                    _this._heightImageData = feng3d.ImageUtil.fromImage(img).imageData;
                    _this.invalidateGeometry();
                });
                return;
            }
            var img = this.heightMap["_pixels"];
            this._heightImageData = feng3d.ImageUtil.fromImage(img).imageData;
            this.invalidateGeometry();
        };
        /**
         * 创建顶点坐标
         */
        TerrainGeometry.prototype.buildGeometry = function () {
            if (!this._heightImageData)
                return;
            var x, z;
            var numInds = 0;
            var base = 0;
            //一排顶点数据
            var tw = this.segmentsW + 1;
            //总顶点数量
            var numVerts = (this.segmentsH + 1) * tw;
            //一个格子所占高度图X轴像素数
            var uDiv = (this._heightImageData.width - 1) / this.segmentsW;
            //一个格子所占高度图Y轴像素数
            var vDiv = (this._heightImageData.height - 1) / this.segmentsH;
            var u, v;
            var y;
            var vertices = [];
            var indices = [];
            numVerts = 0;
            var col;
            for (var zi = 0; zi <= this.segmentsH; ++zi) {
                for (var xi = 0; xi <= this.segmentsW; ++xi) {
                    //顶点坐标
                    x = (xi / this.segmentsW - .5) * this.width;
                    z = (zi / this.segmentsH - .5) * this.depth;
                    //格子对应高度图uv坐标
                    u = xi * uDiv;
                    v = (this.segmentsH - zi) * vDiv;
                    //获取颜色值
                    col = this.getPixel(this._heightImageData, u, v) & 0xff;
                    //计算高度值
                    y = (col > this.maxElevation) ? (this.maxElevation / 0xff) * this.height : ((col < this.minElevation) ? (this.minElevation / 0xff) * this.height : (col / 0xff) * this.height);
                    //保存顶点坐标
                    vertices[numVerts++] = x;
                    vertices[numVerts++] = y;
                    vertices[numVerts++] = z;
                    if (xi != this.segmentsW && zi != this.segmentsH) {
                        //增加 一个顶点同时 生成一个格子或两个三角形
                        base = xi + zi * tw;
                        indices[numInds++] = base;
                        indices[numInds++] = base + tw;
                        indices[numInds++] = base + tw + 1;
                        indices[numInds++] = base;
                        indices[numInds++] = base + tw + 1;
                        indices[numInds++] = base + 1;
                    }
                }
            }
            var uvs = this.buildUVs();
            this.setVAData("a_position", vertices, 3);
            this.setVAData("a_uv", uvs, 2);
            this.indices = indices;
        };
        /**
         * 创建uv坐标
         */
        TerrainGeometry.prototype.buildUVs = function () {
            var numUvs = (this.segmentsH + 1) * (this.segmentsW + 1) * 2;
            var uvs = [];
            numUvs = 0;
            //计算每个顶点的uv坐标
            for (var yi = 0; yi <= this.segmentsH; ++yi) {
                for (var xi = 0; xi <= this.segmentsW; ++xi) {
                    uvs[numUvs++] = xi / this.segmentsW;
                    uvs[numUvs++] = 1 - yi / this.segmentsH;
                }
            }
            return uvs;
        };
        /**
         * 获取位置在（x，z）处的高度y值
         * @param x x坐标
         * @param z z坐标
         * @return 高度
         */
        TerrainGeometry.prototype.getHeightAt = function (x, z) {
            //得到高度图中的值
            var u = (x / this.width + .5) * (this._heightImageData.width - 1);
            var v = (-z / this.depth + .5) * (this._heightImageData.height - 1);
            var col = this.getPixel(this._heightImageData, u, v) & 0xff;
            var h;
            if (col > this.maxElevation) {
                h = (this.maxElevation / 0xff) * this.height;
            }
            else if (col < this.minElevation) {
                h = (this.minElevation / 0xff) * this.height;
            }
            else {
                h = (col / 0xff) * this.height;
            }
            return h;
        };
        /**
         * 获取像素值
         */
        TerrainGeometry.prototype.getPixel = function (imageData, u, v) {
            //取整
            u = ~~u;
            v = ~~v;
            var index = (v * imageData.width + u) * 4;
            var data = imageData.data;
            var red = data[index]; //红色色深
            var green = data[index + 1]; //绿色色深
            var blue = data[index + 2]; //蓝色色深
            var alpha = data[index + 3]; //透明度
            return blue;
        };
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], TerrainGeometry.prototype, "heightMap", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], TerrainGeometry.prototype, "width", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], TerrainGeometry.prototype, "height", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], TerrainGeometry.prototype, "depth", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], TerrainGeometry.prototype, "segmentsW", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], TerrainGeometry.prototype, "segmentsH", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], TerrainGeometry.prototype, "maxElevation", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], TerrainGeometry.prototype, "minElevation", null);
        return TerrainGeometry;
    }(feng3d.Geometry));
    feng3d.TerrainGeometry = TerrainGeometry;
    /**
     * 默认高度图
     */
    var defaultHeightMap = new feng3d.ImageUtil(1024, 1024, new feng3d.Color4(0, 0, 0, 0)).imageData;
    feng3d.AssetData.addAssetData("Terrain-Geometry", feng3d.Geometry.terrain = feng3d.serialization.setValue(new TerrainGeometry(), { name: "Terrain-Geometry", assetId: "Terrain-Geometry", hideFlags: feng3d.HideFlags.NotEditable }));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var TerrainUniforms = /** @class */ (function (_super) {
        __extends(TerrainUniforms, _super);
        function TerrainUniforms() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.__class__ = "feng3d.TerrainUniforms";
            _this.s_splatTexture1 = feng3d.Texture2D.default;
            _this.s_splatTexture2 = feng3d.Texture2D.default;
            _this.s_splatTexture3 = feng3d.Texture2D.default;
            _this.s_blendTexture = feng3d.Texture2D.default;
            _this.u_splatRepeats = new feng3d.Vector4(1, 1, 1, 1);
            return _this;
        }
        __decorate([
            feng3d.serialize,
            feng3d.oav({ block: "terrain" })
        ], TerrainUniforms.prototype, "s_splatTexture1", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ block: "terrain" })
        ], TerrainUniforms.prototype, "s_splatTexture2", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ block: "terrain" })
        ], TerrainUniforms.prototype, "s_splatTexture3", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ block: "terrain" })
        ], TerrainUniforms.prototype, "s_blendTexture", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ block: "terrain" })
        ], TerrainUniforms.prototype, "u_splatRepeats", void 0);
        return TerrainUniforms;
    }(feng3d.StandardUniforms));
    feng3d.TerrainUniforms = TerrainUniforms;
    feng3d.shaderConfig.shaders["terrain"].cls = TerrainUniforms;
    feng3d.AssetData.addAssetData("Terrain-Material", feng3d.Material.terrain = feng3d.serialization.setValue(new feng3d.Material(), { name: "Terrain-Material", assetId: "Terrain-Material", shaderName: "terrain", hideFlags: feng3d.HideFlags.NotEditable }));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 地形材质
     */
    var TerrainMergeMethod = /** @class */ (function (_super) {
        __extends(TerrainMergeMethod, _super);
        /**
         * 构建材质
         */
        function TerrainMergeMethod() {
            var _this = _super.call(this) || this;
            _this.splatMergeTexture = feng3d.Texture2D.default;
            _this.blendTexture = feng3d.Texture2D.default;
            _this.splatRepeats = new feng3d.Vector4(1, 1, 1, 1);
            _this.splatMergeTexture.minFilter = feng3d.TextureMinFilter.NEAREST;
            _this.splatMergeTexture.magFilter = feng3d.TextureMagFilter.NEAREST;
            _this.splatMergeTexture.wrapS = feng3d.TextureWrap.REPEAT;
            _this.splatMergeTexture.wrapT = feng3d.TextureWrap.REPEAT;
            return _this;
        }
        TerrainMergeMethod.prototype.beforeRender = function (renderAtomic) {
            renderAtomic.uniforms.s_blendTexture = this.blendTexture;
            renderAtomic.uniforms.s_splatMergeTexture = this.splatMergeTexture;
            renderAtomic.uniforms.u_splatMergeTextureSize = this.splatMergeTexture.getSize();
            renderAtomic.uniforms.u_splatRepeats = this.splatRepeats;
            //
            renderAtomic.uniforms.u_imageSize = new feng3d.Vector2(2048.0, 1024.0);
            renderAtomic.uniforms.u_tileSize = new feng3d.Vector2(512.0, 512.0);
            renderAtomic.uniforms.u_maxLod = 7;
            renderAtomic.uniforms.u_uvPositionScale = 0.001;
            renderAtomic.uniforms.u_tileOffset = [
                new feng3d.Vector4(0.5, 0.5, 0.0, 0.0),
                new feng3d.Vector4(0.5, 0.5, 0.5, 0.0),
                new feng3d.Vector4(0.5, 0.5, 0.0, 0.5),
            ];
            renderAtomic.uniforms.u_lod0vec = new feng3d.Vector4(0.5, 1, 0, 0);
        };
        return TerrainMergeMethod;
    }(feng3d.EventDispatcher));
    feng3d.TerrainMergeMethod = TerrainMergeMethod;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * The TerrainData class stores heightmaps, detail mesh positions, tree instances, and terrain texture alpha maps.
     *
     * The Terrain component links to the terrain data and renders it.
     */
    var TerrainData = /** @class */ (function () {
        function TerrainData() {
            /**
             * Resolution of the heightmap.
             */
            this.heightmapResolution = 513;
            /**
             * The total size in world units of the terrain.
             */
            this.size = new feng3d.Vector3(500, 600, 500);
            // /**
            //  * Height of the alpha map.
            //  * 混合贴图高度
            //  * @see https://blog.csdn.net/qq_29523119/article/details/52776731
            //  */
            // alphamapHeight
            // /**
            //  * Number of alpha map layers.
            //  */
            // alphamapLayers
            // /**
            //  * Resolution of the alpha map.
            //  */
            // alphamapResolution
            // /**
            //  * Alpha map textures used by the Terrain. Used by Terrain Inspector for undo.
            //  */
            // alphamapTextures
            // /**
            //  * Width of the alpha map.
            //  */
            // alphamapWidth
            // /**
            //  * Resolution of the base map used for rendering far patches on the terrain.
            //  */
            // baseMapResolution
            // /**
            //  * Detail height of the TerrainData.
            //  */
            // detailHeight
            // /**
            //  * Contains the detail texture / meshes that the terrain has.
            //  */
            // detailPrototypes
            // /**
            //  * Detail Resolution of the TerrainData.
            //  */
            // detailResolution
            // /**
            //  * Detail width of the TerrainData.
            //  */
            // detailWidth
            // /**
            //  * Splat texture used by the terrain.
            //  */
            // splatPrototypes
            // /**
            //  * The thickness of the terrain used for collision detection.
            //  */
            // thickness
            // /**
            //  * Returns the number of tree instances.
            //  */
            // treeInstanceCount
            // /**
            //  * Contains the current trees placed in the terrain.
            //  */
            // treeInstances
            // /**
            //  * The list of tree prototypes this are the ones available in the inspector.
            //  */
            // treePrototypes
            // /**
            //  * Amount of waving grass in the terrain.
            //  */
            // wavingGrassAmount
            // /**
            //  * Speed of the waving grass.
            //  */
            // wavingGrassSpeed
            // /**
            //  * Strength of the waving grass in the terrain.
            //  */
            // wavingGrassStrength
            // /**
            //  * Color of the waving grass that the terrain has.
            //  */
            // wavingGrassTint
        }
        Object.defineProperty(TerrainData.prototype, "heightmapWidth", {
            /**
             * Width of the terrain in samples(Read Only).
             */
            get: function () {
                return this.heightmapResolution;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TerrainData.prototype, "heightmapHeight", {
            /**
             * Height of the terrain in samples(Read Only).
             */
            get: function () {
                return this.heightmapResolution;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TerrainData.prototype, "heightmapScale", {
            /**
             * The size of each heightmap sample.
             */
            get: function () {
                return this.size.divideNumberTo(this.heightmapResolution);
            },
            enumerable: true,
            configurable: true
        });
        return TerrainData;
    }());
    feng3d.TerrainData = TerrainData;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * The Terrain component renders the terrain.
     */
    // @ov({ component: "OVTerrain" })
    var Terrain = /** @class */ (function (_super) {
        __extends(Terrain, _super);
        function Terrain() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.__class__ = "feng3d.Terrain";
            _this.geometry = feng3d.Geometry.terrain;
            _this.material = feng3d.Material.terrain;
            return _this;
        }
        return Terrain;
    }(feng3d.Model));
    feng3d.Terrain = Terrain;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子
     */
    var Particle = /** @class */ (function () {
        function Particle() {
            /**
             * 出生时间
             */
            this.birthTime = 0;
            /**
             * 寿命
             */
            this.lifetime = 5;
            /**
             * 位置
             */
            this.position = new feng3d.Vector3();
            /**
             * 速度
             */
            this.velocity = new feng3d.Vector3();
            /**
             * 旋转角度
             */
            this.rotation = new feng3d.Vector3();
            /**
             * 缩放
             */
            this.scale = new feng3d.Vector3(1, 1, 1);
            /**
             * 起始缩放
             */
            this.startScale = new feng3d.Vector3(1, 1, 1);
            /**
             * 颜色
             */
            this.color = new feng3d.Color4();
            /**
             * 起始颜色
             */
            this.startColor = new feng3d.Color4();
        }
        /**
         * 更新状态
         */
        Particle.prototype.updateState = function (preTime, time) {
            preTime = Math.max(preTime, this.birthTime);
            time = Math.max(this.birthTime, time);
            var pTime = time - preTime;
            // 计算位置
            this.position.x += this.velocity.x * pTime;
            this.position.y += this.velocity.y * pTime;
            this.position.z += this.velocity.z * pTime;
        };
        return Particle;
    }());
    feng3d.Particle = Particle;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var ParticleUniforms = /** @class */ (function (_super) {
        __extends(ParticleUniforms, _super);
        function ParticleUniforms() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.__class__ = "feng3d.ParticleUniforms";
            _this.s_diffuse = feng3d.Texture2D.defaultParticle;
            return _this;
        }
        return ParticleUniforms;
    }(feng3d.StandardUniforms));
    feng3d.ParticleUniforms = ParticleUniforms;
    feng3d.shaderConfig.shaders["particle"].cls = ParticleUniforms;
    feng3d.AssetData.addAssetData("Particle-Material", feng3d.Material.particle = feng3d.serialization.setValue(new feng3d.Material(), {
        name: "Particle-Material", assetId: "Particle-Material", shaderName: "particle",
        renderParams: { enableBlend: true, depthMask: false },
        hideFlags: feng3d.HideFlags.NotEditable,
    }));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子系统
     */
    var ParticleSystem = /** @class */ (function (_super) {
        __extends(ParticleSystem, _super);
        function ParticleSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.__class__ = "feng3d.ParticleSystem";
            _this._isPlaying = false;
            /**
             * 粒子时间
             */
            _this.time = 0;
            _this.geometry = feng3d.Geometry.billboard;
            _this.material = feng3d.Material.particle;
            _this.castShadows = true;
            _this.receiveShadows = true;
            _this._awaked = false;
            /**
             * 上次发射时间
             */
            _this._preEmitTime = 0;
            /**
             * 当前真实发射时间
             */
            _this._realEmitTime = 0;
            /**
             * 上次真实发射时间
             */
            _this._preRealEmitTime = 0;
            /**
             * 粒子池，用于存放未发射或者死亡粒子
             */
            _this._particlePool = [];
            /**
             * 活跃的粒子列表
             */
            _this._activeParticles = [];
            /**
             * 属性数据列表
             */
            _this._attributes = {
                a_particle_position: new feng3d.Attribute("a_particle_position", [], 3, 1),
                a_particle_scale: new feng3d.Attribute("a_particle_scale", [], 3, 1),
                a_particle_rotation: new feng3d.Attribute("a_particle_rotation", [], 3, 1),
                a_particle_color: new feng3d.Attribute("a_particle_color", [], 4, 1),
            };
            return _this;
        }
        Object.defineProperty(ParticleSystem.prototype, "isPlaying", {
            /**
             * 是否正在播放
             */
            get: function () {
                return this._isPlaying;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ParticleSystem.prototype, "numActiveParticles", {
            /**
             * 活跃粒子数量
             */
            get: function () {
                return this._activeParticles.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ParticleSystem.prototype, "single", {
            get: function () { return true; },
            enumerable: true,
            configurable: true
        });
        ParticleSystem.prototype.init = function () {
            var _this = this;
            _super.prototype.init.call(this);
            this._modules = [
                this.main = this.main || new feng3d.ParticleMainModule(),
                this.emission = this.emission || new feng3d.ParticleEmissionModule(),
                this.shape = this.shape || new feng3d.ParticleShapeModule(),
                this.velocityOverLifetime = this.velocityOverLifetime || new feng3d.ParticleVelocityOverLifetimeModule(),
                this.accelerationOverLifetime = this.accelerationOverLifetime || new feng3d.ParticleAccelerationOverLifetimeModule(),
                this.colorOverLifetime = this.colorOverLifetime || new feng3d.ParticleColorOverLifetimeModule(),
                this.scaleOverLifetime = this.scaleOverLifetime || new feng3d.ParticleScaleOverLifetimeModule(),
                this.palstanceOverLifetime = this.palstanceOverLifetime || new feng3d.ParticlePalstanceOverLifetimeModule(),
            ];
            this._modules.forEach(function (v) { return v.particleSystem = _this; });
        };
        ParticleSystem.prototype.update = function (interval) {
            if (!this.isPlaying)
                return;
            this.time = this.time + this.main.simulationSpeed * interval / 1000;
            this._realEmitTime = this.time - this.main.startDelay;
            this._updateActiveParticlesState();
            this._emit();
            this._preEmitTime = this.time;
            this._preRealEmitTime = this.time - this.main.startDelay;
            // 判断非循环的效果是否播放结束
            if (!this.main.loop && this._activeParticles.length == 0 && this.time > this.main.startDelay + this.main.duration) {
                this.stop();
                this.dispatch("particleCompleted", this);
            }
        };
        /**
         * 停止
         */
        ParticleSystem.prototype.stop = function () {
            this._isPlaying = false;
            this.time = 0;
            this._preEmitTime = 0;
            this._particlePool = this._particlePool.concat(this._activeParticles);
            this._activeParticles.length = 0;
        };
        /**
         * 播放
         */
        ParticleSystem.prototype.play = function () {
            this._isPlaying = true;
            this.time = 0;
            this._preEmitTime = 0;
            this._particlePool = this._particlePool.concat(this._activeParticles);
            this._activeParticles.length = 0;
        };
        /**
         * 暂停
         */
        ParticleSystem.prototype.pause = function () {
            this._isPlaying = false;
        };
        /**
         * 继续
         */
        ParticleSystem.prototype.continue = function () {
            this._isPlaying = true;
        };
        ParticleSystem.prototype.beforeRender = function (gl, renderAtomic, scene3d, camera) {
            _super.prototype.beforeRender.call(this, gl, renderAtomic, scene3d, camera);
            if (Boolean(scene3d.runEnvironment & feng3d.RunEnvironment.feng3d) && !this._awaked) {
                this._isPlaying = this.main.playOnAwake;
                this._awaked = true;
            }
            renderAtomic.instanceCount = this._activeParticles.length;
            //
            renderAtomic.shaderMacro.HAS_PARTICLE_ANIMATOR = true;
            var cameraMatrix = feng3d.lazy.getvalue(renderAtomic.uniforms.u_cameraMatrix);
            var localCameraPos = this.gameObject.transform.worldToLocalMatrix.transformVector(cameraMatrix.position);
            var localCameraUp = this.gameObject.transform.worldToLocalRotationMatrix.transformVector(cameraMatrix.up);
            var positions = [];
            var scales = [];
            var rotations = [];
            var colors = [];
            for (var i = 0, n = this._activeParticles.length; i < n; i++) {
                var particle = this._activeParticles[i];
                if (this.geometry == feng3d.Geometry.billboard && cameraMatrix) {
                    var matrix = new feng3d.Matrix4x4().recompose([particle.position, particle.rotation.scaleNumberTo(Math.DEG2RAD), particle.scale]);
                    matrix.lookAt(localCameraPos, localCameraUp);
                    particle.rotation = matrix.decompose()[1].scaleNumber(Math.RAD2DEG);
                }
                positions.push(particle.position.x, particle.position.y, particle.position.z);
                scales.push(particle.scale.x, particle.scale.y, particle.scale.z);
                rotations.push(particle.rotation.x, particle.rotation.y, particle.rotation.z);
                colors.push(particle.color.r, particle.color.g, particle.color.b, particle.color.a);
            }
            //
            this._attributes.a_particle_position.data = positions;
            this._attributes.a_particle_scale.data = scales;
            this._attributes.a_particle_rotation.data = rotations;
            this._attributes.a_particle_color.data = colors;
            //
            renderAtomic.uniforms.u_particleTime = this.time - this.main.startDelay;
            for (var key in this._attributes) {
                renderAtomic.attributes[key] = this._attributes[key];
            }
        };
        /**
         * 发射粒子
         * @param time 当前粒子时间
         */
        ParticleSystem.prototype._emit = function () {
            var _this = this;
            if (!this.emission.enabled)
                return;
            // 判断是否达到最大粒子数量
            if (this._activeParticles.length >= this.main.maxParticles)
                return;
            // 判断是否开始发射
            if (this.time <= this.main.startDelay)
                return;
            var duration = this.main.duration;
            var preRealEmitTime = this._preEmitTime - this.main.startDelay;
            // 判断是否结束发射
            if (!this.main.loop && preRealEmitTime >= duration)
                return;
            // 计算最后发射时间
            var realEmitTime = this.time - this.main.startDelay;
            if (!this.main.loop)
                realEmitTime = Math.min(realEmitTime, duration + this.main.startDelay);
            // 
            var emits = [];
            // 单粒子发射周期
            var step = 1 / this.emission.rate.getValue(this.main.rateAtDuration);
            var bursts = this.emission.bursts;
            // 遍历所有发射周期
            var cycleEndIndex = Math.ceil(realEmitTime / duration);
            var cycleStartIndex = Math.floor(preRealEmitTime / duration);
            for (var k = cycleStartIndex; k < cycleEndIndex; k++) {
                var cycleStartTime = k * duration;
                var cycleEndTime = (k + 1) * duration;
                // 单个周期内的起始与结束时间
                var startTime = Math.max(preRealEmitTime, cycleStartTime);
                var endTime = Math.min(realEmitTime, cycleEndTime);
                // 处理稳定发射
                var singleStart = Math.ceil(startTime / step) * step;
                for (var i = singleStart; i < endTime; i += step) {
                    emits.push({ time: i, num: 1 });
                }
                // 处理喷发
                var inCycleStart = startTime - cycleStartTime;
                var inCycleEnd = endTime - cycleStartTime;
                for (var i_1 = 0; i_1 < bursts.length; i_1++) {
                    var burst = bursts[i_1];
                    if (inCycleStart <= burst.time && burst.time <= inCycleEnd && burst.time <= realEmitTime) {
                        emits.push({ time: cycleStartTime + burst.time, num: burst.num });
                    }
                }
            }
            emits.sort(function (a, b) { return a.time - b.time; });
            ;
            emits.forEach(function (v) {
                _this._emitParticles(v.time, v.num);
            });
        };
        /**
         * 发射粒子
         * @param birthTime 发射时间
         * @param num 发射数量
         */
        ParticleSystem.prototype._emitParticles = function (birthTime, num) {
            for (var i = 0; i < num; i++) {
                if (this._activeParticles.length >= this.main.maxParticles)
                    return;
                var lifetime = this.main.startLifetime.getValue(((birthTime - this.main.startDelay) % this.main.duration) / this.main.duration);
                if (lifetime + birthTime + this.main.startDelay > this.time) {
                    var particle = this._particlePool.pop() || new feng3d.Particle();
                    particle.birthTime = birthTime;
                    particle.lifetime = lifetime;
                    this._activeParticles.push(particle);
                    this._initParticleState(particle);
                    this._updateParticleState(particle);
                }
            }
        };
        /**
         * 更新活跃粒子状态
         */
        ParticleSystem.prototype._updateActiveParticlesState = function () {
            for (var i = this._activeParticles.length - 1; i >= 0; i--) {
                var particle = this._activeParticles[i];
                if (particle.birthTime + particle.lifetime + this.main.startDelay < this.time) {
                    this._activeParticles.splice(i, 1);
                    this._particlePool.push(particle);
                }
                else {
                    this._updateParticleState(particle);
                }
            }
        };
        /**
         * 初始化粒子状态
         * @param particle 粒子
         */
        ParticleSystem.prototype._initParticleState = function (particle) {
            this._modules.forEach(function (v) { v.enabled && v.initParticleState(particle); });
        };
        /**
         * 更新粒子状态
         * @param particle 粒子
         */
        ParticleSystem.prototype._updateParticleState = function (particle) {
            var _this = this;
            var preTime = this._preRealEmitTime < particle.birthTime ? particle.birthTime : this._preRealEmitTime;
            var rateAtLifeTime = (this.time - this.main.startDelay - particle.birthTime) / particle.lifetime;
            //
            this._modules.forEach(function (v) { v.enabled && v.updateParticleState(particle, preTime, _this._realEmitTime, rateAtLifeTime); });
            particle.updateState(preTime, this._realEmitTime);
        };
        __decorate([
            feng3d.serialize,
            feng3d.oav({ block: "main", component: "OAVObjectView" })
        ], ParticleSystem.prototype, "main", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ block: "emission", component: "OAVObjectView" })
        ], ParticleSystem.prototype, "emission", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ block: "shape", component: "OAVObjectView" })
        ], ParticleSystem.prototype, "shape", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ block: "velocityOverLifetime", component: "OAVObjectView" })
        ], ParticleSystem.prototype, "velocityOverLifetime", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ block: "accelerationOverLifetime", component: "OAVObjectView" })
        ], ParticleSystem.prototype, "accelerationOverLifetime", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ block: "colorOverLifetime", component: "OAVObjectView" })
        ], ParticleSystem.prototype, "colorOverLifetime", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ block: "scaleOverLifetime", component: "OAVObjectView" })
        ], ParticleSystem.prototype, "scaleOverLifetime", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ block: "palstanceOverLifetime", component: "OAVObjectView" })
        ], ParticleSystem.prototype, "palstanceOverLifetime", void 0);
        __decorate([
            feng3d.oav({ block: "Renderer" })
        ], ParticleSystem.prototype, "geometry", void 0);
        __decorate([
            feng3d.oav({ block: "Renderer" })
        ], ParticleSystem.prototype, "material", void 0);
        __decorate([
            feng3d.oav({ block: "Renderer" }),
            feng3d.serialize
        ], ParticleSystem.prototype, "castShadows", void 0);
        __decorate([
            feng3d.oav({ block: "Renderer" }),
            feng3d.serialize
        ], ParticleSystem.prototype, "receiveShadows", void 0);
        return ParticleSystem;
    }(feng3d.Model));
    feng3d.ParticleSystem = ParticleSystem;
    feng3d.AssetData.addAssetData("Billboard-Geometry", feng3d.Geometry.billboard = feng3d.serialization.setValue(new feng3d.PlaneGeometry(), { name: "Billboard-Geometry", assetId: "Billboard-Geometry", yUp: false, hideFlags: feng3d.HideFlags.NotEditable }));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子模拟空间
     */
    var ParticleSystemSimulationSpace;
    (function (ParticleSystemSimulationSpace) {
        ParticleSystemSimulationSpace[ParticleSystemSimulationSpace["Local"] = 0] = "Local";
        ParticleSystemSimulationSpace[ParticleSystemSimulationSpace["World"] = 1] = "World";
        // Custom
    })(ParticleSystemSimulationSpace = feng3d.ParticleSystemSimulationSpace || (feng3d.ParticleSystemSimulationSpace = {}));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子缩放模式
     */
    var ParticleSystemScalingMode;
    (function (ParticleSystemScalingMode) {
        ParticleSystemScalingMode[ParticleSystemScalingMode["Hierarchy"] = 0] = "Hierarchy";
        ParticleSystemScalingMode[ParticleSystemScalingMode["Local"] = 1] = "Local";
        ParticleSystemScalingMode[ParticleSystemScalingMode["Shape"] = 2] = "Shape";
    })(ParticleSystemScalingMode = feng3d.ParticleSystemScalingMode || (feng3d.ParticleSystemScalingMode = {}));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var ParticleSystemShapeType;
    (function (ParticleSystemShapeType) {
        /**
         * 粒子系统 发射圆锥体
         */
        ParticleSystemShapeType[ParticleSystemShapeType["Cone"] = 0] = "Cone";
        /**
         * 粒子系统 发射球体
         */
        ParticleSystemShapeType[ParticleSystemShapeType["Sphere"] = 1] = "Sphere";
        /**
         * 粒子系统 发射盒子
         */
        ParticleSystemShapeType[ParticleSystemShapeType["Box"] = 2] = "Box";
        /**
         * 粒子系统 发射圆盘
         */
        ParticleSystemShapeType[ParticleSystemShapeType["Circle"] = 3] = "Circle";
        /**
         * 粒子系统 发射边
         */
        ParticleSystemShapeType[ParticleSystemShapeType["Edge"] = 4] = "Edge";
    })(ParticleSystemShapeType = feng3d.ParticleSystemShapeType || (feng3d.ParticleSystemShapeType = {}));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子系统 发射形状
     */
    var ParticleSystemShape = /** @class */ (function () {
        function ParticleSystemShape() {
        }
        /**
         * 初始化粒子状态
         * @param particle 粒子
         */
        ParticleSystemShape.prototype.initParticleState = function (particle) {
        };
        return ParticleSystemShape;
    }());
    feng3d.ParticleSystemShape = ParticleSystemShape;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子系统 发射圆锥体
     */
    var ParticleSystemShapeCone = /** @class */ (function (_super) {
        __extends(ParticleSystemShapeCone, _super);
        function ParticleSystemShapeCone() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.angle = 25;
            _this.radius = 1;
            _this.height = 5;
            _this.arc = 360;
            return _this;
        }
        /**
         * 初始化粒子状态
         * @param particle 粒子
         */
        ParticleSystemShapeCone.prototype.initParticleState = function (particle) {
            var speed = particle.velocity.length;
            // 计算位置
            var angle = Math.random() * Math.degToRad(this.arc);
            var r = Math.random();
            var p = new feng3d.Vector3(Math.sin(angle), Math.cos(angle), 0);
            particle.position.copy(p).scaleNumber(this.radius).scaleNumber(r);
            // 计算速度
            p.scaleNumber(this.radius + this.height * Math.tan(Math.degToRad(this.angle))).scaleNumber(r);
            p.z = this.height;
            var dir = p.sub(particle.position).normalize();
            particle.velocity.copy(dir).scaleNumber(speed);
        };
        __decorate([
            feng3d.serialize,
            feng3d.oav({ tooltip: "圆锥体开口角度。" })
        ], ParticleSystemShapeCone.prototype, "angle", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ tooltip: "圆锥体底部半径。" })
        ], ParticleSystemShapeCone.prototype, "radius", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ tooltip: "圆锥体高度" })
        ], ParticleSystemShapeCone.prototype, "height", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ tooltip: "在弧线周围产生了新的粒子。" })
        ], ParticleSystemShapeCone.prototype, "arc", void 0);
        return ParticleSystemShapeCone;
    }(feng3d.ParticleSystemShape));
    feng3d.ParticleSystemShapeCone = ParticleSystemShapeCone;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子系统 发射球体
     */
    var ParticleSystemShapeSphere = /** @class */ (function (_super) {
        __extends(ParticleSystemShapeSphere, _super);
        function ParticleSystemShapeSphere() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.radius = 1;
            return _this;
        }
        /**
         * 初始化粒子状态
         * @param particle 粒子
         */
        ParticleSystemShapeSphere.prototype.initParticleState = function (particle) {
            var speed = particle.velocity.length;
            // 计算位置
            var dir = feng3d.Vector3.random().scaleNumber(2).subNumber(1).normalize();
            var p = dir.scaleNumberTo(Math.random() * this.radius);
            particle.position.copy(p);
            // 计算速度
            particle.velocity.copy(dir).scaleNumber(speed);
        };
        __decorate([
            feng3d.serialize,
            feng3d.oav({ tooltip: "球体半径" })
        ], ParticleSystemShapeSphere.prototype, "radius", void 0);
        return ParticleSystemShapeSphere;
    }(feng3d.ParticleSystemShape));
    feng3d.ParticleSystemShapeSphere = ParticleSystemShapeSphere;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子系统 发射盒子
     */
    var ParticleSystemShapeBox = /** @class */ (function (_super) {
        __extends(ParticleSystemShapeBox, _super);
        function ParticleSystemShapeBox() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.boxX = 1;
            _this.boxY = 1;
            _this.boxZ = 1;
            return _this;
        }
        /**
         * 初始化粒子状态
         * @param particle 粒子
         */
        ParticleSystemShapeBox.prototype.initParticleState = function (particle) {
            var speed = particle.velocity.length;
            // 计算位置
            var dir = new feng3d.Vector3(0, 0, 1);
            var p = new feng3d.Vector3(this.boxX, this.boxY, this.boxZ).multiply(feng3d.Vector3.random().scaleNumber(2).subNumber(1));
            particle.position.copy(p);
            // 计算速度
            particle.velocity.copy(dir).scaleNumber(speed);
        };
        __decorate([
            feng3d.serialize,
            feng3d.oav({ tooltip: "盒子X方向宽度。" })
        ], ParticleSystemShapeBox.prototype, "boxX", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ tooltip: "盒子Y方向宽度。" })
        ], ParticleSystemShapeBox.prototype, "boxY", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ tooltip: "盒子Z方向宽度。" })
        ], ParticleSystemShapeBox.prototype, "boxZ", void 0);
        return ParticleSystemShapeBox;
    }(feng3d.ParticleSystemShape));
    feng3d.ParticleSystemShapeBox = ParticleSystemShapeBox;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子系统 发射圆盘
     */
    var ParticleSystemShapeCircle = /** @class */ (function (_super) {
        __extends(ParticleSystemShapeCircle, _super);
        function ParticleSystemShapeCircle() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.radius = 1;
            _this.arc = 360;
            return _this;
        }
        /**
         * 初始化粒子状态
         * @param particle 粒子
         */
        ParticleSystemShapeCircle.prototype.initParticleState = function (particle) {
            var speed = particle.velocity.length;
            // 计算位置
            var angle = Math.random() * Math.degToRad(this.arc);
            var dir = new feng3d.Vector3(Math.sin(angle), Math.cos(angle), 0);
            var p = dir.scaleNumberTo(this.radius * Math.random());
            //
            particle.position.copy(p);
            // 计算速度
            particle.velocity.copy(dir).scaleNumber(speed);
        };
        __decorate([
            feng3d.serialize,
            feng3d.oav({ tooltip: "半径" })
        ], ParticleSystemShapeCircle.prototype, "radius", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ tooltip: "弧度" })
        ], ParticleSystemShapeCircle.prototype, "arc", void 0);
        return ParticleSystemShapeCircle;
    }(feng3d.ParticleSystemShape));
    feng3d.ParticleSystemShapeCircle = ParticleSystemShapeCircle;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子系统 发射边
     */
    var ParticleSystemShapeEdge = /** @class */ (function (_super) {
        __extends(ParticleSystemShapeEdge, _super);
        function ParticleSystemShapeEdge() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.length = 1;
            return _this;
        }
        /**
         * 初始化粒子状态
         * @param particle 粒子
         */
        ParticleSystemShapeEdge.prototype.initParticleState = function (particle) {
            var speed = particle.velocity.length;
            // 计算位置
            var dir = new feng3d.Vector3(0, 0, 1);
            var p = new feng3d.Vector3(this.length * (Math.random() * 2 - 1), 0, 0);
            //
            particle.position.copy(p);
            // 计算速度
            particle.velocity.copy(dir).scaleNumber(speed);
        };
        __decorate([
            feng3d.serialize,
            feng3d.oav({ tooltip: "边长" })
        ], ParticleSystemShapeEdge.prototype, "length", void 0);
        return ParticleSystemShapeEdge;
    }(feng3d.ParticleSystemShape));
    feng3d.ParticleSystemShapeEdge = ParticleSystemShapeEdge;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子模块
     */
    var ParticleModule = /** @class */ (function (_super) {
        __extends(ParticleModule, _super);
        function ParticleModule() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 是否开启
             */
            _this.enabled = true;
            return _this;
        }
        /**
         * 初始化粒子状态
         * @param particle 粒子
         */
        ParticleModule.prototype.initParticleState = function (particle) {
        };
        /**
         * 更新粒子状态
         * @param particle 粒子
         */
        ParticleModule.prototype.updateParticleState = function (particle, preTime, time, rateAtLifeTime) {
        };
        __decorate([
            feng3d.oav({ tooltip: "是否开启" }),
            feng3d.serialize
        ], ParticleModule.prototype, "enabled", void 0);
        return ParticleModule;
    }(feng3d.EventDispatcher));
    feng3d.ParticleModule = ParticleModule;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子主模块
     */
    var ParticleMainModule = /** @class */ (function (_super) {
        __extends(ParticleMainModule, _super);
        function ParticleMainModule() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.enabled = true;
            /**
             * 粒子系统发射粒子的时间长度。如果系统是循环的，这表示一个循环的长度。
             */
            _this.duration = 5;
            /**
             * 如果为真，发射周期将在持续时间后重复。
             */
            _this.loop = true;
            /**
             * 这个粒子系统在发射粒子之前会等待几秒。
             */
            _this.startDelay = 0;
            /**
             * 起始寿命为秒，粒子寿命为0时死亡。
             */
            _this.startLifetime = feng3d.serialization.setValue(new feng3d.MinMaxCurve(), { between0And1: true, constant: 5, constant1: 5 });
            /**
             * 粒子的起始速度，应用于起始方向。
             */
            _this.startSpeed = feng3d.serialization.setValue(new feng3d.MinMaxCurve(), { constant: 5, constant1: 5 });
            /**
             * 粒子的起始缩放。
             */
            _this.startScale = feng3d.serialization.setValue(new feng3d.MinMaxCurveVector3(), { xCurve: { between0And1: true, constant: 1, constant1: 1 }, yCurve: { between0And1: true, constant: 1, constant1: 1 }, zCurve: { between0And1: true, constant: 1, constant1: 1 } });
            /**
             * 粒子的起始旋转角度。
             */
            _this.startRotation = feng3d.serialization.setValue(new feng3d.MinMaxCurveVector3(), { xCurve: { curveMultiplier: 180 }, yCurve: { curveMultiplier: 180 }, zCurve: { curveMultiplier: 180 } });
            /**
             * 粒子的起始颜色。
             */
            _this.startColor = new feng3d.MinMaxGradient();
            /**
             * 按物理管理器中定义的重力进行缩放。
             */
            _this.gravityModifier = new feng3d.MinMaxCurve();
            /**
             * 使粒子位置模拟在世界，本地或自定义空间。在本地空间中，它们相对于自己的转换而存在，在自定义空间中，它们相对于自定义转换。
             */
            // @serialize
            // @oav({ tooltip: "模拟空间，使粒子位置模拟在世界，本地或自定义空间。在本地空间中，它们相对于自己的转换而存在，在自定义空间中，它们相对于自定义转换。", component: "OAVEnum", componentParam: { enumClass: ParticleSystemSimulationSpace } })
            // simulationSpace = ParticleSystemSimulationSpace.Local;
            /**
             * 使粒子位置模拟相对于自定义转换组件。
             */
            // @serialize
            // @oav({ tooltip: "使粒子位置模拟相对于自定义转换组件。" })
            // customSimulationSpace: Transform;
            /**
             * 缩放粒子系统的播放速度。
             */
            _this.simulationSpeed = 1;
            /**
             * 我们应该使用来自整个层次的组合尺度，仅仅是这个粒子结点，还是仅仅对形状模块应用尺度
             */
            // @serialize
            // @oav({ tooltip: "我们应该使用来自整个层次的组合尺度，仅仅是这个粒子结点，还是仅仅对形状模块应用尺度?" })
            // scalingMode = ParticleSystemScalingMode.Local;
            /**
             * 如果启用，系统将自动开始运行。
             */
            _this.playOnAwake = true;
            /**
             * 系统中粒子的数量将被这个数限制。如果达到这个目标，排放将暂时发射。
             */
            _this.maxParticles = 1000;
            return _this;
        }
        Object.defineProperty(ParticleMainModule.prototype, "rateAtDuration", {
            /**
             * 此时在周期中的位置
             */
            get: function () {
                return ((this.particleSystem.time - this.startDelay) % this.duration) / this.duration;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 初始化粒子状态
         * @param particle 粒子
         */
        ParticleMainModule.prototype.initParticleState = function (particle) {
            var rateAtDuration = ((particle.birthTime - this.startDelay) % this.duration) / this.duration;
            //
            particle.position.init(0, 0, 0);
            particle.velocity.init(0, 0, this.startSpeed.getValue(rateAtDuration));
            particle.startScale.copy(this.startScale.getValue(rateAtDuration));
            //
            particle.rotation.copy(this.startRotation.getValue(rateAtDuration));
            //
            particle.startColor.copy(this.startColor.getValue(rateAtDuration));
        };
        /**
         * 更新粒子状态
         * @param particle 粒子
         */
        ParticleMainModule.prototype.updateParticleState = function (particle, preTime, time, rateAtLifeTime) {
            // 计算重力加速度影响速度
            var globalAcceleration = new feng3d.Vector3(0, -this.gravityModifier.getValue(this.rateAtDuration) * 9.8, 0);
            // 本地加速度
            var localAcceleration = this.particleSystem.transform.worldToLocalMatrix.deltaTransformVector(globalAcceleration);
            //
            particle.velocity.x += localAcceleration.x * (time - preTime);
            particle.velocity.y += localAcceleration.y * (time - preTime);
            particle.velocity.z += localAcceleration.z * (time - preTime);
            //
            particle.scale.copy(particle.startScale);
            //
            particle.color.copy(particle.startColor);
        };
        __decorate([
            feng3d.oav({ exclude: true })
        ], ParticleMainModule.prototype, "enabled", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ tooltip: "粒子系统发射粒子的时间长度。如果系统是循环的，这表示一个循环的长度。" })
        ], ParticleMainModule.prototype, "duration", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ tooltip: "如果为真，发射周期将在持续时间后重复。" })
        ], ParticleMainModule.prototype, "loop", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ tooltip: "这个粒子系统在发射粒子之前会等待几秒。" })
        ], ParticleMainModule.prototype, "startDelay", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ tooltip: "起始寿命为秒，粒子寿命为0时死亡。" })
        ], ParticleMainModule.prototype, "startLifetime", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ tooltip: "粒子的起始速度，应用于起始方向。" })
        ], ParticleMainModule.prototype, "startSpeed", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ tooltip: "粒子的起始缩放。" })
        ], ParticleMainModule.prototype, "startScale", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ tooltip: "粒子的起始旋转角度。" })
        ], ParticleMainModule.prototype, "startRotation", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ tooltip: "粒子的起始颜色。" })
        ], ParticleMainModule.prototype, "startColor", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ tooltip: "按物理管理器中定义的重力进行缩放。" })
        ], ParticleMainModule.prototype, "gravityModifier", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ tooltip: "缩放粒子系统的播放速度。" })
        ], ParticleMainModule.prototype, "simulationSpeed", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ tooltip: "如果启用，系统将自动开始运行。" })
        ], ParticleMainModule.prototype, "playOnAwake", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ tooltip: "系统中粒子的数量将被这个数限制。如果达到这个目标，将暂时发射。" })
        ], ParticleMainModule.prototype, "maxParticles", void 0);
        return ParticleMainModule;
    }(feng3d.ParticleModule));
    feng3d.ParticleMainModule = ParticleMainModule;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子发射器
     */
    var ParticleEmissionModule = /** @class */ (function (_super) {
        __extends(ParticleEmissionModule, _super);
        function ParticleEmissionModule() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 发射率，每秒发射粒子数量
             */
            _this.rate = feng3d.serialization.setValue(new feng3d.MinMaxCurve(), { between0And1: true, constant: 10, constant1: 10 });
            // rate = 10;
            /**
             * 爆发，在time时刻额外喷射particles粒子
             */
            _this.bursts = [];
            return _this;
        }
        __decorate([
            feng3d.serialize,
            feng3d.oav({ tooltip: "每秒发射粒子数量" })
        ], ParticleEmissionModule.prototype, "rate", void 0);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ component: "OAVArray", tooltip: "在指定时间进行额外发射指定数量的粒子", componentParam: { defaultItem: function () { return { time: 0, num: 30 }; } } })
        ], ParticleEmissionModule.prototype, "bursts", void 0);
        return ParticleEmissionModule;
    }(feng3d.ParticleModule));
    feng3d.ParticleEmissionModule = ParticleEmissionModule;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Shape of the emitter volume, which controls where particles are emitted and their initial direction.
     * 发射体体积的形状，它控制粒子发射的位置和初始方向。
     */
    var ParticleShapeModule = /** @class */ (function (_super) {
        __extends(ParticleShapeModule, _super);
        function ParticleShapeModule() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._type = feng3d.ParticleSystemShapeType.Cone;
            return _this;
        }
        Object.defineProperty(ParticleShapeModule.prototype, "type", {
            /**
             * 发射形状类型
             */
            get: function () {
                return this._type;
            },
            set: function (v) {
                if (this._type == v)
                    return;
                this._type = v;
                this._onTypeChanged();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 初始化粒子状态
         * @param particle 粒子
         */
        ParticleShapeModule.prototype.initParticleState = function (particle) {
            this.shape.initParticleState(particle);
        };
        ParticleShapeModule.prototype._onTypeChanged = function () {
            var preValue = this.shape;
            switch (this.type) {
                case feng3d.ParticleSystemShapeType.Cone:
                    this.shape = new feng3d.ParticleSystemShapeCone();
                    break;
                case feng3d.ParticleSystemShapeType.Sphere:
                    this.shape = new feng3d.ParticleSystemShapeSphere();
                    break;
                case feng3d.ParticleSystemShapeType.Box:
                    this.shape = new feng3d.ParticleSystemShapeBox();
                    break;
                case feng3d.ParticleSystemShapeType.Circle:
                    this.shape = new feng3d.ParticleSystemShapeCircle();
                    break;
                case feng3d.ParticleSystemShapeType.Edge:
                    this.shape = new feng3d.ParticleSystemShapeEdge();
                    break;
            }
            feng3d.serialization.setValue(this.shape, preValue);
            this.dispatch("refreshView");
        };
        __decorate([
            feng3d.serialize,
            feng3d.oav({ tooltip: "发射形状类型", component: "OAVEnum", componentParam: { enumClass: feng3d.ParticleSystemShapeType } })
        ], ParticleShapeModule.prototype, "type", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav({ component: "OAVObjectView" })
        ], ParticleShapeModule.prototype, "shape", void 0);
        return ParticleShapeModule;
    }(feng3d.ParticleModule));
    feng3d.ParticleShapeModule = ParticleShapeModule;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子系统 速度随时间变化模块
     *
     * Controls the velocity of each particle during its lifetime.
     * 控制每个粒子在其生命周期内的速度。
     */
    var ParticleVelocityOverLifetimeModule = /** @class */ (function (_super) {
        __extends(ParticleVelocityOverLifetimeModule, _super);
        function ParticleVelocityOverLifetimeModule() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.velocity = new feng3d.MinMaxCurveVector3();
            _this.space = feng3d.ParticleSystemSimulationSpace.Local;
            return _this;
        }
        /**
         * 更新粒子状态
         * @param particle 粒子
         */
        ParticleVelocityOverLifetimeModule.prototype.updateParticleState = function (particle, preTime, time, rateAtLifeTime) {
            var velocity = this.velocity.getValue(rateAtLifeTime);
            if (this.space == feng3d.ParticleSystemSimulationSpace.World) {
                this.particleSystem.transform.worldToLocalMatrix.deltaTransformVector(velocity, velocity);
            }
            //
            particle.position.x += velocity.x * (time - preTime);
            particle.position.y += velocity.y * (time - preTime);
            particle.position.z += velocity.z * (time - preTime);
        };
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], ParticleVelocityOverLifetimeModule.prototype, "velocity", void 0);
        __decorate([
            feng3d.oav({ tooltip: "模拟空间", component: "OAVEnum", componentParam: { enumClass: feng3d.ParticleSystemSimulationSpace } })
        ], ParticleVelocityOverLifetimeModule.prototype, "space", void 0);
        return ParticleVelocityOverLifetimeModule;
    }(feng3d.ParticleModule));
    feng3d.ParticleVelocityOverLifetimeModule = ParticleVelocityOverLifetimeModule;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子系统 加速度随时间变化模块
     *
     * 控制每个粒子在其生命周期内的加速度。
     */
    var ParticleAccelerationOverLifetimeModule = /** @class */ (function (_super) {
        __extends(ParticleAccelerationOverLifetimeModule, _super);
        function ParticleAccelerationOverLifetimeModule() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.acceleration = new feng3d.MinMaxCurveVector3();
            _this.space = feng3d.ParticleSystemSimulationSpace.Local;
            _this._preAcceleration = new feng3d.Vector3();
            _this._currentAcceleration = new feng3d.Vector3();
            return _this;
        }
        /**
         * 更新粒子状态
         * @param particle 粒子
         */
        ParticleAccelerationOverLifetimeModule.prototype.updateParticleState = function (particle, preTime, time, rateAtLifeTime) {
            //
            this._currentAcceleration.copy(this.acceleration.getValue(rateAtLifeTime));
            if (this.space == feng3d.ParticleSystemSimulationSpace.World) {
                this.particleSystem.transform.worldToLocalMatrix.deltaTransformVector(this._currentAcceleration, this._currentAcceleration);
            }
            //
            particle.velocity.x += (this._currentAcceleration.x + this._preAcceleration.x) * 0.5 * (time - preTime);
            particle.velocity.y += (this._currentAcceleration.y + this._preAcceleration.y) * 0.5 * (time - preTime);
            particle.velocity.z += (this._currentAcceleration.z + this._preAcceleration.z) * 0.5 * (time - preTime);
            this._preAcceleration = this._currentAcceleration.clone();
        };
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], ParticleAccelerationOverLifetimeModule.prototype, "acceleration", void 0);
        __decorate([
            feng3d.oav({ tooltip: "模拟空间", component: "OAVEnum", componentParam: { enumClass: feng3d.ParticleSystemSimulationSpace } })
        ], ParticleAccelerationOverLifetimeModule.prototype, "space", void 0);
        return ParticleAccelerationOverLifetimeModule;
    }(feng3d.ParticleModule));
    feng3d.ParticleAccelerationOverLifetimeModule = ParticleAccelerationOverLifetimeModule;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子系统 缩放随时间变化模块
     */
    var ParticleScaleOverLifetimeModule = /** @class */ (function (_super) {
        __extends(ParticleScaleOverLifetimeModule, _super);
        function ParticleScaleOverLifetimeModule() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.scale = feng3d.serialization.setValue(new feng3d.MinMaxCurveVector3(), { xCurve: { constant: 1, constant1: 1, curveMultiplier: 1 }, yCurve: { constant: 1, constant1: 1, curveMultiplier: 1 }, zCurve: { constant: 1, constant1: 1, curveMultiplier: 1 } });
            return _this;
        }
        /**
         * 更新粒子状态
         * @param particle 粒子
         */
        ParticleScaleOverLifetimeModule.prototype.updateParticleState = function (particle, preTime, time, rateAtLifeTime) {
            particle.scale.multiply(this.scale.getValue(rateAtLifeTime));
        };
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], ParticleScaleOverLifetimeModule.prototype, "scale", void 0);
        return ParticleScaleOverLifetimeModule;
    }(feng3d.ParticleModule));
    feng3d.ParticleScaleOverLifetimeModule = ParticleScaleOverLifetimeModule;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子系统 颜色随时间变化模块
     */
    var ParticleColorOverLifetimeModule = /** @class */ (function (_super) {
        __extends(ParticleColorOverLifetimeModule, _super);
        function ParticleColorOverLifetimeModule() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.color = new feng3d.MinMaxGradient();
            return _this;
        }
        /**
         * 更新粒子状态
         * @param particle 粒子
         */
        ParticleColorOverLifetimeModule.prototype.updateParticleState = function (particle, preTime, time, rateAtLifeTime) {
            particle.color.multiply(this.color.getValue(rateAtLifeTime));
        };
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], ParticleColorOverLifetimeModule.prototype, "color", void 0);
        return ParticleColorOverLifetimeModule;
    }(feng3d.ParticleModule));
    feng3d.ParticleColorOverLifetimeModule = ParticleColorOverLifetimeModule;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 粒子系统 角速度随时间变化模块
     */
    var ParticlePalstanceOverLifetimeModule = /** @class */ (function (_super) {
        __extends(ParticlePalstanceOverLifetimeModule, _super);
        function ParticlePalstanceOverLifetimeModule() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.palstance = feng3d.serialization.setValue(new feng3d.MinMaxCurveVector3(), { xCurve: { constant: 45, constant1: 45, curveMultiplier: 45 }, yCurve: { constant: 45, constant1: 45, curveMultiplier: 45 }, zCurve: { constant: 45, constant1: 45, curveMultiplier: 45 } });
            return _this;
        }
        /**
         * 更新粒子状态
         * @param particle 粒子
         */
        ParticlePalstanceOverLifetimeModule.prototype.updateParticleState = function (particle, preTime, time, rateAtLifeTime) {
            var v = this.palstance.getValue(rateAtLifeTime);
            particle.rotation.x += v.x * (time - preTime);
            particle.rotation.y += v.y * (time - preTime);
            particle.rotation.z += v.z * (time - preTime);
        };
        __decorate([
            feng3d.serialize,
            feng3d.oav({ tooltip: "角速度" })
        ], ParticlePalstanceOverLifetimeModule.prototype, "palstance", void 0);
        return ParticlePalstanceOverLifetimeModule;
    }(feng3d.ParticleModule));
    feng3d.ParticlePalstanceOverLifetimeModule = ParticlePalstanceOverLifetimeModule;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    // /**
    //  * 骨骼数据
    //
    //  */
    // export class Skeleton
    // {
    // }
    /**
     * 骨骼关节数据

     */
    var SkeletonJoint = /** @class */ (function () {
        function SkeletonJoint() {
            /** 父关节索引 （-1说明本身是总父结点，这个序号其实就是行号了，譬如上面”origin“结点的序号就是0，无父结点； "body"结点序号是1，父结点序号是0，也就是说父结点是”origin“）*/
            this.parentIndex = -1;
            this.children = [];
        }
        Object.defineProperty(SkeletonJoint.prototype, "invertMatrix3D", {
            get: function () {
                if (!this._invertMatrix3D)
                    this._invertMatrix3D = this.matrix3D.clone().invert();
                return this._invertMatrix3D;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            feng3d.serialize
        ], SkeletonJoint.prototype, "parentIndex", void 0);
        __decorate([
            feng3d.serialize
        ], SkeletonJoint.prototype, "name", void 0);
        __decorate([
            feng3d.serialize
        ], SkeletonJoint.prototype, "matrix3D", void 0);
        return SkeletonJoint;
    }());
    feng3d.SkeletonJoint = SkeletonJoint;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var SkeletonComponent = /** @class */ (function (_super) {
        __extends(SkeletonComponent, _super);
        function SkeletonComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.__class__ = "feng3d.SkeletonComponent";
            /** 骨骼关节数据列表 */
            _this.joints = [];
            //
            _this.isInitJoints = false;
            return _this;
        }
        Object.defineProperty(SkeletonComponent.prototype, "globalMatrices", {
            /**
             * 当前骨骼姿势的全局矩阵
             * @see #globalPose
             */
            get: function () {
                if (!this.isInitJoints) {
                    this.initSkeleton();
                    this.isInitJoints = true;
                }
                if (this._globalPropertiesInvalid) {
                    this.updateGlobalProperties();
                    this._globalPropertiesInvalid = false;
                }
                return this._globalMatrices;
            },
            enumerable: true,
            configurable: true
        });
        SkeletonComponent.prototype.initSkeleton = function () {
            this.jointGameobjects = [];
            this.jointGameObjectMap = {};
            //
            this.createSkeletonGameObject();
            //
            this._globalPropertiesInvalid = true;
            this._jointsInvalid = [];
            this._globalMatrix3DsInvalid = [];
            this.globalMatrix3Ds = [];
            this._globalMatrices = [];
            //
            var jointNum = this.joints.length;
            for (var i = 0; i < jointNum; i++) {
                this._jointsInvalid[i] = true;
                this._globalMatrix3DsInvalid[i] = true;
                this.globalMatrix3Ds[i] = new feng3d.Matrix4x4();
                this._globalMatrices[i] = new feng3d.Matrix4x4();
            }
        };
        /**
         * 更新骨骼全局变换矩阵
         */
        SkeletonComponent.prototype.updateGlobalProperties = function () {
            //姿势变换矩阵
            var joints = this.joints;
            var jointGameobjects = this.jointGameobjects;
            var globalMatrix3Ds = this.globalMatrix3Ds;
            var _globalMatrix3DsInvalid = this._globalMatrix3DsInvalid;
            //遍历每个关节
            for (var i = 0; i < joints.length; ++i) {
                if (!this._jointsInvalid[i])
                    continue;
                this._globalMatrices[i]
                    .copyFrom(globalMatrix3d(i))
                    .prepend(joints[i].invertMatrix3D);
                this._jointsInvalid[i] = false;
            }
            function globalMatrix3d(index) {
                if (!_globalMatrix3DsInvalid[index])
                    return globalMatrix3Ds[index];
                var jointPose = joints[index];
                var jointGameobject = jointGameobjects[index];
                globalMatrix3Ds[index] = jointGameobject.transform.matrix3d.clone();
                if (jointPose.parentIndex >= 0) {
                    var parentGlobalMatrix3d = globalMatrix3d(jointPose.parentIndex);
                    globalMatrix3Ds[index].append(parentGlobalMatrix3d);
                }
                _globalMatrix3DsInvalid[index] = false;
                return globalMatrix3Ds[index];
            }
        };
        SkeletonComponent.prototype.invalidjoint = function (jointIndex) {
            var _this = this;
            this._globalPropertiesInvalid = true;
            this._jointsInvalid[jointIndex] = true;
            this._globalMatrix3DsInvalid[jointIndex] = true;
            this.joints[jointIndex].children.forEach(function (element) {
                _this.invalidjoint(element);
            });
        };
        SkeletonComponent.prototype.createSkeletonGameObject = function () {
            var skeleton = this;
            var joints = skeleton.joints;
            var jointGameobjects = this.jointGameobjects;
            var jointGameObjectMap = this.jointGameObjectMap;
            for (var i = 0; i < joints.length; i++) {
                createJoint(i);
            }
            function createJoint(i) {
                if (jointGameobjects[i])
                    return jointGameobjects[i].gameObject;
                var skeletonJoint = joints[i];
                var parentGameobject;
                if (skeletonJoint.parentIndex != -1) {
                    parentGameobject = createJoint(skeletonJoint.parentIndex);
                    joints[skeletonJoint.parentIndex].children.push(i);
                }
                else {
                    parentGameobject = skeleton.gameObject;
                }
                var jointGameobject = parentGameobject.find(skeletonJoint.name);
                if (!jointGameobject) {
                    jointGameobject = feng3d.serialization.setValue(new feng3d.GameObject(), { name: skeletonJoint.name, hideFlags: feng3d.HideFlags.DontSave });
                    parentGameobject.addChild(jointGameobject);
                }
                var transform = jointGameobject.transform;
                var matrix3D = skeletonJoint.matrix3D;
                if (skeletonJoint.parentIndex != -1) {
                    matrix3D = matrix3D.clone().append(joints[skeletonJoint.parentIndex].invertMatrix3D);
                }
                transform.matrix3d = matrix3D;
                transform.on("transformChanged", function () {
                    skeleton.invalidjoint(i);
                });
                jointGameobjects[i] = transform;
                jointGameObjectMap[skeletonJoint.name] = transform;
                return jointGameobject;
            }
        };
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], SkeletonComponent.prototype, "joints", void 0);
        return SkeletonComponent;
    }(feng3d.Component));
    feng3d.SkeletonComponent = SkeletonComponent;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var SkinnedModel = /** @class */ (function (_super) {
        __extends(SkinnedModel, _super);
        function SkinnedModel() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.__class__ = "feng3d.SkinnedModel";
            _this.cacheU_skeletonGlobalMatriices = {};
            return _this;
        }
        Object.defineProperty(SkinnedModel.prototype, "single", {
            get: function () { return true; },
            enumerable: true,
            configurable: true
        });
        /**
         * 创建一个骨骼动画类
         */
        SkinnedModel.prototype.init = function () {
            _super.prototype.init.call(this);
            this.hideFlags = feng3d.HideFlags.DontTransform;
        };
        SkinnedModel.prototype.beforeRender = function (gl, renderAtomic, scene3d, camera) {
            var _this = this;
            _super.prototype.beforeRender.call(this, gl, renderAtomic, scene3d, camera);
            var frameId = null;
            var animation = this.getComponentsInParents(feng3d.Animation)[0];
            if (animation) {
                frameId = animation.clipName + "&" + animation.frame;
            }
            renderAtomic.uniforms.u_modelMatrix = function () { return _this.u_modelMatrix; };
            renderAtomic.uniforms.u_ITModelMatrix = function () { return _this.u_ITModelMatrix; };
            //
            var skeletonGlobalMatriices = this.cacheU_skeletonGlobalMatriices[frameId];
            if (!skeletonGlobalMatriices) {
                skeletonGlobalMatriices = this.u_skeletonGlobalMatriices;
                if (frameId)
                    this.cacheU_skeletonGlobalMatriices[frameId] = skeletonGlobalMatriices;
            }
            renderAtomic.uniforms.u_skeletonGlobalMatriices = skeletonGlobalMatriices;
            renderAtomic.shaderMacro.HAS_SKELETON_ANIMATION = true;
            renderAtomic.shaderMacro.NUM_SKELETONJOINT = this.skinSkeleton.joints.length;
        };
        /**
         * 销毁
         */
        SkinnedModel.prototype.dispose = function () {
            this.cacheSkeletonComponent = null;
            _super.prototype.dispose.call(this);
        };
        Object.defineProperty(SkinnedModel.prototype, "u_modelMatrix", {
            get: function () {
                if (this.cacheSkeletonComponent)
                    return this.cacheSkeletonComponent.transform.localToWorldMatrix;
                return this.transform.localToWorldMatrix;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkinnedModel.prototype, "u_ITModelMatrix", {
            get: function () {
                if (this.cacheSkeletonComponent)
                    return this.cacheSkeletonComponent.transform.ITlocalToWorldMatrix;
                return this.transform.ITlocalToWorldMatrix;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkinnedModel.prototype, "u_skeletonGlobalMatriices", {
            get: function () {
                if (!this.cacheSkeletonComponent) {
                    var gameObject = this.gameObject;
                    var skeletonComponent = null;
                    while (gameObject && !skeletonComponent) {
                        skeletonComponent = gameObject.getComponent(feng3d.SkeletonComponent);
                        gameObject = gameObject.parent;
                    }
                    this.cacheSkeletonComponent = skeletonComponent;
                }
                var skeletonGlobalMatriices = [];
                if (this.skinSkeleton && this.cacheSkeletonComponent) {
                    var joints = this.skinSkeleton.joints;
                    var globalMatrices = this.cacheSkeletonComponent.globalMatrices;
                    for (var i = joints.length - 1; i >= 0; i--) {
                        skeletonGlobalMatriices[i] = globalMatrices[joints[i][0]].clone();
                        if (this.initMatrix3d) {
                            skeletonGlobalMatriices[i].prepend(this.initMatrix3d);
                        }
                    }
                }
                else {
                    skeletonGlobalMatriices = defaultSkeletonGlobalMatriices;
                }
                return skeletonGlobalMatriices;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], SkinnedModel.prototype, "skinSkeleton", void 0);
        __decorate([
            feng3d.serialize
        ], SkinnedModel.prototype, "initMatrix3d", void 0);
        return SkinnedModel;
    }(feng3d.Model));
    feng3d.SkinnedModel = SkinnedModel;
    var defaultSkeletonGlobalMatriices = (function () { var v = [new feng3d.Matrix4x4()]; var i = 150; while (i-- > 1)
        v.push(v[0]); return v; })();
    var SkinSkeleton = /** @class */ (function () {
        function SkinSkeleton() {
            /**
             * [在整个骨架中的编号，骨骼名称]
             */
            this.joints = [];
            /**
             * 当前模型包含骨骼数量
             */
            this.numJoint = 0;
        }
        __decorate([
            feng3d.serialize
        ], SkinSkeleton.prototype, "joints", void 0);
        __decorate([
            feng3d.serialize
        ], SkinSkeleton.prototype, "numJoint", void 0);
        return SkinSkeleton;
    }());
    feng3d.SkinSkeleton = SkinSkeleton;
    var SkinSkeletonTemp = /** @class */ (function (_super) {
        __extends(SkinSkeletonTemp, _super);
        function SkinSkeletonTemp() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * temp 解析时临时数据
             */
            _this.cache_map = {};
            return _this;
        }
        SkinSkeletonTemp.prototype.resetJointIndices = function (jointIndices, skeleton) {
            var len = jointIndices.length;
            for (var i = 0; i < len; i++) {
                if (this.cache_map[jointIndices[i]] === undefined)
                    this.cache_map[jointIndices[i]] = this.numJoint++;
                jointIndices[i] = this.cache_map[jointIndices[i]];
            }
            this.joints.length = 0;
            for (var key in this.cache_map) {
                if (this.cache_map.hasOwnProperty(key)) {
                    this.joints[this.cache_map[key]] = [parseInt(key), skeleton.joints[key].name];
                }
            }
        };
        return SkinSkeletonTemp;
    }(SkinSkeleton));
    feng3d.SkinSkeletonTemp = SkinSkeletonTemp;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var PropertyClip = /** @class */ (function () {
        function PropertyClip() {
            this._cacheValues = {};
        }
        PropertyClip.prototype.getValue = function (cliptime, fps) {
            var _this = this;
            var frame = Math.round(fps * cliptime / 1000);
            if (this._cacheValues[frame] != undefined)
                return this._cacheValues[frame];
            this._propertyValues = this._propertyValues || this.propertyValues.map(function (v) {
                return [v[0], _this.getpropertyValue(v[1])];
            });
            var propertyValues = this._propertyValues;
            var propertyValue = propertyValues[0][1];
            if (cliptime <= propertyValues[0][0]) { }
            else if (cliptime >= propertyValues[propertyValues.length - 1][0])
                propertyValue = propertyValues[propertyValues.length - 1][1];
            else {
                for (var j = 0; j < propertyValues.length - 1; j++) {
                    if (propertyValues[j][0] <= cliptime && cliptime < propertyValues[j + 1][0]) {
                        propertyValue = this.interpolation(propertyValues[j][1], propertyValues[j + 1][1], (cliptime - propertyValues[j][0]) / (propertyValues[j + 1][0] - propertyValues[j][0]));
                        break;
                    }
                }
            }
            this._cacheValues[frame] = propertyValue;
            return propertyValue;
        };
        PropertyClip.prototype.interpolation = function (prevalue, nextValue, factor) {
            var propertyValue;
            if (prevalue instanceof feng3d.Quaternion) {
                propertyValue = prevalue.clone();
                propertyValue.lerp(prevalue, nextValue, factor);
            }
            else if (prevalue instanceof feng3d.Vector3) {
                propertyValue = new feng3d.Vector3(prevalue.x * (1 - factor) + nextValue.x * factor, prevalue.y * (1 - factor) + nextValue.y * factor, prevalue.z * (1 - factor) + nextValue.z * factor);
            }
            else {
                propertyValue = prevalue * (1 - factor) + nextValue * factor;
            }
            return propertyValue;
        };
        PropertyClip.prototype.getpropertyValue = function (value) {
            if (this.type == "Number")
                return value[0];
            if (this.type == "Vector3")
                return feng3d.Vector3.fromArray(value);
            if (this.type == "Quaternion")
                return feng3d.Quaternion.fromArray(value);
            console.error("\u672A\u5904\u7406 \u52A8\u753B\u6570\u636E\u7C7B\u578B " + this.type);
            console.error("");
        };
        __decorate([
            feng3d.serialize
        ], PropertyClip.prototype, "path", void 0);
        __decorate([
            feng3d.serialize
        ], PropertyClip.prototype, "propertyName", void 0);
        __decorate([
            feng3d.serialize
        ], PropertyClip.prototype, "type", void 0);
        __decorate([
            feng3d.serialize
        ], PropertyClip.prototype, "propertyValues", void 0);
        return PropertyClip;
    }());
    feng3d.PropertyClip = PropertyClip;
    var PropertyClipPathItemType;
    (function (PropertyClipPathItemType) {
        PropertyClipPathItemType[PropertyClipPathItemType["GameObject"] = 0] = "GameObject";
        PropertyClipPathItemType[PropertyClipPathItemType["Component"] = 1] = "Component";
    })(PropertyClipPathItemType = feng3d.PropertyClipPathItemType || (feng3d.PropertyClipPathItemType = {}));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var AnimationClip = /** @class */ (function (_super) {
        __extends(AnimationClip, _super);
        function AnimationClip() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.assetType = feng3d.AssetType.anim;
            _this.loop = true;
            return _this;
        }
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], AnimationClip.prototype, "name", void 0);
        __decorate([
            feng3d.serialize
        ], AnimationClip.prototype, "length", void 0);
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], AnimationClip.prototype, "loop", void 0);
        __decorate([
            feng3d.serialize
        ], AnimationClip.prototype, "propertyClips", void 0);
        return AnimationClip;
    }(feng3d.AssetData));
    feng3d.AnimationClip = AnimationClip;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var Animation = /** @class */ (function (_super) {
        __extends(Animation, _super);
        function Animation() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.animations = [];
            _this._time = 0;
            _this.isplaying = false;
            /**
             * 播放速度
             */
            _this.playspeed = 1;
            _this.num = 0;
            _this._fps = 24;
            _this._objectCache = new Map();
            return _this;
        }
        Object.defineProperty(Animation.prototype, "animation", {
            get: function () {
                return this._animation;
            },
            set: function (v) {
                if (this._animation == v)
                    return;
                this._animation = v;
                this.onAnimationChanged();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Animation.prototype, "time", {
            /**
             * 动画事件，单位为ms
             */
            get: function () {
                return this._time;
            },
            set: function (v) {
                if (this._time == v)
                    return;
                this._time = v;
                this.onTimeChanged();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Animation.prototype, "clipName", {
            /**
             * 动作名称
             */
            get: function () {
                return this.animation ? this.animation.name : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Animation.prototype, "frame", {
            get: function () {
                if (!this.animation)
                    return -1;
                var cycle = this.animation.length;
                var cliptime = (this.time % cycle + cycle) % cycle;
                var _frame = Math.round(this._fps * cliptime / 1000);
                return _frame;
            },
            enumerable: true,
            configurable: true
        });
        Animation.prototype.update = function (interval) {
            if (this.isplaying)
                this.time += interval * this.playspeed;
        };
        Animation.prototype.dispose = function () {
            this.animation = null;
            this.animations = null;
            _super.prototype.dispose.call(this);
        };
        Animation.prototype.updateAni = function () {
            if (!this.animation)
                return;
            if ((this.num++) % 2 != 0)
                return;
            var cycle = this.animation.length;
            var cliptime = (this.time % cycle + cycle) % cycle;
            var propertyClips = this.animation.propertyClips;
            for (var i = 0; i < propertyClips.length; i++) {
                var propertyClip = propertyClips[i];
                var propertyValues = propertyClip.propertyValues;
                if (propertyValues.length == 0)
                    continue;
                var propertyHost = this.getPropertyHost(propertyClip);
                if (!propertyHost)
                    continue;
                propertyHost[propertyClip.propertyName] = propertyClip.getValue(cliptime, this._fps);
            }
        };
        Animation.prototype.getPropertyHost = function (propertyClip) {
            if (propertyClip.cacheIndex && this._objectCache[propertyClip.cacheIndex])
                return this._objectCache[propertyClip.cacheIndex];
            if (!propertyClip.cacheIndex)
                propertyClip.cacheIndex = autoobjectCacheID++;
            var propertyHost = this.gameObject;
            var path = propertyClip.path;
            for (var i = 0; i < path.length; i++) {
                var element = path[i];
                switch (element[0]) {
                    case feng3d.PropertyClipPathItemType.GameObject:
                        propertyHost = propertyHost.find(element[1]);
                        break;
                    case feng3d.PropertyClipPathItemType.Component:
                        var componentType = feng3d.classUtils.getDefinitionByName(element[1]);
                        propertyHost = propertyHost.getComponent(componentType);
                        break;
                    default:
                        console.error("\u65E0\u6CD5\u83B7\u53D6 PropertyHost " + element);
                }
                if (propertyHost == null)
                    return null;
            }
            this._objectCache[propertyClip.cacheIndex] = propertyHost;
            return propertyHost;
        };
        Animation.prototype.onAnimationChanged = function () {
            this.time = 0;
        };
        Animation.prototype.onTimeChanged = function () {
            this.updateAni();
        };
        __decorate([
            feng3d.oav({ component: "OAVDefault", componentParam: { dragparam: { accepttype: "animationclip", datatype: "animationclip" } } }),
            feng3d.serialize
        ], Animation.prototype, "animation", null);
        __decorate([
            feng3d.oav({ component: "OAVArray", componentParam: { dragparam: { accepttype: "animationclip", datatype: "animationclip" }, defaultItem: function () { return new feng3d.AnimationClip(); } } }),
            feng3d.serialize
        ], Animation.prototype, "animations", void 0);
        __decorate([
            feng3d.oav()
        ], Animation.prototype, "time", null);
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], Animation.prototype, "isplaying", void 0);
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], Animation.prototype, "playspeed", void 0);
        return Animation;
    }(feng3d.Behaviour));
    feng3d.Animation = Animation;
    var autoobjectCacheID = 1;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 文件夹资源
     */
    var FolderAsset = /** @class */ (function (_super) {
        __extends(FolderAsset, _super);
        function FolderAsset() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.assetType = feng3d.AssetType.folder;
            /**
             * 子资源列表
             */
            _this.childrenAssets = [];
            return _this;
        }
        FolderAsset.prototype.initAsset = function () {
        };
        /**
         * 删除资源
         *
         * @param callback 完成回调
         */
        FolderAsset.prototype.delete = function (callback) {
            _super.prototype.delete.call(this, callback);
        };
        /**
         * 保存文件
         * @param callback 完成回调
         */
        FolderAsset.prototype.saveFile = function (callback) {
            this.rs.fs.mkdir(this.assetPath, callback);
        };
        /**
         * 读取文件
         * @param callback 完成回调
         */
        FolderAsset.prototype.readFile = function (callback) {
            callback && callback(null);
        };
        FolderAsset.extenson = "";
        __decorate([
            feng3d.serialize
        ], FolderAsset.prototype, "childrenAssets", void 0);
        return FolderAsset;
    }(feng3d.FileAsset));
    feng3d.FolderAsset = FolderAsset;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 二进制 资源
     */
    var ArrayBufferAsset = /** @class */ (function (_super) {
        __extends(ArrayBufferAsset, _super);
        function ArrayBufferAsset() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * 保存文件
         *
         * @param callback 完成回调
         */
        ArrayBufferAsset.prototype.saveFile = function (callback) {
            this.rs.fs.writeArrayBuffer(this.assetPath, this.arraybuffer, callback);
        };
        /**
         * 读取文件
         *
         * @param callback 完成回调
         */
        ArrayBufferAsset.prototype.readFile = function (callback) {
            var _this = this;
            this.rs.fs.readArrayBuffer(this.assetPath, function (err, data) {
                _this.arraybuffer = data;
                callback && callback(err);
            });
        };
        return ArrayBufferAsset;
    }(feng3d.FileAsset));
    feng3d.ArrayBufferAsset = ArrayBufferAsset;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 字符串 资源
     */
    var StringAsset = /** @class */ (function (_super) {
        __extends(StringAsset, _super);
        function StringAsset() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        StringAsset.prototype.saveFile = function (callback) {
            this.rs.fs.writeString(this.assetPath, this.textContent, callback);
        };
        /**
         * 读取文件
         *
         * @param callback 完成回调
         */
        StringAsset.prototype.readFile = function (callback) {
            var _this = this;
            this.rs.fs.readString(this.assetPath, function (err, data) {
                _this.textContent = data;
                callback && callback(err);
            });
        };
        __decorate([
            feng3d.oav({ component: "OAVMultiText" })
        ], StringAsset.prototype, "textContent", void 0);
        return StringAsset;
    }(feng3d.FileAsset));
    feng3d.StringAsset = StringAsset;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 对象资源
     */
    var ObjectAsset = /** @class */ (function (_super) {
        __extends(ObjectAsset, _super);
        function ObjectAsset() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(ObjectAsset.prototype, "data", {
            /**
             * 资源对象
             */
            get: function () {
                return this._data;
            },
            set: function (v) {
                if (this._data == v)
                    return;
                if (this._data) {
                    feng3d.objectevent.off(this._data, "propertyValueChanged", this._onDataChanged, this);
                }
                this._data = v;
                if (this._data) {
                    feng3d.objectevent.on(this._data, "propertyValueChanged", this._onDataChanged, this);
                }
            },
            enumerable: true,
            configurable: true
        });
        ObjectAsset.prototype.saveFile = function (callback) {
            this.data.assetId = this.assetId;
            var d = feng3d.serialization.serialize(this.data);
            this.rs.fs.writeObject(this.assetPath, d, function (err) {
                callback && callback(err);
            });
        };
        /**
         * 读取文件
         *
         * @param callback 完成回调
         */
        ObjectAsset.prototype.readFile = function (callback) {
            var _this = this;
            this.rs.fs.readObject(this.assetPath, function (err, object) {
                _this.rs.deserializeWithAssets(object, function (data) {
                    _this.data = data;
                    feng3d.debuger && console.assert(_this.data.assetId == _this.assetId);
                    callback && callback(err);
                });
            });
        };
        ObjectAsset.prototype._onDataChanged = function () {
            this.write();
        };
        __decorate([
            feng3d.oav({ component: "OAVObjectView" })
        ], ObjectAsset.prototype, "data", null);
        return ObjectAsset;
    }(feng3d.FileAsset));
    feng3d.ObjectAsset = ObjectAsset;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 脚本资源
     */
    var ScriptAsset = /** @class */ (function (_super) {
        __extends(ScriptAsset, _super);
        function ScriptAsset() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.assetType = feng3d.AssetType.script;
            return _this;
        }
        Object.defineProperty(ScriptAsset.prototype, "textContent", {
            get: function () {
                return this._textContent;
            },
            set: function (v) {
                if (this._textContent == v)
                    return;
                this._textContent = v;
                this.onTextContentChanged();
            },
            enumerable: true,
            configurable: true
        });
        ScriptAsset.prototype.initAsset = function () {
            this.textContent = this.textContent || "";
        };
        ScriptAsset.prototype.onTextContentChanged = function () {
            if (!this.textContent) {
                this.scriptName = "";
                return;
            }
            // 获取脚本类名称
            var result = feng3d.regExps.classReg.exec(this.textContent);
            feng3d.debuger && console.assert(result != null, "\u5728\u811A\u672C " + this.assetPath + " \u4E2D\u6CA1\u6709\u627E\u5230 \u811A\u672C\u7C7B\u5B9A\u4E49");
            var script = result[3];
            if (result[5]) {
                this.parentScriptName = result[5].split(".").pop();
            }
            // 获取导出类命名空间
            if (result[1]) {
                result = feng3d.regExps.namespace.exec(this.textContent);
                feng3d.debuger && console.assert(result != null, "\u83B7\u53D6\u811A\u672C " + this.assetPath + " \u547D\u540D\u7A7A\u95F4\u5931\u8D25");
                script = result[1] + "." + script;
            }
            this.scriptName = script;
        };
        ScriptAsset.extenson = ".ts";
        return ScriptAsset;
    }(feng3d.StringAsset));
    feng3d.ScriptAsset = ScriptAsset;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 着色器 资源
     */
    var ShaderAsset = /** @class */ (function (_super) {
        __extends(ShaderAsset, _super);
        function ShaderAsset() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.assetType = feng3d.AssetType.shader;
            return _this;
        }
        ShaderAsset.extenson = ".ts";
        return ShaderAsset;
    }(feng3d.ScriptAsset));
    feng3d.ShaderAsset = ShaderAsset;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * JS资源
     */
    var JSAsset = /** @class */ (function (_super) {
        __extends(JSAsset, _super);
        function JSAsset() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.assetType = feng3d.AssetType.js;
            return _this;
        }
        JSAsset.prototype.initAsset = function () {
            this.textContent = this.textContent || "";
        };
        JSAsset.extenson = ".js";
        return JSAsset;
    }(feng3d.StringAsset));
    feng3d.JSAsset = JSAsset;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * JSON 资源
     */
    var JsonAsset = /** @class */ (function (_super) {
        __extends(JsonAsset, _super);
        function JsonAsset() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.assetType = feng3d.AssetType.json;
            return _this;
        }
        JsonAsset.prototype.initAsset = function () {
            this.textContent = this.textContent || "{}";
        };
        JsonAsset.extenson = ".json";
        return JsonAsset;
    }(feng3d.StringAsset));
    feng3d.JsonAsset = JsonAsset;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var TextAsset = /** @class */ (function (_super) {
        __extends(TextAsset, _super);
        function TextAsset() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.assetType = feng3d.AssetType.txt;
            return _this;
        }
        TextAsset.prototype.initAsset = function () {
            this.textContent = this.textContent || "";
        };
        TextAsset.extenson = ".txt";
        return TextAsset;
    }(feng3d.StringAsset));
    feng3d.TextAsset = TextAsset;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 音效资源
     */
    var AudioAsset = /** @class */ (function (_super) {
        __extends(AudioAsset, _super);
        function AudioAsset() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.assetType = feng3d.AssetType.audio;
            return _this;
            // readonly extenson: ".ogg" | ".mp3" | ".wav" = ".mp3";
        }
        return AudioAsset;
    }(feng3d.ArrayBufferAsset));
    feng3d.AudioAsset = AudioAsset;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 纹理文件
     */
    var TextureAsset = /** @class */ (function (_super) {
        __extends(TextureAsset, _super);
        function TextureAsset() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.assetType = feng3d.AssetType.texture;
            return _this;
        }
        Object.defineProperty(TextureAsset.prototype, "image", {
            /**
             * 图片
             */
            get: function () { return this.data["_pixels"]; },
            set: function (v) {
                this.data["_pixels"] = v;
                this.saveFile();
            },
            enumerable: true,
            configurable: true
        });
        TextureAsset.prototype.initAsset = function () {
            this.data = this.data || new feng3d.Texture2D();
            this.data.assetId = this.data.assetId || this.assetId;
        };
        TextureAsset.prototype.saveFile = function (callback) {
            this.rs.fs.writeImage(this.assetPath, this.image, function (err) {
                callback && callback(err);
            });
        };
        /**
         * 读取文件
         *
         * @param callback 完成回调
         */
        TextureAsset.prototype.readFile = function (callback) {
            var _this = this;
            this.rs.fs.readImage(this.assetPath, function (err, img) {
                _this.data["_pixels"] = img;
                callback && callback(err);
            });
        };
        /**
         * 读取元标签
         *
         * @param callback 完成回调
         */
        TextureAsset.prototype.readMeta = function (callback) {
            var _this = this;
            _super.prototype.readMeta.call(this, function (err) {
                _this.rs.deserializeWithAssets(_this.meta.texture, function (result) {
                    _this.data = result;
                    callback && callback(err);
                });
            });
        };
        /**
         * 写元标签
         *
         * @param callback 完成回调
         */
        TextureAsset.prototype.writeMeta = function (callback) {
            this.meta.texture = feng3d.serialization.serialize(this.data);
            _super.prototype.writeMeta.call(this, callback);
        };
        TextureAsset.extenson = ".png";
        __decorate([
            feng3d.oav({ component: "OAVObjectView" })
        ], TextureAsset.prototype, "data", void 0);
        return TextureAsset;
    }(feng3d.FileAsset));
    feng3d.TextureAsset = TextureAsset;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 立方体纹理资源
     */
    var TextureCubeAsset = /** @class */ (function (_super) {
        __extends(TextureCubeAsset, _super);
        function TextureCubeAsset() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.assetType = feng3d.AssetType.texturecube;
            return _this;
        }
        TextureCubeAsset.prototype.initAsset = function () {
            this.data = this.data || new feng3d.TextureCube();
            this.data.assetId = this.data.assetId || this.assetId;
        };
        TextureCubeAsset.extenson = ".json";
        __decorate([
            feng3d.oav({ component: "OAVObjectView" })
        ], TextureCubeAsset.prototype, "data", void 0);
        return TextureCubeAsset;
    }(feng3d.ObjectAsset));
    feng3d.TextureCubeAsset = TextureCubeAsset;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 几何体资源
     */
    var GeometryAsset = /** @class */ (function (_super) {
        __extends(GeometryAsset, _super);
        function GeometryAsset() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.assetType = feng3d.AssetType.geometry;
            return _this;
        }
        GeometryAsset.prototype.initAsset = function () {
            this.data = this.data || new feng3d.CubeGeometry();
            this.data.assetId = this.data.assetId || this.assetId;
        };
        GeometryAsset.extenson = ".json";
        __decorate([
            feng3d.oav({ component: "OAVObjectView" })
        ], GeometryAsset.prototype, "data", void 0);
        return GeometryAsset;
    }(feng3d.ObjectAsset));
    feng3d.GeometryAsset = GeometryAsset;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 材质资源
     */
    var MaterialAsset = /** @class */ (function (_super) {
        __extends(MaterialAsset, _super);
        function MaterialAsset() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.assetType = feng3d.AssetType.material;
            return _this;
        }
        MaterialAsset.prototype.initAsset = function () {
            this.data = this.data || new feng3d.Material();
            this.data.assetId = this.data.assetId || this.assetId;
        };
        MaterialAsset.extenson = ".json";
        __decorate([
            feng3d.oav({ component: "OAVObjectView" })
        ], MaterialAsset.prototype, "data", void 0);
        return MaterialAsset;
    }(feng3d.ObjectAsset));
    feng3d.MaterialAsset = MaterialAsset;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 游戏对象资源
     */
    var GameObjectAsset = /** @class */ (function (_super) {
        __extends(GameObjectAsset, _super);
        function GameObjectAsset() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.assetType = feng3d.AssetType.gameobject;
            return _this;
        }
        GameObjectAsset.prototype.initAsset = function () {
            this.data = this.data || new feng3d.GameObject();
            this.data.assetId = this.data.assetId || this.assetId;
        };
        GameObjectAsset.prototype._getAssetData = function () {
            var gameobject = feng3d.serialization.clone(this.data);
            delete gameobject.assetId;
            gameobject.prefabId = this.assetId;
            return gameobject;
        };
        GameObjectAsset.extenson = ".json";
        __decorate([
            feng3d.oav({ component: "OAVObjectView" })
        ], GameObjectAsset.prototype, "data", void 0);
        return GameObjectAsset;
    }(feng3d.ObjectAsset));
    feng3d.GameObjectAsset = GameObjectAsset;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * OBJ模型解析器
     */
    var OBJParser = /** @class */ (function () {
        function OBJParser() {
        }
        /**
         * 解析
         * @param context
         */
        OBJParser.prototype.parser = function (context) {
            currentObj = null;
            currentSubObj = null;
            //
            var objData = { mtl: null, objs: [], vertex: [], vn: [], vt: [] };
            var lines = context.split("\n").reverse();
            do {
                var line = lines.pop();
                line && parserLine(line, objData);
            } while (lines.length > 0);
            return objData;
        };
        return OBJParser;
    }());
    feng3d.OBJParser = OBJParser;
    feng3d.objParser = new OBJParser();
    /** mtl正则 */
    var mtlReg = /mtllib\s+([\w\s]+\.mtl)/;
    /** 对象名称正则 */
    var objReg = /o\s+([\w\.]+)/;
    /** 顶点坐标正则 */
    var vertexReg = /v\s+([-\d.]+)\s+([-\d.]+)\s+([-\d.]+)/;
    /** 顶点法线正则 */
    var vnReg = /vn\s+([-\d.]+)\s+([-\d.]+)\s+([-\d.]+)/;
    /** 顶点uv正则 */
    var vtReg = /vt\s+([-\d.]+)\s+([-\d.]+)(\s+([-\d.]+))?/;
    /** 使用材质正则 */
    var usemtlReg = /usemtl\s+([\w.]+)/;
    /** 面正则 vertex */
    var faceV3Reg = /f\s+(\d+)\s+(\d+)\s+(\d+)/;
    /** 面正则 vertex */
    var faceVReg = /f\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)/;
    /** 面正则 vertex/uv/normal */
    var faceVUNReg = /f\s+((\d+)\/(\d+)\/(\d+))\s+((\d+)\/(\d+)\/(\d+))\s+((\d+)\/(\d+)\/(\d+))/;
    /** 面正则 vertex//normal */
    var faceVN3Reg = /f\s+(\d+)\/\/(\d+)\s+(\d+)\/\/(\d+)\s+(\d+)\/\/(\d+)/;
    // g
    var gReg = /g\s+([\(\)\w]+)?/;
    var sReg = /s\s+(\w+)/;
    //
    var currentObj;
    var currentSubObj;
    function parserLine(line, objData) {
        if (!line)
            return;
        line = line.trim();
        if (!line.length)
            return;
        if (line.charAt(0) == "#")
            return;
        var result;
        if ((result = mtlReg.exec(line)) && result[0] == line) {
            objData.mtl = result[1];
        }
        else if ((result = objReg.exec(line)) && result[0] == line) {
            currentObj = { name: result[1], subObjs: [] };
            objData.objs.push(currentObj);
        }
        else if ((result = vertexReg.exec(line)) && result[0] == line) {
            if (currentObj == null) {
                currentObj = { name: "", subObjs: [] };
                objData.objs.push(currentObj);
            }
            objData.vertex.push({ x: parseFloat(result[1]), y: parseFloat(result[2]), z: parseFloat(result[3]) });
        }
        else if ((result = vnReg.exec(line)) && result[0] == line) {
            objData.vn.push({ x: parseFloat(result[1]), y: parseFloat(result[2]), z: parseFloat(result[3]) });
        }
        else if ((result = vtReg.exec(line)) && result[0] == line) {
            objData.vt.push({ u: parseFloat(result[1]), v: 1 - parseFloat(result[2]), s: parseFloat(result[4]) });
        }
        else if ((result = gReg.exec(line)) && result[0] == line) {
            currentSubObj = { faces: [] };
            currentObj.subObjs.push(currentSubObj);
            currentSubObj.g = result[1];
        }
        else if ((result = sReg.exec(line)) && result[0] == line) {
        }
        else if ((result = usemtlReg.exec(line)) && result[0] == line) {
            currentSubObj = { faces: [] };
            currentObj.subObjs.push(currentSubObj);
            currentSubObj.material = result[1];
        }
        else if ((result = faceV3Reg.exec(line)) && result[0] == line) {
            currentSubObj.faces.push({
                indexIds: [result[2], result[1], result[3]],
                vertexIndices: [result[2], result[1], result[3]]
            });
        }
        else if ((result = faceVN3Reg.exec(line)) && result[0] == line) {
            currentSubObj.faces.push({
                indexIds: [result[3], result[1], result[5]],
                vertexIndices: [result[3], result[1], result[5]],
                normalIndices: [result[4], result[2], result[6]],
            });
        }
        else if ((result = faceVReg.exec(line)) && result[0] == line) {
            currentSubObj.faces.push({
                indexIds: [result[2], result[1], result[3]],
                vertexIndices: [result[2], result[1], result[3]]
            });
            currentSubObj.faces.push({
                indexIds: [result[4], result[3], result[1]],
                vertexIndices: [result[4], result[3], result[1]]
            });
        }
        else if ((result = faceVUNReg.exec(line)) && result[0] == line) {
            currentSubObj.faces.push({
                indexIds: [result[5], result[1], result[9]],
                vertexIndices: [result[6], result[2], result[10]],
                uvIndices: [result[7], result[3], result[11]],
                normalIndices: [result[8], result[4], result[12]]
            });
        }
        else {
            throw new Error("\u65E0\u6CD5\u89E3\u6790" + line);
        }
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * OBJ模型MTL材质解析器
     */
    var MTLParser = /** @class */ (function () {
        function MTLParser() {
        }
        /**
         * 解析
         * @param context
         */
        MTLParser.prototype.parser = function (context) {
            var mtl = {};
            var lines = context.split("\n");
            for (var i = 0; i < lines.length; i++) {
                var element = lines[i];
                parserLine(lines[i], mtl);
            }
            return mtl;
        };
        return MTLParser;
    }());
    feng3d.MTLParser = MTLParser;
    feng3d.mtlParser = new MTLParser();
    var newmtlReg = /newmtl\s+([\w.]+)/;
    var kaReg = /Ka\s+([\d.]+)\s+([\d.]+)\s+([\d.]+)/;
    var kdReg = /Kd\s+([\d.]+)\s+([\d.]+)\s+([\d.]+)/;
    var ksReg = /Ks\s+([\d.]+)\s+([\d.]+)\s+([\d.]+)/;
    var nsReg = /Ns\s+([\d.]+)/;
    var niReg = /Ni\s+([\d.]+)/;
    var dReg = /d\s+([\d.]+)/;
    var illumReg = /illum\s+([\d]+)/;
    var map_Bump_Reg = /map_Bump\s+([\w\W]+\.[\w\W]+)/;
    var map_Ka_Reg = /map_Ka\s+([\w\W]+\.[\w\W]+)/;
    var map_Kd_Reg = /map_Kd\s+([\w\W]+\.[\w\W]+)/;
    var map_Ks_Reg = /map_Ks\s+([\w\W]+\.[\w\W]+)/;
    var currentMaterial;
    function parserLine(line, mtl) {
        if (!line)
            return;
        line = line.trim();
        if (!line.length)
            return;
        if (line.charAt(0) == "#")
            return;
        var result;
        if ((result = newmtlReg.exec(line)) && result[0] == line) {
            currentMaterial = { name: result[1], ka: [], kd: [], ks: [], ns: 0, ni: 0, d: 0, illum: 0, map_Bump: "", map_Ka: "", map_Kd: "", map_Ks: "" };
            mtl[currentMaterial.name] = currentMaterial;
        }
        else if ((result = kaReg.exec(line)) && result[0] == line) {
            currentMaterial.ka = [parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3])];
        }
        else if ((result = kdReg.exec(line)) && result[0] == line) {
            currentMaterial.kd = [parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3])];
        }
        else if ((result = ksReg.exec(line)) && result[0] == line) {
            currentMaterial.ks = [parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3])];
        }
        else if ((result = nsReg.exec(line)) && result[0] == line) {
            currentMaterial.ns = parseFloat(result[1]);
        }
        else if ((result = niReg.exec(line)) && result[0] == line) {
            currentMaterial.ni = parseFloat(result[1]);
        }
        else if ((result = dReg.exec(line)) && result[0] == line) {
            currentMaterial.d = parseFloat(result[1]);
        }
        else if ((result = illumReg.exec(line)) && result[0] == line) {
            currentMaterial.illum = parseFloat(result[1]);
        }
        else if ((result = map_Bump_Reg.exec(line)) && result[0] == line) {
            currentMaterial.map_Bump = result[1];
        }
        else if ((result = map_Ka_Reg.exec(line)) && result[0] == line) {
            currentMaterial.map_Ka = result[1];
        }
        else if ((result = map_Kd_Reg.exec(line)) && result[0] == line) {
            currentMaterial.map_Kd = result[1];
        }
        else if ((result = map_Ks_Reg.exec(line)) && result[0] == line) {
            currentMaterial.map_Ks = result[1];
        }
        else {
            throw new Error("\u65E0\u6CD5\u89E3\u6790" + line);
        }
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * MD5模型解析器
     */
    var MD5MeshParser = /** @class */ (function () {
        function MD5MeshParser() {
        }
        /**
         * 解析
         * @param context
         */
        MD5MeshParser.prototype.parse = function (context) {
            //
            var md5MeshData = {};
            var lines = context.split("\n");
            for (var i = 0; i < lines.length; i++) {
                parserLine(lines[i], md5MeshData);
            }
            return md5MeshData;
        };
        return MD5MeshParser;
    }());
    feng3d.MD5MeshParser = MD5MeshParser;
    feng3d.md5MeshParser = new MD5MeshParser();
    var MD5VersionReg = /MD5Version\s+(\d+)/;
    var commandlineReg = /commandline\s+"([\w\s/.-]+)"/;
    var numJointsReg = /numJoints\s+(\d+)/;
    var numMeshesReg = /numMeshes\s+(\d+)/;
    var jointsStartReg = /joints\s+{/;
    var jointsReg = /"(\w+)"\s+([-\d]+)\s+\(\s+([\d.-]+)\s+([\d.-]+)\s+([\d.-]+)\s+\)\s+\(\s+([\d.-]+)\s+([\d.-]+)\s+([\d.-]+)\s+\)(\s+\/\/(\s+\w+)?)?/;
    var endBlockReg = /}/;
    var meshStartReg = /mesh\s+{/;
    var annotationReg = /\/\/[\s\w:]+/;
    var shaderReg = /shader\s+"([\w\/]+)"/;
    var numvertsReg = /numverts\s+(\d+)/;
    var vertReg = /vert\s+(\d+)\s+\(\s+([\d.]+)\s+([\d.]+)\s+\)\s+(\d+)\s+(\d+)/;
    var numtrisReg = /numtris\s+(\d+)/;
    var triReg = /tri\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)/;
    var numweightsReg = /numweights\s+(\d+)/;
    var weightReg = /weight\s+(\d+)\s+(\d+)\s+([\d.]+)\s+\(\s+([\d.-]+)\s+([\d.-]+)\s+([\d.-]+)\s+\)/;
    /**
     * 状态
     */
    var State;
    (function (State) {
        /** 读取关节 */
        State[State["joints"] = 0] = "joints";
        State[State["mesh"] = 1] = "mesh";
    })(State || (State = {}));
    /** 当前处于状态 */
    var states = [];
    var currentMesh;
    function parserLine(line, md5MeshData) {
        if (!line)
            return;
        line = line.trim();
        if (!line.length)
            return;
        var result;
        if ((result = MD5VersionReg.exec(line)) && result[0] == line) {
            md5MeshData.MD5Version = parseInt(result[1]);
        }
        else if ((result = commandlineReg.exec(line)) && result[0] == line) {
            md5MeshData.commandline = result[1];
        }
        else if ((result = numJointsReg.exec(line)) && result[0] == line) {
            md5MeshData.numJoints = parseInt(result[1]);
        }
        else if ((result = numMeshesReg.exec(line)) && result[0] == line) {
            md5MeshData.numMeshes = parseInt(result[1]);
        }
        else if ((result = jointsStartReg.exec(line)) && result[0] == line) {
            states.push(State.joints);
            md5MeshData.joints = [];
        }
        else if ((result = jointsReg.exec(line)) && result[0] == line) {
            md5MeshData.joints.push({
                name: result[1], parentIndex: parseInt(result[2]),
                position: [parseFloat(result[3]), parseFloat(result[4]), parseFloat(result[5])],
                rotation: [parseFloat(result[6]), parseFloat(result[7]), parseFloat(result[8])]
            });
        }
        else if ((result = endBlockReg.exec(line)) && result[0] == line) {
            var exitState = states.pop();
            if (exitState == State.mesh) {
                currentMesh = null;
            }
        }
        else if ((result = meshStartReg.exec(line)) && result[0] == line) {
            states.push(State.mesh);
            if (!md5MeshData.meshs) {
                md5MeshData.meshs = [];
            }
            currentMesh = {};
            md5MeshData.meshs.push(currentMesh);
        }
        else if ((result = annotationReg.exec(line)) && result[0] == line) {
        }
        else if ((result = shaderReg.exec(line)) && result[0] == line) {
            currentMesh.shader = result[1];
        }
        else if ((result = numvertsReg.exec(line)) && result[0] == line) {
            currentMesh.numverts = parseInt(result[1]);
            currentMesh.verts = [];
        }
        else if ((result = vertReg.exec(line)) && result[0] == line) {
            currentMesh.verts.push({
                index: parseFloat(result[1]), u: parseFloat(result[2]), v: parseFloat(result[3]),
                startWeight: parseFloat(result[4]), countWeight: parseFloat(result[5])
            });
        }
        else if ((result = numtrisReg.exec(line)) && result[0] == line) {
            currentMesh.numtris = parseInt(result[1]);
            currentMesh.tris = [];
        }
        else if ((result = triReg.exec(line)) && result[0] == line) {
            var index = parseInt(result[1]) * 3;
            currentMesh.tris[index] = parseInt(result[2]);
            currentMesh.tris[index + 1] = parseInt(result[3]);
            currentMesh.tris[index + 2] = parseInt(result[4]);
        }
        else if ((result = numweightsReg.exec(line)) && result[0] == line) {
            currentMesh.numweights = parseInt(result[1]);
            currentMesh.weights = [];
        }
        else if ((result = weightReg.exec(line)) && result[0] == line) {
            currentMesh.weights.push({
                index: parseInt(result[1]), joint: parseInt(result[2]), bias: parseFloat(result[3]),
                pos: [parseFloat(result[4]), parseFloat(result[5]), parseFloat(result[6])]
            });
        }
        else {
            throw new Error("\u65E0\u6CD5\u89E3\u6790" + line);
        }
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * MD5动画解析器
     */
    var MD5AnimParser = /** @class */ (function () {
        function MD5AnimParser() {
        }
        /**
         * 解析
         * @param context
         */
        MD5AnimParser.prototype.parse = function (context) {
            var md5AnimData = {};
            var lines = context.split("\n").reverse();
            do {
                var line = lines.pop();
                line && parserLine(line, md5AnimData);
            } while (line);
            return md5AnimData;
        };
        return MD5AnimParser;
    }());
    feng3d.MD5AnimParser = MD5AnimParser;
    feng3d.md5AnimParser = new MD5AnimParser();
    var MD5VersionReg = /MD5Version\s+(\d+)/;
    var commandlineReg = /commandline\s+"([\w\s/.-]+)"/;
    var numFramesReg = /numFrames\s+(\d+)/;
    var numJointsReg = /numJoints\s+(\d+)/;
    var frameRateReg = /frameRate\s+(\d+)/;
    var numAnimatedComponentsReg = /numAnimatedComponents\s+(\d+)/;
    var hierarchyStartReg = /hierarchy\s+{/;
    var hierarchyReg = /"(\w+)"\s+([\d-]+)\s+(\d+)\s+(\d+)(\s+\/\/(\s+\w+)?(\s+\([\s\w]+\))?)?/;
    var endBlockReg = /}/;
    var boundsStartReg = /bounds\s+{/;
    //2组3个number
    var number32Reg = /\(\s+([\d.-]+)\s+([\d.-]+)\s+([\d.-]+)\s+\)\s+\(\s+([\d.-]+)\s+([\d.-]+)\s+([\d.-]+)\s+\)/;
    var baseframeStartReg = /baseframe\s+{/;
    var frameStartReg = /frame\s+(\d+)\s+{/;
    var numbersReg = /(-?[\d.]+)(\s+-?[\d.]+){0,}/;
    /**
     * 状态
     */
    var State;
    (function (State) {
        State[State["hierarchy"] = 0] = "hierarchy";
        State[State["bounds"] = 1] = "bounds";
        State[State["baseframe"] = 2] = "baseframe";
        State[State["frame"] = 3] = "frame";
    })(State || (State = {}));
    /** 当前处于状态 */
    var states = [];
    var currentFrame;
    function parserLine(line, md5AnimData) {
        if (!line)
            return;
        line = line.trim();
        if (!line.length)
            return;
        var result;
        if ((result = MD5VersionReg.exec(line)) && result[0] == line) {
            md5AnimData.MD5Version = parseInt(result[1]);
        }
        else if ((result = commandlineReg.exec(line)) && result[0] == line) {
            md5AnimData.commandline = result[1];
        }
        else if ((result = numFramesReg.exec(line)) && result[0] == line) {
            md5AnimData.numFrames = parseInt(result[1]);
        }
        else if ((result = numJointsReg.exec(line)) && result[0] == line) {
            md5AnimData.numJoints = parseInt(result[1]);
        }
        else if ((result = frameRateReg.exec(line)) && result[0] == line) {
            md5AnimData.frameRate = parseInt(result[1]);
        }
        else if ((result = numAnimatedComponentsReg.exec(line)) && result[0] == line) {
            md5AnimData.numAnimatedComponents = parseInt(result[1]);
        }
        else if ((result = hierarchyStartReg.exec(line)) && result[0] == line) {
            md5AnimData.hierarchy = [];
            states.push(State.hierarchy);
        }
        else if ((result = hierarchyReg.exec(line)) && result[0] == line) {
            switch (states[states.length - 1]) {
                case State.hierarchy:
                    md5AnimData.hierarchy.push({
                        name: result[1], parentIndex: parseInt(result[2]),
                        flags: parseInt(result[3]), startIndex: parseInt(result[4])
                    });
                    break;
                default:
                    throw new Error("没有对应的数据处理");
            }
        }
        else if ((result = endBlockReg.exec(line)) && result[0] == line) {
            var state = states.pop();
            if (state == State.frame) {
                if (currentFrame && currentFrame.components.length != md5AnimData.numAnimatedComponents) {
                    throw new Error("frame中数据不对");
                }
                currentFrame = null;
            }
        }
        else if ((result = boundsStartReg.exec(line)) && result[0] == line) {
            md5AnimData.bounds = [];
            states.push(State.bounds);
        }
        else if ((result = baseframeStartReg.exec(line)) && result[0] == line) {
            md5AnimData.baseframe = [];
            states.push(State.baseframe);
        }
        else if ((result = number32Reg.exec(line)) && result[0] == line) {
            switch (states[states.length - 1]) {
                case State.bounds:
                    md5AnimData.bounds.push({ min: [parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3])], max: [parseFloat(result[4]), parseFloat(result[5]), parseFloat(result[6])] });
                    break;
                case State.baseframe:
                    md5AnimData.baseframe.push({ position: [parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3])], orientation: [parseFloat(result[4]), parseFloat(result[5]), parseFloat(result[6])] });
                    break;
                default:
                    throw new Error("没有对应的数据处理");
            }
        }
        else if ((result = frameStartReg.exec(line)) && result[0] == line) {
            if (!md5AnimData.frame) {
                md5AnimData.frame = [];
            }
            currentFrame = { index: parseInt(result[1]), components: [] };
            md5AnimData.frame.push(currentFrame);
            states.push(State.frame);
        }
        else if ((result = numbersReg.exec(line)) && result[0] == line) {
            switch (states[states.length - 1]) {
                case State.frame:
                    if (currentFrame) {
                        var numbers = line.split(" ");
                        for (var i = 0; i < numbers.length; i++) {
                            currentFrame.components.push(parseFloat(numbers[i]));
                        }
                    }
                    break;
                default:
                    throw new Error("没有对应的数据处理");
            }
        }
        else {
            throw new Error("\u65E0\u6CD5\u89E3\u6790" + line);
        }
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var war3;
    (function (war3) {
        /**
         * 透明度动画
         */
        var AnimAlpha = /** @class */ (function () {
            function AnimAlpha() {
            }
            return AnimAlpha;
        }());
        war3.AnimAlpha = AnimAlpha;
        /**
         * 全局动作信息
         */
        var AnimInfo = /** @class */ (function () {
            function AnimInfo() {
                /** 是否循环 */
                this.loop = true;
            }
            return AnimInfo;
        }());
        war3.AnimInfo = AnimInfo;
        /**
         * 几何体动作信息
         */
        var AnimInfo1 = /** @class */ (function () {
            function AnimInfo1() {
            }
            return AnimInfo1;
        }());
        war3.AnimInfo1 = AnimInfo1;
        /**
         * 骨骼的角度信息
         */
        var BoneRotation = /** @class */ (function () {
            function BoneRotation() {
                this.rotations = [];
            }
            BoneRotation.prototype.getRotationItem = function (rotation) {
                var quaternion = new feng3d.Quaternion();
                if (this.type == "DontInterp") {
                    quaternion.fromEulerAngles(rotation.value.x, rotation.value.y, rotation.value.z);
                }
                else {
                    quaternion.copy(rotation.value);
                }
                return quaternion;
            };
            BoneRotation.prototype.getRotation = function (keyFrameTime) {
                var rotationQuaternion = new feng3d.Quaternion();
                if (this.rotations.length == 0 || keyFrameTime < this.rotations[0].time || keyFrameTime > this.rotations[this.rotations.length - 1].time)
                    return new feng3d.Quaternion();
                var key1 = this.rotations[0];
                var key2 = this.rotations[0];
                for (var i = 0; i < this.rotations.length; i++) {
                    key2 = this.rotations[i];
                    if (key2.time > keyFrameTime) {
                        break;
                    }
                    key1 = key2;
                }
                if (key1 == key2) {
                    rotationQuaternion.copy(key1.value);
                    return rotationQuaternion;
                }
                var Factor = (keyFrameTime - key1.time) / (key2.time - key1.time);
                var InverseFactor = 1.0 - Factor;
                var tempVec;
                var Factor1;
                var Factor2;
                var Factor3;
                var Factor4;
                var FactorTimesTwo;
                var InverseFactorTimesTwo;
                var q;
                var q1;
                var q2;
                switch (this.type) {
                    case "DontInterp":
                        rotationQuaternion.fromEulerAngles(key1.value.x, key1.value.y, key1.value.z);
                        break;
                    case "Linear":
                        q1 = key1.value.clone();
                        q2 = key2.value.clone();
                        q1.slerpTo(q2, Factor, rotationQuaternion);
                        break;
                    case "Hermite":
                    case "Bezier":
                        q1 = key1.value.clone();
                        q2 = key2.value.clone();
                        q1.slerpTo(q2, Factor, rotationQuaternion);
                        break;
                }
                return rotationQuaternion;
            };
            return BoneRotation;
        }());
        war3.BoneRotation = BoneRotation;
        /**
         * 骨骼信息(包含骨骼，helper等其他对象)
         */
        var BoneObject = /** @class */ (function () {
            function BoneObject() {
                /** 父对象 */
                this.Parent = -1;
                /** 骨骼位移动画 */
                this.Translation = new BoneTranslation();
                /** 骨骼缩放动画 */
                this.Scaling = new BoneScaling();
                /** 骨骼角度动画 */
                this.Rotation = new BoneRotation();
                /** 当前对象变换矩阵 */
                this.c_transformation = new feng3d.Matrix4x4();
                /** 当前全局变换矩阵 */
                this.c_globalTransformation = new feng3d.Matrix4x4();
            }
            BoneObject.prototype.calculateTransformation = function (keyFrameTime) {
                var pScalingCenter = this.pivotPoint;
                var pScaling = this.Scaling.getScaling(keyFrameTime);
                var pRotation = this.Rotation.getRotation(keyFrameTime);
                var pTranslation = this.Translation.getTranslation(keyFrameTime);
                var matrix3D = this.c_transformation;
                matrix3D.appendScale(pScaling.x, pScaling.y, pScaling.z).append(pRotation.toMatrix3D());
                //设置旋转缩放中心
                matrix3D.prependTranslation(-this.pivotPoint.x, -this.pivotPoint.y, -this.pivotPoint.z);
                matrix3D.appendTranslation(this.pivotPoint.x, this.pivotPoint.y, this.pivotPoint.z);
                //平移
                matrix3D.appendTranslation(pTranslation.x, pTranslation.y, pTranslation.z);
                //
            };
            BoneObject.prototype.buildAnimationclip = function (animationclip, __chache__, start, end) {
                var path = [
                    [feng3d.PropertyClipPathItemType.GameObject, this.name],
                    [feng3d.PropertyClipPathItemType.Component, "feng3d.Transform"],
                ];
                if (this.Scaling.scalings.length > 0) {
                    var scalings = this.Scaling.scalings;
                    for (var i = 0, n = scalings.length; i < n; i++) {
                        var scaling = scalings[i];
                        if (start <= scaling.time && scaling.time <= end) {
                            setPropertyClipFrame(path, "scale", scaling.time - start, scaling.value.toArray(), "Vector3");
                        }
                    }
                }
                if (this.Translation.translations.length > 0) {
                    var translations = this.Translation.translations;
                    for (var i = 0, n = translations.length; i < n; i++) {
                        var translation = translations[i];
                        if (start <= translation.time && translation.time <= end) {
                            setPropertyClipFrame(path, "position", translation.time - start, translation.value.addTo(this.pivotPoint).toArray(), "Vector3");
                        }
                    }
                }
                if (this.Rotation.rotations.length > 0) {
                    var rotations = this.Rotation.rotations;
                    for (var i = 0, n = rotations.length; i < n; i++) {
                        var rotation = rotations[i];
                        if (start <= rotation.time && rotation.time <= end) {
                            setPropertyClipFrame(path, "orientation", rotation.time - start, this.Rotation.getRotationItem(rotation).toArray(), "Quaternion");
                        }
                    }
                }
                function setPropertyClipFrame(path, propertyName, time, propertyValue, type) {
                    var propertyClip = getPropertyClip(path, propertyName);
                    propertyClip.type = type;
                    propertyClip.propertyValues.push([time, propertyValue]);
                }
                function getPropertyClip(path, propertyName) {
                    var key = path.join("-") + propertyName;
                    if (__chache__[key])
                        return __chache__[key];
                    if (!__chache__[key]) {
                        var propertyClip = __chache__[key] = new feng3d.PropertyClip();
                        propertyClip.path = path;
                        propertyClip.propertyName = propertyName;
                        propertyClip.propertyValues = [];
                        animationclip.propertyClips.push(propertyClip);
                    }
                    return __chache__[key];
                }
            };
            BoneObject.prototype.getMatrix3D = function (time) {
                var pScaling = this.Scaling.getScaling(time);
                var pRotation = this.Rotation.getRotation(time);
                var pTranslation = this.Translation.getTranslation(time);
                var matrix3D = new feng3d.Matrix4x4().appendScale(pScaling.x, pScaling.y, pScaling.z).append(pRotation.toMatrix3D());
                //平移
                matrix3D.appendTranslation(pTranslation.x + this.pivotPoint.x, pTranslation.y + this.pivotPoint.y, pTranslation.z + this.pivotPoint.z);
                //
                return matrix3D;
            };
            return BoneObject;
        }());
        war3.BoneObject = BoneObject;
        /**
         * 骨骼的位移信息
         */
        var BoneScaling = /** @class */ (function () {
            function BoneScaling() {
                this.scalings = [];
            }
            BoneScaling.prototype.getScaling = function (keyFrameTime) {
                var scalingVector = new feng3d.Vector3();
                if (this.scalings.length == 0 || keyFrameTime < this.scalings[0].time || keyFrameTime > this.scalings[this.scalings.length - 1].time)
                    return new feng3d.Vector3(1, 1, 1);
                var key1 = this.scalings[0];
                var key2 = this.scalings[0];
                for (var i = 0; i < this.scalings.length; i++) {
                    key2 = this.scalings[i];
                    if (key2.time >= keyFrameTime) {
                        break;
                    }
                    key1 = key2;
                }
                if (key1.time == key2.time) {
                    scalingVector.copy(key1.value);
                    return scalingVector;
                }
                var Factor = (keyFrameTime - key1.time) / (key2.time - key1.time);
                var InverseFactor = 1.0 - Factor;
                var tempVec;
                var Factor1;
                var Factor2;
                var Factor3;
                var Factor4;
                var FactorTimesTwo;
                var InverseFactorTimesTwo;
                switch (this.type) {
                    case "DontInterp":
                        scalingVector.copy(key1.value);
                        break;
                    case "Linear":
                        tempVec = key1.value.clone();
                        tempVec.scaleNumber(InverseFactor);
                        scalingVector.add(tempVec);
                        tempVec = key2.value.clone();
                        tempVec.scaleNumber(Factor);
                        scalingVector.add(tempVec);
                        break;
                    case "Hermite":
                        FactorTimesTwo = Factor * Factor;
                        Factor1 = FactorTimesTwo * (2.0 * Factor - 3.0) + 1;
                        Factor2 = FactorTimesTwo * (Factor - 2.0) + Factor;
                        Factor3 = FactorTimesTwo * (Factor - 1.0);
                        Factor4 = FactorTimesTwo * (3.0 - 2.0 * Factor);
                        tempVec = key1.value.clone();
                        tempVec.scaleNumber(Factor1);
                        scalingVector.add(tempVec);
                        tempVec = key1.OutTan.clone();
                        tempVec.scaleNumber(Factor2);
                        scalingVector.add(tempVec);
                        tempVec = key2.InTan.clone();
                        tempVec.scaleNumber(Factor3);
                        scalingVector.add(tempVec);
                        tempVec = key2.value.clone();
                        tempVec.scaleNumber(Factor4);
                        scalingVector.add(tempVec);
                        break;
                    case "Bezier":
                        FactorTimesTwo = Factor * Factor;
                        InverseFactorTimesTwo = InverseFactor * InverseFactor;
                        Factor1 = InverseFactorTimesTwo * InverseFactor;
                        Factor2 = 3.0 * Factor * InverseFactorTimesTwo;
                        Factor3 = 3.0 * FactorTimesTwo * InverseFactor;
                        Factor4 = FactorTimesTwo * Factor;
                        tempVec = key1.value.clone();
                        tempVec.scaleNumber(Factor1);
                        scalingVector.add(tempVec);
                        tempVec = key1.OutTan.clone();
                        tempVec.scaleNumber(Factor2);
                        scalingVector.add(tempVec);
                        tempVec = key2.InTan.clone();
                        tempVec.scaleNumber(Factor3);
                        scalingVector.add(tempVec);
                        tempVec = key2.value.clone();
                        tempVec.scaleNumber(Factor4);
                        scalingVector.add(tempVec);
                        break;
                }
                return scalingVector;
            };
            return BoneScaling;
        }());
        war3.BoneScaling = BoneScaling;
        /**
         * 骨骼的位移信息
         */
        var BoneTranslation = /** @class */ (function () {
            function BoneTranslation() {
                this.translations = [];
            }
            BoneTranslation.prototype.getTranslation = function (keyFrameTime) {
                var TranslationVector = new feng3d.Vector3();
                if (this.translations.length == 0)
                    return new feng3d.Vector3();
                var key1 = this.translations[0];
                var key2 = this.translations[0];
                for (var i = 0; i < this.translations.length; i++) {
                    key2 = this.translations[i];
                    if (key2.time > keyFrameTime) {
                        break;
                    }
                    key1 = key2;
                }
                if (key1 == key2) {
                    TranslationVector.copy(key1.value);
                    return TranslationVector;
                }
                var Factor = (keyFrameTime - key1.time) / (key2.time - key1.time);
                var InverseFactor = 1.0 - Factor;
                var tempVec;
                var Factor1;
                var Factor2;
                var Factor3;
                var Factor4;
                var FactorTimesTwo;
                var InverseFactorTimesTwo;
                switch (this.type) {
                    case "DontInterp":
                        TranslationVector.copy(key1.value);
                        break;
                    case "Linear":
                        tempVec = key1.value.clone();
                        tempVec.scaleNumber(InverseFactor);
                        TranslationVector.add(tempVec);
                        tempVec = key2.value.clone();
                        tempVec.scaleNumber(Factor);
                        TranslationVector.add(tempVec);
                        break;
                    case "Hermite":
                        FactorTimesTwo = Factor * Factor;
                        Factor1 = FactorTimesTwo * (2.0 * Factor - 3.0) + 1;
                        Factor2 = FactorTimesTwo * (Factor - 2.0) + Factor;
                        Factor3 = FactorTimesTwo * (Factor - 1.0);
                        Factor4 = FactorTimesTwo * (3.0 - 2.0 * Factor);
                        tempVec = key1.value.clone();
                        tempVec.scaleNumber(Factor1);
                        TranslationVector.add(tempVec);
                        tempVec = key1.OutTan.clone();
                        tempVec.scaleNumber(Factor2);
                        TranslationVector.add(tempVec);
                        tempVec = key2.InTan.clone();
                        tempVec.scaleNumber(Factor3);
                        TranslationVector.add(tempVec);
                        tempVec = key2.value.clone();
                        tempVec.scaleNumber(Factor4);
                        TranslationVector.add(tempVec);
                        break;
                    case "Bezier":
                        FactorTimesTwo = Factor * Factor;
                        InverseFactorTimesTwo = InverseFactor * InverseFactor;
                        Factor1 = InverseFactorTimesTwo * InverseFactor;
                        Factor2 = 3.0 * Factor * InverseFactorTimesTwo;
                        Factor3 = 3.0 * FactorTimesTwo * InverseFactor;
                        Factor4 = FactorTimesTwo * Factor;
                        tempVec = key1.value.clone();
                        tempVec.scaleNumber(Factor1);
                        TranslationVector.add(tempVec);
                        tempVec = key1.OutTan.clone();
                        tempVec.scaleNumber(Factor2);
                        TranslationVector.add(tempVec);
                        tempVec = key2.InTan.clone();
                        tempVec.scaleNumber(Factor3);
                        TranslationVector.add(tempVec);
                        tempVec = key2.value.clone();
                        tempVec.scaleNumber(Factor4);
                        TranslationVector.add(tempVec);
                        break;
                }
                return TranslationVector;
            };
            return BoneTranslation;
        }());
        war3.BoneTranslation = BoneTranslation;
        /**
         * 纹理
         */
        var FBitmap = /** @class */ (function () {
            function FBitmap() {
            }
            return FBitmap;
        }());
        war3.FBitmap = FBitmap;
        /**
         * 几何设置
         */
        var Geoset = /** @class */ (function () {
            function Geoset() {
                /** 动作信息 */
                this.Anims = [];
            }
            return Geoset;
        }());
        war3.Geoset = Geoset;
        /**
         * 几何体动画
         */
        var GeosetAnim = /** @class */ (function () {
            function GeosetAnim() {
            }
            return GeosetAnim;
        }());
        war3.GeosetAnim = GeosetAnim;
        /**
         * 全局序列
         */
        var Globalsequences = /** @class */ (function () {
            function Globalsequences() {
                /** 持续时间 */
                this.durations = [];
            }
            return Globalsequences;
        }());
        war3.Globalsequences = Globalsequences;
        /**
         * 动作间隔
         */
        var Interval = /** @class */ (function () {
            function Interval() {
            }
            return Interval;
        }());
        war3.Interval = Interval;
        /**
         * 材质层
         */
        var Layer = /** @class */ (function () {
            function Layer() {
            }
            return Layer;
        }());
        war3.Layer = Layer;
        /**
         * 材质
         */
        var Material = /** @class */ (function () {
            function Material() {
                /** 材质层列表 */
                this.layers = [];
            }
            return Material;
        }());
        war3.Material = Material;
        /**
         * 模型信息
         */
        var Model = /** @class */ (function () {
            function Model() {
            }
            return Model;
        }());
        war3.Model = Model;
        /**
         *
         */
        var Rotation = /** @class */ (function () {
            function Rotation() {
            }
            return Rotation;
        }());
        war3.Rotation = Rotation;
        /**
         *
         */
        var Scaling = /** @class */ (function () {
            function Scaling() {
            }
            return Scaling;
        }());
        war3.Scaling = Scaling;
        /**
         *
         */
        var Translation = /** @class */ (function () {
            function Translation() {
            }
            return Translation;
        }());
        war3.Translation = Translation;
    })(war3 = feng3d.war3 || (feng3d.war3 = {}));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var war3;
    (function (war3) {
        /**
         * war3模型数据
         */
        var War3Model = /** @class */ (function () {
            function War3Model() {
                /** 几何设置列表 */
                this.geosets = [];
                /** 骨骼动画列表 */
                this.bones = [];
            }
            War3Model.prototype.getMesh = function () {
                this.meshs = [];
                this.meshs.length = this.geosets.length;
                var container = feng3d.serialization.setValue(new feng3d.GameObject(), { name: this.model.name });
                var skeletonjoints = createSkeleton(this);
                this.skeletonComponent = container.addComponent(feng3d.SkeletonComponent);
                this.skeletonComponent.joints = skeletonjoints;
                for (var i = 0; i < this.geosets.length; i++) {
                    var geoset = this.geosets[i];
                    var mesh = this.meshs[i] = new feng3d.GameObject();
                    // var model = mesh.addComponent(Model);
                    var model = mesh.addComponent(feng3d.SkinnedModel);
                    var geometry = new feng3d.CustomGeometry();
                    geometry.positions = geoset.Vertices;
                    geometry.uvs = geoset.TVertices;
                    geometry.indices = geoset.Faces;
                    var normals = feng3d.geometryUtils.createVertexNormals(geometry.indices, geometry.positions, true);
                    geometry.normals = normals;
                    var skins = BuildAnimatedMeshSkin(geoset);
                    var skinSkeleton = new feng3d.SkinSkeletonTemp();
                    skinSkeleton.resetJointIndices(skins.jointIndices0, this.skeletonComponent);
                    //更新关节索引与权重索引
                    geometry.setVAData("a_jointindex0", skins.jointIndices0, 4);
                    geometry.setVAData("a_jointweight0", skins.jointWeights0, 4);
                    var material = this.materials[geoset.MaterialID];
                    if (!material.material) {
                        var fBitmap = this.getFBitmap(material);
                        var image = fBitmap.image;
                        // if (image && image.length > 0)
                        // {
                        // image = image.substring(0, image.indexOf("."));
                        // image += ".JPG";
                        material.material = model.material = feng3d.serialization.setValue(new feng3d.Material(), { name: image, renderParams: { cullFace: feng3d.CullFace.FRONT } });
                        // }
                        feng3d.dispatcher.dispatch("asset.parsed", material.material);
                    }
                    feng3d.dispatcher.dispatch("asset.parsed", geometry);
                    model.geometry = geometry;
                    model.skinSkeleton = skinSkeleton;
                    container.addChild(mesh);
                }
                var animationclips = createAnimationClips(this);
                var animation = container.addComponent(feng3d.Animation);
                animation.animation = animationclips[0];
                animation.animations = animationclips;
                //
                container.transform.rx = 90;
                container.transform.sx = 0.01;
                container.transform.sy = 0.01;
                container.transform.sz = -0.01;
                return container;
            };
            War3Model.prototype.getFBitmap = function (material) {
                var TextureID = 0;
                for (var i = 0; i < material.layers.length; i++) {
                    var layer = material.layers[i];
                    TextureID = layer.TextureID;
                    break;
                }
                var fBitmap = this.textures[TextureID];
                return fBitmap;
            };
            return War3Model;
        }());
        war3.War3Model = War3Model;
        function createSkeleton(war3Model) {
            var bones = war3Model.bones;
            var skeletonjoints = [];
            for (var i = 0; i < bones.length; i++) {
                createSkeletonJoint(i);
            }
            return skeletonjoints;
            function createSkeletonJoint(index) {
                if (skeletonjoints[index])
                    return skeletonjoints[index];
                var joint = bones[index];
                var skeletonJoint = new feng3d.SkeletonJoint();
                skeletonJoint.name = joint.name;
                skeletonJoint.parentIndex = joint.Parent;
                var position = war3Model.pivotPoints[joint.ObjectId];
                ;
                var matrix3D = new feng3d.Matrix4x4().recompose([
                    position,
                    new feng3d.Vector3(),
                    new feng3d.Vector3(1, 1, 1)
                ]);
                if (skeletonJoint.parentIndex != -1) {
                    var parentskeletonJoint = createSkeletonJoint(skeletonJoint.parentIndex);
                    joint.pivotPoint = matrix3D.position.subTo(parentskeletonJoint.matrix3D.position);
                }
                else {
                    joint.pivotPoint = position;
                }
                skeletonJoint.matrix3D = matrix3D;
                skeletonjoints[index] = skeletonJoint;
                return skeletonJoint;
            }
        }
        function BuildAnimatedMeshSkin(geoset) {
            //关节索引数据
            var jointIndices0 = [];
            //关节权重数据
            var jointWeights0 = [];
            var numVertexs = geoset.Vertices.length / 3;
            for (var i = 0; i < numVertexs; i++) {
                //顶点所在组索引
                var iGroupIndex = geoset.VertexGroup[i];
                //顶点所在组索引
                var group = geoset.Groups[iGroupIndex];
                //顶点关联骨骼数量
                var numBones = group.length;
                var weightJoints = [0, 0, 0, 0];
                for (var j = 0; j < numBones; j++) {
                    var boneIndex = group[j];
                    weightJoints[j] = boneIndex;
                }
                var weightBiass = [0, 0, 0, 0];
                for (var j = 0; j < 4; j++) {
                    if (j < numBones)
                        weightBiass[j] = 1 / numBones;
                }
                //
                jointIndices0[i * 4] = weightJoints[0];
                jointIndices0[i * 4 + 1] = weightJoints[1];
                jointIndices0[i * 4 + 2] = weightJoints[2];
                jointIndices0[i * 4 + 3] = weightJoints[3];
                //
                jointWeights0[i * 4] = weightBiass[0];
                jointWeights0[i * 4 + 1] = weightBiass[1];
                jointWeights0[i * 4 + 2] = weightBiass[2];
                jointWeights0[i * 4 + 3] = weightBiass[3];
            }
            return { jointIndices0: jointIndices0, jointWeights0: jointWeights0 };
        }
        function createAnimationClips(war3Model) {
            var sequences = war3Model.sequences;
            var animationclips = [];
            for (var i = 0; i < sequences.length; i++) {
                var sequence = sequences[i];
                var animationclip = new feng3d.AnimationClip();
                animationclip.name = sequence.name;
                animationclip.loop = sequence.loop;
                animationclip.length = sequence.interval.end - sequence.interval.start;
                animationclip.propertyClips = [];
                var __chache__ = {};
                war3Model.bones.forEach(function (bone) {
                    bone.buildAnimationclip(animationclip, __chache__, sequence.interval.start, sequence.interval.end);
                });
                feng3d.dispatcher.dispatch("asset.parsed", animationclip);
                animationclips.push(animationclip);
            }
            return animationclips;
        }
    })(war3 = feng3d.war3 || (feng3d.war3 = {}));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var war3;
    (function (war3) {
        /**
         * war3的mdl文件解析器
         */
        var MDLParser = /** @class */ (function () {
            function MDLParser() {
            }
            /**
             * 解析war3的mdl文件
             * @param data MDL模型数据
             * @param completed 完成回调
             */
            MDLParser.prototype.parse = function (data, completed) {
                parse(data, completed);
            };
            return MDLParser;
        }());
        war3.MDLParser = MDLParser;
        war3.mdlParser = new MDLParser();
        var VERSION_TOKEN = "Version";
        var COMMENT_TOKEN = "//";
        var MODEL = "Model";
        var SEQUENCES = "Sequences";
        var GLOBALSEQUENCES = "GlobalSequences";
        var TEXTURES = "Textures";
        var MATERIALS = "Materials";
        var GEOSET = "Geoset";
        var GEOSETANIM = "GeosetAnim";
        var BONE = "Bone";
        var HELPER = "Helper";
        function parse(data, onParseComplete) {
            var token;
            var bone;
            var geoset;
            var junpStr;
            var num = 0;
            var war3Model = new war3.War3Model();
            /** 字符串数据 */
            var context = data;
            /** 当前解析位置 */
            var _parseIndex = 0;
            /** 是否文件尾 */
            var _reachedEOF = false;
            /** 当前解析行号 */
            var _line;
            /** 当前行的字符位置 */
            var _charLineIndex = 0;
            while (!_reachedEOF) {
                //获取关键字
                token = getNextToken();
                switch (token) {
                    case COMMENT_TOKEN:
                        ignoreLine();
                        break;
                    case VERSION_TOKEN:
                        war3Model._version = parseVersion();
                        break;
                    case MODEL:
                        war3Model.model = parseModel();
                        break;
                    case SEQUENCES:
                        war3Model.sequences = parseSequences();
                        break;
                    case GLOBALSEQUENCES:
                        war3Model.globalsequences = parseGlobalsequences();
                        break;
                    case TEXTURES:
                        war3Model.textures = parseTextures();
                        break;
                    case MATERIALS:
                        war3Model.materials = parseMaterials();
                        break;
                    case GEOSET:
                        geoset = parseGeoset();
                        war3Model.geosets.push(geoset);
                        break;
                    case GEOSETANIM:
                        parseGeosetanim();
                        break;
                    case BONE:
                        bone = parseBone();
                        war3Model.bones[bone.ObjectId] = bone;
                        break;
                    case HELPER:
                        bone = parseHelper();
                        war3Model.bones[bone.ObjectId] = bone;
                        break;
                    case "PivotPoints":
                        war3Model.pivotPoints = parsePivotPoints();
                        break;
                    case "ParticleEmitter2":
                        parseLiteralString();
                        junpStr = jumpChunk();
                        break;
                    case "EventObject":
                        parseLiteralString();
                        junpStr = jumpChunk();
                        break;
                    case "Attachment":
                        parseLiteralString();
                        junpStr = jumpChunk();
                        break;
                    case "RibbonEmitter":
                        parseLiteralString();
                        junpStr = jumpChunk();
                        break;
                    case "CollisionShape":
                        parseLiteralString();
                        junpStr = jumpChunk();
                        break;
                    case "Camera":
                        parseLiteralString();
                        junpStr = jumpChunk();
                        break;
                    case "Light":
                        parseLiteralString();
                        junpStr = jumpChunk();
                        break;
                    default:
                        if (!_reachedEOF)
                            sendUnknownKeywordError(token);
                }
            }
            onParseComplete && onParseComplete(war3Model);
            /**
             * 获取骨骼深度
             * @param bone
             * @param bones
             * @return
             */
            function getBoneDepth(bone, bones) {
                if (bone.Parent == -1)
                    return 0;
                return getBoneDepth(bones[bone.Parent], bones) + 1;
            }
            /**
             * 解析版本号
             */
            function parseVersion() {
                var token = getNextToken();
                if (token != "{")
                    sendParseError(token);
                token = getNextToken();
                if (token != "FormatVersion")
                    sendUnknownKeywordError(token);
                var version = getNextInt();
                token = getNextToken();
                if (token != "}")
                    sendParseError(token);
                return version;
            }
            /**
             * 解析模型数据统计结果
             */
            function parseModel() {
                var model = new war3.Model();
                model.name = parseLiteralString();
                var token = getNextToken();
                if (token != "{")
                    sendParseError(token);
                var ch = "";
                while (ch != "}") {
                    ch = getNextToken();
                    switch (ch) {
                        case COMMENT_TOKEN:
                            ignoreLine();
                            break;
                        case "BlendTime":
                            model.BlendTime = getNextInt();
                            break;
                        case "MinimumExtent":
                            model.MinimumExtent = parseVector3D();
                            break;
                        case "MaximumExtent":
                            model.MaximumExtent = parseVector3D();
                            break;
                        case "}":
                            break;
                        default:
                            ignoreLine();
                            break;
                    }
                }
                return model;
            }
            /**
             * 解析动作序列
             */
            function parseSequences() {
                //跳过动作个数
                getNextInt();
                var sequences = [];
                var token = getNextToken();
                if (token != "{")
                    sendParseError(token);
                var ch = "";
                while (ch != "}") {
                    ch = getNextToken();
                    switch (ch) {
                        case COMMENT_TOKEN:
                            ignoreLine();
                            break;
                        case "Anim":
                            var anim = parseAnim();
                            sequences.push(anim);
                            break;
                        case "}":
                            break;
                        default:
                            sendUnknownKeywordError(ch);
                            break;
                    }
                }
                return sequences;
            }
            /**
             * 解析全局序列
             */
            function parseGlobalsequences() {
                var globalsequences = new war3.Globalsequences();
                globalsequences.id = getNextInt();
                var token = getNextToken();
                if (token != "{")
                    sendParseError(token);
                var ch = "";
                while (ch != "}") {
                    ch = getNextToken();
                    switch (ch) {
                        case COMMENT_TOKEN:
                            ignoreLine();
                            break;
                        case "Duration":
                            var duration = getNextInt();
                            globalsequences.durations.push(duration);
                            break;
                        case "}":
                            break;
                        default:
                            sendUnknownKeywordError(ch);
                            break;
                    }
                }
                return globalsequences;
            }
            /**
             * 解析纹理列表
             */
            function parseTextures() {
                //跳过纹理个数
                getNextInt();
                var bitmaps = [];
                var token = getNextToken();
                if (token != "{")
                    sendParseError(token);
                var ch = "";
                while (ch != "}") {
                    ch = getNextToken();
                    switch (ch) {
                        case COMMENT_TOKEN:
                            ignoreLine();
                            break;
                        case "Bitmap":
                            var bitmap = parseBitmap();
                            bitmaps.push(bitmap);
                            break;
                        case "}":
                            break;
                        default:
                            sendUnknownKeywordError(ch);
                            break;
                    }
                }
                return bitmaps;
            }
            /**
             * 解析材质
             */
            function parseMaterials() {
                //跳过纹理个数
                getNextInt();
                var materials = [];
                var token = getNextToken();
                if (token != "{")
                    sendParseError(token);
                var ch = "";
                while (ch != "}") {
                    ch = getNextToken();
                    switch (ch) {
                        case COMMENT_TOKEN:
                            ignoreLine();
                            break;
                        case "Material":
                            var material = parseMaterial();
                            materials.push(material);
                            break;
                        case "}":
                            break;
                        default:
                            sendUnknownKeywordError(ch);
                            break;
                    }
                }
                return materials;
            }
            function parseGeoset() {
                var geoset = new war3.Geoset();
                var token = getNextToken();
                if (token != "{")
                    sendParseError(token);
                var ch = "";
                while (ch != "}") {
                    ch = getNextToken();
                    switch (ch) {
                        case COMMENT_TOKEN:
                            ignoreLine();
                            break;
                        case "Vertices":
                            geoset.Vertices = parseVertices();
                            break;
                        case "Normals":
                            geoset.Normals = parseNormals();
                            break;
                        case "TVertices":
                            geoset.TVertices = parseTVertices();
                            break;
                        case "VertexGroup":
                            geoset.VertexGroup = parseVertexGroup();
                            break;
                        case "Faces":
                            geoset.Faces = parseFaces();
                            break;
                        case "Groups":
                            geoset.Groups = parseGroups();
                            break;
                        case "MinimumExtent":
                            geoset.MinimumExtent = parseVector3D();
                            break;
                        case "MaximumExtent":
                            geoset.MaximumExtent = parseVector3D();
                            break;
                        case "BoundsRadius":
                            geoset.BoundsRadius = getNextNumber();
                            break;
                        case "Anim":
                            var anim = parseAnim1();
                            geoset.Anims.push(anim);
                            break;
                        case "MaterialID":
                            geoset.MaterialID = getNextInt();
                            break;
                        case "SelectionGroup":
                            geoset.SelectionGroup = getNextInt();
                            break;
                        case "Unselectable":
                            geoset.Unselectable = true;
                            break;
                        case "}":
                            break;
                        default:
                            sendUnknownKeywordError(ch);
                            break;
                    }
                }
                return geoset;
            }
            /**
             * 解析骨骼动画
             */
            function parseBone() {
                var bone = new war3.BoneObject();
                bone.type = "bone";
                bone.name = parseLiteralString();
                var token = getNextToken();
                if (token != "{")
                    sendParseError(token);
                var ch = "";
                while (ch != "}") {
                    ch = getNextToken();
                    switch (ch) {
                        case COMMENT_TOKEN:
                            ignoreLine();
                            break;
                        case "ObjectId":
                            bone.ObjectId = getNextInt();
                            break;
                        case "Parent":
                            bone.Parent = getNextInt();
                            break;
                        case "GeosetId":
                            bone.GeosetId = getNextToken();
                            break;
                        case "GeosetAnimId":
                            bone.GeosetAnimId = getNextToken();
                            break;
                        case "Billboarded":
                            bone.Billboarded = true;
                            break;
                        case "Translation":
                            parseBoneTranslation(bone.Translation);
                            break;
                        case "Scaling":
                            parseBoneScaling(bone.Scaling);
                            break;
                        case "Rotation":
                            parseBoneRotation(bone.Rotation);
                            break;
                        case "BillboardedLockZ":
                            break;
                        case "BillboardedLockY":
                            break;
                        case "BillboardedLockX":
                            break;
                        case "}":
                            break;
                        default:
                            sendUnknownKeywordError(ch);
                            break;
                    }
                }
                return bone;
            }
            /**
             * 解析骨骼动画
             */
            function parseHelper() {
                var bone = new war3.BoneObject();
                bone.type = "helper";
                bone.name = parseLiteralString();
                var token = getNextToken();
                if (token != "{")
                    sendParseError(token);
                var ch = "";
                while (ch != "}") {
                    ch = getNextToken();
                    switch (ch) {
                        case COMMENT_TOKEN:
                            ignoreLine();
                            break;
                        case "ObjectId":
                            bone.ObjectId = getNextInt();
                            break;
                        case "Parent":
                            bone.Parent = getNextInt();
                            break;
                        case "GeosetId":
                            bone.GeosetId = getNextToken();
                            break;
                        case "GeosetAnimId":
                            bone.GeosetAnimId = getNextToken();
                            break;
                        case "Billboarded":
                            bone.Billboarded = true;
                            break;
                        case "Translation":
                            parseBoneTranslation(bone.Translation);
                            break;
                        case "Scaling":
                            parseBoneScaling(bone.Scaling);
                            break;
                        case "Rotation":
                            parseBoneRotation(bone.Rotation);
                            break;
                        case "BillboardedLockX":
                            break;
                        case "BillboardedLockY":
                            break;
                        case "BillboardedLockZ":
                            break;
                        case "DontInherit":
                            jumpChunk();
                            break;
                        case "}":
                            break;
                        default:
                            sendUnknownKeywordError(ch);
                            break;
                    }
                }
                return bone;
            }
            /**
             * 解析骨骼角度
             */
            function parseBoneScaling(boneScaling) {
                //跳过长度
                var len = getNextInt();
                check("{");
                boneScaling.type = getNextToken();
                var currentIndex = _parseIndex;
                var token = getNextToken();
                if (token == "GlobalSeqId") {
                    boneScaling.GlobalSeqId = getNextInt();
                }
                else {
                    _parseIndex = currentIndex;
                }
                var i = 0;
                var scaling;
                switch (boneScaling.type) {
                    case "Hermite":
                    case "Bezier":
                        for (i = 0; i < len; i++) {
                            scaling = new war3.Scaling();
                            scaling.time = getNextInt();
                            scaling.value = parseVector3D();
                            scaling[getNextToken()] = parseVector3D();
                            scaling[getNextToken()] = parseVector3D();
                            boneScaling.scalings.push(scaling);
                        }
                        break;
                    case "Linear":
                        for (i = 0; i < len; i++) {
                            scaling = new war3.Scaling();
                            scaling.time = getNextInt();
                            scaling.value = parseVector3D();
                            boneScaling.scalings.push(scaling);
                        }
                        break;
                    case "DontInterp":
                        for (i = 0; i < len; i++) {
                            scaling = new war3.Scaling();
                            scaling.time = getNextInt();
                            scaling.value = parseVector3D();
                            boneScaling.scalings.push(scaling);
                        }
                        break;
                    default:
                        throw new Error("未处理" + boneScaling.type + "类型角度");
                }
                check("}");
            }
            /**
             * 解析骨骼角度
             */
            function parseBoneTranslation(boneTranslation) {
                //跳过长度
                var len = getNextInt();
                check("{");
                boneTranslation.type = getNextToken();
                var currentIndex = _parseIndex;
                var token = getNextToken();
                if (token == "GlobalSeqId") {
                    boneTranslation.GlobalSeqId = getNextInt();
                }
                else {
                    _parseIndex = currentIndex;
                }
                var i = 0;
                var translation;
                switch (boneTranslation.type) {
                    case "Hermite":
                    case "Bezier":
                        for (i = 0; i < len; i++) {
                            translation = new war3.Translation();
                            translation.time = getNextInt();
                            translation.value = parseVector3D();
                            translation[getNextToken()] = parseVector3D();
                            translation[getNextToken()] = parseVector3D();
                            boneTranslation.translations.push(translation);
                        }
                        break;
                    case "Linear":
                        for (i = 0; i < len; i++) {
                            translation = new war3.Translation();
                            translation.time = getNextInt();
                            translation.value = parseVector3D();
                            boneTranslation.translations.push(translation);
                        }
                        break;
                    case "DontInterp":
                        for (i = 0; i < len; i++) {
                            translation = new war3.Translation();
                            translation.time = getNextInt();
                            translation.value = parseVector3D();
                            boneTranslation.translations.push(translation);
                        }
                        break;
                    default:
                        throw new Error("未处理" + boneTranslation.type + "类型角度");
                }
                check("}");
            }
            /**
             * 解析骨骼角度
             */
            function parseBoneRotation(boneRotation) {
                var len = getNextInt();
                check("{");
                boneRotation.type = getNextToken();
                var currentIndex = _parseIndex;
                var token = getNextToken();
                if (token == "GlobalSeqId") {
                    boneRotation.GlobalSeqId = getNextInt();
                }
                else {
                    _parseIndex = currentIndex;
                }
                var i = 0;
                var rotation;
                switch (boneRotation.type) {
                    case "Hermite":
                    case "Bezier":
                        for (i = 0; i < len; i++) {
                            rotation = new war3.Rotation();
                            rotation.time = getNextInt();
                            rotation.value = parseVector3D4();
                            rotation[getNextToken()] = parseVector3D4();
                            rotation[getNextToken()] = parseVector3D4();
                            boneRotation.rotations.push(rotation);
                        }
                        break;
                    case "Linear":
                        for (i = 0; i < len; i++) {
                            rotation = new war3.Rotation();
                            rotation.time = getNextInt();
                            rotation.value = parseVector3D4();
                            boneRotation.rotations.push(rotation);
                        }
                        break;
                    case "DontInterp":
                        for (i = 0; i < len; i++) {
                            rotation = new war3.Rotation();
                            rotation.time = getNextInt();
                            rotation.value = parseVector3D4();
                            boneRotation.rotations.push(rotation);
                        }
                        break;
                    default:
                        throw new Error("未处理" + boneRotation.type + "类型角度");
                }
                check("}");
            }
            /**
             * 解析多边形动画
             */
            function parseGeosetanim() {
                var jumpStr = jumpChunk();
                return null;
                // if (war3Model.geosetAnims == null)
                // 	war3Model.geosetAnims = [];
                // var geosetAnim: GeosetAnim = new GeosetAnim();
                // war3Model.geosetAnims.push(geosetAnim);
                // var token: string = getNextToken();
                // if (token != "{")
                // 	sendParseError(token);
                // var ch: string;
                // while (ch != "}")
                // {
                // 	ch = getNextToken();
                // 	switch (ch)
                // 	{
                // 		case COMMENT_TOKEN:
                // 			ignoreLine();
                // 			break;
                // 		case "Alpha":
                // 			//						parseAnimAlpha();
                // 			break;
                // 		case "}":
                // 			break;
                // 		default:
                // 			sendUnknownKeywordError(ch);
                // 			break;
                // 	}
                // }
                // return geosetAnim;
            }
            /**
             * 解析顶点
             */
            function parseVertices() {
                var vertices = [];
                //跳过长度
                var len = getNextInt();
                var token = getNextToken();
                if (token != "{")
                    sendParseError(token);
                var vertex;
                for (var i = 0; i < len; i++) {
                    vertex = parseVector3D();
                    vertices.push(vertex.x, vertex.y, vertex.z);
                }
                token = getNextToken();
                if (token != "}")
                    sendParseError(token);
                return vertices;
            }
            /**
             * 解析法线
             */
            function parseNormals() {
                var normals = [];
                //跳过长度
                var len = getNextInt();
                var token = getNextToken();
                if (token != "{")
                    sendParseError(token);
                var vertex;
                for (var i = 0; i < len; i++) {
                    vertex = parseVector3D();
                    normals.push(vertex.x, vertex.y, vertex.z);
                }
                token = getNextToken();
                if (token != "}")
                    sendParseError(token);
                return normals;
            }
            /**
             * 解析纹理坐标
             */
            function parseTVertices() {
                var tVertices = [];
                //跳过长度
                var len = getNextInt();
                var token = getNextToken();
                if (token != "{")
                    sendParseError(token);
                var uv;
                for (var i = 0; i < len; i++) {
                    uv = parsePoint();
                    tVertices.push(uv.x, uv.y);
                }
                token = getNextToken();
                if (token != "}")
                    sendParseError(token);
                return tVertices;
            }
            /**
             * 解析顶点分组
             */
            function parseVertexGroup() {
                var vertexGroup = [];
                var token = getNextToken();
                if (token != "{")
                    sendParseError(token);
                token = getNextToken();
                while (token != "}") {
                    vertexGroup.push(Number(token));
                    token = getNextToken();
                }
                return vertexGroup;
            }
            /**
             * 解析面
             */
            function parseFaces() {
                var faces = [];
                var faceNum = getNextInt();
                var indexNum = getNextInt();
                var token;
                check("{");
                check("Triangles");
                check("{");
                check("{");
                token = getNextToken();
                while (token != "}") {
                    faces.push(Number(token));
                    token = getNextToken();
                }
                check("}");
                check("}");
                return faces;
            }
            /**
             * 解顶点分组
             */
            function parseGroups() {
                var groups = [];
                var groupNum = getNextInt();
                var valueNum = getNextInt();
                var token;
                check("{");
                token = getNextToken();
                while (token != "}") {
                    if (token == "Matrices") {
                        check("{");
                        token = getNextToken();
                        var Matrices = [];
                        while (token != "}") {
                            Matrices.push(Number(token));
                            token = getNextToken();
                        }
                        groups.push(Matrices);
                    }
                    token = getNextToken();
                }
                return groups;
            }
            /**
             * 解析纹理
             */
            function parseBitmap() {
                var bitmap = new war3.FBitmap();
                var token = getNextToken();
                if (token != "{")
                    sendParseError(token);
                var ch = "";
                while (ch != "}") {
                    ch = getNextToken();
                    switch (ch) {
                        case COMMENT_TOKEN:
                            ignoreLine();
                            break;
                        case "Image":
                            bitmap.image = parseLiteralString();
                            bitmap.image = bitmap.image.replace(/\\/g, "/");
                            break;
                        case "ReplaceableId":
                            bitmap.ReplaceableId = getNextInt();
                            break;
                        case "WrapWidth":
                            break;
                        case "WrapHeight":
                            break;
                        case "}":
                            break;
                        default:
                            sendUnknownKeywordError(ch);
                            break;
                    }
                }
                return bitmap;
            }
            /**
             * 解析材质
             */
            function parseMaterial() {
                var material = new war3.Material();
                var token = getNextToken();
                if (token != "{")
                    sendParseError(token);
                var ch = "";
                while (ch != "}") {
                    ch = getNextToken();
                    switch (ch) {
                        case COMMENT_TOKEN:
                            ignoreLine();
                            break;
                        case "Layer":
                            var layer = parseLayer();
                            material.layers.push(layer);
                            break;
                        case "SortPrimsFarZ":
                            break;
                        case "ConstantColor":
                            break;
                        case "}":
                            break;
                        default:
                            sendUnknownKeywordError(ch);
                            break;
                    }
                }
                return material;
            }
            /**
             * 解析材质层
             */
            function parseLayer() {
                var layer = new war3.Layer();
                var token = getNextToken();
                if (token != "{")
                    sendParseError(token);
                var staticSigned = false;
                var ch = "";
                while (ch != "}") {
                    ch = getNextToken();
                    switch (ch) {
                        case COMMENT_TOKEN:
                            ignoreLine();
                            break;
                        case "FilterMode":
                            layer.FilterMode = getNextToken();
                            break;
                        case "static":
                            staticSigned = true;
                            break;
                        case "TextureID":
                            if (staticSigned) {
                                layer.TextureID = getNextInt();
                            }
                            else {
                                sendUnknownKeywordError(ch);
                            }
                            staticSigned = false;
                            break;
                        case "Alpha":
                            if (staticSigned) {
                                layer.Alpha = getNextNumber();
                            }
                            else {
                                getNextInt();
                                jumpChunk();
                                //							sendUnknownKeywordError(ch);
                            }
                            staticSigned = false;
                            break;
                        case "Unshaded":
                            layer.Unshaded = true;
                            break;
                        case "Unfogged":
                            layer.Unfogged = true;
                            break;
                        case "TwoSided":
                            layer.TwoSided = true;
                            break;
                        case "SphereEnvMap":
                            layer.SphereEnvMap = true;
                            break;
                        case "NoDepthTest":
                            layer.NoDepthTest = true;
                            break;
                        case "NoDepthSet":
                            layer.NoDepthSet = true;
                            break;
                        case "}":
                            break;
                        default:
                            sendUnknownKeywordError(ch);
                            break;
                    }
                }
                return layer;
            }
            /**
             * 解析动作信息
             */
            function parseAnim() {
                var anim = new war3.AnimInfo();
                anim.name = parseLiteralString();
                var token = getNextToken();
                if (token != "{")
                    sendParseError(token);
                var ch = "";
                while (ch != "}") {
                    ch = getNextToken();
                    switch (ch) {
                        case COMMENT_TOKEN:
                            ignoreLine();
                            break;
                        case "Interval":
                            anim.interval = parseInterval();
                            break;
                        case "MinimumExtent":
                            anim.MinimumExtent = parseVector3D();
                            break;
                        case "MaximumExtent":
                            anim.MaximumExtent = parseVector3D();
                            break;
                        case "BoundsRadius":
                            anim.BoundsRadius = getNextNumber();
                            break;
                        case "Rarity":
                            anim.Rarity = getNextNumber();
                            break;
                        case "NonLooping":
                            anim.loop = false;
                            break;
                        case "MoveSpeed":
                            anim.MoveSpeed = getNextNumber();
                            break;
                        case "}":
                            break;
                        default:
                            sendUnknownKeywordError(ch);
                            break;
                    }
                }
                return anim;
            }
            /**
             * 解析几何体动作信息
             */
            function parseAnim1() {
                var anim = new war3.AnimInfo1();
                var token = getNextToken();
                if (token != "{")
                    sendParseError(token);
                var ch = "";
                while (ch != "}") {
                    ch = getNextToken();
                    switch (ch) {
                        case COMMENT_TOKEN:
                            ignoreLine();
                            break;
                        case "MinimumExtent":
                            anim.MinimumExtent = parseVector3D();
                            break;
                        case "MaximumExtent":
                            anim.MaximumExtent = parseVector3D();
                            break;
                        case "BoundsRadius":
                            anim.BoundsRadius = getNextNumber();
                            break;
                        case "}":
                            break;
                        default:
                            sendUnknownKeywordError(ch);
                            break;
                    }
                }
                return anim;
            }
            /**
             * 解析骨骼轴心坐标
             */
            function parsePivotPoints() {
                var points = [];
                var len = getNextInt();
                check("{");
                for (var i = 0; i < len; i++) {
                    var point = parseVector3D();
                    points.push(point);
                }
                check("}");
                return points;
            }
            /**
             * 解析3d向量
             */
            function parseVector3D() {
                var vec = new feng3d.Vector3();
                var ch = getNextToken();
                if (ch != "{")
                    sendParseError("{");
                vec.x = getNextNumber();
                vec.y = getNextNumber();
                vec.z = getNextNumber();
                ch = getNextToken();
                if (!(ch == "}" || ch == "},"))
                    sendParseError("}");
                return vec;
            }
            /**
             * 解析四元素
             */
            function parseVector3D4() {
                var vec = new feng3d.Quaternion();
                var ch = getNextToken();
                if (ch != "{")
                    sendParseError("{");
                vec.x = getNextNumber();
                vec.y = getNextNumber();
                vec.z = getNextNumber();
                vec.w = getNextNumber();
                ch = getNextToken();
                if (!(ch == "}" || ch == "},"))
                    sendParseError("}");
                return vec;
            }
            /**
             * 解析2d坐标
             */
            function parsePoint() {
                var point = new feng3d.Vector2();
                var ch = getNextToken();
                if (ch != "{")
                    sendParseError("{");
                point.x = getNextNumber();
                point.y = getNextNumber();
                ch = getNextToken();
                if (!(ch == "}" || ch == "},"))
                    sendParseError("}");
                return point;
            }
            /**
             * 解析间隔
             */
            function parseInterval() {
                var interval = new war3.Interval();
                var ch = getNextToken();
                if (ch != "{")
                    sendParseError("{");
                interval.start = getNextInt();
                interval.end = getNextInt();
                ch = getNextToken();
                if (!(ch == "}" || ch == "},"))
                    sendParseError("}");
                return interval;
            }
            /**
             * 解析带双引号的字符串
             */
            function parseLiteralString() {
                skipWhiteSpace();
                var ch = getNextChar();
                var str = "";
                if (ch != "\"")
                    sendParseError("\"");
                do {
                    if (_reachedEOF)
                        sendEOFError();
                    ch = getNextChar();
                    if (ch != "\"")
                        str += ch;
                } while (ch != "\"");
                return str;
            }
            /**
             * 读取下个Number
             */
            function getNextNumber() {
                var f = parseFloat(getNextToken());
                if (isNaN(f))
                    sendParseError("float type");
                return f;
            }
            /**
             * 读取下个字符
             */
            function getNextChar() {
                var ch = context.charAt(_parseIndex++);
                if (ch == "\n") {
                    ++_line;
                    _charLineIndex = 0;
                }
                else if (ch != "\r")
                    ++_charLineIndex;
                if (_parseIndex >= context.length)
                    _reachedEOF = true;
                return ch;
            }
            /**
             * 读取下个int
             */
            function getNextInt() {
                var i = parseInt(getNextToken());
                if (isNaN(i))
                    sendParseError("int type");
                return i;
            }
            /**
             * 获取下个关键字
             */
            function getNextToken() {
                var ch;
                var token = "";
                while (!_reachedEOF) {
                    ch = getNextChar();
                    if (ch == " " || ch == "\r" || ch == "\n" || ch == "\t" || ch == ",") {
                        if (token != COMMENT_TOKEN)
                            skipWhiteSpace();
                        if (token != "")
                            return token;
                    }
                    else
                        token += ch;
                    if (token == COMMENT_TOKEN)
                        return token;
                }
                return token;
            }
            /**
             * 跳过块
             * @return 跳过的内容
             */
            function jumpChunk() {
                var start = _parseIndex;
                check("{");
                var stack = ["{"];
                var ch;
                while (!_reachedEOF) {
                    ch = getNextChar();
                    if (ch == "{") {
                        stack.push("{");
                    }
                    if (ch == "}") {
                        stack.pop();
                        if (stack.length == 0) {
                            return context.substring(start, _parseIndex);
                        }
                    }
                }
                return "";
            }
            /**
             * 返回到上个字符位置
             */
            function putBack() {
                _parseIndex--;
                _charLineIndex--;
                _reachedEOF = _parseIndex >= context.length;
            }
            /**
             * 跳过空白
             */
            function skipWhiteSpace() {
                var ch;
                do
                    ch = getNextChar();
                while (ch == "\n" || ch == " " || ch == "\r" || ch == "\t");
                putBack();
            }
            /**
             * 忽略该行
             */
            function ignoreLine() {
                var ch = "";
                while (!_reachedEOF && ch != "\n")
                    ch = getNextChar();
            }
            function check(key) {
                var token = getNextToken();
                if (token != key)
                    sendParseError(token);
            }
            /**
             * 抛出一个文件尾过早结束文件时遇到错误
             */
            function sendEOFError() {
                throw new Error("Unexpected end of file");
            }
            /**
             * 遇到了一个意想不到的令牌时将抛出一个错误。
             * @param expected 发生错误的标记
             */
            function sendParseError(expected) {
                throw new Error("Unexpected token at line " + (_line + 1) + ", character " + _charLineIndex + ". " + expected + " expected, but " + context.charAt(_parseIndex - 1) + " encountered");
            }
            /**
             * 发生未知关键字错误
             */
            function sendUnknownKeywordError(keyword) {
                throw new Error("Unknown keyword[" + keyword + "] at line " + (_line + 1) + ", character " + _charLineIndex + ". ");
            }
        }
    })(war3 = feng3d.war3 || (feng3d.war3 = {}));
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * OBJ模型MTL材质转换器
     */
    var MTLConverter = /** @class */ (function () {
        function MTLConverter() {
        }
        /**
         * OBJ模型MTL材质原始数据转换引擎中材质对象
         * @param mtl MTL材质原始数据
         */
        MTLConverter.prototype.convert = function (mtl, completed) {
            var materials = {};
            for (var name_1 in mtl) {
                var materialInfo = mtl[name_1];
                var material = materials[name_1] = feng3d.serialization.setValue(new feng3d.Material(), {
                    name: materialInfo.name,
                    uniforms: {
                        u_diffuse: { r: materialInfo.kd[0], g: materialInfo.kd[1], b: materialInfo.kd[2], },
                        u_specular: { r: materialInfo.ks[0], g: materialInfo.ks[1], b: materialInfo.ks[2], },
                    },
                });
                feng3d.dispatcher.dispatch("asset.parsed", material);
            }
            completed && completed(null, materials);
        };
        return MTLConverter;
    }());
    feng3d.MTLConverter = MTLConverter;
    feng3d.mtlConverter = new MTLConverter();
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * OBJ模型转换器
     */
    var OBJConverter = /** @class */ (function () {
        function OBJConverter() {
        }
        /**
         * OBJ模型数据转换为游戏对象
         * @param objData OBJ模型数据
         * @param materials 材质列表
         * @param completed 转换完成回调
         */
        OBJConverter.prototype.convert = function (objData, materials, completed) {
            var object = new feng3d.GameObject();
            object.name = objData.name;
            var objs = objData.objs;
            for (var i = 0; i < objs.length; i++) {
                var obj = objs[i];
                var gameObject = createSubObj(objData, obj, materials);
                object.addChild(gameObject);
            }
            feng3d.dispatcher.dispatch("asset.parsed", object);
            completed && completed(object);
        };
        return OBJConverter;
    }());
    feng3d.OBJConverter = OBJConverter;
    feng3d.objConverter = new OBJConverter();
    function createSubObj(objData, obj, materials) {
        var gameObject = feng3d.serialization.setValue(new feng3d.GameObject(), { name: obj.name });
        var subObjs = obj.subObjs;
        for (var i = 0; i < subObjs.length; i++) {
            var materialObj = createMaterialObj(objData, subObjs[i], materials);
            gameObject.addChild(materialObj);
        }
        return gameObject;
    }
    var _realIndices;
    var _vertexIndex;
    function createMaterialObj(obj, subObj, materials) {
        var gameObject = new feng3d.GameObject();
        gameObject.name = subObj.g || gameObject.name;
        var model = gameObject.addComponent(feng3d.Model);
        if (materials && materials[subObj.material])
            model.material = materials[subObj.material];
        var geometry = model.geometry = new feng3d.CustomGeometry();
        geometry.name = subObj.g || geometry.name;
        var vertices = [];
        var normals = [];
        var uvs = [];
        _realIndices = [];
        _vertexIndex = 0;
        var faces = subObj.faces;
        var indices = [];
        for (var i = 0; i < faces.length; i++) {
            var face = faces[i];
            var numVerts = face.indexIds.length - 1;
            for (var j = 1; j < numVerts; ++j) {
                translateVertexData(face, j, vertices, uvs, indices, normals, obj);
                translateVertexData(face, 0, vertices, uvs, indices, normals, obj);
                translateVertexData(face, j + 1, vertices, uvs, indices, normals, obj);
            }
        }
        geometry.indices = indices;
        geometry.setVAData("a_position", vertices, 3);
        if (normals.length > 0)
            geometry.setVAData("a_normal", normals, 3);
        if (uvs.length > 0)
            geometry.setVAData("a_uv", uvs, 2);
        feng3d.dispatcher.dispatch("asset.parsed", geometry);
        return gameObject;
        function translateVertexData(face, vertexIndex, vertices, uvs, indices, normals, obj) {
            var index;
            var vertex;
            var vertexNormal;
            var uv;
            if (!_realIndices[face.indexIds[vertexIndex]]) {
                index = _vertexIndex;
                _realIndices[face.indexIds[vertexIndex]] = ++_vertexIndex;
                vertex = obj.vertex[parseInt(face.vertexIndices[vertexIndex]) - 1];
                vertices.push(vertex.x, vertex.y, vertex.z);
                if (face.normalIndices && face.normalIndices.length > 0) {
                    vertexNormal = obj.vn[parseInt(face.normalIndices[vertexIndex]) - 1];
                    normals.push(vertexNormal.x, vertexNormal.y, vertexNormal.z);
                }
                if (face.uvIndices && face.uvIndices.length > 0) {
                    try {
                        uv = obj.vt[parseInt(face.uvIndices[vertexIndex]) - 1];
                        uvs.push(uv.u, uv.v);
                    }
                    catch (e) {
                        switch (vertexIndex) {
                            case 0:
                                uvs.push(0, 1);
                                break;
                            case 1:
                                uvs.push(.5, 0);
                                break;
                            case 2:
                                uvs.push(1, 1);
                        }
                    }
                }
            }
            else
                index = _realIndices[face.indexIds[vertexIndex]] - 1;
            indices.push(index);
        }
    }
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * MD5模型转换器
     */
    var MD5MeshConverter = /** @class */ (function () {
        function MD5MeshConverter() {
        }
        /**
         * MD5模型数据转换为游戏对象
         * @param md5MeshData MD5模型数据
         * @param completed 转换完成回调
         */
        MD5MeshConverter.prototype.convert = function (md5MeshData, completed) {
            var gameObject = new feng3d.GameObject();
            gameObject.name = md5MeshData.name;
            gameObject.addComponent(feng3d.Animation);
            gameObject.transform.rx = -90;
            //顶点最大关节关联数
            var _maxJointCount = this.calculateMaxJointCount(md5MeshData);
            feng3d.debuger && console.assert(_maxJointCount <= 8, "顶点最大关节关联数最多支持8个");
            var skeletonjoints = this.createSkeleton(md5MeshData.joints);
            var skeletonComponent = gameObject.addComponent(feng3d.SkeletonComponent);
            skeletonComponent.joints = skeletonjoints;
            for (var i = 0; i < md5MeshData.meshs.length; i++) {
                var skinSkeleton = new feng3d.SkinSkeletonTemp();
                var geometry = this.createGeometry(md5MeshData.meshs[i], skeletonComponent, skinSkeleton);
                var skeletonGameObject = new feng3d.GameObject();
                var skinnedModel = skeletonGameObject.addComponent(feng3d.SkinnedModel);
                skinnedModel.geometry = geometry;
                skinnedModel.skinSkeleton = skinSkeleton;
                gameObject.addChild(skeletonGameObject);
            }
            feng3d.dispatcher.dispatch("asset.parsed", gameObject);
            completed && completed(gameObject);
        };
        /**
         * 计算最大关节数量
         */
        MD5MeshConverter.prototype.calculateMaxJointCount = function (md5MeshData) {
            var _maxJointCount = 0;
            //遍历所有的网格数据
            var numMeshData = md5MeshData.meshs.length;
            for (var i = 0; i < numMeshData; ++i) {
                var meshData = md5MeshData.meshs[i];
                var vertexData = meshData.verts;
                var numVerts = vertexData.length;
                //遍历每个顶点 寻找关节关联最大数量
                for (var j = 0; j < numVerts; ++j) {
                    var zeroWeights = this.countZeroWeightJoints(vertexData[j], meshData.weights);
                    var totalJoints = vertexData[j].countWeight - zeroWeights;
                    if (totalJoints > _maxJointCount)
                        _maxJointCount = totalJoints;
                }
            }
            return _maxJointCount;
        };
        /**
         * 计算0权重关节数量
         * @param vertex 顶点数据
         * @param weights 关节权重数组
         * @return
         */
        MD5MeshConverter.prototype.countZeroWeightJoints = function (vertex, weights) {
            var start = vertex.startWeight;
            var end = vertex.startWeight + vertex.countWeight;
            var count = 0;
            var weight;
            for (var i = start; i < end; ++i) {
                weight = weights[i].bias;
                if (weight == 0)
                    ++count;
            }
            return count;
        };
        MD5MeshConverter.prototype.createSkeleton = function (joints) {
            var skeletonjoints = [];
            for (var i = 0; i < joints.length; i++) {
                var skeletonJoint = this.createSkeletonJoint(joints[i]);
                skeletonjoints.push(skeletonJoint);
            }
            return skeletonjoints;
        };
        MD5MeshConverter.prototype.createSkeletonJoint = function (joint) {
            var skeletonJoint = new feng3d.SkeletonJoint();
            skeletonJoint.name = joint.name;
            skeletonJoint.parentIndex = joint.parentIndex;
            var position = joint.position;
            var rotation = joint.rotation;
            var quat = new feng3d.Quaternion(rotation[0], -rotation[1], -rotation[2]);
            // quat supposed to be unit length
            var t = 1 - quat.x * quat.x - quat.y * quat.y - quat.z * quat.z;
            quat.w = t < 0 ? 0 : -Math.sqrt(t);
            //
            var matrix3D = quat.toMatrix3D();
            matrix3D.appendTranslation(-position[0], position[1], position[2]);
            //
            skeletonJoint.matrix3D = matrix3D;
            return skeletonJoint;
        };
        MD5MeshConverter.prototype.createGeometry = function (md5Mesh, skeleton, skinSkeleton) {
            var vertexData = md5Mesh.verts;
            var weights = md5Mesh.weights;
            var indices = md5Mesh.tris;
            var geometry = new feng3d.CustomGeometry();
            var len = vertexData.length;
            var vertex;
            var weight;
            var bindPose;
            var pos;
            //uv数据
            var uvs = [];
            uvs.length = len * 2;
            //顶点位置数据
            var vertices = [];
            vertices.length = len * 3;
            //关节索引数据
            var jointIndices0 = [];
            jointIndices0.length = len * 4;
            var jointIndices1 = [];
            jointIndices1.length = len * 4;
            //关节权重数据
            var jointWeights0 = [];
            jointWeights0.length = len * 4;
            var jointWeights1 = [];
            jointWeights1.length = len * 4;
            for (var i = 0; i < len; ++i) {
                vertex = vertexData[i];
                vertices[i * 3] = vertices[i * 3 + 1] = vertices[i * 3 + 2] = 0;
                /**
                 * 参考 http://blog.csdn.net/summerhust/article/details/17421213
                 * VertexPos = (MJ-0 * weight[index0].pos * weight[index0].bias) + ... + (MJ-N * weight[indexN].pos * weight[indexN].bias)
                 * 变量对应  MJ-N -> bindPose; 第J个关节的变换矩阵
                 * weight[indexN].pos -> weight.pos;
                 * weight[indexN].bias -> weight.bias;
                 */
                var weightJoints = [];
                var weightBiass = [];
                for (var j = 0; j < 8; ++j) {
                    weightJoints[j] = 0;
                    weightBiass[j] = 0;
                    if (j < vertex.countWeight) {
                        weight = weights[vertex.startWeight + j];
                        if (weight.bias > 0) {
                            bindPose = skeleton.joints[weight.joint].matrix3D;
                            pos = bindPose.transformVector(new feng3d.Vector3(-weight.pos[0], weight.pos[1], weight.pos[2]));
                            vertices[i * 3] += pos.x * weight.bias;
                            vertices[i * 3 + 1] += pos.y * weight.bias;
                            vertices[i * 3 + 2] += pos.z * weight.bias;
                            weightJoints[j] = weight.joint;
                            weightBiass[j] = weight.bias;
                        }
                    }
                }
                jointIndices0[i * 4] = weightJoints[0];
                jointIndices0[i * 4 + 1] = weightJoints[1];
                jointIndices0[i * 4 + 2] = weightJoints[2];
                jointIndices0[i * 4 + 3] = weightJoints[3];
                jointIndices1[i * 4] = weightJoints[4];
                jointIndices1[i * 4 + 1] = weightJoints[5];
                jointIndices1[i * 4 + 2] = weightJoints[6];
                jointIndices1[i * 4 + 3] = weightJoints[7];
                //
                jointWeights0[i * 4] = weightBiass[0];
                jointWeights0[i * 4 + 1] = weightBiass[1];
                jointWeights0[i * 4 + 2] = weightBiass[2];
                jointWeights0[i * 4 + 3] = weightBiass[3];
                jointWeights1[i * 4] = weightBiass[4];
                jointWeights1[i * 4 + 1] = weightBiass[5];
                jointWeights1[i * 4 + 2] = weightBiass[6];
                jointWeights1[i * 4 + 3] = weightBiass[7];
                uvs[vertex.index * 2] = vertex.u;
                uvs[vertex.index * 2 + 1] = vertex.v;
            }
            skinSkeleton.resetJointIndices(jointIndices0, skeleton);
            skinSkeleton.resetJointIndices(jointIndices1, skeleton);
            //更新索引数据
            geometry.indices = indices;
            //更新顶点坐标与uv数据
            geometry.setVAData("a_position", vertices, 3);
            geometry.setVAData("a_uv", uvs, 2);
            //更新关节索引与权重索引
            geometry.setVAData("a_jointindex0", jointIndices0, 4);
            geometry.setVAData("a_jointweight0", jointWeights0, 4);
            geometry.setVAData("a_jointindex1", jointIndices1, 4);
            geometry.setVAData("a_jointweight1", jointWeights1, 4);
            return geometry;
        };
        return MD5MeshConverter;
    }());
    feng3d.MD5MeshConverter = MD5MeshConverter;
    feng3d.md5MeshConverter = new MD5MeshConverter();
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * MD5动画转换器
     */
    var MD5AnimConverter = /** @class */ (function () {
        function MD5AnimConverter() {
        }
        /**
         * MD5动画数据转换为引擎动画数据
         * @param md5AnimData MD5动画数据
         * @param completed 转换完成回调
         */
        MD5AnimConverter.prototype.convert = function (md5AnimData, completed) {
            var animationClip = new feng3d.AnimationClip();
            animationClip.name = md5AnimData.name;
            animationClip.length = md5AnimData.numFrames / md5AnimData.frameRate * 1000;
            animationClip.propertyClips = [];
            var __chache__ = {};
            for (var i = 0; i < md5AnimData.numFrames; ++i) {
                translatePose(md5AnimData, md5AnimData.frame[i], animationClip);
            }
            feng3d.dispatcher.dispatch("asset.parsed", animationClip);
            completed && completed(animationClip);
            /**
             * 将一个关键帧数据转换为SkeletonPose
             * @param frameData 帧数据
             * @return 包含帧数据的SkeletonPose对象
             */
            function translatePose(md5AnimData, frameData, animationclip) {
                var hierarchy;
                var base;
                var flags;
                var j;
                //偏移量
                var translation = new feng3d.Vector3();
                //旋转四元素
                var components = frameData.components;
                for (var i = 0; i < md5AnimData.numJoints; ++i) {
                    //通过原始帧数据与层级数据计算出当前骨骼pose数据
                    j = 0;
                    //层级数据
                    hierarchy = md5AnimData.hierarchy[i];
                    //基础帧数据
                    base = md5AnimData.baseframe[i];
                    //层级标记
                    flags = hierarchy.flags;
                    translation.x = base.position[0];
                    translation.y = base.position[1];
                    translation.z = base.position[2];
                    var orientation = new feng3d.Quaternion();
                    orientation.x = base.orientation[0];
                    orientation.y = base.orientation[1];
                    orientation.z = base.orientation[2];
                    //调整位移与角度数据
                    if (flags & 1)
                        translation.x = components[hierarchy.startIndex + (j++)];
                    if (flags & 2)
                        translation.y = components[hierarchy.startIndex + (j++)];
                    if (flags & 4)
                        translation.z = components[hierarchy.startIndex + (j++)];
                    if (flags & 8)
                        orientation.x = components[hierarchy.startIndex + (j++)];
                    if (flags & 16)
                        orientation.y = components[hierarchy.startIndex + (j++)];
                    if (flags & 32)
                        orientation.z = components[hierarchy.startIndex + (j++)];
                    //计算四元素w值
                    var w = 1 - orientation.x * orientation.x - orientation.y * orientation.y - orientation.z * orientation.z;
                    orientation.w = w < 0 ? 0 : -Math.sqrt(w);
                    orientation.y = -orientation.y;
                    orientation.z = -orientation.z;
                    translation.x = -translation.x;
                    var eulers = orientation.toEulerAngles();
                    eulers.scaleNumber(180 / Math.PI);
                    var path = [
                        [feng3d.PropertyClipPathItemType.GameObject, hierarchy.name],
                        [feng3d.PropertyClipPathItemType.Component, "feng3d.Transform"],
                    ];
                    var time = (frameData.index / md5AnimData.frameRate) * 1000;
                    setPropertyClipFrame(path, "position", time, translation.toArray(), "Vector3");
                    setPropertyClipFrame(path, "orientation", time, orientation.toArray(), "Quaternion");
                }
                function setPropertyClipFrame(path, propertyName, time, propertyValue, type) {
                    var propertyClip = getPropertyClip(path, propertyName);
                    propertyClip.type = type;
                    propertyClip.propertyValues.push([time, propertyValue]);
                }
                function getPropertyClip(path, propertyName) {
                    var key = path.join("-") + propertyName;
                    if (__chache__[key])
                        return __chache__[key];
                    if (!__chache__[key]) {
                        var propertyClip = __chache__[key] = new feng3d.PropertyClip();
                        propertyClip.path = path;
                        propertyClip.propertyName = propertyName;
                        propertyClip.propertyValues = [];
                        animationclip.propertyClips.push(propertyClip);
                    }
                    return __chache__[key];
                }
            }
        };
        return MD5AnimConverter;
    }());
    feng3d.MD5AnimConverter = MD5AnimConverter;
    feng3d.md5AnimConverter = new MD5AnimConverter();
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * OBJ模型MTL材质加载器
     */
    var MTLLoader = /** @class */ (function () {
        function MTLLoader() {
        }
        /**
         * 加载MTL材质
         * @param path MTL材质文件路径
         * @param completed 加载完成回调
         */
        MTLLoader.prototype.load = function (path, completed) {
            feng3d.fs.readString(path, function (err, content) {
                if (err) {
                    completed(err, null);
                    return;
                }
                var mtlData = feng3d.mtlParser.parser(content);
                feng3d.mtlConverter.convert(mtlData, completed);
            });
        };
        return MTLLoader;
    }());
    feng3d.MTLLoader = MTLLoader;
    feng3d.mtlLoader = new MTLLoader();
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * Obj模型加载类
     */
    var ObjLoader = /** @class */ (function () {
        function ObjLoader() {
        }
        /**
         * 加载资源
         * @param url   路径
         */
        ObjLoader.prototype.load = function (url, completed) {
            var root = url.substring(0, url.lastIndexOf("/") + 1);
            feng3d.fs.readString(url, function (err, content) {
                var objData = feng3d.objParser.parser(content);
                objData.name = feng3d.pathUtils.getName(url);
                var mtl = objData.mtl;
                if (mtl) {
                    feng3d.mtlLoader.load(root + mtl, function (err, materials) {
                        feng3d.objConverter.convert(objData, materials, completed);
                    });
                }
                else {
                    feng3d.objConverter.convert(objData, null, completed);
                }
            });
        };
        return ObjLoader;
    }());
    feng3d.ObjLoader = ObjLoader;
    feng3d.objLoader = new ObjLoader();
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * MD5模型加载类
     */
    var MD5Loader = /** @class */ (function () {
        function MD5Loader() {
        }
        /**
         * 加载资源
         * @param url   路径
         * @param completed 加载完成回调
         */
        MD5Loader.prototype.load = function (url, completed) {
            feng3d.fs.readString(url, function (err, content) {
                var md5MeshData = feng3d.md5MeshParser.parse(content);
                md5MeshData.name = feng3d.pathUtils.getName(url);
                feng3d.md5MeshConverter.convert(md5MeshData, completed);
            });
        };
        /**
         * 加载MD5模型动画
         * @param url MD5模型动画资源路径
         * @param completed 加载完成回调
         */
        MD5Loader.prototype.loadAnim = function (url, completed) {
            feng3d.fs.readString(url, function (err, content) {
                var md5AnimData = feng3d.md5AnimParser.parse(content);
                md5AnimData.name = feng3d.pathUtils.getName(url);
                feng3d.md5AnimConverter.convert(md5AnimData, completed);
            });
        };
        return MD5Loader;
    }());
    feng3d.MD5Loader = MD5Loader;
    feng3d.md5Loader = new MD5Loader();
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * MDL模型加载器
     */
    var MDLLoader = /** @class */ (function () {
        function MDLLoader() {
        }
        /**
         * 加载MDL模型
         * @param mdlurl MDL模型路径
         * @param callback 加载完成回调
         */
        MDLLoader.prototype.load = function (mdlurl, callback) {
            feng3d.fs.readString(mdlurl, function (err, content) {
                feng3d.war3.mdlParser.parse(content, function (war3Model) {
                    var showMesh = war3Model.getMesh();
                    var gameObject = feng3d.serialization.setValue(new feng3d.GameObject(), { name: feng3d.pathUtils.getName(mdlurl), children: [showMesh] });
                    feng3d.dispatcher.dispatch("asset.parsed", gameObject);
                    callback && callback(gameObject);
                });
            });
        };
        return MDLLoader;
    }());
    feng3d.MDLLoader = MDLLoader;
    feng3d.mdlLoader = new MDLLoader();
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var UIImage = /** @class */ (function (_super) {
        __extends(UIImage, _super);
        function UIImage() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return UIImage;
    }(feng3d.Model));
    feng3d.UIImage = UIImage;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    var GameObjectFactory = /** @class */ (function () {
        function GameObjectFactory() {
        }
        GameObjectFactory.prototype.createGameObject = function (name) {
            if (name === void 0) { name = "GameObject"; }
            return feng3d.serialization.setValue(new feng3d.GameObject(), { name: name });
        };
        GameObjectFactory.prototype.createCube = function (name) {
            if (name === void 0) { name = "cube"; }
            var g = feng3d.serialization.setValue(new feng3d.GameObject(), {
                name: name,
                components: [{ __class__: "feng3d.MeshModel", geometry: feng3d.Geometry.cube },]
            });
            g.addComponent(feng3d.BoxCollider);
            g.addComponent(feng3d.Rigidbody);
            return g;
        };
        GameObjectFactory.prototype.createPlane = function (name) {
            if (name === void 0) { name = "plane"; }
            var g = feng3d.serialization.setValue(new feng3d.GameObject(), {
                name: name,
                components: [{ __class__: "feng3d.MeshModel", geometry: feng3d.Geometry.plane },]
            });
            g.addComponent(feng3d.PlaneCollider);
            g.addComponent(feng3d.Rigidbody);
            return g;
        };
        GameObjectFactory.prototype.createCylinder = function (name) {
            if (name === void 0) { name = "cylinder"; }
            var g = feng3d.serialization.setValue(new feng3d.GameObject(), {
                name: name,
                components: [{ __class__: "feng3d.MeshModel", geometry: feng3d.Geometry.cylinder },]
            });
            g.addComponent(feng3d.CylinderCollider);
            g.addComponent(feng3d.Rigidbody);
            return g;
        };
        GameObjectFactory.prototype.createCone = function (name) {
            if (name === void 0) { name = "Cone"; }
            return feng3d.serialization.setValue(new feng3d.GameObject(), {
                name: name,
                components: [{ __class__: "feng3d.MeshModel", geometry: feng3d.Geometry.cone },]
            });
        };
        GameObjectFactory.prototype.createTorus = function (name) {
            if (name === void 0) { name = "Torus"; }
            return feng3d.serialization.setValue(new feng3d.GameObject(), {
                name: name,
                components: [{ __class__: "feng3d.MeshModel", geometry: feng3d.Geometry.torus },]
            });
        };
        GameObjectFactory.prototype.createSphere = function (name) {
            if (name === void 0) { name = "sphere"; }
            var sphere = feng3d.serialization.setValue(new feng3d.GameObject(), {
                name: name,
                components: [{ __class__: "feng3d.MeshModel", geometry: feng3d.Geometry.sphere },]
            });
            sphere.addComponent(feng3d.SphereCollider);
            sphere.addComponent(feng3d.Rigidbody);
            return sphere;
        };
        GameObjectFactory.prototype.createCapsule = function (name) {
            if (name === void 0) { name = "capsule"; }
            var g = feng3d.serialization.setValue(new feng3d.GameObject(), {
                name: name,
                components: [{ __class__: "feng3d.MeshModel", geometry: feng3d.Geometry.capsule },]
            });
            g.addComponent(feng3d.CapsuleCollider);
            g.addComponent(feng3d.Rigidbody);
            return g;
        };
        GameObjectFactory.prototype.createTerrain = function (name) {
            if (name === void 0) { name = "Terrain"; }
            return feng3d.serialization.setValue(new feng3d.GameObject(), {
                name: name,
                components: [{ __class__: "feng3d.Terrain" },]
            });
        };
        GameObjectFactory.prototype.createCamera = function (name) {
            if (name === void 0) { name = "Camera"; }
            return feng3d.serialization.setValue(new feng3d.GameObject(), {
                name: name,
                components: [{ __class__: "feng3d.Camera" },]
            });
        };
        GameObjectFactory.prototype.createPointLight = function (name) {
            if (name === void 0) { name = "PointLight"; }
            return feng3d.serialization.setValue(new feng3d.GameObject(), {
                name: name,
                components: [{ __class__: "feng3d.PointLight" },]
            });
        };
        GameObjectFactory.prototype.createDirectionalLight = function (name) {
            if (name === void 0) { name = "DirectionalLight"; }
            return feng3d.serialization.setValue(new feng3d.GameObject(), {
                name: name,
                components: [{ __class__: "feng3d.DirectionalLight" },]
            });
        };
        GameObjectFactory.prototype.createSpotLight = function (name) {
            if (name === void 0) { name = "SpotLight"; }
            return feng3d.serialization.setValue(new feng3d.GameObject(), {
                name: name,
                components: [{ __class__: "feng3d.SpotLight" },]
            });
        };
        GameObjectFactory.prototype.createParticle = function (name) {
            if (name === void 0) { name = "Particle"; }
            return feng3d.serialization.setValue(new feng3d.GameObject(), {
                name: name,
                components: [{ __class__: "feng3d.Transform", rx: -90 }, { __class__: "feng3d.ParticleSystem" },],
            });
        };
        GameObjectFactory.prototype.createWater = function (name) {
            if (name === void 0) { name = "water"; }
            return feng3d.serialization.setValue(new feng3d.GameObject(), {
                name: name,
                components: [{ __class__: "feng3d.Water" },],
            });
        };
        return GameObjectFactory;
    }());
    feng3d.GameObjectFactory = GameObjectFactory;
    feng3d.gameObjectFactory = new GameObjectFactory();
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 鼠标事件管理
     */
    var Mouse3DManager = /** @class */ (function () {
        function Mouse3DManager(mouseInput, viewport) {
            this._mouseEventTypes = [];
            //
            this.mouseInput = mouseInput;
            this.viewport = viewport;
        }
        Object.defineProperty(Mouse3DManager.prototype, "mouseInput", {
            get: function () {
                return this._mouseInput;
            },
            set: function (v) {
                var _this = this;
                if (this._mouseInput == v)
                    return;
                if (this._mouseInput) {
                    mouseEventTypes.forEach(function (element) {
                        _this._mouseInput.off(element, _this.onMouseEvent, _this);
                    });
                }
                this._mouseInput = v;
                if (this._mouseInput) {
                    mouseEventTypes.forEach(function (element) {
                        _this._mouseInput.on(element, _this.onMouseEvent, _this);
                    });
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Mouse3DManager.prototype, "selectedGameObject", {
            get: function () {
                return this._selectedGameObject;
            },
            set: function (v) {
                this.setSelectedGameObject(v);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 拾取
         * @param scene3d 场景
         * @param camera 摄像机
         */
        Mouse3DManager.prototype.pick = function (engine, scene3d, camera) {
            if (this._mouseEventTypes.length == 0)
                return;
            //计算得到鼠标射线相交的物体
            var pickingCollisionVO = feng3d.raycaster.pick(engine.getMouseRay3D(), scene3d.mouseCheckObjects);
            var gameobject = pickingCollisionVO && pickingCollisionVO.gameObject;
            return gameobject;
        };
        Mouse3DManager.prototype.dispatch = function (type) {
            if (this.viewport) {
                var bound = feng3d.lazy.getvalue(this.viewport);
                if (!bound.contains(feng3d.windowEventProxy.clientX, feng3d.windowEventProxy.clientY))
                    return;
            }
            if (this._mouseEventTypes.indexOf(type) == -1)
                this._mouseEventTypes.push(type);
        };
        /**
         * 监听鼠标事件收集事件类型
         */
        Mouse3DManager.prototype.onMouseEvent = function (event) {
            this.dispatch(event.type);
        };
        /**
         * 设置选中对象
         */
        Mouse3DManager.prototype.setSelectedGameObject = function (value) {
            var _this = this;
            if (this._selectedGameObject != value) {
                if (this._selectedGameObject)
                    this._selectedGameObject.dispatch("mouseout", null, true);
                if (value)
                    value.dispatch("mouseover", null, true);
            }
            this._selectedGameObject = value;
            this._mouseEventTypes.forEach(function (element) {
                switch (element) {
                    case "mousedown":
                        if (_this.preMouseDownGameObject != _this._selectedGameObject) {
                            _this.gameObjectClickNum = 0;
                            _this.preMouseDownGameObject = _this._selectedGameObject;
                        }
                        _this._selectedGameObject && _this._selectedGameObject.dispatch(element, null, true);
                        break;
                    case "mouseup":
                        if (_this._selectedGameObject == _this.preMouseDownGameObject) {
                            _this.gameObjectClickNum++;
                        }
                        else {
                            _this.gameObjectClickNum = 0;
                            _this.preMouseDownGameObject = null;
                        }
                        _this._selectedGameObject && _this._selectedGameObject.dispatch(element, null, true);
                        break;
                    case "mousemove":
                        _this._selectedGameObject && _this._selectedGameObject.dispatch(element, null, true);
                        break;
                    case "click":
                        if (_this.gameObjectClickNum > 0)
                            _this._selectedGameObject && _this._selectedGameObject.dispatch(element, null, true);
                        break;
                    case "dblclick":
                        if (_this.gameObjectClickNum > 1) {
                            _this._selectedGameObject && _this._selectedGameObject.dispatch(element, null, true);
                            _this.gameObjectClickNum = 0;
                        }
                        break;
                }
            });
            this._mouseEventTypes.length = 0;
        };
        return Mouse3DManager;
    }());
    feng3d.Mouse3DManager = Mouse3DManager;
    /**
     * 鼠标事件输入
     */
    var MouseInput = /** @class */ (function (_super) {
        __extends(MouseInput, _super);
        function MouseInput() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 是否启动
             */
            _this.enable = true;
            /**
             * 是否捕获鼠标移动
             */
            _this.catchMouseMove = false;
            return _this;
        }
        /**
         * 将事件调度到事件流中. 事件目标是对其调用 dispatchEvent() 方法的 IEvent 对象。
         * @param type                      事件的类型。类型区分大小写。
         * @param data                      事件携带的自定义数据。
         * @param bubbles                   表示事件是否为冒泡事件。如果事件可以冒泡，则此值为 true；否则为 false。
         */
        MouseInput.prototype.dispatch = function (type, data, bubbles) {
            if (bubbles === void 0) { bubbles = false; }
            if (!this.enable)
                return null;
            if (!this.catchMouseMove && type == "mousemove")
                return null;
            return _super.prototype.dispatch.call(this, type, data, bubbles);
        };
        /**
         * 派发事件
         * @param event   事件对象
         */
        MouseInput.prototype.dispatchEvent = function (event) {
            if (!this.enable)
                return false;
            if (!this.catchMouseMove && event.type == "mousemove")
                return false;
            return _super.prototype.dispatchEvent.call(this, event);
        };
        return MouseInput;
    }(feng3d.EventDispatcher));
    feng3d.MouseInput = MouseInput;
    /**
     * 鼠标事件列表
     */
    var mouseEventTypes = [
        "mouseout",
        "mouseover",
        "mousemove",
        "mousedown",
        "mouseup",
        "click",
        "middlemousedown",
        "middlemouseup",
        "middleclick",
        "rightmousedown",
        "rightmouseup",
        "rightclick",
        "dblclick",
    ];
    /**
     * Window鼠标事件输入
     */
    var WindowMouseInput = /** @class */ (function (_super) {
        __extends(WindowMouseInput, _super);
        function WindowMouseInput() {
            var _this = _super.call(this) || this;
            feng3d.windowEventProxy.on("click", _this.onMouseEvent, _this);
            feng3d.windowEventProxy.on("dblclick", _this.onMouseEvent, _this);
            feng3d.windowEventProxy.on("mousedown", _this.onMouseEvent, _this);
            feng3d.windowEventProxy.on("mouseup", _this.onMouseEvent, _this);
            feng3d.windowEventProxy.on("mousemove", _this.onMouseEvent, _this);
            return _this;
        }
        /**
         * 监听鼠标事件收集事件类型
         */
        WindowMouseInput.prototype.onMouseEvent = function (event) {
            var type = event.type;
            // 处理鼠标中键与右键
            if (event instanceof MouseEvent) {
                if (["click", "mousedown", "mouseup"].indexOf(event.type) != -1) {
                    type = ["", "middle", "right"][event.button] + event.type;
                }
            }
            this.dispatch(type, { mouseX: event.clientX, mouseY: event.clientY });
        };
        return WindowMouseInput;
    }(MouseInput));
    feng3d.WindowMouseInput = WindowMouseInput;
})(feng3d || (feng3d = {}));
var CANNON;
(function (CANNON) {
    var Vec3 = /** @class */ (function () {
        /**
         * 3-dimensional vector
         *
         * @param x
         * @param y
         * @param z
         *
         * @author schteppe
         * @example
         *     var v = new Vec3(1, 2, 3);
         *     console.log('x=' + v.x); // x=1
         */
        function Vec3(x, y, z) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (z === void 0) { z = 0.0; }
            this.x = x;
            this.y = y;
            this.z = z;
        }
        /**
         * Vector cross product
         *
         * @param v
         * @param target Target to save in.
         */
        Vec3.prototype.cross = function (v, target) {
            if (target === void 0) { target = new Vec3(); }
            var vx = v.x, vy = v.y, vz = v.z, x = this.x, y = this.y, z = this.z;
            target = target;
            target.x = (y * vz) - (z * vy);
            target.y = (z * vx) - (x * vz);
            target.z = (x * vy) - (y * vx);
            return target;
        };
        /**
         * Set the vectors' 3 elements
         * @param x
         * @param y
         * @param z
         */
        Vec3.prototype.set = function (x, y, z) {
            this.x = x;
            this.y = y;
            this.z = z;
            return this;
        };
        /**
         * Set all components of the vector to zero.
         */
        Vec3.prototype.setZero = function () {
            this.x = this.y = this.z = 0;
        };
        /**
         * Vector addition
         * @param v
         * @param target
         */
        Vec3.prototype.vadd = function (v, target) {
            if (target === void 0) { target = null; }
            if (target) {
                target.x = v.x + this.x;
                target.y = v.y + this.y;
                target.z = v.z + this.z;
            }
            else {
                return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z);
            }
        };
        /**
         * Vector subtraction
         * @param v
         * @param target Target to save in.
         */
        Vec3.prototype.vsub = function (v, target) {
            if (target === void 0) { target = null; }
            if (target) {
                target.x = this.x - v.x;
                target.y = this.y - v.y;
                target.z = this.z - v.z;
            }
            else {
                return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z);
            }
        };
        /**
         * Get the cross product matrix a_cross from a vector, such that a x b = a_cross * b = c
         * @see http://www8.cs.umu.se/kurser/TDBD24/VT06/lectures/Lecture6.pdf
         */
        Vec3.prototype.crossmat = function () {
            return new CANNON.Mat3([0, -this.z, this.y,
                this.z, 0, -this.x,
                -this.y, this.x, 0]);
        };
        /**
         * Normalize the vector. Note that this changes the values in the vector.
         * @returns Returns the norm of the vector
         */
        Vec3.prototype.normalize = function () {
            var x = this.x, y = this.y, z = this.z;
            var n = Math.sqrt(x * x + y * y + z * z);
            if (n > 0.0) {
                var invN = 1 / n;
                this.x *= invN;
                this.y *= invN;
                this.z *= invN;
            }
            else {
                // Make something up
                this.x = 0;
                this.y = 0;
                this.z = 0;
            }
            return n;
        };
        /**
         * Get the version of this vector that is of length 1.
         * @param target target to save in
         */
        Vec3.prototype.unit = function (target) {
            if (target === void 0) { target = new Vec3(); }
            target = target;
            var x = this.x, y = this.y, z = this.z;
            var ninv = Math.sqrt(x * x + y * y + z * z);
            if (ninv > 0.0) {
                ninv = 1.0 / ninv;
                target.x = x * ninv;
                target.y = y * ninv;
                target.z = z * ninv;
            }
            else {
                target.x = 1;
                target.y = 0;
                target.z = 0;
            }
            return target;
        };
        /**
         * Get the length of the vector
         * @deprecated Use .length() instead
         */
        Vec3.prototype.norm = function () {
            var x = this.x, y = this.y, z = this.z;
            return Math.sqrt(x * x + y * y + z * z);
        };
        /**
         * Get the length of the vector
         */
        Vec3.prototype.length = function () {
            var x = this.x, y = this.y, z = this.z;
            return Math.sqrt(x * x + y * y + z * z);
        };
        /**
         * Get the squared length of the vector
         * @deprecated Use .lengthSquared() instead.
         */
        Vec3.prototype.norm2 = function () {
            return this.dot(this);
        };
        /**
         * Get the squared length of the vector
         */
        Vec3.prototype.lengthSquared = function () {
            return this.dot(this);
        };
        /**
         * Get distance from this point to another point
         * @param p
         */
        Vec3.prototype.distanceTo = function (p) {
            var x = this.x, y = this.y, z = this.z;
            var px = p.x, py = p.y, pz = p.z;
            return Math.sqrt((px - x) * (px - x) +
                (py - y) * (py - y) +
                (pz - z) * (pz - z));
        };
        /**
         * Get squared distance from this point to another point
         * @param p
         */
        Vec3.prototype.distanceSquared = function (p) {
            var x = this.x, y = this.y, z = this.z;
            var px = p.x, py = p.y, pz = p.z;
            return (px - x) * (px - x) + (py - y) * (py - y) + (pz - z) * (pz - z);
        };
        /**
         * Multiply all the components of the vector with a scalar.
         * @param scalar
         * @param  target The vector to save the result in.
         * @deprecated Use .scale() instead
         */
        Vec3.prototype.mult = function (scalar, target) {
            if (target === void 0) { target = new Vec3(); }
            var x = this.x, y = this.y, z = this.z;
            target.x = scalar * x;
            target.y = scalar * y;
            target.z = scalar * z;
            return target;
        };
        /**
         * Multiply all the components of the vector with a scalar.
         * @param scalar
         * @param  target The vector to save the result in.
         */
        Vec3.prototype.scale = function (scalar, target) {
            if (target === void 0) { target = new Vec3(); }
            var x = this.x, y = this.y, z = this.z;
            target.x = scalar * x;
            target.y = scalar * y;
            target.z = scalar * z;
            return target;
        };
        /**
         * Multiply the vector with an other vector, component-wise.
         * @param  vector
         * @param  target The vector to save the result in.
         */
        Vec3.prototype.vmul = function (vector, target) {
            if (target === void 0) { target = new Vec3(); }
            target.x = vector.x * this.x;
            target.y = vector.y * this.y;
            target.z = vector.z * this.z;
            return target;
        };
        /**
         * Scale a vector and add it to this vector. Save the result in "target". (target = this + vector * scalar)
         * @param scalar
         * @param vector
         * @param  target The vector to save the result in.
         */
        Vec3.prototype.addScaledVector = function (scalar, vector, target) {
            if (target === void 0) { target = new Vec3(); }
            target.x = this.x + scalar * vector.x;
            target.y = this.y + scalar * vector.y;
            target.z = this.z + scalar * vector.z;
            return target;
        };
        /**
         * Calculate dot product
         * @param {Vec3} v
         */
        Vec3.prototype.dot = function (v) {
            return this.x * v.x + this.y * v.y + this.z * v.z;
        };
        Vec3.prototype.isZero = function () {
            return this.x === 0 && this.y === 0 && this.z === 0;
        };
        ;
        /**
         * Make the vector point in the opposite direction.
         * @param target Optional target to save in
         */
        Vec3.prototype.negate = function (target) {
            target = target || new Vec3();
            target.x = -this.x;
            target.y = -this.y;
            target.z = -this.z;
            return target;
        };
        Vec3.prototype.tangents = function (t1, t2) {
            var norm = this.norm();
            if (norm > 0.0) {
                var n = Vec3_tangents_n;
                var inorm = 1 / norm;
                n.set(this.x * inorm, this.y * inorm, this.z * inorm);
                var randVec = Vec3_tangents_randVec;
                if (Math.abs(n.x) < 0.9) {
                    randVec.set(1, 0, 0);
                    n.cross(randVec, t1);
                }
                else {
                    randVec.set(0, 1, 0);
                    n.cross(randVec, t1);
                }
                n.cross(t1, t2);
            }
            else {
                // The normal length is zero, make something up
                t1.set(1, 0, 0);
                t2.set(0, 1, 0);
            }
        };
        /**
         * Converts to a more readable format
         */
        Vec3.prototype.toString = function () {
            return this.x + "," + this.y + "," + this.z;
        };
        /**
         * Converts to an array
         */
        Vec3.prototype.toArray = function () {
            return [this.x, this.y, this.z];
        };
        /**
         * Copies value of source to this vector.
         * @param source
         */
        Vec3.prototype.copy = function (source) {
            this.x = source.x;
            this.y = source.y;
            this.z = source.z;
            return this;
        };
        /**
         * Do a linear interpolation between two vectors
         *
         * @param v
         * @param t A number between 0 and 1. 0 will make this function return u, and 1 will make it return v. Numbers in between will generate a vector in between them.
         */
        Vec3.prototype.lerp = function (v, t, target) {
            var x = this.x, y = this.y, z = this.z;
            target.x = x + (v.x - x) * t;
            target.y = y + (v.y - y) * t;
            target.z = z + (v.z - z) * t;
        };
        /**
         * Check if a vector equals is almost equal to another one.
         * @param v
         * @param  precision
         */
        Vec3.prototype.almostEquals = function (v, precision) {
            if (precision === void 0) { precision = 1e-6; }
            if (Math.abs(this.x - v.x) > precision ||
                Math.abs(this.y - v.y) > precision ||
                Math.abs(this.z - v.z) > precision) {
                return false;
            }
            return true;
        };
        /**
         * Check if a vector is almost zero
         * @param precision
         */
        Vec3.prototype.almostZero = function (precision) {
            if (precision === void 0) { precision = 1e-6; }
            if (Math.abs(this.x) > precision ||
                Math.abs(this.y) > precision ||
                Math.abs(this.z) > precision) {
                return false;
            }
            return true;
        };
        /**
         * Check if the vector is anti-parallel to another vector.
         * @param  v
         * @param  precision Set to zero for exact comparisons
         */
        Vec3.prototype.isAntiparallelTo = function (v, precision) {
            if (precision === void 0) { precision = 1e-6; }
            this.negate(antip_neg);
            return antip_neg.almostEquals(v, precision);
        };
        /**
         * Clone the vector
         */
        Vec3.prototype.clone = function () {
            return new Vec3(this.x, this.y, this.z);
        };
        Vec3.ZERO = new Vec3(0, 0, 0);
        Vec3.UNIT_X = new Vec3(1, 0, 0);
        Vec3.UNIT_Y = new Vec3(0, 1, 0);
        Vec3.UNIT_Z = new Vec3(0, 0, 1);
        return Vec3;
    }());
    CANNON.Vec3 = Vec3;
    /**
     * Compute two artificial tangents to the vector
     * @method tangents
     * @param {Vec3} t1 Vector object to save the first tangent in
     * @param {Vec3} t2 Vector object to save the second tangent in
     */
    var Vec3_tangents_n = new Vec3();
    var Vec3_tangents_randVec = new Vec3();
    var antip_neg = new Vec3();
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var Mat3 = /** @class */ (function () {
        /**
         * A 3x3 matrix.
         * @class Mat3
         * @constructor
         * @param array elements Array of nine elements. Optional.
         * @author schteppe / http://github.com/schteppe
         */
        function Mat3(elements) {
            if (elements === void 0) { elements = [0, 0, 0, 0, 0, 0, 0, 0, 0]; }
            if (elements) {
                this.elements = elements;
            }
            else {
                this.elements = [0, 0, 0, 0, 0, 0, 0, 0, 0];
            }
        }
        /**
         * Sets the matrix to identity
         * @todo Should perhaps be renamed to setIdentity() to be more clear.
         * @todo Create another function that immediately creates an identity matrix eg. eye()
         */
        Mat3.prototype.identity = function () {
            var e = this.elements;
            e[0] = 1;
            e[1] = 0;
            e[2] = 0;
            e[3] = 0;
            e[4] = 1;
            e[5] = 0;
            e[6] = 0;
            e[7] = 0;
            e[8] = 1;
        };
        /**
         * Set all elements to zero
         */
        Mat3.prototype.setZero = function () {
            var e = this.elements;
            e[0] = 0;
            e[1] = 0;
            e[2] = 0;
            e[3] = 0;
            e[4] = 0;
            e[5] = 0;
            e[6] = 0;
            e[7] = 0;
            e[8] = 0;
        };
        /**
         * Sets the matrix diagonal elements from a Vec3
         * @param vec3
         */
        Mat3.prototype.setTrace = function (vec3) {
            var e = this.elements;
            e[0] = vec3.x;
            e[4] = vec3.y;
            e[8] = vec3.z;
        };
        /**
         * Gets the matrix diagonal elements
         */
        Mat3.prototype.getTrace = function (target) {
            if (target === void 0) { target = new CANNON.Vec3(); }
            var e = this.elements;
            target.x = e[0];
            target.y = e[4];
            target.z = e[8];
        };
        /**
         * Matrix-Vector multiplication
         * @param v The vector to multiply with
         * @param target Optional, target to save the result in.
         */
        Mat3.prototype.vmult = function (v, target) {
            if (target === void 0) { target = new CANNON.Vec3(); }
            var e = this.elements, x = v.x, y = v.y, z = v.z;
            target.x = e[0] * x + e[1] * y + e[2] * z;
            target.y = e[3] * x + e[4] * y + e[5] * z;
            target.z = e[6] * x + e[7] * y + e[8] * z;
            return target;
        };
        /**
         * Matrix-scalar multiplication
         * @param s
         */
        Mat3.prototype.smult = function (s) {
            for (var i = 0; i < this.elements.length; i++) {
                this.elements[i] *= s;
            }
        };
        /**
         * Matrix multiplication
         * @param  m Matrix to multiply with from left side.
         */
        Mat3.prototype.mmult = function (m, target) {
            if (target === void 0) { target = new Mat3(); }
            for (var i = 0; i < 3; i++) {
                for (var j = 0; j < 3; j++) {
                    var sum = 0.0;
                    for (var k = 0; k < 3; k++) {
                        sum += m.elements[i + k * 3] * this.elements[k + j * 3];
                    }
                    target.elements[i + j * 3] = sum;
                }
            }
            return target;
        };
        /**
         * Scale each column of the matrix
         * @param v
         */
        Mat3.prototype.scale = function (v, target) {
            if (target === void 0) { target = new Mat3(); }
            var e = this.elements, t = target.elements;
            for (var i = 0; i !== 3; i++) {
                t[3 * i + 0] = v.x * e[3 * i + 0];
                t[3 * i + 1] = v.y * e[3 * i + 1];
                t[3 * i + 2] = v.z * e[3 * i + 2];
            }
            return target;
        };
        /**
         * Solve Ax=b
         * @param b The right hand side
         * @param target Optional. Target vector to save in.
         * @todo should reuse arrays
         */
        Mat3.prototype.solve = function (b, target) {
            if (target === void 0) { target = new CANNON.Vec3(); }
            // Construct equations
            var nr = 3; // num rows
            var nc = 4; // num cols
            var eqns = [];
            for (var i = 0; i < nr * nc; i++) {
                eqns.push(0);
            }
            var i, j;
            for (i = 0; i < 3; i++) {
                for (j = 0; j < 3; j++) {
                    eqns[i + nc * j] = this.elements[i + 3 * j];
                }
            }
            eqns[3 + 4 * 0] = b.x;
            eqns[3 + 4 * 1] = b.y;
            eqns[3 + 4 * 2] = b.z;
            // Compute right upper triangular version of the matrix - Gauss elimination
            var n = 3, k = n, np;
            var kp = 4; // num rows
            var p, els;
            do {
                i = k - n;
                if (eqns[i + nc * i] === 0) {
                    // the pivot is null, swap lines
                    for (j = i + 1; j < k; j++) {
                        if (eqns[i + nc * j] !== 0) {
                            np = kp;
                            do { // do ligne( i ) = ligne( i ) + ligne( k )
                                p = kp - np;
                                eqns[p + nc * i] += eqns[p + nc * j];
                            } while (--np);
                            break;
                        }
                    }
                }
                if (eqns[i + nc * i] !== 0) {
                    for (j = i + 1; j < k; j++) {
                        var multiplier = eqns[i + nc * j] / eqns[i + nc * i];
                        np = kp;
                        do { // do ligne( k ) = ligne( k ) - multiplier * ligne( i )
                            p = kp - np;
                            eqns[p + nc * j] = p <= i ? 0 : eqns[p + nc * j] - eqns[p + nc * i] * multiplier;
                        } while (--np);
                    }
                }
            } while (--n);
            // Get the solution
            target.z = eqns[2 * nc + 3] / eqns[2 * nc + 2];
            target.y = (eqns[1 * nc + 3] - eqns[1 * nc + 2] * target.z) / eqns[1 * nc + 1];
            target.x = (eqns[0 * nc + 3] - eqns[0 * nc + 2] * target.z - eqns[0 * nc + 1] * target.y) / eqns[0 * nc + 0];
            if (isNaN(target.x) || isNaN(target.y) || isNaN(target.z) || target.x === Infinity || target.y === Infinity || target.z === Infinity) {
                throw "Could not solve equation! Got x=[" + target.toString() + "], b=[" + b.toString() + "], A=[" + this.toString() + "]";
            }
            return target;
        };
        /**
         * Get an element in the matrix by index. Index starts at 0, not 1!!!
         * @param row
         * @param column
         * @param value Optional. If provided, the matrix element will be set to this value.
         */
        Mat3.prototype.e = function (row, column, value) {
            if (value === undefined) {
                return this.elements[column + 3 * row];
            }
            else {
                // Set value
                this.elements[column + 3 * row] = value;
            }
        };
        /**
         * Copy another matrix into this matrix object.
         * @param source
         */
        Mat3.prototype.copy = function (source) {
            for (var i = 0; i < source.elements.length; i++) {
                this.elements[i] = source.elements[i];
            }
            return this;
        };
        /**
         * Returns a string representation of the matrix.
         */
        Mat3.prototype.toString = function () {
            var r = "";
            var sep = ",";
            for (var i = 0; i < 9; i++) {
                r += this.elements[i] + sep;
            }
            return r;
        };
        /**
         * reverse the matrix
         * @param target Optional. Target matrix to save in.
         */
        Mat3.prototype.reverse = function (target) {
            if (target === void 0) { target = new Mat3(); }
            // Construct equations
            var nr = 3; // num rows
            var nc = 6; // num cols
            var eqns = [];
            for (var i = 0; i < nr * nc; i++) {
                eqns.push(0);
            }
            var i, j;
            for (i = 0; i < 3; i++) {
                for (j = 0; j < 3; j++) {
                    eqns[i + nc * j] = this.elements[i + 3 * j];
                }
            }
            eqns[3 + 6 * 0] = 1;
            eqns[3 + 6 * 1] = 0;
            eqns[3 + 6 * 2] = 0;
            eqns[4 + 6 * 0] = 0;
            eqns[4 + 6 * 1] = 1;
            eqns[4 + 6 * 2] = 0;
            eqns[5 + 6 * 0] = 0;
            eqns[5 + 6 * 1] = 0;
            eqns[5 + 6 * 2] = 1;
            // Compute right upper triangular version of the matrix - Gauss elimination
            var n = 3, k = n, np;
            var kp = nc; // num rows
            var p;
            do {
                i = k - n;
                if (eqns[i + nc * i] === 0) {
                    // the pivot is null, swap lines
                    for (j = i + 1; j < k; j++) {
                        if (eqns[i + nc * j] !== 0) {
                            np = kp;
                            do { // do line( i ) = line( i ) + line( k )
                                p = kp - np;
                                eqns[p + nc * i] += eqns[p + nc * j];
                            } while (--np);
                            break;
                        }
                    }
                }
                if (eqns[i + nc * i] !== 0) {
                    for (j = i + 1; j < k; j++) {
                        var multiplier = eqns[i + nc * j] / eqns[i + nc * i];
                        np = kp;
                        do { // do line( k ) = line( k ) - multiplier * line( i )
                            p = kp - np;
                            eqns[p + nc * j] = p <= i ? 0 : eqns[p + nc * j] - eqns[p + nc * i] * multiplier;
                        } while (--np);
                    }
                }
            } while (--n);
            // eliminate the upper left triangle of the matrix
            i = 2;
            do {
                j = i - 1;
                do {
                    var multiplier = eqns[i + nc * j] / eqns[i + nc * i];
                    np = nc;
                    do {
                        p = nc - np;
                        eqns[p + nc * j] = eqns[p + nc * j] - eqns[p + nc * i] * multiplier;
                    } while (--np);
                } while (j--);
            } while (--i);
            // operations on the diagonal
            i = 2;
            do {
                var multiplier = 1 / eqns[i + nc * i];
                np = nc;
                do {
                    p = nc - np;
                    eqns[p + nc * i] = eqns[p + nc * i] * multiplier;
                } while (--np);
            } while (i--);
            i = 2;
            do {
                j = 2;
                do {
                    p = eqns[nr + j + nc * i];
                    if (isNaN(p) || p === Infinity) {
                        throw "Could not reverse! A=[" + this.toString() + "]";
                    }
                    target.e(i, j, p);
                } while (j--);
            } while (i--);
            return target;
        };
        /**
         * Set the matrix from a quaterion
         * @param q
         */
        Mat3.prototype.setRotationFromQuaternion = function (q) {
            var x = q.x, y = q.y, z = q.z, w = q.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2, e = this.elements;
            e[3 * 0 + 0] = 1 - (yy + zz);
            e[3 * 0 + 1] = xy - wz;
            e[3 * 0 + 2] = xz + wy;
            e[3 * 1 + 0] = xy + wz;
            e[3 * 1 + 1] = 1 - (xx + zz);
            e[3 * 1 + 2] = yz - wx;
            e[3 * 2 + 0] = xz - wy;
            e[3 * 2 + 1] = yz + wx;
            e[3 * 2 + 2] = 1 - (xx + yy);
            return this;
        };
        /**
         * Transpose the matrix
         * @param target Where to store the result.
         * @return The target Mat3, or a new Mat3 if target was omitted.
         */
        Mat3.prototype.transpose = function (target) {
            if (target === void 0) { target = new Mat3(); }
            var Mt = target.elements, M = this.elements;
            for (var i = 0; i !== 3; i++) {
                for (var j = 0; j !== 3; j++) {
                    Mt[3 * i + j] = M[3 * j + i];
                }
            }
            return target;
        };
        return Mat3;
    }());
    CANNON.Mat3 = Mat3;
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var Quaternion = /** @class */ (function () {
        /**
         * A Quaternion describes a rotation in 3D space. The Quaternion is mathematically defined as Q = x*i + y*j + z*k + w, where (i,j,k) are imaginary basis vectors. (x,y,z) can be seen as a vector related to the axis of rotation, while the real multiplier, w, is related to the amount of rotation.
         *
         * @param x Multiplier of the imaginary basis vector i.
         * @param y Multiplier of the imaginary basis vector j.
         * @param z Multiplier of the imaginary basis vector k.
         * @param w Multiplier of the real part.
         * @see http://en.wikipedia.org/wiki/Quaternion
         */
        function Quaternion(x, y, z, w) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            if (z === void 0) { z = 0; }
            if (w === void 0) { w = 1; }
            this.x = x !== undefined ? x : 0;
            this.y = y !== undefined ? y : 0;
            this.z = z !== undefined ? z : 0;
            this.w = w !== undefined ? w : 1;
        }
        /**
         * Set the value of the quaternion.
         * @param x
         * @param y
         * @param z
         * @param w
         */
        Quaternion.prototype.set = function (x, y, z, w) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
            return this;
        };
        /**
         * Convert to a readable format
         */
        Quaternion.prototype.toString = function () {
            return this.x + "," + this.y + "," + this.z + "," + this.w;
        };
        /**
         * Convert to an Array
         */
        Quaternion.prototype.toArray = function () {
            return [this.x, this.y, this.z, this.w];
        };
        /**
         * Set the quaternion components given an axis and an angle.
         * @param axis
         * @param angle in radians
         */
        Quaternion.prototype.setFromAxisAngle = function (axis, angle) {
            var s = Math.sin(angle * 0.5);
            this.x = axis.x * s;
            this.y = axis.y * s;
            this.z = axis.z * s;
            this.w = Math.cos(angle * 0.5);
            return this;
        };
        /**
         * Converts the quaternion to axis/angle representation.
         * @param targetAxis A vector object to reuse for storing the axis.
         * @return An array, first elemnt is the axis and the second is the angle in radians.
         */
        Quaternion.prototype.toAxisAngle = function (targetAxis) {
            if (targetAxis === void 0) { targetAxis = new CANNON.Vec3(); }
            this.normalize(); // if w>1 acos and sqrt will produce errors, this cant happen if quaternion is normalised
            var angle = 2 * Math.acos(this.w);
            var s = Math.sqrt(1 - this.w * this.w); // assuming quaternion normalised then w is less than 1, so term always positive.
            if (s < 0.001) { // test to avoid divide by zero, s is always positive due to sqrt
                // if s close to zero then direction of axis not important
                targetAxis.x = this.x; // if it is important that axis is normalised then replace with x=1; y=z=0;
                targetAxis.y = this.y;
                targetAxis.z = this.z;
            }
            else {
                targetAxis.x = this.x / s; // normalise axis
                targetAxis.y = this.y / s;
                targetAxis.z = this.z / s;
            }
            return [targetAxis, angle];
        };
        /**
         * Set the quaternion value given two vectors. The resulting rotation will be the needed rotation to rotate u to v.
         * @param u
         * @param v
         */
        Quaternion.prototype.setFromVectors = function (u, v) {
            if (u.isAntiparallelTo(v)) {
                var t1 = sfv_t1;
                var t2 = sfv_t2;
                u.tangents(t1, t2);
                this.setFromAxisAngle(t1, Math.PI);
            }
            else {
                var a = u.cross(v);
                this.x = a.x;
                this.y = a.y;
                this.z = a.z;
                this.w = Math.sqrt(Math.pow(u.norm(), 2) * Math.pow(v.norm(), 2)) + u.dot(v);
                this.normalize();
            }
            return this;
        };
        /**
         * Quaternion multiplication
         * @param q
         * @param target
         */
        Quaternion.prototype.mult = function (q, target) {
            if (target === void 0) { target = new Quaternion(); }
            var ax = this.x, ay = this.y, az = this.z, aw = this.w, bx = q.x, by = q.y, bz = q.z, bw = q.w;
            target.x = ax * bw + aw * bx + ay * bz - az * by;
            target.y = ay * bw + aw * by + az * bx - ax * bz;
            target.z = az * bw + aw * bz + ax * by - ay * bx;
            target.w = aw * bw - ax * bx - ay * by - az * bz;
            return target;
        };
        /**
         * Get the inverse quaternion rotation.
         * @param target
         */
        Quaternion.prototype.inverse = function (target) {
            var x = this.x, y = this.y, z = this.z, w = this.w;
            target = target || new Quaternion();
            this.conjugate(target);
            var inorm2 = 1 / (x * x + y * y + z * z + w * w);
            target.x *= inorm2;
            target.y *= inorm2;
            target.z *= inorm2;
            target.w *= inorm2;
            return target;
        };
        /**
         * Get the quaternion conjugate
         * @param target
         */
        Quaternion.prototype.conjugate = function (target) {
            if (target === void 0) { target = new Quaternion(); }
            target.x = -this.x;
            target.y = -this.y;
            target.z = -this.z;
            target.w = this.w;
            return target;
        };
        /**
         * Normalize the quaternion. Note that this changes the values of the quaternion.
         */
        Quaternion.prototype.normalize = function () {
            var l = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
            if (l === 0) {
                this.x = 0;
                this.y = 0;
                this.z = 0;
                this.w = 0;
            }
            else {
                l = 1 / l;
                this.x *= l;
                this.y *= l;
                this.z *= l;
                this.w *= l;
            }
            return this;
        };
        /**
         * Approximation of quaternion normalization. Works best when quat is already almost-normalized.
         * @see http://jsperf.com/fast-quaternion-normalization
         * @author unphased, https://github.com/unphased
         */
        Quaternion.prototype.normalizeFast = function () {
            var f = (3.0 - (this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)) / 2.0;
            if (f === 0) {
                this.x = 0;
                this.y = 0;
                this.z = 0;
                this.w = 0;
            }
            else {
                this.x *= f;
                this.y *= f;
                this.z *= f;
                this.w *= f;
            }
            return this;
        };
        /**
         * Multiply the quaternion by a vector
         * @param v
         * @param target Optional
         */
        Quaternion.prototype.vmult = function (v, target) {
            if (target === void 0) { target = new CANNON.Vec3(); }
            var x = v.x, y = v.y, z = v.z;
            var qx = this.x, qy = this.y, qz = this.z, qw = this.w;
            // q*v
            var ix = qw * x + qy * z - qz * y, iy = qw * y + qz * x - qx * z, iz = qw * z + qx * y - qy * x, iw = -qx * x - qy * y - qz * z;
            target.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
            target.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
            target.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
            return target;
        };
        /**
         * Copies value of source to this quaternion.
         * @param source
         */
        Quaternion.prototype.copy = function (source) {
            this.x = source.x;
            this.y = source.y;
            this.z = source.z;
            this.w = source.w;
            return this;
        };
        /**
         * Convert the quaternion to euler angle representation. Order: YZX, as this page describes: http://www.euclideanspace.com/maths/standards/index.htm
         * @param target
         * @param order Three-character string e.g. "YZX", which also is default.
         */
        Quaternion.prototype.toEuler = function (target, order) {
            order = order || "YZX";
            var heading, attitude, bank;
            var x = this.x, y = this.y, z = this.z, w = this.w;
            switch (order) {
                case "YZX":
                    var test = x * y + z * w;
                    if (test > 0.499) { // singularity at north pole
                        heading = 2 * Math.atan2(x, w);
                        attitude = Math.PI / 2;
                        bank = 0;
                    }
                    if (test < -0.499) { // singularity at south pole
                        heading = -2 * Math.atan2(x, w);
                        attitude = -Math.PI / 2;
                        bank = 0;
                    }
                    if (isNaN(heading)) {
                        var sqx = x * x;
                        var sqy = y * y;
                        var sqz = z * z;
                        heading = Math.atan2(2 * y * w - 2 * x * z, 1 - 2 * sqy - 2 * sqz); // Heading
                        attitude = Math.asin(2 * test); // attitude
                        bank = Math.atan2(2 * x * w - 2 * y * z, 1 - 2 * sqx - 2 * sqz); // bank
                    }
                    break;
                default:
                    throw new Error("Euler order " + order + " not supported yet.");
            }
            target.y = heading;
            target.z = attitude;
            target.x = bank;
        };
        /**
         * See http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m
         * @param x
         * @param y
         * @param z
         * @param order The order to apply angles: 'XYZ' or 'YXZ' or any other combination
         */
        Quaternion.prototype.setFromEuler = function (x, y, z, order) {
            order = order || "XYZ";
            var c1 = Math.cos(x / 2);
            var c2 = Math.cos(y / 2);
            var c3 = Math.cos(z / 2);
            var s1 = Math.sin(x / 2);
            var s2 = Math.sin(y / 2);
            var s3 = Math.sin(z / 2);
            if (order === 'XYZ') {
                this.x = s1 * c2 * c3 + c1 * s2 * s3;
                this.y = c1 * s2 * c3 - s1 * c2 * s3;
                this.z = c1 * c2 * s3 + s1 * s2 * c3;
                this.w = c1 * c2 * c3 - s1 * s2 * s3;
            }
            else if (order === 'YXZ') {
                this.x = s1 * c2 * c3 + c1 * s2 * s3;
                this.y = c1 * s2 * c3 - s1 * c2 * s3;
                this.z = c1 * c2 * s3 - s1 * s2 * c3;
                this.w = c1 * c2 * c3 + s1 * s2 * s3;
            }
            else if (order === 'ZXY') {
                this.x = s1 * c2 * c3 - c1 * s2 * s3;
                this.y = c1 * s2 * c3 + s1 * c2 * s3;
                this.z = c1 * c2 * s3 + s1 * s2 * c3;
                this.w = c1 * c2 * c3 - s1 * s2 * s3;
            }
            else if (order === 'ZYX') {
                this.x = s1 * c2 * c3 - c1 * s2 * s3;
                this.y = c1 * s2 * c3 + s1 * c2 * s3;
                this.z = c1 * c2 * s3 - s1 * s2 * c3;
                this.w = c1 * c2 * c3 + s1 * s2 * s3;
            }
            else if (order === 'YZX') {
                this.x = s1 * c2 * c3 + c1 * s2 * s3;
                this.y = c1 * s2 * c3 + s1 * c2 * s3;
                this.z = c1 * c2 * s3 - s1 * s2 * c3;
                this.w = c1 * c2 * c3 - s1 * s2 * s3;
            }
            else if (order === 'XZY') {
                this.x = s1 * c2 * c3 - c1 * s2 * s3;
                this.y = c1 * s2 * c3 - s1 * c2 * s3;
                this.z = c1 * c2 * s3 + s1 * s2 * c3;
                this.w = c1 * c2 * c3 + s1 * s2 * s3;
            }
            return this;
        };
        Quaternion.prototype.clone = function () {
            return new Quaternion(this.x, this.y, this.z, this.w);
        };
        /**
         * Performs a spherical linear interpolation between two quat
         *
         * @param toQuat second operand
         * @param t interpolation amount between the self quaternion and toQuat
         * @param target A quaternion to store the result in. If not provided, a new one will be created.
         * @returns The "target" object
         */
        Quaternion.prototype.slerp = function (toQuat, t, target) {
            if (target === void 0) { target = new Quaternion(); }
            var ax = this.x, ay = this.y, az = this.z, aw = this.w, bx = toQuat.x, by = toQuat.y, bz = toQuat.z, bw = toQuat.w;
            var omega, cosom, sinom, scale0, scale1;
            // calc cosine
            cosom = ax * bx + ay * by + az * bz + aw * bw;
            // adjust signs (if necessary)
            if (cosom < 0.0) {
                cosom = -cosom;
                bx = -bx;
                by = -by;
                bz = -bz;
                bw = -bw;
            }
            // calculate coefficients
            if ((1.0 - cosom) > 0.000001) {
                // standard case (slerp)
                omega = Math.acos(cosom);
                sinom = Math.sin(omega);
                scale0 = Math.sin((1.0 - t) * omega) / sinom;
                scale1 = Math.sin(t * omega) / sinom;
            }
            else {
                // "from" and "to" quaternions are very close
                //  ... so we can do a linear interpolation
                scale0 = 1.0 - t;
                scale1 = t;
            }
            // calculate final values
            target.x = scale0 * ax + scale1 * bx;
            target.y = scale0 * ay + scale1 * by;
            target.z = scale0 * az + scale1 * bz;
            target.w = scale0 * aw + scale1 * bw;
            return target;
        };
        /**
         * Rotate an absolute orientation quaternion given an angular velocity and a time step.
         * @param angularVelocity
         * @param dt
         * @param angularFactor
         * @param  target
         * @return The "target" object
         */
        Quaternion.prototype.integrate = function (angularVelocity, dt, angularFactor, target) {
            target = target || new Quaternion();
            var ax = angularVelocity.x * angularFactor.x, ay = angularVelocity.y * angularFactor.y, az = angularVelocity.z * angularFactor.z, bx = this.x, by = this.y, bz = this.z, bw = this.w;
            var half_dt = dt * 0.5;
            target.x += half_dt * (ax * bw + ay * bz - az * by);
            target.y += half_dt * (ay * bw + az * bx - ax * bz);
            target.z += half_dt * (az * bw + ax * by - ay * bx);
            target.w += half_dt * (-ax * bx - ay * by - az * bz);
            return target;
        };
        return Quaternion;
    }());
    CANNON.Quaternion = Quaternion;
    var sfv_t1 = new CANNON.Vec3();
    var sfv_t2 = new CANNON.Vec3();
    var Quaternion_mult_va = new CANNON.Vec3();
    var Quaternion_mult_vb = new CANNON.Vec3();
    var Quaternion_mult_vaxvb = new CANNON.Vec3();
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var Transform = /** @class */ (function () {
        function Transform(options) {
            if (options === void 0) { options = {}; }
            this.position = new CANNON.Vec3();
            if (options.position) {
                this.position.copy(options.position);
            }
            this.quaternion = new CANNON.Quaternion();
            if (options.quaternion) {
                this.quaternion.copy(options.quaternion);
            }
        }
        /**
         * @param position
         * @param quaternion
         * @param worldPoint
         * @param result
         */
        Transform.pointToLocalFrame = function (position, quaternion, worldPoint, result) {
            if (result === void 0) { result = new CANNON.Vec3(); }
            worldPoint.vsub(position, result);
            quaternion.conjugate(tmpQuat);
            tmpQuat.vmult(result, result);
            return result;
        };
        /**
         * Get a global point in local transform coordinates.
         * @param worldPoint
         * @param result
         * @returnThe "result" vector object
         */
        Transform.prototype.pointToLocal = function (worldPoint, result) {
            return Transform.pointToLocalFrame(this.position, this.quaternion, worldPoint, result);
        };
        /**
         * @param position
         * @param quaternion
         * @param localPoint
         * @param result
         */
        Transform.pointToWorldFrame = function (position, quaternion, localPoint, result) {
            if (result === void 0) { result = new CANNON.Vec3(); }
            quaternion.vmult(localPoint, result);
            result.vadd(position, result);
            return result;
        };
        /**
         * Get a local point in global transform coordinates.
         * @param point
         * @param result
         * @return The "result" vector object
         */
        Transform.prototype.pointToWorld = function (localPoint, result) {
            return Transform.pointToWorldFrame(this.position, this.quaternion, localPoint, result);
        };
        Transform.prototype.vectorToWorldFrame = function (localVector, result) {
            if (result === void 0) { result = new CANNON.Vec3(); }
            this.quaternion.vmult(localVector, result);
            return result;
        };
        Transform.vectorToWorldFrame = function (quaternion, localVector, result) {
            quaternion.vmult(localVector, result);
            return result;
        };
        Transform.vectorToLocalFrame = function (position, quaternion, worldVector, result) {
            if (result === void 0) { result = new CANNON.Vec3(); }
            quaternion.w *= -1;
            quaternion.vmult(worldVector, result);
            quaternion.w *= -1;
            return result;
        };
        return Transform;
    }());
    CANNON.Transform = Transform;
    var tmpQuat = new CANNON.Quaternion();
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var JacobianElement = /** @class */ (function () {
        /**
         * An element containing 6 entries, 3 spatial and 3 rotational degrees of freedom.
         */
        function JacobianElement() {
            this.spatial = new CANNON.Vec3();
            this.rotational = new CANNON.Vec3();
        }
        /**
         * Multiply with other JacobianElement
         * @param element
         */
        JacobianElement.prototype.multiplyElement = function (element) {
            return element.spatial.dot(this.spatial) + element.rotational.dot(this.rotational);
        };
        /**
         * Multiply with two vectors
         * @param spatial
         * @param rotational
         */
        JacobianElement.prototype.multiplyVectors = function (spatial, rotational) {
            return spatial.dot(this.spatial) + rotational.dot(this.rotational);
        };
        return JacobianElement;
    }());
    CANNON.JacobianElement = JacobianElement;
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    /**
     * Base class for objects that dispatches events.
     */
    var EventTarget = /** @class */ (function () {
        function EventTarget() {
        }
        /**
         * Add an event listener
         * @param  type
         * @param  listener
         * @return The self object, for chainability.
         */
        EventTarget.prototype.addEventListener = function (type, listener) {
            if (this._listeners === undefined) {
                this._listeners = {};
            }
            var listeners = this._listeners;
            if (listeners[type] === undefined) {
                listeners[type] = [];
            }
            if (listeners[type].indexOf(listener) === -1) {
                listeners[type].push(listener);
            }
            return this;
        };
        /**
         * Check if an event listener is added
         * @param type
         * @param listener
         */
        EventTarget.prototype.hasEventListener = function (type, listener) {
            if (this._listeners === undefined) {
                return false;
            }
            var listeners = this._listeners;
            if (listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1) {
                return true;
            }
            return false;
        };
        /**
         * Check if any event listener of the given type is added
         * @param type
         */
        EventTarget.prototype.hasAnyEventListener = function (type) {
            if (this._listeners === undefined) {
                return false;
            }
            var listeners = this._listeners;
            return (listeners[type] !== undefined);
        };
        /**
         * Remove an event listener
         * @param type
         * @param listener
         * @return The self object, for chainability.
         */
        EventTarget.prototype.removeEventListener = function (type, listener) {
            if (this._listeners === undefined) {
                return this;
            }
            var listeners = this._listeners;
            if (listeners[type] === undefined) {
                return this;
            }
            var index = listeners[type].indexOf(listener);
            if (index !== -1) {
                listeners[type].splice(index, 1);
            }
            return this;
        };
        /**
         * Emit an event.
         * @param event
         * @return The self object, for chainability.
         */
        EventTarget.prototype.dispatchEvent = function (event) {
            if (this._listeners === undefined) {
                return this;
            }
            var listeners = this._listeners;
            var listenerArray = listeners[event.type];
            if (listenerArray !== undefined) {
                event.target = this;
                for (var i = 0, l = listenerArray.length; i < l; i++) {
                    listenerArray[i].call(this, event);
                }
            }
            return this;
        };
        return EventTarget;
    }());
    CANNON.EventTarget = EventTarget;
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    /**
     * For pooling objects that can be reused.
     */
    var Pool = /** @class */ (function () {
        function Pool() {
            this.objects = [];
            this.type = Object;
        }
        /**
         * Release an object after use
         */
        Pool.prototype.release = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var Nargs = arguments.length;
            for (var i = 0; i !== Nargs; i++) {
                this.objects.push(arguments[i]);
            }
            return this;
        };
        /**
         * Get an object
         */
        Pool.prototype.get = function () {
            if (this.objects.length === 0) {
                return this.constructObject();
            }
            else {
                return this.objects.pop();
            }
        };
        /**
         * Construct an object. Should be implmented in each subclass.
         */
        Pool.prototype.constructObject = function () {
            throw new Error("constructObject() not implemented in this Pool subclass yet!");
        };
        /**
         * @param size
         * @return Self, for chaining
         */
        Pool.prototype.resize = function (size) {
            var objects = this.objects;
            while (objects.length > size) {
                objects.pop();
            }
            while (objects.length < size) {
                objects.push(this.constructObject());
            }
            return this;
        };
        return Pool;
    }());
    CANNON.Pool = Pool;
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var Utils = /** @class */ (function () {
        function Utils() {
        }
        /**
         * Extend an options object with default values.
         * @param  options The options object. May be falsy: in this case, a new object is created and returned.
         * @param  defaults An object containing default values.
         * @return The modified options object.
         */
        Utils.defaults = function (options, defaults) {
            options = options || {};
            for (var key in defaults) {
                if (!(key in options)) {
                    options[key] = defaults[key];
                }
            }
            return options;
        };
        return Utils;
    }());
    CANNON.Utils = Utils;
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var Vec3Pool = /** @class */ (function (_super) {
        __extends(Vec3Pool, _super);
        function Vec3Pool() {
            var _this = _super.call(this) || this;
            _this.type = CANNON.Vec3;
            return _this;
        }
        /**
         * Construct a vector
         */
        Vec3Pool.prototype.constructObject = function () {
            return new CANNON.Vec3();
        };
        return Vec3Pool;
    }(CANNON.Pool));
    CANNON.Vec3Pool = Vec3Pool;
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var TupleDictionary = /** @class */ (function () {
        function TupleDictionary() {
            /**
             * The data storage
             */
            this.data = { keys: [] };
        }
        /**
         * @param i
         * @param j
         */
        TupleDictionary.prototype.get = function (i, j) {
            if (i > j) {
                // swap
                var temp = j;
                j = i;
                i = temp;
            }
            return this.data[i + '-' + j];
        };
        TupleDictionary.prototype.set = function (i, j, value) {
            if (i > j) {
                var temp = j;
                j = i;
                i = temp;
            }
            var key = i + '-' + j;
            // Check if key already exists
            if (!this.get(i, j)) {
                this.data.keys.push(key);
            }
            this.data[key] = value;
        };
        TupleDictionary.prototype.reset = function () {
            var data = this.data, keys = data.keys;
            while (keys.length > 0) {
                var key = keys.pop();
                delete data[key];
            }
        };
        return TupleDictionary;
    }());
    CANNON.TupleDictionary = TupleDictionary;
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var Constraint = /** @class */ (function () {
        /**
         * Constraint base class
         *
         * @param bodyA
         * @param bodyB
         * @param options
         *
         * @author schteppe
         */
        function Constraint(bodyA, bodyB, options) {
            if (options === void 0) { options = {}; }
            options = CANNON.Utils.defaults(options, {
                collideConnected: true,
                wakeUpBodies: true,
            });
            this.equations = [];
            this.bodyA = bodyA;
            this.bodyB = bodyB;
            this.id = Constraint.idCounter++;
            this.collideConnected = options.collideConnected;
            if (options.wakeUpBodies) {
                if (bodyA) {
                    bodyA.wakeUp();
                }
                if (bodyB) {
                    bodyB.wakeUp();
                }
            }
        }
        /**
         * Update all the equations with data.
         */
        Constraint.prototype.update = function () {
            throw new Error("method update() not implmemented in this Constraint subclass!");
        };
        /**
         * Enables all equations in the constraint.
         */
        Constraint.prototype.enable = function () {
            var eqs = this.equations;
            for (var i = 0; i < eqs.length; i++) {
                eqs[i].enabled = true;
            }
        };
        /**
         * Disables all equations in the constraint.
         */
        Constraint.prototype.disable = function () {
            var eqs = this.equations;
            for (var i = 0; i < eqs.length; i++) {
                eqs[i].enabled = false;
            }
        };
        Constraint.idCounter = 0;
        return Constraint;
    }());
    CANNON.Constraint = Constraint;
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var DistanceConstraint = /** @class */ (function (_super) {
        __extends(DistanceConstraint, _super);
        /**
         * Constrains two bodies to be at a constant distance from each others center of mass.
         *
         * @param bodyA
         * @param bodyB
         * @param distance The distance to keep. If undefined, it will be set to the current distance between bodyA and bodyB
         * @param maxForce
         * @param number
         *
         * @author schteppe
         */
        function DistanceConstraint(bodyA, bodyB, distance, maxForce) {
            var _this = _super.call(this, bodyA, bodyB) || this;
            if (typeof (distance) === "undefined") {
                distance = bodyA.position.distanceTo(bodyB.position);
            }
            if (typeof (maxForce) === "undefined") {
                maxForce = 1e6;
            }
            _this.distance = distance;
            /**
             * @property {ContactEquation} distanceEquation
             */
            var eq = _this.distanceEquation = new CANNON.ContactEquation(bodyA, bodyB);
            _this.equations.push(eq);
            // Make it bidirectional
            eq.minForce = -maxForce;
            eq.maxForce = maxForce;
            return _this;
        }
        DistanceConstraint.prototype.update = function () {
            var bodyA = this.bodyA;
            var bodyB = this.bodyB;
            var eq = this.distanceEquation;
            var halfDist = this.distance * 0.5;
            var normal = eq.ni;
            bodyB.position.vsub(bodyA.position, normal);
            normal.normalize();
            normal.mult(halfDist, eq.ri);
            normal.mult(-halfDist, eq.rj);
        };
        return DistanceConstraint;
    }(CANNON.Constraint));
    CANNON.DistanceConstraint = DistanceConstraint;
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var PointToPointConstraint = /** @class */ (function (_super) {
        __extends(PointToPointConstraint, _super);
        /**
         * Connects two bodies at given offset points.
         *
         * @param bodyA
         * @param pivotA The point relative to the center of mass of bodyA which bodyA is constrained to.
         * @param bodyB Body that will be constrained in a similar way to the same point as bodyA. We will therefore get a link between bodyA and bodyB. If not specified, bodyA will be constrained to a static point.
         * @param pivotB See pivotA.
         * @param maxForce The maximum force that should be applied to constrain the bodies.
         *
         * @example
         *     var bodyA = new Body({ mass: 1 });
         *     var bodyB = new Body({ mass: 1 });
         *     bodyA.position.set(-1, 0, 0);
         *     bodyB.position.set(1, 0, 0);
         *     bodyA.addShape(shapeA);
         *     bodyB.addShape(shapeB);
         *     world.addBody(bodyA);
         *     world.addBody(bodyB);
         *     var localPivotA = new Vec3(1, 0, 0);
         *     var localPivotB = new Vec3(-1, 0, 0);
         *     var constraint = new PointToPointConstraint(bodyA, localPivotA, bodyB, localPivotB);
         *     world.addConstraint(constraint);
         */
        function PointToPointConstraint(bodyA, pivotA, bodyB, pivotB, maxForce) {
            var _this = _super.call(this, bodyA, bodyB) || this;
            maxForce = typeof (maxForce) !== 'undefined' ? maxForce : 1e6;
            _this.pivotA = pivotA ? pivotA.clone() : new CANNON.Vec3();
            _this.pivotB = pivotB ? pivotB.clone() : new CANNON.Vec3();
            var x = _this.equationX = new CANNON.ContactEquation(bodyA, bodyB);
            var y = _this.equationY = new CANNON.ContactEquation(bodyA, bodyB);
            var z = _this.equationZ = new CANNON.ContactEquation(bodyA, bodyB);
            // Equations to be fed to the solver
            _this.equations.push(x, y, z);
            // Make the equations bidirectional
            x.minForce = y.minForce = z.minForce = -maxForce;
            x.maxForce = y.maxForce = z.maxForce = maxForce;
            x.ni.set(1, 0, 0);
            y.ni.set(0, 1, 0);
            z.ni.set(0, 0, 1);
            return _this;
        }
        PointToPointConstraint.prototype.update = function () {
            var bodyA = this.bodyA;
            var bodyB = this.bodyB;
            var x = this.equationX;
            var y = this.equationY;
            var z = this.equationZ;
            // Rotate the pivots to world space
            bodyA.quaternion.vmult(this.pivotA, x.ri);
            bodyB.quaternion.vmult(this.pivotB, x.rj);
            y.ri.copy(x.ri);
            y.rj.copy(x.rj);
            z.ri.copy(x.ri);
            z.rj.copy(x.rj);
        };
        return PointToPointConstraint;
    }(CANNON.Constraint));
    CANNON.PointToPointConstraint = PointToPointConstraint;
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var ConeTwistConstraint = /** @class */ (function (_super) {
        __extends(ConeTwistConstraint, _super);
        /**
         * @class ConeTwistConstraint
         *
         * @param bodyA
         * @param bodyB
         * @param options
         *
         * @author schteppe
         */
        function ConeTwistConstraint(bodyA, bodyB, options) {
            if (options === void 0) { options = {}; }
            var _this = _super.call(this, bodyA, options.pivotA ? options.pivotA.clone() : new CANNON.Vec3(), bodyB, options.pivotB ? options.pivotB.clone() : new CANNON.Vec3(), typeof (options.maxForce) !== 'undefined' ? options.maxForce : 1e6) || this;
            _this.axisA = options.axisA ? options.axisA.clone() : new CANNON.Vec3();
            _this.axisB = options.axisB ? options.axisB.clone() : new CANNON.Vec3();
            var maxForce = typeof (options.maxForce) !== 'undefined' ? options.maxForce : 1e6;
            _this.collideConnected = !!options.collideConnected;
            _this.angle = typeof (options.angle) !== 'undefined' ? options.angle : 0;
            /**
             * @property {ConeEquation} coneEquation
             */
            var c = _this.coneEquation = new CANNON.ConeEquation(bodyA, bodyB, options);
            /**
             * @property {RotationalEquation} twistEquation
             */
            var t = _this.twistEquation = new CANNON.RotationalEquation(bodyA, bodyB, options);
            _this.twistAngle = typeof (options.twistAngle) !== 'undefined' ? options.twistAngle : 0;
            // Make the cone equation push the bodies toward the cone axis, not outward
            c.maxForce = 0;
            c.minForce = -maxForce;
            // Make the twist equation add torque toward the initial position
            t.maxForce = 0;
            t.minForce = -maxForce;
            _this.equations.push(c, t);
            return _this;
        }
        ConeTwistConstraint.prototype.update = function () {
            var bodyA = this.bodyA, bodyB = this.bodyB, cone = this.coneEquation, twist = this.twistEquation;
            _super.prototype.update.call(this);
            // Update the axes to the cone constraint
            bodyA.vectorToWorldFrame(this.axisA, cone.axisA);
            bodyB.vectorToWorldFrame(this.axisB, cone.axisB);
            // Update the world axes in the twist constraint
            this.axisA.tangents(twist.axisA, twist.axisA);
            bodyA.vectorToWorldFrame(twist.axisA, twist.axisA);
            this.axisB.tangents(twist.axisB, twist.axisB);
            bodyB.vectorToWorldFrame(twist.axisB, twist.axisB);
            cone.angle = this.angle;
            twist.maxAngle = this.twistAngle;
        };
        return ConeTwistConstraint;
    }(CANNON.PointToPointConstraint));
    CANNON.ConeTwistConstraint = ConeTwistConstraint;
    var ConeTwistConstraint_update_tmpVec1 = new CANNON.Vec3();
    var ConeTwistConstraint_update_tmpVec2 = new CANNON.Vec3();
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var HingeConstraint = /** @class */ (function (_super) {
        __extends(HingeConstraint, _super);
        /**
         * Hinge constraint. Think of it as a door hinge. It tries to keep the door in the correct place and with the correct orientation.
         *
         * @param bodyA
         * @param bodyB
         * @param options
         *
         * @author schteppe
         */
        function HingeConstraint(bodyA, bodyB, options) {
            if (options === void 0) { options = {}; }
            var _this = _super.call(this, bodyA, options.pivotA ? options.pivotA.clone() : new CANNON.Vec3(), bodyB, options.pivotB ? options.pivotB.clone() : new CANNON.Vec3(), maxForce) || this;
            var maxForce = typeof (options.maxForce) !== 'undefined' ? options.maxForce : 1e6;
            var axisA = _this.axisA = options.axisA ? options.axisA.clone() : new CANNON.Vec3(1, 0, 0);
            axisA.normalize();
            var axisB = _this.axisB = options.axisB ? options.axisB.clone() : new CANNON.Vec3(1, 0, 0);
            axisB.normalize();
            var r1 = _this.rotationalEquation1 = new CANNON.RotationalEquation(bodyA, bodyB, options);
            var r2 = _this.rotationalEquation2 = new CANNON.RotationalEquation(bodyA, bodyB, options);
            var motor = _this.motorEquation = new CANNON.RotationalMotorEquation(bodyA, bodyB, maxForce);
            motor.enabled = false; // Not enabled by default
            // Equations to be fed to the solver
            _this.equations.push(r1, // rotational1
            r2, // rotational2
            motor);
            return _this;
        }
        HingeConstraint.prototype.enableMotor = function () {
            this.motorEquation.enabled = true;
        };
        HingeConstraint.prototype.disableMotor = function () {
            this.motorEquation.enabled = false;
        };
        HingeConstraint.prototype.setMotorSpeed = function (speed) {
            this.motorEquation.targetVelocity = speed;
        };
        HingeConstraint.prototype.setMotorMaxForce = function (maxForce) {
            this.motorEquation.maxForce = maxForce;
            this.motorEquation.minForce = -maxForce;
        };
        HingeConstraint.prototype.update = function () {
            var bodyA = this.bodyA, bodyB = this.bodyB, motor = this.motorEquation, r1 = this.rotationalEquation1, r2 = this.rotationalEquation2, worldAxisA = HingeConstraint_update_tmpVec1, worldAxisB = HingeConstraint_update_tmpVec2;
            var axisA = this.axisA;
            var axisB = this.axisB;
            _super.prototype.update.call(this);
            // Get world axes
            bodyA.quaternion.vmult(axisA, worldAxisA);
            bodyB.quaternion.vmult(axisB, worldAxisB);
            worldAxisA.tangents(r1.axisA, r2.axisA);
            r1.axisB.copy(worldAxisB);
            r2.axisB.copy(worldAxisB);
            if (this.motorEquation.enabled) {
                bodyA.quaternion.vmult(this.axisA, motor.axisA);
                bodyB.quaternion.vmult(this.axisB, motor.axisB);
            }
        };
        return HingeConstraint;
    }(CANNON.PointToPointConstraint));
    CANNON.HingeConstraint = HingeConstraint;
    var HingeConstraint_update_tmpVec1 = new CANNON.Vec3();
    var HingeConstraint_update_tmpVec2 = new CANNON.Vec3();
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var LockConstraint = /** @class */ (function (_super) {
        __extends(LockConstraint, _super);
        /**
         * Lock constraint. Will remove all degrees of freedom between the bodies.
         *
         * @param bodyA
         * @param bodyB
         * @param options
         *
         * @author schteppe
         */
        function LockConstraint(bodyA, bodyB, options) {
            if (options === void 0) { options = {}; }
            var _this = 
            // The point-to-point constraint will keep a point shared between the bodies
            _super.call(this, bodyA, new CANNON.Vec3(), bodyB, new CANNON.Vec3(), typeof (options.maxForce) !== 'undefined' ? options.maxForce : 1e6) || this;
            // Set pivot point in between
            var pivotA = _this.pivotA;
            var pivotB = _this.pivotB;
            var halfWay = new CANNON.Vec3();
            bodyA.position.vadd(bodyB.position, halfWay);
            halfWay.scale(0.5, halfWay);
            bodyB.pointToLocalFrame(halfWay, pivotB);
            bodyA.pointToLocalFrame(halfWay, pivotA);
            // Store initial rotation of the bodies as unit vectors in the local body spaces
            _this.xA = bodyA.vectorToLocalFrame(CANNON.Vec3.UNIT_X);
            _this.xB = bodyB.vectorToLocalFrame(CANNON.Vec3.UNIT_X);
            _this.yA = bodyA.vectorToLocalFrame(CANNON.Vec3.UNIT_Y);
            _this.yB = bodyB.vectorToLocalFrame(CANNON.Vec3.UNIT_Y);
            _this.zA = bodyA.vectorToLocalFrame(CANNON.Vec3.UNIT_Z);
            _this.zB = bodyB.vectorToLocalFrame(CANNON.Vec3.UNIT_Z);
            // ...and the following rotational equations will keep all rotational DOF's in place
            var r1 = _this.rotationalEquation1 = new CANNON.RotationalEquation(bodyA, bodyB, options);
            var r2 = _this.rotationalEquation2 = new CANNON.RotationalEquation(bodyA, bodyB, options);
            var r3 = _this.rotationalEquation3 = new CANNON.RotationalEquation(bodyA, bodyB, options);
            _this.equations.push(r1, r2, r3);
            return _this;
        }
        LockConstraint.prototype.update = function () {
            var bodyA = this.bodyA, bodyB = this.bodyB, motor = this.motorEquation, r1 = this.rotationalEquation1, r2 = this.rotationalEquation2, r3 = this.rotationalEquation3, worldAxisA = LockConstraint_update_tmpVec1, worldAxisB = LockConstraint_update_tmpVec2;
            _super.prototype.update.call(this);
            // These vector pairs must be orthogonal
            bodyA.vectorToWorldFrame(this.xA, r1.axisA);
            bodyB.vectorToWorldFrame(this.yB, r1.axisB);
            bodyA.vectorToWorldFrame(this.yA, r2.axisA);
            bodyB.vectorToWorldFrame(this.zB, r2.axisB);
            bodyA.vectorToWorldFrame(this.zA, r3.axisA);
            bodyB.vectorToWorldFrame(this.xB, r3.axisB);
        };
        ;
        return LockConstraint;
    }(CANNON.PointToPointConstraint));
    CANNON.LockConstraint = LockConstraint;
    var LockConstraint_update_tmpVec1 = new CANNON.Vec3();
    var LockConstraint_update_tmpVec2 = new CANNON.Vec3();
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var Shape = /** @class */ (function () {
        /**
         * Base class for shapes
         *
         * @param options
         * @author schteppe
         */
        function Shape(options) {
            if (options === void 0) { options = {}; }
            this.id = Shape.idCounter++;
            this.type = options.type || 0;
            this.boundingSphereRadius = 0;
            this.collisionResponse = options.collisionResponse ? options.collisionResponse : true;
            this.collisionFilterGroup = options.collisionFilterGroup !== undefined ? options.collisionFilterGroup : 1;
            this.collisionFilterMask = options.collisionFilterMask !== undefined ? options.collisionFilterMask : -1;
            this.material = options.material ? options.material : null;
            this.body = null;
        }
        /**
         * Computes the bounding sphere radius. The result is stored in the property .boundingSphereRadius
         */
        Shape.prototype.updateBoundingSphereRadius = function () {
            throw "computeBoundingSphereRadius() not implemented for shape type " + this.type;
        };
        /**
         * Get the volume of this shape
         */
        Shape.prototype.volume = function () {
            throw "volume() not implemented for shape type " + this.type;
        };
        /**
         * Calculates the inertia in the local frame for this shape.
         * @param mass
         * @param target
         * @see http://en.wikipedia.org/wiki/List_of_moments_of_inertia
         */
        Shape.prototype.calculateLocalInertia = function (mass, target) {
            throw "calculateLocalInertia() not implemented for shape type " + this.type;
        };
        Shape.prototype.calculateWorldAABB = function (pos, quat, min, max) {
            throw "未实现";
        };
        Shape.idCounter = 0;
        /**
         * The available shape types.
         */
        Shape.types = {
            SPHERE: 1,
            PLANE: 2,
            BOX: 4,
            COMPOUND: 8,
            CONVEXPOLYHEDRON: 16,
            HEIGHTFIELD: 32,
            PARTICLE: 64,
            CYLINDER: 128,
            TRIMESH: 256
        };
        return Shape;
    }());
    CANNON.Shape = Shape;
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var ConvexPolyhedron = /** @class */ (function (_super) {
        __extends(ConvexPolyhedron, _super);
        /**
         * A set of polygons describing a convex shape.
         * @class ConvexPolyhedron
         * @constructor
         * @extends Shape
         * @description The shape MUST be convex for the code to work properly. No polygons may be coplanar (contained
         * in the same 3D plane), instead these should be merged into one polygon.
         *
         * @param {array} points An array of Vec3's
         * @param {array} faces Array of integer arrays, describing which vertices that is included in each face.
         *
         * @author qiao / https://github.com/qiao (original author, see https://github.com/qiao/three.js/commit/85026f0c769e4000148a67d45a9e9b9c5108836f)
         * @author schteppe / https://github.com/schteppe
         * @see http://www.altdevblogaday.com/2011/05/13/contact-generation-between-3d-convex-meshes/
         * @see http://bullet.googlecode.com/svn/trunk/src/BulletCollision/NarrowPhaseCollision/btPolyhedralContactClipping.cpp
         *
         * @todo Move the clipping functions to ContactGenerator?
         * @todo Automatically merge coplanar polygons in constructor.
         */
        function ConvexPolyhedron(points, faces, uniqueAxes) {
            var _this = _super.call(this, {
                type: CANNON.Shape.types.CONVEXPOLYHEDRON
            }) || this;
            _this.vertices = points || [];
            _this.worldVertices = []; // World transformed version of .vertices
            _this.worldVerticesNeedsUpdate = true;
            _this.faces = faces || [];
            _this.faceNormals = [];
            _this.computeNormals();
            _this.worldFaceNormalsNeedsUpdate = true;
            _this.worldFaceNormals = []; // World transformed version of .faceNormals
            _this.uniqueEdges = [];
            _this.uniqueAxes = uniqueAxes ? uniqueAxes.slice() : null;
            _this.computeEdges();
            _this.updateBoundingSphereRadius();
            return _this;
        }
        /**
         * Computes uniqueEdges
         */
        ConvexPolyhedron.prototype.computeEdges = function () {
            var faces = this.faces;
            var vertices = this.vertices;
            var nv = vertices.length;
            var edges = this.uniqueEdges;
            edges.length = 0;
            var edge = computeEdges_tmpEdge;
            for (var i = 0; i !== faces.length; i++) {
                var face = faces[i];
                var numVertices = face.length;
                for (var j = 0; j !== numVertices; j++) {
                    var k = (j + 1) % numVertices;
                    vertices[face[j]].vsub(vertices[face[k]], edge);
                    edge.normalize();
                    var found = false;
                    for (var p = 0; p !== edges.length; p++) {
                        if (edges[p].almostEquals(edge) || edges[p].almostEquals(edge)) {
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        edges.push(edge.clone());
                    }
                }
            }
        };
        /**
         * Compute the normals of the faces. Will reuse existing Vec3 objects in the .faceNormals array if they exist.
         */
        ConvexPolyhedron.prototype.computeNormals = function () {
            this.faceNormals.length = this.faces.length;
            // Generate normals
            for (var i = 0; i < this.faces.length; i++) {
                // Check so all vertices exists for this face
                for (var j = 0; j < this.faces[i].length; j++) {
                    if (!this.vertices[this.faces[i][j]]) {
                        throw new Error("Vertex " + this.faces[i][j] + " not found!");
                    }
                }
                var n = this.faceNormals[i] || new CANNON.Vec3();
                this.getFaceNormal(i, n);
                n.negate(n);
                this.faceNormals[i] = n;
                var vertex = this.vertices[this.faces[i][0]];
                if (n.dot(vertex) < 0) {
                    console.error(".faceNormals[" + i + "] = Vec3(" + n.toString() + ") looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.");
                    for (var j = 0; j < this.faces[i].length; j++) {
                        console.warn(".vertices[" + this.faces[i][j] + "] = Vec3(" + this.vertices[this.faces[i][j]].toString() + ")");
                    }
                }
            }
        };
        /**
         * Get face normal given 3 vertices
         *
         * @param va
         * @param vb
         * @param vc
         * @param target
         */
        ConvexPolyhedron.computeNormal = function (va, vb, vc, target) {
            vb.vsub(va, ab);
            vc.vsub(vb, cb);
            cb.cross(ab, target);
            if (!target.isZero()) {
                target.normalize();
            }
        };
        /**
         * Compute the normal of a face from its vertices
         *
         * @param i
         * @param target
         */
        ConvexPolyhedron.prototype.getFaceNormal = function (i, target) {
            var f = this.faces[i];
            var va = this.vertices[f[0]];
            var vb = this.vertices[f[1]];
            var vc = this.vertices[f[2]];
            return ConvexPolyhedron.computeNormal(va, vb, vc, target);
        };
        /**
         * @param posA
         * @param quatA
         * @param hullB
         * @param posB
         * @param quatB
         * @param separatingNormal
         * @param minDist Clamp distance
         * @param maxDist
         * @param result The an array of contact point objects, see clipFaceAgainstHull
         * @see http://bullet.googlecode.com/svn/trunk/src/BulletCollision/NarrowPhaseCollision/btPolyhedralContactClipping.cpp
         */
        ConvexPolyhedron.prototype.clipAgainstHull = function (posA, quatA, hullB, posB, quatB, separatingNormal, minDist, maxDist, result) {
            var WorldNormal = cah_WorldNormal;
            var hullA = this;
            var curMaxDist = maxDist;
            var closestFaceB = -1;
            var dmax = -Number.MAX_VALUE;
            for (var face = 0; face < hullB.faces.length; face++) {
                WorldNormal.copy(hullB.faceNormals[face]);
                quatB.vmult(WorldNormal, WorldNormal);
                //posB.vadd(WorldNormal,WorldNormal);
                var d = WorldNormal.dot(separatingNormal);
                if (d > dmax) {
                    dmax = d;
                    closestFaceB = face;
                }
            }
            var worldVertsB1 = [];
            var polyB = hullB.faces[closestFaceB];
            var numVertices = polyB.length;
            for (var e0 = 0; e0 < numVertices; e0++) {
                var b = hullB.vertices[polyB[e0]];
                var worldb = new CANNON.Vec3();
                worldb.copy(b);
                quatB.vmult(worldb, worldb);
                posB.vadd(worldb, worldb);
                worldVertsB1.push(worldb);
            }
            if (closestFaceB >= 0) {
                this.clipFaceAgainstHull(separatingNormal, posA, quatA, worldVertsB1, minDist, maxDist, result);
            }
        };
        /**
         * Find the separating axis between this hull and another
         *
         * @param hullB
         * @param posA
         * @param quatA
         * @param posB
         * @param quatB
         * @param target The target vector to save the axis in
         * @param faceListA
         * @param faceListB
         * @returns Returns false if a separation is found, else true
         */
        ConvexPolyhedron.prototype.findSeparatingAxis = function (hullB, posA, quatA, posB, quatB, target, faceListA, faceListB) {
            var faceANormalWS3 = fsa_faceANormalWS3, Worldnormal1 = fsa_Worldnormal1, deltaC = fsa_deltaC, worldEdge0 = fsa_worldEdge0, worldEdge1 = fsa_worldEdge1, Cross = fsa_Cross;
            var dmin = Number.MAX_VALUE;
            var hullA = this;
            var curPlaneTests = 0;
            if (!hullA.uniqueAxes) {
                var numFacesA = faceListA ? faceListA.length : hullA.faces.length;
                // Test face normals from hullA
                for (var i = 0; i < numFacesA; i++) {
                    var fi = faceListA ? faceListA[i] : i;
                    // Get world face normal
                    faceANormalWS3.copy(hullA.faceNormals[fi]);
                    quatA.vmult(faceANormalWS3, faceANormalWS3);
                    var d = hullA.testSepAxis(faceANormalWS3, hullB, posA, quatA, posB, quatB);
                    if (d === false) {
                        return false;
                    }
                    if (d < dmin) {
                        dmin = d;
                        target.copy(faceANormalWS3);
                    }
                }
            }
            else {
                // Test unique axes
                for (var i = 0; i !== hullA.uniqueAxes.length; i++) {
                    // Get world axis
                    quatA.vmult(hullA.uniqueAxes[i], faceANormalWS3);
                    var d = hullA.testSepAxis(faceANormalWS3, hullB, posA, quatA, posB, quatB);
                    if (d === false) {
                        return false;
                    }
                    if (d < dmin) {
                        dmin = d;
                        target.copy(faceANormalWS3);
                    }
                }
            }
            if (!hullB.uniqueAxes) {
                // Test face normals from hullB
                var numFacesB = faceListB ? faceListB.length : hullB.faces.length;
                for (var i = 0; i < numFacesB; i++) {
                    var fi = faceListB ? faceListB[i] : i;
                    Worldnormal1.copy(hullB.faceNormals[fi]);
                    quatB.vmult(Worldnormal1, Worldnormal1);
                    curPlaneTests++;
                    var d = hullA.testSepAxis(Worldnormal1, hullB, posA, quatA, posB, quatB);
                    if (d === false) {
                        return false;
                    }
                    if (d < dmin) {
                        dmin = d;
                        target.copy(Worldnormal1);
                    }
                }
            }
            else {
                // Test unique axes in B
                for (var i = 0; i !== hullB.uniqueAxes.length; i++) {
                    quatB.vmult(hullB.uniqueAxes[i], Worldnormal1);
                    curPlaneTests++;
                    var d = hullA.testSepAxis(Worldnormal1, hullB, posA, quatA, posB, quatB);
                    if (d === false) {
                        return false;
                    }
                    if (d < dmin) {
                        dmin = d;
                        target.copy(Worldnormal1);
                    }
                }
            }
            // Test edges
            for (var e0 = 0; e0 !== hullA.uniqueEdges.length; e0++) {
                // Get world edge
                quatA.vmult(hullA.uniqueEdges[e0], worldEdge0);
                for (var e1 = 0; e1 !== hullB.uniqueEdges.length; e1++) {
                    // Get world edge 2
                    quatB.vmult(hullB.uniqueEdges[e1], worldEdge1);
                    worldEdge0.cross(worldEdge1, Cross);
                    if (!Cross.almostZero()) {
                        Cross.normalize();
                        var dist = hullA.testSepAxis(Cross, hullB, posA, quatA, posB, quatB);
                        if (dist === false) {
                            return false;
                        }
                        if (dist < dmin) {
                            dmin = dist;
                            target.copy(Cross);
                        }
                    }
                }
            }
            posB.vsub(posA, deltaC);
            if ((deltaC.dot(target)) > 0.0) {
                target.negate(target);
            }
            return true;
        };
        /**
         * Test separating axis against two hulls. Both hulls are projected onto the axis and the overlap size is returned if there is one.
         *
         * @param axis
         * @param hullB
         * @param posA
         * @param quatA
         * @param posB
         * @param quatB
         * @return The overlap depth, or FALSE if no penetration.
         */
        ConvexPolyhedron.prototype.testSepAxis = function (axis, hullB, posA, quatA, posB, quatB) {
            var hullA = this;
            ConvexPolyhedron.project(hullA, axis, posA, quatA, maxminA);
            ConvexPolyhedron.project(hullB, axis, posB, quatB, maxminB);
            var maxA = maxminA[0];
            var minA = maxminA[1];
            var maxB = maxminB[0];
            var minB = maxminB[1];
            if (maxA < minB || maxB < minA) {
                return false; // Separated
            }
            var d0 = maxA - minB;
            var d1 = maxB - minA;
            var depth = d0 < d1 ? d0 : d1;
            return depth;
        };
        /**
         *
         * @param mass
         * @param target
         */
        ConvexPolyhedron.prototype.calculateLocalInertia = function (mass, target) {
            // Approximate with box inertia
            // Exact inertia calculation is overkill, but see http://geometrictools.com/Documentation/PolyhedralMassProperties.pdf for the correct way to do it
            this.computeLocalAABB(cli_aabbmin, cli_aabbmax);
            var x = cli_aabbmax.x - cli_aabbmin.x, y = cli_aabbmax.y - cli_aabbmin.y, z = cli_aabbmax.z - cli_aabbmin.z;
            target.x = 1.0 / 12.0 * mass * (2 * y * 2 * y + 2 * z * 2 * z);
            target.y = 1.0 / 12.0 * mass * (2 * x * 2 * x + 2 * z * 2 * z);
            target.z = 1.0 / 12.0 * mass * (2 * y * 2 * y + 2 * x * 2 * x);
        };
        /**
         *
         * @param face_i Index of the face
         */
        ConvexPolyhedron.prototype.getPlaneConstantOfFace = function (face_i) {
            var f = this.faces[face_i];
            var n = this.faceNormals[face_i];
            var v = this.vertices[f[0]];
            var c = -n.dot(v);
            return c;
        };
        /**
         * Clip a face against a hull.
         *
         * @param separatingNormal
         * @param posA
         * @param quatA
         * @param worldVertsB1 An array of Vec3 with vertices in the world frame.
         * @param minDist Distance clamping
         * @param maxDist
         * @param result Array to store resulting contact points in. Will be objects with properties: point, depth, normal. These are represented in world coordinates.
         */
        ConvexPolyhedron.prototype.clipFaceAgainstHull = function (separatingNormal, posA, quatA, worldVertsB1, minDist, maxDist, result) {
            var faceANormalWS = cfah_faceANormalWS, edge0 = cfah_edge0, WorldEdge0 = cfah_WorldEdge0, worldPlaneAnormal1 = cfah_worldPlaneAnormal1, planeNormalWS1 = cfah_planeNormalWS1, worldA1 = cfah_worldA1, localPlaneNormal = cfah_localPlaneNormal, planeNormalWS = cfah_planeNormalWS;
            var hullA = this;
            var worldVertsB2 = [];
            var pVtxIn = worldVertsB1;
            var pVtxOut = worldVertsB2;
            // Find the face with normal closest to the separating axis
            var closestFaceA = -1;
            var dmin = Number.MAX_VALUE;
            for (var face = 0; face < hullA.faces.length; face++) {
                faceANormalWS.copy(hullA.faceNormals[face]);
                quatA.vmult(faceANormalWS, faceANormalWS);
                //posA.vadd(faceANormalWS,faceANormalWS);
                var d = faceANormalWS.dot(separatingNormal);
                if (d < dmin) {
                    dmin = d;
                    closestFaceA = face;
                }
            }
            if (closestFaceA < 0) {
                // console.log("--- did not find any closest face... ---");
                return;
            }
            //console.log("closest A: ",closestFaceA);
            // Get the face and construct connected faces
            var polyA = hullA.faces[closestFaceA];
            polyA.connectedFaces = [];
            for (var i = 0; i < hullA.faces.length; i++) {
                for (var j = 0; j < hullA.faces[i].length; j++) {
                    if (polyA.indexOf(hullA.faces[i][j]) !== -1 /* Sharing a vertex*/ && i !== closestFaceA /* Not the one we are looking for connections from */ && polyA.connectedFaces.indexOf(i) === -1 /* Not already added */) {
                        polyA.connectedFaces.push(i);
                    }
                }
            }
            // Clip the polygon to the back of the planes of all faces of hull A, that are adjacent to the witness face
            var numContacts = pVtxIn.length;
            var numVerticesA = polyA.length;
            var res = [];
            for (var e0 = 0; e0 < numVerticesA; e0++) {
                var a = hullA.vertices[polyA[e0]];
                var b = hullA.vertices[polyA[(e0 + 1) % numVerticesA]];
                a.vsub(b, edge0);
                WorldEdge0.copy(edge0);
                quatA.vmult(WorldEdge0, WorldEdge0);
                posA.vadd(WorldEdge0, WorldEdge0);
                worldPlaneAnormal1.copy(this.faceNormals[closestFaceA]); //transA.getBasis()* btVector3(polyA.m_plane[0],polyA.m_plane[1],polyA.m_plane[2]);
                quatA.vmult(worldPlaneAnormal1, worldPlaneAnormal1);
                posA.vadd(worldPlaneAnormal1, worldPlaneAnormal1);
                WorldEdge0.cross(worldPlaneAnormal1, planeNormalWS1);
                planeNormalWS1.negate(planeNormalWS1);
                worldA1.copy(a);
                quatA.vmult(worldA1, worldA1);
                posA.vadd(worldA1, worldA1);
                var planeEqWS1 = -worldA1.dot(planeNormalWS1);
                var planeEqWS;
                if (true) {
                    var otherFace = polyA.connectedFaces[e0];
                    localPlaneNormal.copy(this.faceNormals[otherFace]);
                    var localPlaneEq = this.getPlaneConstantOfFace(otherFace);
                    planeNormalWS.copy(localPlaneNormal);
                    quatA.vmult(planeNormalWS, planeNormalWS);
                    //posA.vadd(planeNormalWS,planeNormalWS);
                    var planeEqWS = localPlaneEq - planeNormalWS.dot(posA);
                }
                else {
                    planeNormalWS.copy(planeNormalWS1);
                    planeEqWS = planeEqWS1;
                }
                // Clip face against our constructed plane
                this.clipFaceAgainstPlane(pVtxIn, pVtxOut, planeNormalWS, planeEqWS);
                // Throw away all clipped points, but save the reamining until next clip
                while (pVtxIn.length) {
                    pVtxIn.shift();
                }
                while (pVtxOut.length) {
                    pVtxIn.push(pVtxOut.shift());
                }
            }
            //console.log("Resulting points after clip:",pVtxIn);
            // only keep contact points that are behind the witness face
            localPlaneNormal.copy(this.faceNormals[closestFaceA]);
            var localPlaneEq = this.getPlaneConstantOfFace(closestFaceA);
            planeNormalWS.copy(localPlaneNormal);
            quatA.vmult(planeNormalWS, planeNormalWS);
            var planeEqWS = localPlaneEq - planeNormalWS.dot(posA);
            for (var i = 0; i < pVtxIn.length; i++) {
                var depth = planeNormalWS.dot(pVtxIn[i]) + planeEqWS; //???
                /*console.log("depth calc from normal=",planeNormalWS.toString()," and constant "+planeEqWS+" and vertex ",pVtxIn[i].toString()," gives "+depth);*/
                if (depth <= minDist) {
                    console.log("clamped: depth=" + depth + " to minDist=" + (minDist + ""));
                    depth = minDist;
                }
                if (depth <= maxDist) {
                    var point = pVtxIn[i];
                    if (depth <= 0) {
                        /*console.log("Got contact point ",point.toString(),
                          ", depth=",depth,
                          "contact normal=",separatingNormal.toString(),
                          "plane",planeNormalWS.toString(),
                          "planeConstant",planeEqWS);*/
                        var p = {
                            point: point,
                            normal: planeNormalWS,
                            depth: depth,
                        };
                        result.push(p);
                    }
                }
            }
        };
        /**
         * Clip a face in a hull against the back of a plane.
         *
         * @param inVertices
         * @param outVertices
         * @param planeNormal
         * @param planeConstant The constant in the mathematical plane equation
         */
        ConvexPolyhedron.prototype.clipFaceAgainstPlane = function (inVertices, outVertices, planeNormal, planeConstant) {
            var n_dot_first, n_dot_last;
            var numVerts = inVertices.length;
            if (numVerts < 2) {
                return outVertices;
            }
            var firstVertex = inVertices[inVertices.length - 1], lastVertex = inVertices[0];
            n_dot_first = planeNormal.dot(firstVertex) + planeConstant;
            for (var vi = 0; vi < numVerts; vi++) {
                lastVertex = inVertices[vi];
                n_dot_last = planeNormal.dot(lastVertex) + planeConstant;
                if (n_dot_first < 0) {
                    if (n_dot_last < 0) {
                        // Start < 0, end < 0, so output lastVertex
                        var newv = new CANNON.Vec3();
                        newv.copy(lastVertex);
                        outVertices.push(newv);
                    }
                    else {
                        // Start < 0, end >= 0, so output intersection
                        var newv = new CANNON.Vec3();
                        firstVertex.lerp(lastVertex, n_dot_first / (n_dot_first - n_dot_last), newv);
                        outVertices.push(newv);
                    }
                }
                else {
                    if (n_dot_last < 0) {
                        // Start >= 0, end < 0 so output intersection and end
                        var newv = new CANNON.Vec3();
                        firstVertex.lerp(lastVertex, n_dot_first / (n_dot_first - n_dot_last), newv);
                        outVertices.push(newv);
                        outVertices.push(lastVertex);
                    }
                }
                firstVertex = lastVertex;
                n_dot_first = n_dot_last;
            }
            return outVertices;
        };
        // Updates .worldVertices and sets .worldVerticesNeedsUpdate to false.
        ConvexPolyhedron.prototype.computeWorldVertices = function (position, quat) {
            var N = this.vertices.length;
            while (this.worldVertices.length < N) {
                this.worldVertices.push(new CANNON.Vec3());
            }
            var verts = this.vertices, worldVerts = this.worldVertices;
            for (var i = 0; i !== N; i++) {
                quat.vmult(verts[i], worldVerts[i]);
                position.vadd(worldVerts[i], worldVerts[i]);
            }
            this.worldVerticesNeedsUpdate = false;
        };
        ConvexPolyhedron.prototype.computeLocalAABB = function (aabbmin, aabbmax) {
            var n = this.vertices.length, vertices = this.vertices, worldVert = computeLocalAABB_worldVert;
            aabbmin.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
            aabbmax.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
            for (var i = 0; i < n; i++) {
                var v = vertices[i];
                if (v.x < aabbmin.x) {
                    aabbmin.x = v.x;
                }
                else if (v.x > aabbmax.x) {
                    aabbmax.x = v.x;
                }
                if (v.y < aabbmin.y) {
                    aabbmin.y = v.y;
                }
                else if (v.y > aabbmax.y) {
                    aabbmax.y = v.y;
                }
                if (v.z < aabbmin.z) {
                    aabbmin.z = v.z;
                }
                else if (v.z > aabbmax.z) {
                    aabbmax.z = v.z;
                }
            }
        };
        /**
         * Updates .worldVertices and sets .worldVerticesNeedsUpdate to false.
         *
         * @param quat
         */
        ConvexPolyhedron.prototype.computeWorldFaceNormals = function (quat) {
            var N = this.faceNormals.length;
            while (this.worldFaceNormals.length < N) {
                this.worldFaceNormals.push(new CANNON.Vec3());
            }
            var normals = this.faceNormals, worldNormals = this.worldFaceNormals;
            for (var i = 0; i !== N; i++) {
                quat.vmult(normals[i], worldNormals[i]);
            }
            this.worldFaceNormalsNeedsUpdate = false;
        };
        ;
        ConvexPolyhedron.prototype.updateBoundingSphereRadius = function () {
            // Assume points are distributed with local (0,0,0) as center
            var max2 = 0;
            var verts = this.vertices;
            for (var i = 0, N = verts.length; i !== N; i++) {
                var norm2 = verts[i].norm2();
                if (norm2 > max2) {
                    max2 = norm2;
                }
            }
            this.boundingSphereRadius = Math.sqrt(max2);
        };
        /**
         *
         * @param  pos
         * @param quat
         * @param min
         * @param max
         */
        ConvexPolyhedron.prototype.calculateWorldAABB = function (pos, quat, min, max) {
            var n = this.vertices.length, verts = this.vertices;
            var minx, miny, minz, maxx, maxy, maxz;
            for (var i = 0; i < n; i++) {
                tempWorldVertex.copy(verts[i]);
                quat.vmult(tempWorldVertex, tempWorldVertex);
                pos.vadd(tempWorldVertex, tempWorldVertex);
                var v = tempWorldVertex;
                if (v.x < minx || minx === undefined) {
                    minx = v.x;
                }
                else if (v.x > maxx || maxx === undefined) {
                    maxx = v.x;
                }
                if (v.y < miny || miny === undefined) {
                    miny = v.y;
                }
                else if (v.y > maxy || maxy === undefined) {
                    maxy = v.y;
                }
                if (v.z < minz || minz === undefined) {
                    minz = v.z;
                }
                else if (v.z > maxz || maxz === undefined) {
                    maxz = v.z;
                }
            }
            min.set(minx, miny, minz);
            max.set(maxx, maxy, maxz);
        };
        /**
         * Get approximate convex volume
         */
        ConvexPolyhedron.prototype.volume = function () {
            return 4.0 * Math.PI * this.boundingSphereRadius / 3.0;
        };
        /**
         * Get an average of all the vertices positions
         *
         * @param target
         */
        ConvexPolyhedron.prototype.getAveragePointLocal = function (target) {
            target = target || new CANNON.Vec3();
            var n = this.vertices.length, verts = this.vertices;
            for (var i = 0; i < n; i++) {
                target.vadd(verts[i], target);
            }
            target.mult(1 / n, target);
            return target;
        };
        /**
         * Transform all local points. Will change the .vertices
         *
         * @param  offset
         * @param quat
         */
        ConvexPolyhedron.prototype.transformAllPoints = function (offset, quat) {
            var n = this.vertices.length, verts = this.vertices;
            // Apply rotation
            if (quat) {
                // Rotate vertices
                for (var i = 0; i < n; i++) {
                    var v = verts[i];
                    quat.vmult(v, v);
                }
                // Rotate face normals
                for (var i = 0; i < this.faceNormals.length; i++) {
                    var v = this.faceNormals[i];
                    quat.vmult(v, v);
                }
                /*
                // Rotate edges
                for(var i=0; i<this.uniqueEdges.length; i++){
                    var v = this.uniqueEdges[i];
                    quat.vmult(v,v);
                }*/
            }
            // Apply offset
            if (offset) {
                for (var i = 0; i < n; i++) {
                    var v = verts[i];
                    v.vadd(offset, v);
                }
            }
        };
        /**
         * Checks whether p is inside the polyhedra. Must be in local coords. The point lies outside of the convex hull of the other points if and only if the direction of all the vectors from it to those other points are on less than one half of a sphere around it.
         *
         * @param p      A point given in local coordinates
         */
        ConvexPolyhedron.prototype.pointIsInside = function (p) {
            var n = this.vertices.length, verts = this.vertices, faces = this.faces, normals = this.faceNormals;
            var positiveResult = null;
            var N = this.faces.length;
            var pointInside = ConvexPolyhedron_pointIsInside;
            this.getAveragePointLocal(pointInside);
            for (var i = 0; i < N; i++) {
                var numVertices = this.faces[i].length;
                var n0 = normals[i];
                var v = verts[faces[i][0]]; // We only need one point in the face
                // This dot product determines which side of the edge the point is
                var vToP = ConvexPolyhedron_vToP;
                p.vsub(v, vToP);
                var r1 = n0.dot(vToP);
                var vToPointInside = ConvexPolyhedron_vToPointInside;
                pointInside.vsub(v, vToPointInside);
                var r2 = n0.dot(vToPointInside);
                if ((r1 < 0 && r2 > 0) || (r1 > 0 && r2 < 0)) {
                    return false; // Encountered some other sign. Exit.
                }
                else {
                }
            }
            // If we got here, all dot products were of the same sign.
            return positiveResult ? 1 : -1;
        };
        /**
         * Get max and min dot product of a convex hull at position (pos,quat) projected onto an axis. Results are saved in the array maxmin.
         *
         * @param hull
         * @param axis
         * @param pos
         * @param quat
         * @param result result[0] and result[1] will be set to maximum and minimum, respectively.
         */
        ConvexPolyhedron.project = function (hull, axis, pos, quat, result) {
            var n = hull.vertices.length, worldVertex = project_worldVertex, localAxis = project_localAxis, max = 0, min = 0, localOrigin = project_localOrigin, vs = hull.vertices;
            localOrigin.setZero();
            // Transform the axis to local
            CANNON.Transform.vectorToLocalFrame(pos, quat, axis, localAxis);
            CANNON.Transform.pointToLocalFrame(pos, quat, localOrigin, localOrigin);
            var add = localOrigin.dot(localAxis);
            min = max = vs[0].dot(localAxis);
            for (var i = 1; i < n; i++) {
                var val = vs[i].dot(localAxis);
                if (val > max) {
                    max = val;
                }
                if (val < min) {
                    min = val;
                }
            }
            min -= add;
            max -= add;
            if (min > max) {
                // Inconsistent - swap
                var temp = min;
                min = max;
                max = temp;
            }
            // Output
            result[0] = max;
            result[1] = min;
        };
        ;
        return ConvexPolyhedron;
    }(CANNON.Shape));
    CANNON.ConvexPolyhedron = ConvexPolyhedron;
    var computeEdges_tmpEdge = new CANNON.Vec3();
    var cb = new CANNON.Vec3();
    var ab = new CANNON.Vec3();
    var cah_WorldNormal = new CANNON.Vec3();
    var fsa_faceANormalWS3 = new CANNON.Vec3();
    var fsa_Worldnormal1 = new CANNON.Vec3();
    var fsa_deltaC = new CANNON.Vec3();
    var fsa_worldEdge0 = new CANNON.Vec3();
    var fsa_worldEdge1 = new CANNON.Vec3();
    var fsa_Cross = new CANNON.Vec3();
    var maxminA = [], maxminB = [];
    var cli_aabbmin = new CANNON.Vec3();
    var cli_aabbmax = new CANNON.Vec3();
    var cfah_faceANormalWS = new CANNON.Vec3();
    var cfah_edge0 = new CANNON.Vec3();
    var cfah_WorldEdge0 = new CANNON.Vec3();
    var cfah_worldPlaneAnormal1 = new CANNON.Vec3();
    var cfah_planeNormalWS1 = new CANNON.Vec3();
    var cfah_worldA1 = new CANNON.Vec3();
    var cfah_localPlaneNormal = new CANNON.Vec3();
    var cfah_planeNormalWS = new CANNON.Vec3();
    var computeLocalAABB_worldVert = new CANNON.Vec3();
    var tempWorldVertex = new CANNON.Vec3();
    var ConvexPolyhedron_pointIsInside = new CANNON.Vec3();
    var ConvexPolyhedron_vToP = new CANNON.Vec3();
    var ConvexPolyhedron_vToPointInside = new CANNON.Vec3();
    var project_worldVertex = new CANNON.Vec3();
    var project_localAxis = new CANNON.Vec3();
    var project_localOrigin = new CANNON.Vec3();
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var Box = /** @class */ (function (_super) {
        __extends(Box, _super);
        /**
         * A 3d box shape.
         * @param halfExtents
         * @author schteppe
         */
        function Box(halfExtents) {
            var _this = _super.call(this, {
                type: CANNON.Shape.types.BOX
            }) || this;
            _this.halfExtents = halfExtents;
            _this.convexPolyhedronRepresentation = null;
            _this.updateConvexPolyhedronRepresentation();
            _this.updateBoundingSphereRadius();
            return _this;
        }
        /**
         * Updates the local convex polyhedron representation used for some collisions.
         */
        Box.prototype.updateConvexPolyhedronRepresentation = function () {
            var sx = this.halfExtents.x;
            var sy = this.halfExtents.y;
            var sz = this.halfExtents.z;
            var V = CANNON.Vec3;
            var vertices = [
                new V(-sx, -sy, -sz),
                new V(sx, -sy, -sz),
                new V(sx, sy, -sz),
                new V(-sx, sy, -sz),
                new V(-sx, -sy, sz),
                new V(sx, -sy, sz),
                new V(sx, sy, sz),
                new V(-sx, sy, sz)
            ];
            var indices = [
                [3, 2, 1, 0],
                [4, 5, 6, 7],
                [5, 4, 0, 1],
                [2, 3, 7, 6],
                [0, 4, 7, 3],
                [1, 2, 6, 5],
            ];
            var axes = [
                new V(0, 0, 1),
                new V(0, 1, 0),
                new V(1, 0, 0)
            ];
            var h = new CANNON.ConvexPolyhedron(vertices, indices);
            this.convexPolyhedronRepresentation = h;
            h.material = this.material;
        };
        Box.prototype.calculateLocalInertia = function (mass, target) {
            if (target === void 0) { target = new CANNON.Vec3(); }
            Box.calculateInertia(this.halfExtents, mass, target);
            return target;
        };
        Box.calculateInertia = function (halfExtents, mass, target) {
            var e = halfExtents;
            target.x = 1.0 / 12.0 * mass * (2 * e.y * 2 * e.y + 2 * e.z * 2 * e.z);
            target.y = 1.0 / 12.0 * mass * (2 * e.x * 2 * e.x + 2 * e.z * 2 * e.z);
            target.z = 1.0 / 12.0 * mass * (2 * e.y * 2 * e.y + 2 * e.x * 2 * e.x);
        };
        /**
         * Get the box 6 side normals
         * @param sixTargetVectors An array of 6 vectors, to store the resulting side normals in.
         * @param quat             Orientation to apply to the normal vectors. If not provided, the vectors will be in respect to the local frame.
         */
        Box.prototype.getSideNormals = function (sixTargetVectors, quat) {
            var sides = sixTargetVectors;
            var ex = this.halfExtents;
            sides[0].set(ex.x, 0, 0);
            sides[1].set(0, ex.y, 0);
            sides[2].set(0, 0, ex.z);
            sides[3].set(-ex.x, 0, 0);
            sides[4].set(0, -ex.y, 0);
            sides[5].set(0, 0, -ex.z);
            if (quat !== undefined) {
                for (var i = 0; i !== sides.length; i++) {
                    quat.vmult(sides[i], sides[i]);
                }
            }
            return sides;
        };
        Box.prototype.volume = function () {
            return 8.0 * this.halfExtents.x * this.halfExtents.y * this.halfExtents.z;
        };
        Box.prototype.updateBoundingSphereRadius = function () {
            this.boundingSphereRadius = this.halfExtents.norm();
        };
        Box.prototype.forEachWorldCorner = function (pos, quat, callback) {
            var e = this.halfExtents;
            var corners = [[e.x, e.y, e.z],
                [-e.x, e.y, e.z],
                [-e.x, -e.y, e.z],
                [-e.x, -e.y, -e.z],
                [e.x, -e.y, -e.z],
                [e.x, e.y, -e.z],
                [-e.x, e.y, -e.z],
                [e.x, -e.y, e.z]];
            for (var i = 0; i < corners.length; i++) {
                worldCornerTempPos.set(corners[i][0], corners[i][1], corners[i][2]);
                quat.vmult(worldCornerTempPos, worldCornerTempPos);
                pos.vadd(worldCornerTempPos, worldCornerTempPos);
                callback(worldCornerTempPos.x, worldCornerTempPos.y, worldCornerTempPos.z);
            }
        };
        Box.prototype.calculateWorldAABB = function (pos, quat, min, max) {
            var e = this.halfExtents;
            worldCornersTemp[0].set(e.x, e.y, e.z);
            worldCornersTemp[1].set(-e.x, e.y, e.z);
            worldCornersTemp[2].set(-e.x, -e.y, e.z);
            worldCornersTemp[3].set(-e.x, -e.y, -e.z);
            worldCornersTemp[4].set(e.x, -e.y, -e.z);
            worldCornersTemp[5].set(e.x, e.y, -e.z);
            worldCornersTemp[6].set(-e.x, e.y, -e.z);
            worldCornersTemp[7].set(e.x, -e.y, e.z);
            var wc = worldCornersTemp[0];
            quat.vmult(wc, wc);
            pos.vadd(wc, wc);
            max.copy(wc);
            min.copy(wc);
            for (var i = 1; i < 8; i++) {
                var wc = worldCornersTemp[i];
                quat.vmult(wc, wc);
                pos.vadd(wc, wc);
                var x = wc.x;
                var y = wc.y;
                var z = wc.z;
                if (x > max.x) {
                    max.x = x;
                }
                if (y > max.y) {
                    max.y = y;
                }
                if (z > max.z) {
                    max.z = z;
                }
                if (x < min.x) {
                    min.x = x;
                }
                if (y < min.y) {
                    min.y = y;
                }
                if (z < min.z) {
                    min.z = z;
                }
            }
            // Get each axis max
            // min.set(Infinity,Infinity,Infinity);
            // max.set(-Infinity,-Infinity,-Infinity);
            // this.forEachWorldCorner(pos,quat,function(x,y,z){
            //     if(x > max.x){
            //         max.x = x;
            //     }
            //     if(y > max.y){
            //         max.y = y;
            //     }
            //     if(z > max.z){
            //         max.z = z;
            //     }
            //     if(x < min.x){
            //         min.x = x;
            //     }
            //     if(y < min.y){
            //         min.y = y;
            //     }
            //     if(z < min.z){
            //         min.z = z;
            //     }
            // });
        };
        return Box;
    }(CANNON.Shape));
    CANNON.Box = Box;
    var worldCornerTempPos = new CANNON.Vec3();
    var worldCornerTempNeg = new CANNON.Vec3();
    var worldCornersTemp = [
        new CANNON.Vec3(),
        new CANNON.Vec3(),
        new CANNON.Vec3(),
        new CANNON.Vec3(),
        new CANNON.Vec3(),
        new CANNON.Vec3(),
        new CANNON.Vec3(),
        new CANNON.Vec3()
    ];
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var Cylinder = /** @class */ (function (_super) {
        __extends(Cylinder, _super);
        /**
         * @param radiusTop
         * @param radiusBottom
         * @param height
         * @param numSegments The number of segments to build the cylinder out of
         *
         * @author schteppe / https://github.com/schteppe
         */
        function Cylinder(radiusTop, radiusBottom, height, numSegments) {
            var _this = this;
            var N = numSegments, verts = [], axes = [], faces = [], bottomface = [], topface = [], cos = Math.cos, sin = Math.sin;
            // First bottom point
            verts.push(new CANNON.Vec3(radiusBottom * cos(0), radiusBottom * sin(0), -height * 0.5));
            bottomface.push(0);
            // First top point
            verts.push(new CANNON.Vec3(radiusTop * cos(0), radiusTop * sin(0), height * 0.5));
            topface.push(1);
            for (var i = 0; i < N; i++) {
                var theta = 2 * Math.PI / N * (i + 1);
                var thetaN = 2 * Math.PI / N * (i + 0.5);
                if (i < N - 1) {
                    // Bottom
                    verts.push(new CANNON.Vec3(radiusBottom * cos(theta), radiusBottom * sin(theta), -height * 0.5));
                    bottomface.push(2 * i + 2);
                    // Top
                    verts.push(new CANNON.Vec3(radiusTop * cos(theta), radiusTop * sin(theta), height * 0.5));
                    topface.push(2 * i + 3);
                    // Face
                    faces.push([2 * i + 2, 2 * i + 3, 2 * i + 1, 2 * i]);
                }
                else {
                    faces.push([0, 1, 2 * i + 1, 2 * i]); // Connect
                }
                // Axis: we can cut off half of them if we have even number of segments
                if (N % 2 === 1 || i < N / 2) {
                    axes.push(new CANNON.Vec3(cos(thetaN), sin(thetaN), 0));
                }
            }
            faces.push(topface);
            axes.push(new CANNON.Vec3(0, 0, 1));
            // Reorder bottom face
            var temp = [];
            for (var i = 0; i < bottomface.length; i++) {
                temp.push(bottomface[bottomface.length - i - 1]);
            }
            faces.push(temp);
            _this = _super.call(this, verts, faces, axes) || this;
            return _this;
        }
        return Cylinder;
    }(CANNON.ConvexPolyhedron));
    CANNON.Cylinder = Cylinder;
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var Heightfield = /** @class */ (function (_super) {
        __extends(Heightfield, _super);
        /**
         * Heightfield shape class. Height data is given as an array. These data points are spread out evenly with a given distance.
         *
         * @param data An array of Y values that will be used to construct the terrain.
         * @param options
         * @param options.minValue] Minimum value of the data points in the data array. Will be computed automatically if not given.
         * @param options.maxValue Maximum value.
         * @param options.elementSize=0.1 World spacing between the data points in X direction.
         * @todo Should be possible to use along all axes, not just y
         * @todo should be possible to scale along all axes
         *
         * @example
         *     // Generate some height data (y-values).
         *     var data = [];
         *     for(var i = 0; i < 1000; i++){
         *         var y = 0.5 * Math.cos(0.2 * i);
         *         data.push(y);
         *     }
         *
         *     // Create the heightfield shape
         *     var heightfieldShape = new Heightfield(data, {
         *         elementSize: 1 // Distance between the data points in X and Y directions
         *     });
         *     var heightfieldBody = new Body();
         *     heightfieldBody.addShape(heightfieldShape);
         *     world.addBody(heightfieldBody);
         */
        /**
         *
         * @param data
         * @param options
         */
        function Heightfield(data, options) {
            if (options === void 0) { options = {}; }
            var _this = _super.call(this) || this;
            options = CANNON.Utils.defaults(options, {
                maxValue: null,
                minValue: null,
                elementSize: 1
            });
            _this.data = data;
            _this.maxValue = options.maxValue;
            _this.minValue = options.minValue;
            _this.elementSize = options.elementSize;
            if (options.minValue === null) {
                _this.updateMinValue();
            }
            if (options.maxValue === null) {
                _this.updateMaxValue();
            }
            _this.cacheEnabled = true;
            CANNON.Shape.call(_this, {
                type: CANNON.Shape.types.HEIGHTFIELD
            });
            _this.pillarConvex = new CANNON.ConvexPolyhedron();
            _this.pillarOffset = new CANNON.Vec3();
            _this.updateBoundingSphereRadius();
            // "i_j_isUpper" => { convex: ..., offset: ... }
            // for example:
            // _cachedPillars["0_2_1"]
            _this._cachedPillars = {};
            return _this;
        }
        /**
         * Call whenever you change the data array.
         */
        Heightfield.prototype.update = function () {
            this._cachedPillars = {};
        };
        /**
         * Update the .minValue property
         */
        Heightfield.prototype.updateMinValue = function () {
            var data = this.data;
            var minValue = data[0][0];
            for (var i = 0; i !== data.length; i++) {
                for (var j = 0; j !== data[i].length; j++) {
                    var v = data[i][j];
                    if (v < minValue) {
                        minValue = v;
                    }
                }
            }
            this.minValue = minValue;
        };
        /**
         * Update the .maxValue property
         */
        Heightfield.prototype.updateMaxValue = function () {
            var data = this.data;
            var maxValue = data[0][0];
            for (var i = 0; i !== data.length; i++) {
                for (var j = 0; j !== data[i].length; j++) {
                    var v = data[i][j];
                    if (v > maxValue) {
                        maxValue = v;
                    }
                }
            }
            this.maxValue = maxValue;
        };
        /**
         * Set the height value at an index. Don't forget to update maxValue and minValue after you're done.
         *
         * @param xi
         * @param yi
         * @param value
         */
        Heightfield.prototype.setHeightValueAtIndex = function (xi, yi, value) {
            var data = this.data;
            data[xi][yi] = value;
            // Invalidate cache
            this.clearCachedConvexTrianglePillar(xi, yi, false);
            if (xi > 0) {
                this.clearCachedConvexTrianglePillar(xi - 1, yi, true);
                this.clearCachedConvexTrianglePillar(xi - 1, yi, false);
            }
            if (yi > 0) {
                this.clearCachedConvexTrianglePillar(xi, yi - 1, true);
                this.clearCachedConvexTrianglePillar(xi, yi - 1, false);
            }
            if (yi > 0 && xi > 0) {
                this.clearCachedConvexTrianglePillar(xi - 1, yi - 1, true);
            }
        };
        /**
         * Get max/min in a rectangle in the matrix data
         *
         * @param iMinX
         * @param iMinY
         * @param iMaxX
         * @param iMaxY
         * @param result An array to store the results in.
         * @return The result array, if it was passed in. Minimum will be at position 0 and max at 1.
         */
        Heightfield.prototype.getRectMinMax = function (iMinX, iMinY, iMaxX, iMaxY, result) {
            result = result || [];
            // Get max and min of the data
            var data = this.data, max = this.minValue; // Set first value
            for (var i = iMinX; i <= iMaxX; i++) {
                for (var j = iMinY; j <= iMaxY; j++) {
                    var height = data[i][j];
                    if (height > max) {
                        max = height;
                    }
                }
            }
            result[0] = this.minValue;
            result[1] = max;
        };
        /**
         * Get the index of a local position on the heightfield. The indexes indicate the rectangles, so if your terrain is made of N x N height data points, you will have rectangle indexes ranging from 0 to N-1.
         *
         * @param x
         * @param y
         * @param result Two-element array
         * @param clamp If the position should be clamped to the heightfield edge.
         */
        Heightfield.prototype.getIndexOfPosition = function (x, y, result, clamp) {
            // Get the index of the data points to test against
            var w = this.elementSize;
            var data = this.data;
            var xi = Math.floor(x / w);
            var yi = Math.floor(y / w);
            result[0] = xi;
            result[1] = yi;
            if (clamp) {
                // Clamp index to edges
                if (xi < 0) {
                    xi = 0;
                }
                if (yi < 0) {
                    yi = 0;
                }
                if (xi >= data.length - 1) {
                    xi = data.length - 1;
                }
                if (yi >= data[0].length - 1) {
                    yi = data[0].length - 1;
                }
            }
            // Bail out if we are out of the terrain
            if (xi < 0 || yi < 0 || xi >= data.length - 1 || yi >= data[0].length - 1) {
                return false;
            }
            return true;
        };
        Heightfield.prototype.getTriangleAt = function (x, y, edgeClamp, a, b, c) {
            var idx = getHeightAt_idx;
            this.getIndexOfPosition(x, y, idx, edgeClamp);
            var xi = idx[0];
            var yi = idx[1];
            var data = this.data;
            if (edgeClamp) {
                xi = Math.min(data.length - 2, Math.max(0, xi));
                yi = Math.min(data[0].length - 2, Math.max(0, yi));
            }
            var elementSize = this.elementSize;
            var lowerDist2 = Math.pow(x / elementSize - xi, 2) + Math.pow(y / elementSize - yi, 2);
            var upperDist2 = Math.pow(x / elementSize - (xi + 1), 2) + Math.pow(y / elementSize - (yi + 1), 2);
            var upper = lowerDist2 > upperDist2;
            this.getTriangle(xi, yi, upper, a, b, c);
            return upper;
        };
        Heightfield.prototype.getNormalAt = function (x, y, edgeClamp, result) {
            var a = getNormalAt_a;
            var b = getNormalAt_b;
            var c = getNormalAt_c;
            var e0 = getNormalAt_e0;
            var e1 = getNormalAt_e1;
            this.getTriangleAt(x, y, edgeClamp, a, b, c);
            b.vsub(a, e0);
            c.vsub(a, e1);
            e0.cross(e1, result);
            result.normalize();
        };
        /**
         * Get an AABB of a square in the heightfield
         *
         * @param xi
         * @param yi
         * @param result
         */
        Heightfield.prototype.getAabbAtIndex = function (xi, yi, result) {
            var data = this.data;
            var elementSize = this.elementSize;
            result.lowerBound.set(xi * elementSize, yi * elementSize, data[xi][yi]);
            result.upperBound.set((xi + 1) * elementSize, (yi + 1) * elementSize, data[xi + 1][yi + 1]);
        };
        /**
         * Get the height in the heightfield at a given position
         *
         * @param x
         * @param y
         * @param edgeClamp
         */
        Heightfield.prototype.getHeightAt = function (x, y, edgeClamp) {
            var data = this.data;
            var a = getHeightAt_a;
            var b = getHeightAt_b;
            var c = getHeightAt_c;
            var idx = getHeightAt_idx;
            this.getIndexOfPosition(x, y, idx, edgeClamp);
            var xi = idx[0];
            var yi = idx[1];
            if (edgeClamp) {
                xi = Math.min(data.length - 2, Math.max(0, xi));
                yi = Math.min(data[0].length - 2, Math.max(0, yi));
            }
            var upper = this.getTriangleAt(x, y, edgeClamp, a, b, c);
            barycentricWeights(x, y, a.x, a.y, b.x, b.y, c.x, c.y, getHeightAt_weights);
            var w = getHeightAt_weights;
            if (upper) {
                // Top triangle verts
                return data[xi + 1][yi + 1] * w.x + data[xi][yi + 1] * w.y + data[xi + 1][yi] * w.z;
            }
            else {
                // Top triangle verts
                return data[xi][yi] * w.x + data[xi + 1][yi] * w.y + data[xi][yi + 1] * w.z;
            }
        };
        Heightfield.prototype.getCacheConvexTrianglePillarKey = function (xi, yi, getUpperTriangle) {
            return xi + '_' + yi + '_' + (getUpperTriangle ? 1 : 0);
        };
        Heightfield.prototype.getCachedConvexTrianglePillar = function (xi, yi, getUpperTriangle) {
            return this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)];
        };
        Heightfield.prototype.setCachedConvexTrianglePillar = function (xi, yi, getUpperTriangle, convex, offset) {
            this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)] = {
                convex: convex,
                offset: offset
            };
        };
        Heightfield.prototype.clearCachedConvexTrianglePillar = function (xi, yi, getUpperTriangle) {
            delete this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)];
        };
        /**
         * Get a triangle from the heightfield
         *
         * @param xi
         * @param yi
         * @param upper
         * @param a
         * @param b
         * @param c
         */
        Heightfield.prototype.getTriangle = function (xi, yi, upper, a, b, c) {
            var data = this.data;
            var elementSize = this.elementSize;
            if (upper) {
                // Top triangle verts
                a.set((xi + 1) * elementSize, (yi + 1) * elementSize, data[xi + 1][yi + 1]);
                b.set(xi * elementSize, (yi + 1) * elementSize, data[xi][yi + 1]);
                c.set((xi + 1) * elementSize, yi * elementSize, data[xi + 1][yi]);
            }
            else {
                // Top triangle verts
                a.set(xi * elementSize, yi * elementSize, data[xi][yi]);
                b.set((xi + 1) * elementSize, yi * elementSize, data[xi + 1][yi]);
                c.set(xi * elementSize, (yi + 1) * elementSize, data[xi][yi + 1]);
            }
        };
        ;
        /**
         * Get a triangle in the terrain in the form of a triangular convex shape.
         *
         * @param i
         * @param j
         * @param getUpperTriangle
         */
        Heightfield.prototype.getConvexTrianglePillar = function (xi, yi, getUpperTriangle) {
            var result = this.pillarConvex;
            var offsetResult = this.pillarOffset;
            if (this.cacheEnabled) {
                var data0 = this.getCachedConvexTrianglePillar(xi, yi, getUpperTriangle);
                if (data0) {
                    this.pillarConvex = data0.convex;
                    this.pillarOffset = data0.offset;
                    return;
                }
                result = new CANNON.ConvexPolyhedron();
                offsetResult = new CANNON.Vec3();
                this.pillarConvex = result;
                this.pillarOffset = offsetResult;
            }
            var data = this.data;
            var elementSize = this.elementSize;
            var faces = result.faces;
            // Reuse verts if possible
            result.vertices.length = 6;
            for (var i = 0; i < 6; i++) {
                if (!result.vertices[i]) {
                    result.vertices[i] = new CANNON.Vec3();
                }
            }
            // Reuse faces if possible
            faces.length = 5;
            for (var i = 0; i < 5; i++) {
                if (!faces[i]) {
                    faces[i] = [];
                }
            }
            var verts = result.vertices;
            var h = (Math.min(data[xi][yi], data[xi + 1][yi], data[xi][yi + 1], data[xi + 1][yi + 1]) - this.minValue) / 2 + this.minValue;
            if (!getUpperTriangle) {
                // Center of the triangle pillar - all polygons are given relative to this one
                offsetResult.set((xi + 0.25) * elementSize, // sort of center of a triangle
                (yi + 0.25) * elementSize, h // vertical center
                );
                // Top triangle verts
                verts[0].set(-0.25 * elementSize, -0.25 * elementSize, data[xi][yi] - h);
                verts[1].set(0.75 * elementSize, -0.25 * elementSize, data[xi + 1][yi] - h);
                verts[2].set(-0.25 * elementSize, 0.75 * elementSize, data[xi][yi + 1] - h);
                // bottom triangle verts
                verts[3].set(-0.25 * elementSize, -0.25 * elementSize, -h - 1);
                verts[4].set(0.75 * elementSize, -0.25 * elementSize, -h - 1);
                verts[5].set(-0.25 * elementSize, 0.75 * elementSize, -h - 1);
                // top triangle
                faces[0][0] = 0;
                faces[0][1] = 1;
                faces[0][2] = 2;
                // bottom triangle
                faces[1][0] = 5;
                faces[1][1] = 4;
                faces[1][2] = 3;
                // -x facing quad
                faces[2][0] = 0;
                faces[2][1] = 2;
                faces[2][2] = 5;
                faces[2][3] = 3;
                // -y facing quad
                faces[3][0] = 1;
                faces[3][1] = 0;
                faces[3][2] = 3;
                faces[3][3] = 4;
                // +xy facing quad
                faces[4][0] = 4;
                faces[4][1] = 5;
                faces[4][2] = 2;
                faces[4][3] = 1;
            }
            else {
                // Center of the triangle pillar - all polygons are given relative to this one
                offsetResult.set((xi + 0.75) * elementSize, // sort of center of a triangle
                (yi + 0.75) * elementSize, h // vertical center
                );
                // Top triangle verts
                verts[0].set(0.25 * elementSize, 0.25 * elementSize, data[xi + 1][yi + 1] - h);
                verts[1].set(-0.75 * elementSize, 0.25 * elementSize, data[xi][yi + 1] - h);
                verts[2].set(0.25 * elementSize, -0.75 * elementSize, data[xi + 1][yi] - h);
                // bottom triangle verts
                verts[3].set(0.25 * elementSize, 0.25 * elementSize, -h - 1);
                verts[4].set(-0.75 * elementSize, 0.25 * elementSize, -h - 1);
                verts[5].set(0.25 * elementSize, -0.75 * elementSize, -h - 1);
                // Top triangle
                faces[0][0] = 0;
                faces[0][1] = 1;
                faces[0][2] = 2;
                // bottom triangle
                faces[1][0] = 5;
                faces[1][1] = 4;
                faces[1][2] = 3;
                // +x facing quad
                faces[2][0] = 2;
                faces[2][1] = 5;
                faces[2][2] = 3;
                faces[2][3] = 0;
                // +y facing quad
                faces[3][0] = 3;
                faces[3][1] = 4;
                faces[3][2] = 1;
                faces[3][3] = 0;
                // -xy facing quad
                faces[4][0] = 1;
                faces[4][1] = 4;
                faces[4][2] = 5;
                faces[4][3] = 2;
            }
            result.computeNormals();
            result.computeEdges();
            result.updateBoundingSphereRadius();
            this.setCachedConvexTrianglePillar(xi, yi, getUpperTriangle, result, offsetResult);
        };
        ;
        Heightfield.prototype.calculateLocalInertia = function (mass, target) {
            if (target === void 0) { target = new CANNON.Vec3(); }
            target.set(0, 0, 0);
            return target;
        };
        Heightfield.prototype.volume = function () {
            return Number.MAX_VALUE; // The terrain is infinite
        };
        Heightfield.prototype.calculateWorldAABB = function (pos, quat, min, max) {
            // TODO: do it properly
            min.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
            max.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        };
        Heightfield.prototype.updateBoundingSphereRadius = function () {
            // Use the bounding box of the min/max values
            var data = this.data, s = this.elementSize;
            this.boundingSphereRadius = new CANNON.Vec3(data.length * s, data[0].length * s, Math.max(Math.abs(this.maxValue), Math.abs(this.minValue))).norm();
        };
        /**
         * Sets the height values from an image. Currently only supported in browser.
         *
         * @param image
         * @param scale
         */
        Heightfield.prototype.setHeightsFromImage = function (image, scale) {
            var canvas = document.createElement('canvas');
            canvas.width = image.width;
            canvas.height = image.height;
            var context = canvas.getContext('2d');
            context.drawImage(image, 0, 0);
            var imageData = context.getImageData(0, 0, image.width, image.height);
            var matrix = this.data;
            matrix.length = 0;
            this.elementSize = Math.abs(scale.x) / imageData.width;
            for (var i = 0; i < imageData.height; i++) {
                var row = [];
                for (var j = 0; j < imageData.width; j++) {
                    var a = imageData.data[(i * imageData.height + j) * 4];
                    var b = imageData.data[(i * imageData.height + j) * 4 + 1];
                    var c = imageData.data[(i * imageData.height + j) * 4 + 2];
                    var height = (a + b + c) / 4 / 255 * scale.z;
                    if (scale.x < 0) {
                        row.push(height);
                    }
                    else {
                        row.unshift(height);
                    }
                }
                if (scale.y < 0) {
                    matrix.unshift(row);
                }
                else {
                    matrix.push(row);
                }
            }
            this.updateMaxValue();
            this.updateMinValue();
            this.update();
        };
        return Heightfield;
    }(CANNON.Shape));
    CANNON.Heightfield = Heightfield;
    var getHeightAt_idx = [];
    var getHeightAt_weights = new CANNON.Vec3();
    var getHeightAt_a = new CANNON.Vec3();
    var getHeightAt_b = new CANNON.Vec3();
    var getHeightAt_c = new CANNON.Vec3();
    var getNormalAt_a = new CANNON.Vec3();
    var getNormalAt_b = new CANNON.Vec3();
    var getNormalAt_c = new CANNON.Vec3();
    var getNormalAt_e0 = new CANNON.Vec3();
    var getNormalAt_e1 = new CANNON.Vec3();
    // from https://en.wikipedia.org/wiki/Barycentric_coordinate_system
    function barycentricWeights(x, y, ax, ay, bx, by, cx, cy, result) {
        result.x = ((by - cy) * (x - cx) + (cx - bx) * (y - cy)) / ((by - cy) * (ax - cx) + (cx - bx) * (ay - cy));
        result.y = ((cy - ay) * (x - cx) + (ax - cx) * (y - cy)) / ((by - cy) * (ax - cx) + (cx - bx) * (ay - cy));
        result.z = 1 - result.x - result.y;
    }
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var Particle = /** @class */ (function (_super) {
        __extends(Particle, _super);
        /**
         * Particle shape.
         *
         * @author schteppe
         */
        function Particle() {
            return _super.call(this, {
                type: CANNON.Shape.types.PARTICLE
            }) || this;
        }
        /**
         * @param mass
         * @param target
         */
        Particle.prototype.calculateLocalInertia = function (mass, target) {
            target = target || new CANNON.Vec3();
            target.set(0, 0, 0);
            return target;
        };
        Particle.prototype.volume = function () {
            return 0;
        };
        Particle.prototype.updateBoundingSphereRadius = function () {
            this.boundingSphereRadius = 0;
        };
        Particle.prototype.calculateWorldAABB = function (pos, quat, min, max) {
            // Get each axis max
            min.copy(pos);
            max.copy(pos);
        };
        return Particle;
    }(CANNON.Shape));
    CANNON.Particle = Particle;
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var Plane = /** @class */ (function (_super) {
        __extends(Plane, _super);
        /**
         * A plane, facing in the Z direction. The plane has its surface at z=0 and everything below z=0 is assumed to be solid plane. To make the plane face in some other direction than z, you must put it inside a Body and rotate that body. See the demos.
         *
         * @author schteppe
         */
        function Plane() {
            var _this = _super.call(this, {
                type: CANNON.Shape.types.PLANE
            }) || this;
            // World oriented normal
            _this.worldNormal = new CANNON.Vec3();
            _this.worldNormalNeedsUpdate = true;
            _this.boundingSphereRadius = Number.MAX_VALUE;
            return _this;
        }
        Plane.prototype.computeWorldNormal = function (quat) {
            var n = this.worldNormal;
            n.copy(CANNON.World.worldNormal);
            quat.vmult(n, n);
            this.worldNormalNeedsUpdate = false;
        };
        Plane.prototype.calculateLocalInertia = function (mass, target) {
            if (target === void 0) { target = new CANNON.Vec3(); }
            return target;
        };
        Plane.prototype.volume = function () {
            return Number.MAX_VALUE; // The plane is infinite...
        };
        Plane.prototype.calculateWorldAABB = function (pos, quat, min, max) {
            // The plane AABB is infinite, except if the normal is pointing along any axis
            tempNormal.copy(CANNON.World.worldNormal); // Default plane normal is z
            quat.vmult(tempNormal, tempNormal);
            var maxVal = Number.MAX_VALUE;
            min.set(-maxVal, -maxVal, -maxVal);
            max.set(maxVal, maxVal, maxVal);
            if (tempNormal.x === 1) {
                max.x = pos.x;
            }
            if (tempNormal.y === 1) {
                max.y = pos.y;
            }
            if (tempNormal.z === 1) {
                max.z = pos.z;
            }
            if (tempNormal.x === -1) {
                min.x = pos.x;
            }
            if (tempNormal.y === -1) {
                min.y = pos.y;
            }
            if (tempNormal.z === -1) {
                min.z = pos.z;
            }
        };
        Plane.prototype.updateBoundingSphereRadius = function () {
            this.boundingSphereRadius = Number.MAX_VALUE;
        };
        return Plane;
    }(CANNON.Shape));
    CANNON.Plane = Plane;
    var tempNormal = new CANNON.Vec3();
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var Sphere = /** @class */ (function (_super) {
        __extends(Sphere, _super);
        /**
         * Spherical shape
         *
         * @param radius The radius of the sphere, a non-negative number.
         * @author schteppe / http://github.com/schteppe
         */
        function Sphere(radius) {
            var _this = _super.call(this, {
                type: CANNON.Shape.types.SPHERE
            }) || this;
            _this.radius = radius !== undefined ? radius : 1.0;
            if (_this.radius < 0) {
                throw new Error('The sphere radius cannot be negative.');
            }
            _this.updateBoundingSphereRadius();
            return _this;
        }
        Sphere.prototype.calculateLocalInertia = function (mass, target) {
            if (target === void 0) { target = new CANNON.Vec3(); }
            var I = 2.0 * mass * this.radius * this.radius / 5.0;
            target.x = I;
            target.y = I;
            target.z = I;
            return target;
        };
        Sphere.prototype.volume = function () {
            return 4.0 * Math.PI * this.radius / 3.0;
        };
        Sphere.prototype.updateBoundingSphereRadius = function () {
            this.boundingSphereRadius = this.radius;
        };
        Sphere.prototype.calculateWorldAABB = function (pos, quat, min, max) {
            var r = this.radius;
            var axes = ['x', 'y', 'z'];
            for (var i = 0; i < axes.length; i++) {
                var ax = axes[i];
                min[ax] = pos[ax] - r;
                max[ax] = pos[ax] + r;
            }
        };
        return Sphere;
    }(CANNON.Shape));
    CANNON.Sphere = Sphere;
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var AABB = /** @class */ (function () {
        /**
         *
         * @param options
         *
         * Axis aligned bounding box class.
         */
        function AABB(options) {
            if (options === void 0) { options = {}; }
            this.lowerBound = new CANNON.Vec3();
            if (options.lowerBound) {
                this.lowerBound.copy(options.lowerBound);
            }
            this.upperBound = new CANNON.Vec3();
            if (options.upperBound) {
                this.upperBound.copy(options.upperBound);
            }
        }
        /**
         * Set the AABB bounds from a set of points.
         * @param points An array of Vec3's.
         * @param position
         * @param quaternion
         * @param skinSize
         * @return The self object
         */
        AABB.prototype.setFromPoints = function (points, position, quaternion, skinSize) {
            var l = this.lowerBound, u = this.upperBound, q = quaternion;
            // Set to the first point
            l.copy(points[0]);
            if (q) {
                q.vmult(l, l);
            }
            u.copy(l);
            for (var i = 1; i < points.length; i++) {
                var p = points[i];
                if (q) {
                    q.vmult(p, tmp);
                    p = tmp;
                }
                if (p.x > u.x) {
                    u.x = p.x;
                }
                if (p.x < l.x) {
                    l.x = p.x;
                }
                if (p.y > u.y) {
                    u.y = p.y;
                }
                if (p.y < l.y) {
                    l.y = p.y;
                }
                if (p.z > u.z) {
                    u.z = p.z;
                }
                if (p.z < l.z) {
                    l.z = p.z;
                }
            }
            // Add offset
            if (position) {
                position.vadd(l, l);
                position.vadd(u, u);
            }
            if (skinSize) {
                l.x -= skinSize;
                l.y -= skinSize;
                l.z -= skinSize;
                u.x += skinSize;
                u.y += skinSize;
                u.z += skinSize;
            }
            return this;
        };
        /**
         * Copy bounds from an AABB to this AABB
         * @param aabb Source to copy from
         * @return The this object, for chainability
         */
        AABB.prototype.copy = function (aabb) {
            this.lowerBound.copy(aabb.lowerBound);
            this.upperBound.copy(aabb.upperBound);
            return this;
        };
        /**
         * Clone an AABB
         */
        AABB.prototype.clone = function () {
            return new AABB().copy(this);
        };
        /**
         * Extend this AABB so that it covers the given AABB too.
         * @param aabb
         */
        AABB.prototype.extend = function (aabb) {
            this.lowerBound.x = Math.min(this.lowerBound.x, aabb.lowerBound.x);
            this.upperBound.x = Math.max(this.upperBound.x, aabb.upperBound.x);
            this.lowerBound.y = Math.min(this.lowerBound.y, aabb.lowerBound.y);
            this.upperBound.y = Math.max(this.upperBound.y, aabb.upperBound.y);
            this.lowerBound.z = Math.min(this.lowerBound.z, aabb.lowerBound.z);
            this.upperBound.z = Math.max(this.upperBound.z, aabb.upperBound.z);
        };
        /**
         * Returns true if the given AABB overlaps this AABB.
         * @param aabb
         */
        AABB.prototype.overlaps = function (aabb) {
            var l1 = this.lowerBound, u1 = this.upperBound, l2 = aabb.lowerBound, u2 = aabb.upperBound;
            //      l2        u2
            //      |---------|
            // |--------|
            // l1       u1
            var overlapsX = ((l2.x <= u1.x && u1.x <= u2.x) || (l1.x <= u2.x && u2.x <= u1.x));
            var overlapsY = ((l2.y <= u1.y && u1.y <= u2.y) || (l1.y <= u2.y && u2.y <= u1.y));
            var overlapsZ = ((l2.z <= u1.z && u1.z <= u2.z) || (l1.z <= u2.z && u2.z <= u1.z));
            return overlapsX && overlapsY && overlapsZ;
        };
        /**
         * Mostly for debugging
         */
        AABB.prototype.volume = function () {
            var l = this.lowerBound, u = this.upperBound;
            return (u.x - l.x) * (u.y - l.y) * (u.z - l.z);
        };
        /**
         * Returns true if the given AABB is fully contained in this AABB.
         * @param aabb
         */
        AABB.prototype.contains = function (aabb) {
            var l1 = this.lowerBound, u1 = this.upperBound, l2 = aabb.lowerBound, u2 = aabb.upperBound;
            //      l2        u2
            //      |---------|
            // |---------------|
            // l1              u1
            return ((l1.x <= l2.x && u1.x >= u2.x) &&
                (l1.y <= l2.y && u1.y >= u2.y) &&
                (l1.z <= l2.z && u1.z >= u2.z));
        };
        AABB.prototype.getCorners = function (a, b, c, d, e, f, g, h) {
            var l = this.lowerBound, u = this.upperBound;
            a.copy(l);
            b.set(u.x, l.y, l.z);
            c.set(u.x, u.y, l.z);
            d.set(l.x, u.y, u.z);
            e.set(u.x, l.y, l.z);
            f.set(l.x, u.y, l.z);
            g.set(l.x, l.y, u.z);
            h.copy(u);
        };
        /**
         * Get the representation of an AABB in another frame.
         * @param frame
         * @param target
         * @return The "target" AABB object.
         */
        AABB.prototype.toLocalFrame = function (frame, target) {
            var corners = transformIntoFrame_corners;
            var a = corners[0];
            var b = corners[1];
            var c = corners[2];
            var d = corners[3];
            var e = corners[4];
            var f = corners[5];
            var g = corners[6];
            var h = corners[7];
            // Get corners in current frame
            this.getCorners(a, b, c, d, e, f, g, h);
            // Transform them to new local frame
            for (var i = 0; i !== 8; i++) {
                var corner = corners[i];
                frame.pointToLocal(corner, corner);
            }
            return target.setFromPoints(corners);
        };
        /**
         * Get the representation of an AABB in the global frame.
         * @param frame
         * @param target
         * @return The "target" AABB object.
         */
        AABB.prototype.toWorldFrame = function (frame, target) {
            var corners = transformIntoFrame_corners;
            var a = corners[0];
            var b = corners[1];
            var c = corners[2];
            var d = corners[3];
            var e = corners[4];
            var f = corners[5];
            var g = corners[6];
            var h = corners[7];
            // Get corners in current frame
            this.getCorners(a, b, c, d, e, f, g, h);
            // Transform them to new local frame
            for (var i = 0; i !== 8; i++) {
                var corner = corners[i];
                frame.pointToWorld(corner, corner);
            }
            return target.setFromPoints(corners);
        };
        /**
         * Check if the AABB is hit by a ray.
         */
        AABB.prototype.overlapsRay = function (ray) {
            var t = 0;
            // ray.direction is unit direction vector of ray
            var dirFracX = 1 / ray._direction.x;
            var dirFracY = 1 / ray._direction.y;
            var dirFracZ = 1 / ray._direction.z;
            // this.lowerBound is the corner of AABB with minimal coordinates - left bottom, rt is maximal corner
            var t1 = (this.lowerBound.x - ray.from.x) * dirFracX;
            var t2 = (this.upperBound.x - ray.from.x) * dirFracX;
            var t3 = (this.lowerBound.y - ray.from.y) * dirFracY;
            var t4 = (this.upperBound.y - ray.from.y) * dirFracY;
            var t5 = (this.lowerBound.z - ray.from.z) * dirFracZ;
            var t6 = (this.upperBound.z - ray.from.z) * dirFracZ;
            // var tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)));
            // var tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)));
            var tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6));
            var tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6));
            // if tmax < 0, ray (line) is intersecting AABB, but whole AABB is behing us
            if (tmax < 0) {
                //t = tmax;
                return false;
            }
            // if tmin > tmax, ray doesn't intersect AABB
            if (tmin > tmax) {
                //t = tmax;
                return false;
            }
            return true;
        };
        return AABB;
    }());
    CANNON.AABB = AABB;
    var tmp = new CANNON.Vec3();
    var transformIntoFrame_corners = [
        new CANNON.Vec3(),
        new CANNON.Vec3(),
        new CANNON.Vec3(),
        new CANNON.Vec3(),
        new CANNON.Vec3(),
        new CANNON.Vec3(),
        new CANNON.Vec3(),
        new CANNON.Vec3()
    ];
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var Trimesh = /** @class */ (function (_super) {
        __extends(Trimesh, _super);
        /**
         * @param vertices
         * @param indices
         *
         * @example
         *     // How to make a mesh with a single triangle
         *     var vertices = [
         *         0, 0, 0, // vertex 0
         *         1, 0, 0, // vertex 1
         *         0, 1, 0  // vertex 2
         *     ];
         *     var indices = [
         *         0, 1, 2  // triangle 0
         *     ];
         *     var trimeshShape = new Trimesh(vertices, indices);
         */
        function Trimesh(vertices, indices) {
            var _this = _super.call(this, {
                type: CANNON.Shape.types.TRIMESH
            }) || this;
            _this.vertices = new Float32Array(vertices);
            /**
             * Array of integers, indicating which vertices each triangle consists of. The length of this array is thus 3 times the number of triangles.
             */
            _this.indices = new Int16Array(indices);
            _this.normals = new Float32Array(indices.length);
            _this.aabb = new CANNON.AABB();
            _this.edges = null;
            _this.scale = new CANNON.Vec3(1, 1, 1);
            _this.tree = new CANNON.Octree();
            _this.updateEdges();
            _this.updateNormals();
            _this.updateAABB();
            _this.updateBoundingSphereRadius();
            _this.updateTree();
            return _this;
        }
        Trimesh.prototype.updateTree = function () {
            var tree = this.tree;
            tree.reset();
            tree.aabb.copy(this.aabb);
            var scale = this.scale; // The local mesh AABB is scaled, but the octree AABB should be unscaled
            tree.aabb.lowerBound.x *= 1 / scale.x;
            tree.aabb.lowerBound.y *= 1 / scale.y;
            tree.aabb.lowerBound.z *= 1 / scale.z;
            tree.aabb.upperBound.x *= 1 / scale.x;
            tree.aabb.upperBound.y *= 1 / scale.y;
            tree.aabb.upperBound.z *= 1 / scale.z;
            // Insert all triangles
            var triangleAABB = new CANNON.AABB();
            var a = new CANNON.Vec3();
            var b = new CANNON.Vec3();
            var c = new CANNON.Vec3();
            var points = [a, b, c];
            for (var i = 0; i < this.indices.length / 3; i++) {
                //this.getTriangleVertices(i, a, b, c);
                // Get unscaled triangle verts
                var i3 = i * 3;
                this._getUnscaledVertex(this.indices[i3], a);
                this._getUnscaledVertex(this.indices[i3 + 1], b);
                this._getUnscaledVertex(this.indices[i3 + 2], c);
                triangleAABB.setFromPoints(points);
                tree.insert(triangleAABB, i);
            }
            tree.removeEmptyNodes();
        };
        /**
         * Get triangles in a local AABB from the trimesh.
         *
         * @param aabb
         * @param result An array of integers, referencing the queried triangles.
         */
        Trimesh.prototype.getTrianglesInAABB = function (aabb, result) {
            unscaledAABB.copy(aabb);
            // Scale it to local
            var scale = this.scale;
            var isx = scale.x;
            var isy = scale.y;
            var isz = scale.z;
            var l = unscaledAABB.lowerBound;
            var u = unscaledAABB.upperBound;
            l.x /= isx;
            l.y /= isy;
            l.z /= isz;
            u.x /= isx;
            u.y /= isy;
            u.z /= isz;
            return this.tree.aabbQuery(unscaledAABB, result);
        };
        /**
         * @param scale
         */
        Trimesh.prototype.setScale = function (scale) {
            // var wasUniform = this.scale.x === this.scale.y === this.scale.z;// 等价下面代码?
            var wasUniform = this.scale.x === this.scale.y && this.scale.y === this.scale.z; //?
            // var isUniform = scale.x === scale.y === scale.z;// 等价下面代码?
            var isUniform = scale.x === scale.y && scale.y === scale.z; //?
            if (!(wasUniform && isUniform)) {
                // Non-uniform scaling. Need to update normals.
                this.updateNormals();
            }
            this.scale.copy(scale);
            this.updateAABB();
            this.updateBoundingSphereRadius();
        };
        /**
         * Compute the normals of the faces. Will save in the .normals array.
         */
        Trimesh.prototype.updateNormals = function () {
            var n = computeNormals_n;
            // Generate normals
            var normals = this.normals;
            for (var i = 0; i < this.indices.length / 3; i++) {
                var i3 = i * 3;
                var a = this.indices[i3], b = this.indices[i3 + 1], c = this.indices[i3 + 2];
                this.getVertex(a, va);
                this.getVertex(b, vb);
                this.getVertex(c, vc);
                Trimesh.computeNormal(vb, va, vc, n);
                normals[i3] = n.x;
                normals[i3 + 1] = n.y;
                normals[i3 + 2] = n.z;
            }
        };
        /**
         * Update the .edges property
         */
        Trimesh.prototype.updateEdges = function () {
            var edges = {};
            var add = function (indexA, indexB) {
                var key = a < b ? a + '_' + b : b + '_' + a;
                edges[key] = true;
            };
            for (var i = 0; i < this.indices.length / 3; i++) {
                var i3 = i * 3;
                var a = this.indices[i3], b = this.indices[i3 + 1], c = this.indices[i3 + 2];
                add(a, b);
                add(b, c);
                add(c, a);
            }
            var keys = Object.keys(edges);
            this.edges = new Int16Array(keys.length * 2);
            for (var i = 0; i < keys.length; i++) {
                var indices = keys[i].split('_');
                this.edges[2 * i] = parseInt(indices[0], 10);
                this.edges[2 * i + 1] = parseInt(indices[1], 10);
            }
        };
        /**
         * Get an edge vertex
         *
         * @param edgeIndex
         * @param firstOrSecond 0 or 1, depending on which one of the vertices you need.
         * @param vertexStore Where to store the result
         */
        Trimesh.prototype.getEdgeVertex = function (edgeIndex, firstOrSecond, vertexStore) {
            var vertexIndex = this.edges[edgeIndex * 2 + (firstOrSecond ? 1 : 0)];
            this.getVertex(vertexIndex, vertexStore);
        };
        /**
         * Get a vector along an edge.
         *
         * @param edgeIndex
         * @param vectorStore
         */
        Trimesh.prototype.getEdgeVector = function (edgeIndex, vectorStore) {
            var va = getEdgeVector_va;
            var vb = getEdgeVector_vb;
            this.getEdgeVertex(edgeIndex, 0, va);
            this.getEdgeVertex(edgeIndex, 1, vb);
            vb.vsub(va, vectorStore);
        };
        /**
         * Get face normal given 3 vertices
         *
         * @param va
         * @param vb
         * @param vc
         * @param target
         */
        Trimesh.computeNormal = function (va, vb, vc, target) {
            vb.vsub(va, ab);
            vc.vsub(vb, cb);
            cb.cross(ab, target);
            if (!target.isZero()) {
                target.normalize();
            }
        };
        /**
         * Get vertex i.
         *
         * @param i
         * @param out
         * @return The "out" vector object
         */
        Trimesh.prototype.getVertex = function (i, out) {
            var scale = this.scale;
            this._getUnscaledVertex(i, out);
            out.x *= scale.x;
            out.y *= scale.y;
            out.z *= scale.z;
            return out;
        };
        /**
         * Get raw vertex i
         *
         * @param i
         * @param out
         * @return The "out" vector object
         */
        Trimesh.prototype._getUnscaledVertex = function (i, out) {
            var i3 = i * 3;
            var vertices = this.vertices;
            return out.set(vertices[i3], vertices[i3 + 1], vertices[i3 + 2]);
        };
        /**
         * Get a vertex from the trimesh,transformed by the given position and quaternion.
         *
         * @param i
         * @param pos
         * @param quat
         * @param out
         * @return The "out" vector object
         */
        Trimesh.prototype.getWorldVertex = function (i, pos, quat, out) {
            this.getVertex(i, out);
            CANNON.Transform.pointToWorldFrame(pos, quat, out, out);
            return out;
        };
        /**
         * Get the three vertices for triangle i.
         *
         * @param i
         * @param a
         * @param b
         * @param c
         */
        Trimesh.prototype.getTriangleVertices = function (i, a, b, c) {
            var i3 = i * 3;
            this.getVertex(this.indices[i3], a);
            this.getVertex(this.indices[i3 + 1], b);
            this.getVertex(this.indices[i3 + 2], c);
        };
        /**
         * Compute the normal of triangle i.
         *
         * @param i
         * @param target
         * @return The "target" vector object
         */
        Trimesh.prototype.getNormal = function (i, target) {
            var i3 = i * 3;
            return target.set(this.normals[i3], this.normals[i3 + 1], this.normals[i3 + 2]);
        };
        /**
         *
         * @param mass
         * @param target
         * @return The "target" vector object
         */
        Trimesh.prototype.calculateLocalInertia = function (mass, target) {
            // Approximate with box inertia
            // Exact inertia calculation is overkill, but see http://geometrictools.com/Documentation/PolyhedralMassProperties.pdf for the correct way to do it
            this.computeLocalAABB(cli_aabb);
            var x = cli_aabb.upperBound.x - cli_aabb.lowerBound.x, y = cli_aabb.upperBound.y - cli_aabb.lowerBound.y, z = cli_aabb.upperBound.z - cli_aabb.lowerBound.z;
            return target.set(1.0 / 12.0 * mass * (2 * y * 2 * y + 2 * z * 2 * z), 1.0 / 12.0 * mass * (2 * x * 2 * x + 2 * z * 2 * z), 1.0 / 12.0 * mass * (2 * y * 2 * y + 2 * x * 2 * x));
        };
        /**
         * Compute the local AABB for the trimesh
         *
         * @param aabb
         */
        Trimesh.prototype.computeLocalAABB = function (aabb) {
            var l = aabb.lowerBound, u = aabb.upperBound, n = this.vertices.length, vertices = this.vertices, v = computeLocalAABB_worldVert;
            this.getVertex(0, v);
            l.copy(v);
            u.copy(v);
            for (var i = 0; i !== n; i++) {
                this.getVertex(i, v);
                if (v.x < l.x) {
                    l.x = v.x;
                }
                else if (v.x > u.x) {
                    u.x = v.x;
                }
                if (v.y < l.y) {
                    l.y = v.y;
                }
                else if (v.y > u.y) {
                    u.y = v.y;
                }
                if (v.z < l.z) {
                    l.z = v.z;
                }
                else if (v.z > u.z) {
                    u.z = v.z;
                }
            }
        };
        /**
         * Update the .aabb property
         */
        Trimesh.prototype.updateAABB = function () {
            this.computeLocalAABB(this.aabb);
        };
        /**
         * Will update the .boundingSphereRadius property
         */
        Trimesh.prototype.updateBoundingSphereRadius = function () {
            // Assume points are distributed with local (0,0,0) as center
            var max2 = 0;
            var vertices = this.vertices;
            var v = new CANNON.Vec3();
            for (var i = 0, N = vertices.length / 3; i !== N; i++) {
                this.getVertex(i, v);
                var norm2 = v.norm2();
                if (norm2 > max2) {
                    max2 = norm2;
                }
            }
            this.boundingSphereRadius = Math.sqrt(max2);
        };
        Trimesh.prototype.calculateWorldAABB = function (pos, quat, min, max) {
            /*
            var n = this.vertices.length / 3,
                verts = this.vertices;
            var minx,miny,minz,maxx,maxy,maxz;
        
            var v = tempWorldVertex;
            for(var i=0; i<n; i++){
                this.getVertex(i, v);
                quat.vmult(v, v);
                pos.vadd(v, v);
                if (v.x < minx || minx===undefined){
                    minx = v.x;
                } else if(v.x > maxx || maxx===undefined){
                    maxx = v.x;
                }
        
                if (v.y < miny || miny===undefined){
                    miny = v.y;
                } else if(v.y > maxy || maxy===undefined){
                    maxy = v.y;
                }
        
                if (v.z < minz || minz===undefined){
                    minz = v.z;
                } else if(v.z > maxz || maxz===undefined){
                    maxz = v.z;
                }
            }
            min.set(minx,miny,minz);
            max.set(maxx,maxy,maxz);
            */
            // Faster approximation using local AABB
            var frame = calculateWorldAABB_frame;
            var result = calculateWorldAABB_aabb;
            frame.position = pos;
            frame.quaternion = quat;
            this.aabb.toWorldFrame(frame, result);
            min.copy(result.lowerBound);
            max.copy(result.upperBound);
        };
        ;
        /**
         * Get approximate volume
         */
        Trimesh.prototype.volume = function () {
            return 4.0 * Math.PI * this.boundingSphereRadius / 3.0;
        };
        /**
         * Create a Trimesh instance, shaped as a torus.
         *
         * @param radius
         * @param tube
         * @param radialSegments
         * @param tubularSegments
         * @param arc
         *
         * @return A torus
         */
        Trimesh.createTorus = function (radius, tube, radialSegments, tubularSegments, arc) {
            radius = radius || 1;
            tube = tube || 0.5;
            radialSegments = radialSegments || 8;
            tubularSegments = tubularSegments || 6;
            arc = arc || Math.PI * 2;
            var vertices = [];
            var indices = [];
            for (var j = 0; j <= radialSegments; j++) {
                for (var i = 0; i <= tubularSegments; i++) {
                    var u = i / tubularSegments * arc;
                    var v = j / radialSegments * Math.PI * 2;
                    var x = (radius + tube * Math.cos(v)) * Math.cos(u);
                    var y = (radius + tube * Math.cos(v)) * Math.sin(u);
                    var z = tube * Math.sin(v);
                    vertices.push(x, y, z);
                }
            }
            for (var j = 1; j <= radialSegments; j++) {
                for (var i = 1; i <= tubularSegments; i++) {
                    var a = (tubularSegments + 1) * j + i - 1;
                    var b = (tubularSegments + 1) * (j - 1) + i - 1;
                    var c = (tubularSegments + 1) * (j - 1) + i;
                    var d = (tubularSegments + 1) * j + i;
                    indices.push(a, b, d);
                    indices.push(b, c, d);
                }
            }
            return new Trimesh(vertices, indices);
        };
        ;
        return Trimesh;
    }(CANNON.Shape));
    CANNON.Trimesh = Trimesh;
    var computeNormals_n = new CANNON.Vec3();
    var unscaledAABB = new CANNON.AABB();
    var getEdgeVector_va = new CANNON.Vec3();
    var getEdgeVector_vb = new CANNON.Vec3();
    var cb = new CANNON.Vec3();
    var ab = new CANNON.Vec3();
    var va = new CANNON.Vec3();
    var vb = new CANNON.Vec3();
    var vc = new CANNON.Vec3();
    var cli_aabb = new CANNON.AABB();
    var computeLocalAABB_worldVert = new CANNON.Vec3();
    var tempWorldVertex = new CANNON.Vec3();
    var calculateWorldAABB_frame = new CANNON.Transform();
    var calculateWorldAABB_aabb = new CANNON.AABB();
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var OctreeNode = /** @class */ (function () {
        /**
         *
         * @param options
         */
        function OctreeNode(options) {
            if (options === void 0) { options = {}; }
            this.root = options.root || null;
            this.aabb = options.aabb ? options.aabb.clone() : new CANNON.AABB();
            this.data = [];
            this.children = [];
        }
        OctreeNode.prototype.reset = function (aabb, options) {
            this.children.length = this.data.length = 0;
        };
        /**
         * Insert data into this node
         *
         * @param aabb
         * @param elementData
         * @return True if successful, otherwise false
         */
        OctreeNode.prototype.insert = function (aabb, elementData, level) {
            if (level === void 0) { level = 0; }
            var nodeData = this.data;
            // Ignore objects that do not belong in this node
            if (!this.aabb.contains(aabb)) {
                return false; // object cannot be added
            }
            var children = this.children;
            if (level < (this.maxDepth || this.root.maxDepth)) {
                // Subdivide if there are no children yet
                var subdivided = false;
                if (!children.length) {
                    this.subdivide();
                    subdivided = true;
                }
                // add to whichever node will accept it
                for (var i = 0; i !== 8; i++) {
                    if (children[i].insert(aabb, elementData, level + 1)) {
                        return true;
                    }
                }
                if (subdivided) {
                    // No children accepted! Might as well just remove em since they contain none
                    children.length = 0;
                }
            }
            // Too deep, or children didnt want it. add it in current node
            nodeData.push(elementData);
            return true;
        };
        /**
         * Create 8 equally sized children nodes and put them in the .children array.
         */
        OctreeNode.prototype.subdivide = function () {
            var aabb = this.aabb;
            var l = aabb.lowerBound;
            var u = aabb.upperBound;
            var children = this.children;
            children.push(new OctreeNode({ aabb: new CANNON.AABB({ lowerBound: new CANNON.Vec3(0, 0, 0) }) }), new OctreeNode({ aabb: new CANNON.AABB({ lowerBound: new CANNON.Vec3(1, 0, 0) }) }), new OctreeNode({ aabb: new CANNON.AABB({ lowerBound: new CANNON.Vec3(1, 1, 0) }) }), new OctreeNode({ aabb: new CANNON.AABB({ lowerBound: new CANNON.Vec3(1, 1, 1) }) }), new OctreeNode({ aabb: new CANNON.AABB({ lowerBound: new CANNON.Vec3(0, 1, 1) }) }), new OctreeNode({ aabb: new CANNON.AABB({ lowerBound: new CANNON.Vec3(0, 0, 1) }) }), new OctreeNode({ aabb: new CANNON.AABB({ lowerBound: new CANNON.Vec3(1, 0, 1) }) }), new OctreeNode({ aabb: new CANNON.AABB({ lowerBound: new CANNON.Vec3(0, 1, 0) }) }));
            u.vsub(l, halfDiagonal);
            halfDiagonal.scale(0.5, halfDiagonal);
            var root = this.root || this;
            for (var i = 0; i !== 8; i++) {
                var child = children[i];
                // Set current node as root
                child.root = root;
                // Compute bounds
                var lowerBound = child.aabb.lowerBound;
                lowerBound.x *= halfDiagonal.x;
                lowerBound.y *= halfDiagonal.y;
                lowerBound.z *= halfDiagonal.z;
                lowerBound.vadd(l, lowerBound);
                // Upper bound is always lower bound + halfDiagonal
                lowerBound.vadd(halfDiagonal, child.aabb.upperBound);
            }
        };
        /**
         * Get all data, potentially within an AABB
         *
         * @param aabb
         * @param result
         * @return The "result" object
         */
        OctreeNode.prototype.aabbQuery = function (aabb, result) {
            var nodeData = this.data;
            // abort if the range does not intersect this node
            // if (!this.aabb.overlaps(aabb)){
            //     return result;
            // }
            // Add objects at this level
            // Array.prototype.push.apply(result, nodeData);
            // Add child data
            // @todo unwrap recursion into a queue / loop, that's faster in JS
            var children = this.children;
            // for (var i = 0, N = this.children.length; i !== N; i++) {
            //     children[i].aabbQuery(aabb, result);
            // }
            var queue = [this];
            while (queue.length) {
                var node = queue.pop();
                if (node.aabb.overlaps(aabb)) {
                    Array.prototype.push.apply(result, node.data);
                }
                Array.prototype.push.apply(queue, node.children);
            }
            return result;
        };
        /**
         * Get all data, potentially intersected by a ray.
         *
         * @param ray
         * @param treeTransform
         * @param result
         * @return The "result" object
         */
        OctreeNode.prototype.rayQuery = function (ray, treeTransform, result) {
            // Use aabb query for now.
            // @todo implement real ray query which needs less lookups
            ray.getAABB(tmpAABB);
            tmpAABB.toLocalFrame(treeTransform, tmpAABB);
            this.aabbQuery(tmpAABB, result);
            return result;
        };
        OctreeNode.prototype.removeEmptyNodes = function () {
            var queue = [this];
            while (queue.length) {
                var node = queue.pop();
                for (var i = node.children.length - 1; i >= 0; i--) {
                    if (!node.children[i].data.length) {
                        node.children.splice(i, 1);
                    }
                }
                Array.prototype.push.apply(queue, node.children);
            }
        };
        return OctreeNode;
    }());
    CANNON.OctreeNode = OctreeNode;
    var Octree = /** @class */ (function (_super) {
        __extends(Octree, _super);
        /**
         * @class Octree
         * @param {AABB} aabb The total AABB of the tree
         * @param {object} [options]
         * @param {number} [options.maxDepth=8]
         * @extends OctreeNode
         */
        function Octree(aabb, options) {
            if (options === void 0) { options = {}; }
            var _this = _super.call(this, options) || this;
            options.root = null;
            options.aabb = aabb;
            _this.maxDepth = typeof (options.maxDepth) !== 'undefined' ? options.maxDepth : 8;
            return _this;
        }
        return Octree;
    }(OctreeNode));
    CANNON.Octree = Octree;
    var halfDiagonal = new CANNON.Vec3();
    var tmpAABB = new CANNON.AABB();
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var ArrayCollisionMatrix = /** @class */ (function () {
        /**
         * Collision "matrix". It's actually a triangular-shaped array of whether two bodies are touching this step, for reference next step
         */
        function ArrayCollisionMatrix() {
            this.matrix = [];
        }
        /**
         * Get an element
         *
         * @param i
         * @param j
         */
        ArrayCollisionMatrix.prototype.get = function (i0, j0) {
            var i = i0.index;
            var j = j0.index;
            if (j > i) {
                var temp = j;
                j = i;
                i = temp;
            }
            return this.matrix[(i * (i + 1) >> 1) + j - 1];
        };
        /**
         * Set an element
         *
         * @param i0
         * @param j0
         * @param value
         */
        ArrayCollisionMatrix.prototype.set = function (i0, j0, value) {
            var i = i0.index;
            var j = j0.index;
            if (j > i) {
                var temp = j;
                j = i;
                i = temp;
            }
            this.matrix[(i * (i + 1) >> 1) + j - 1] = value ? 1 : 0;
        };
        /**
         * Sets all elements to zero
         */
        ArrayCollisionMatrix.prototype.reset = function () {
            for (var i = 0, l = this.matrix.length; i !== l; i++) {
                this.matrix[i] = 0;
            }
        };
        /**
         * Sets the max number of objects
         */
        ArrayCollisionMatrix.prototype.setNumObjects = function (n) {
            this.matrix.length = n * (n - 1) >> 1;
        };
        return ArrayCollisionMatrix;
    }());
    CANNON.ArrayCollisionMatrix = ArrayCollisionMatrix;
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var ObjectCollisionMatrix = /** @class */ (function () {
        /**
         * Records what objects are colliding with each other
         */
        function ObjectCollisionMatrix() {
            /**
             * The matrix storage
             */
            this.matrix = {};
            this.matrix = {};
        }
        ObjectCollisionMatrix.prototype.get = function (i0, j0) {
            var i = i0.id;
            var j = j0.id;
            if (j > i) {
                var temp = j;
                j = i;
                i = temp;
            }
            return i + '-' + j in this.matrix;
        };
        ObjectCollisionMatrix.prototype.set = function (i0, j0, value) {
            var i = i0.id;
            var j = j0.id;
            if (j > i) {
                var temp = j;
                j = i;
                i = temp;
            }
            if (value) {
                this.matrix[i + '-' + j] = true;
            }
            else {
                delete this.matrix[i + '-' + j];
            }
        };
        /**
         * Empty the matrix
         */
        ObjectCollisionMatrix.prototype.reset = function () {
            this.matrix = {};
        };
        /**
         * Set max number of objects
         *
         * @param n
         */
        ObjectCollisionMatrix.prototype.setNumObjects = function (n) {
        };
        return ObjectCollisionMatrix;
    }());
    CANNON.ObjectCollisionMatrix = ObjectCollisionMatrix;
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var OverlapKeeper = /** @class */ (function () {
        function OverlapKeeper() {
            this.current = [];
            this.previous = [];
            this.current = [];
            this.previous = [];
        }
        OverlapKeeper.prototype.getKey = function (i, j) {
            if (j < i) {
                var temp = j;
                j = i;
                i = temp;
            }
            return (i << 16) | j;
        };
        OverlapKeeper.prototype.set = function (i, j) {
            // Insertion sort. This way the diff will have linear complexity.
            var key = this.getKey(i, j);
            var current = this.current;
            var index = 0;
            while (key > current[index]) {
                index++;
            }
            if (key === current[index]) {
                return; // Pair was already added
            }
            for (var j = current.length - 1; j >= index; j--) {
                current[j + 1] = current[j];
            }
            current[index] = key;
        };
        OverlapKeeper.prototype.tick = function () {
            var tmp = this.current;
            this.current = this.previous;
            this.previous = tmp;
            this.current.length = 0;
        };
        OverlapKeeper.prototype.unpackAndPush = function (array, key) {
            array.push((key & 0xFFFF0000) >> 16, key & 0x0000FFFF);
        };
        OverlapKeeper.prototype.getDiff = function (additions, removals) {
            var a = this.current;
            var b = this.previous;
            var al = a.length;
            var bl = b.length;
            var j = 0;
            for (var i = 0; i < al; i++) {
                var found = false;
                var keyA = a[i];
                while (keyA > b[j]) {
                    j++;
                }
                found = keyA === b[j];
                if (!found) {
                    this.unpackAndPush(additions, keyA);
                }
            }
            j = 0;
            for (var i = 0; i < bl; i++) {
                var found = false;
                var keyB = b[i];
                while (keyB > a[j]) {
                    j++;
                }
                found = a[j] === keyB;
                if (!found) {
                    this.unpackAndPush(removals, keyB);
                }
            }
        };
        return OverlapKeeper;
    }());
    CANNON.OverlapKeeper = OverlapKeeper;
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var RaycastResult = /** @class */ (function () {
        /**
         * Storage for Ray casting data.
         */
        function RaycastResult() {
            this.rayFromWorld = new CANNON.Vec3();
            this.rayToWorld = new CANNON.Vec3();
            this.hitNormalWorld = new CANNON.Vec3();
            this.hitPointWorld = new CANNON.Vec3();
            this.hasHit = false;
            this.shape = null;
            this.body = null;
            /**
             * The index of the hit triangle, if the hit shape was a trimesh.
             */
            this.hitFaceIndex = -1;
            /**
             * Distance to the hit. Will be set to -1 if there was no hit.
             */
            this.distance = -1;
            /**
             * If the ray should stop traversing the bodies.
             */
            this._shouldStop = false;
        }
        /**
         * Reset all result data.
         */
        RaycastResult.prototype.reset = function () {
            this.rayFromWorld.setZero();
            this.rayToWorld.setZero();
            this.hitNormalWorld.setZero();
            this.hitPointWorld.setZero();
            this.hasHit = false;
            this.shape = null;
            this.body = null;
            this.hitFaceIndex = -1;
            this.distance = -1;
            this._shouldStop = false;
        };
        RaycastResult.prototype.abort = function () {
            this._shouldStop = true;
        };
        RaycastResult.prototype.set = function (rayFromWorld, rayToWorld, hitNormalWorld, hitPointWorld, shape, body, distance) {
            this.rayFromWorld.copy(rayFromWorld);
            this.rayToWorld.copy(rayToWorld);
            this.hitNormalWorld.copy(hitNormalWorld);
            this.hitPointWorld.copy(hitPointWorld);
            this.shape = shape;
            this.body = body;
            this.distance = distance;
        };
        return RaycastResult;
    }());
    CANNON.RaycastResult = RaycastResult;
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var Broadphase = /** @class */ (function () {
        /**
         * Base class for broadphase implementations
         *
         * @author schteppe
         */
        function Broadphase() {
            this.world = null;
            this.useBoundingBoxes = false;
            this.dirty = true;
        }
        /**
         * Get the collision pairs from the world
         *
         * @param world The world to search in
         * @param p1 Empty array to be filled with body objects
         * @param p2 Empty array to be filled with body objects
         */
        Broadphase.prototype.collisionPairs = function (world, p1, p2) {
            throw new Error("collisionPairs not implemented for this BroadPhase class!");
        };
        /**
         * Check if a body pair needs to be intersection tested at all.
         *
         * @param bodyA
         * @param bodyB
         */
        Broadphase.prototype.needBroadphaseCollision = function (bodyA, bodyB) {
            // Check collision filter masks
            if ((bodyA.collisionFilterGroup & bodyB.collisionFilterMask) === 0 || (bodyB.collisionFilterGroup & bodyA.collisionFilterMask) === 0) {
                return false;
            }
            // Check types
            if (((bodyA.type & CANNON.Body.STATIC) !== 0 || bodyA.sleepState === CANNON.Body.SLEEPING) &&
                ((bodyB.type & CANNON.Body.STATIC) !== 0 || bodyB.sleepState === CANNON.Body.SLEEPING)) {
                // Both bodies are static or sleeping. Skip.
                return false;
            }
            return true;
        };
        /**
         * Check if the bounding volumes of two bodies intersect.
          *
          * @param bodyA
          * @param bodyB
          * @param pairs1
          * @param pairs2
          */
        Broadphase.prototype.intersectionTest = function (bodyA, bodyB, pairs1, pairs2) {
            if (this.useBoundingBoxes) {
                this.doBoundingBoxBroadphase(bodyA, bodyB, pairs1, pairs2);
            }
            else {
                this.doBoundingSphereBroadphase(bodyA, bodyB, pairs1, pairs2);
            }
        };
        /**
         * Check if the bounding spheres of two bodies are intersecting.
         * @param bodyA
         * @param bodyB
         * @param pairs1 bodyA is appended to this array if intersection
         * @param pairs2 bodyB is appended to this array if intersection
         */
        Broadphase.prototype.doBoundingSphereBroadphase = function (bodyA, bodyB, pairs1, pairs2) {
            var r = Broadphase_collisionPairs_r;
            bodyB.position.vsub(bodyA.position, r);
            var boundingRadiusSum2 = Math.pow(bodyA.boundingRadius + bodyB.boundingRadius, 2);
            var norm2 = r.norm2();
            if (norm2 < boundingRadiusSum2) {
                pairs1.push(bodyA);
                pairs2.push(bodyB);
            }
        };
        /**
         * Check if the bounding boxes of two bodies are intersecting.
         * @param bodyA
         * @param bodyB
         * @param pairs1
         * @param pairs2
         */
        Broadphase.prototype.doBoundingBoxBroadphase = function (bodyA, bodyB, pairs1, pairs2) {
            if (bodyA.aabbNeedsUpdate) {
                bodyA.computeAABB();
            }
            if (bodyB.aabbNeedsUpdate) {
                bodyB.computeAABB();
            }
            // Check AABB / AABB
            if (bodyA.aabb.overlaps(bodyB.aabb)) {
                pairs1.push(bodyA);
                pairs2.push(bodyB);
            }
        };
        /**
         * Removes duplicate pairs from the pair arrays.
         * @param pairs1
         * @param pairs2
         */
        Broadphase.prototype.makePairsUnique = function (pairs1, pairs2) {
            var t = Broadphase_makePairsUnique_temp, p1 = Broadphase_makePairsUnique_p1, p2 = Broadphase_makePairsUnique_p2, N = pairs1.length;
            for (var i = 0; i !== N; i++) {
                p1[i] = pairs1[i];
                p2[i] = pairs2[i];
            }
            pairs1.length = 0;
            pairs2.length = 0;
            for (var i = 0; i !== N; i++) {
                var id1 = p1[i].id, id2 = p2[i].id;
                var key = id1 < id2 ? id1 + "," + id2 : id2 + "," + id1;
                t[key] = i;
                t.keys.push(key);
            }
            for (var i = 0; i !== t.keys.length; i++) {
                var key = t.keys.pop();
                var pairIndex = t[key];
                pairs1.push(p1[pairIndex]);
                pairs2.push(p2[pairIndex]);
                delete t[key];
            }
        };
        /**
         * To be implemented by subcasses
         * @method setWorld
         * @param {World} world
         */
        Broadphase.prototype.setWorld = function (world) {
        };
        /**
         * Check if the bounding spheres of two bodies overlap.
         * @param bodyA
         * @param bodyB
         */
        Broadphase.boundingSphereCheck = function (bodyA, bodyB) {
            var dist = bsc_dist;
            bodyA.position.vsub(bodyB.position, dist);
            return Math.pow(bodyA.shape.boundingSphereRadius + bodyB.shape.boundingSphereRadius, 2) > dist.norm2();
        };
        /**
         * Returns all the bodies within the AABB.
         *
         * @param world
         * @param aabb
         * @param result An array to store resulting bodies in.
         */
        Broadphase.prototype.aabbQuery = function (world, aabb, result) {
            console.warn('.aabbQuery is not implemented in this Broadphase subclass.');
            return [];
        };
        return Broadphase;
    }());
    CANNON.Broadphase = Broadphase;
    var Broadphase_collisionPairs_r = new CANNON.Vec3(); // Temp objects
    var Broadphase_collisionPairs_normal = new CANNON.Vec3();
    var Broadphase_collisionPairs_quat = new CANNON.Quaternion();
    var Broadphase_collisionPairs_relpos = new CANNON.Vec3();
    var Broadphase_makePairsUnique_temp = { keys: [] };
    var Broadphase_makePairsUnique_p1 = [];
    var Broadphase_makePairsUnique_p2 = [];
    var bsc_dist = new CANNON.Vec3();
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var GridBroadphase = /** @class */ (function (_super) {
        __extends(GridBroadphase, _super);
        /**
         * Axis aligned uniform grid broadphase.
         *
         * @param aabbMin
         * @param aabbMax
         * @param nx Number of boxes along x
         * @param ny Number of boxes along y
         * @param nz Number of boxes along z
         *
         * @todo Needs support for more than just planes and spheres.
         */
        function GridBroadphase(aabbMin, aabbMax, nx, ny, nz) {
            var _this = _super.call(this) || this;
            _this.nx = nx || 10;
            _this.ny = ny || 10;
            _this.nz = nz || 10;
            _this.aabbMin = aabbMin || new CANNON.Vec3(100, 100, 100);
            _this.aabbMax = aabbMax || new CANNON.Vec3(-100, -100, -100);
            var nbins = _this.nx * _this.ny * _this.nz;
            if (nbins <= 0) {
                throw "GridBroadphase: Each dimension's n must be >0";
            }
            _this.bins = [];
            _this.binLengths = []; //Rather than continually resizing arrays (thrashing the memory), just record length and allow them to grow
            _this.bins.length = nbins;
            _this.binLengths.length = nbins;
            for (var i = 0; i < nbins; i++) {
                _this.bins[i] = [];
                _this.binLengths[i] = 0;
            }
            return _this;
        }
        /**
         * Get all the collision pairs in the physics world
         *
         * @param world
         * @param pairs1
         * @param pairs2
         */
        GridBroadphase.prototype.collisionPairs = function (world, pairs1, pairs2) {
            var N = world.numObjects(), bodies = world.bodies;
            var max = this.aabbMax, min = this.aabbMin, nx = this.nx, ny = this.ny, nz = this.nz;
            var xstep = ny * nz;
            var ystep = nz;
            var zstep = 1;
            var xmax = max.x, ymax = max.y, zmax = max.z, xmin = min.x, ymin = min.y, zmin = min.z;
            var xmult = nx / (xmax - xmin), ymult = ny / (ymax - ymin), zmult = nz / (zmax - zmin);
            var binsizeX = (xmax - xmin) / nx, binsizeY = (ymax - ymin) / ny, binsizeZ = (zmax - zmin) / nz;
            var binRadius = Math.sqrt(binsizeX * binsizeX + binsizeY * binsizeY + binsizeZ * binsizeZ) * 0.5;
            var types = CANNON.Shape.types;
            var SPHERE = types.SPHERE, PLANE = types.PLANE, BOX = types.BOX, COMPOUND = types.COMPOUND, CONVEXPOLYHEDRON = types.CONVEXPOLYHEDRON;
            var bins = this.bins, binLengths = this.binLengths, Nbins = this.bins.length;
            // Reset bins
            for (var i = 0; i !== Nbins; i++) {
                binLengths[i] = 0;
            }
            var ceil = Math.ceil;
            // var min = Math.min;
            // var max = Math.max;
            function addBoxToBins(x0, y0, z0, x1, y1, z1, bi) {
                var xoff0 = ((x0 - xmin) * xmult) | 0, yoff0 = ((y0 - ymin) * ymult) | 0, zoff0 = ((z0 - zmin) * zmult) | 0, xoff1 = ceil((x1 - xmin) * xmult), yoff1 = ceil((y1 - ymin) * ymult), zoff1 = ceil((z1 - zmin) * zmult);
                if (xoff0 < 0) {
                    xoff0 = 0;
                }
                else if (xoff0 >= nx) {
                    xoff0 = nx - 1;
                }
                if (yoff0 < 0) {
                    yoff0 = 0;
                }
                else if (yoff0 >= ny) {
                    yoff0 = ny - 1;
                }
                if (zoff0 < 0) {
                    zoff0 = 0;
                }
                else if (zoff0 >= nz) {
                    zoff0 = nz - 1;
                }
                if (xoff1 < 0) {
                    xoff1 = 0;
                }
                else if (xoff1 >= nx) {
                    xoff1 = nx - 1;
                }
                if (yoff1 < 0) {
                    yoff1 = 0;
                }
                else if (yoff1 >= ny) {
                    yoff1 = ny - 1;
                }
                if (zoff1 < 0) {
                    zoff1 = 0;
                }
                else if (zoff1 >= nz) {
                    zoff1 = nz - 1;
                }
                xoff0 *= xstep;
                yoff0 *= ystep;
                zoff0 *= zstep;
                xoff1 *= xstep;
                yoff1 *= ystep;
                zoff1 *= zstep;
                for (var xoff = xoff0; xoff <= xoff1; xoff += xstep) {
                    for (var yoff = yoff0; yoff <= yoff1; yoff += ystep) {
                        for (var zoff = zoff0; zoff <= zoff1; zoff += zstep) {
                            var idx = xoff + yoff + zoff;
                            bins[idx][binLengths[idx]++] = bi;
                        }
                    }
                }
            }
            // Put all bodies into the bins
            for (var i = 0; i !== N; i++) {
                var bi = bodies[i];
                var si = bi.shape;
                switch (si.type) {
                    case SPHERE:
                        // Put in bin
                        // check if overlap with other bins
                        var x = bi.position.x, y = bi.position.y, z = bi.position.z;
                        var r = si.radius;
                        addBoxToBins(x - r, y - r, z - r, x + r, y + r, z + r, bi);
                        break;
                    case PLANE:
                        if (si.worldNormalNeedsUpdate) {
                            si.computeWorldNormal(bi.quaternion);
                        }
                        var planeNormal = si.worldNormal;
                        //Relative position from origin of plane object to the first bin
                        //Incremented as we iterate through the bins
                        var xreset = xmin + binsizeX * 0.5 - bi.position.x, yreset = ymin + binsizeY * 0.5 - bi.position.y, zreset = zmin + binsizeZ * 0.5 - bi.position.z;
                        var d = GridBroadphase_collisionPairs_d;
                        d.set(xreset, yreset, zreset);
                        for (var xi = 0, xoff = 0; xi !== nx; xi++, xoff += xstep, d.y = yreset, d.x += binsizeX) {
                            for (var yi = 0, yoff = 0; yi !== ny; yi++, yoff += ystep, d.z = zreset, d.y += binsizeY) {
                                for (var zi = 0, zoff = 0; zi !== nz; zi++, zoff += zstep, d.z += binsizeZ) {
                                    if (d.dot(planeNormal) < binRadius) {
                                        var idx = xoff + yoff + zoff;
                                        bins[idx][binLengths[idx]++] = bi;
                                    }
                                }
                            }
                        }
                        break;
                    default:
                        if (bi.aabbNeedsUpdate) {
                            bi.computeAABB();
                        }
                        addBoxToBins(bi.aabb.lowerBound.x, bi.aabb.lowerBound.y, bi.aabb.lowerBound.z, bi.aabb.upperBound.x, bi.aabb.upperBound.y, bi.aabb.upperBound.z, bi);
                        break;
                }
            }
            // Check each bin
            for (var i = 0; i !== Nbins; i++) {
                var binLength = binLengths[i];
                //Skip bins with no potential collisions
                if (binLength > 1) {
                    var bin = bins[i];
                    // Do N^2 broadphase inside
                    for (var xi = 0; xi !== binLength; xi++) {
                        var bi = bin[xi];
                        for (var yi = 0; yi !== xi; yi++) {
                            var bj = bin[yi];
                            if (this.needBroadphaseCollision(bi, bj)) {
                                this.intersectionTest(bi, bj, pairs1, pairs2);
                            }
                        }
                    }
                }
            }
            //	for (var zi = 0, zoff=0; zi < nz; zi++, zoff+= zstep) {
            //		console.log("layer "+zi);
            //		for (var yi = 0, yoff=0; yi < ny; yi++, yoff += ystep) {
            //			var row = '';
            //			for (var xi = 0, xoff=0; xi < nx; xi++, xoff += xstep) {
            //				var idx = xoff + yoff + zoff;
            //				row += ' ' + binLengths[idx];
            //			}
            //			console.log(row);
            //		}
            //	}
            this.makePairsUnique(pairs1, pairs2);
        };
        return GridBroadphase;
    }(CANNON.Broadphase));
    CANNON.GridBroadphase = GridBroadphase;
    var GridBroadphase_collisionPairs_d = new CANNON.Vec3();
    var GridBroadphase_collisionPairs_binPos = new CANNON.Vec3();
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var NaiveBroadphase = /** @class */ (function (_super) {
        __extends(NaiveBroadphase, _super);
        /**
         * Naive broadphase implementation, used in lack of better ones.
         * @description The naive broadphase looks at all possible pairs without restriction, therefore it has complexity N^2 (which is bad)
         */
        function NaiveBroadphase() {
            return _super.call(this) || this;
        }
        /**
         * Get all the collision pairs in the physics world
         * @param world
         * @param pairs1
         * @param pairs2
         */
        NaiveBroadphase.prototype.collisionPairs = function (world, pairs1, pairs2) {
            var bodies = world.bodies, n = bodies.length, i, j, bi, bj;
            // Naive N^2 ftw!
            for (i = 0; i !== n; i++) {
                for (j = 0; j !== i; j++) {
                    bi = bodies[i];
                    bj = bodies[j];
                    if (!this.needBroadphaseCollision(bi, bj)) {
                        continue;
                    }
                    this.intersectionTest(bi, bj, pairs1, pairs2);
                }
            }
        };
        /**
         * Returns all the bodies within an AABB.
         * @param world
         * @param aabb
         * @param result An array to store resulting bodies in.
         */
        NaiveBroadphase.prototype.aabbQuery = function (world, aabb, result) {
            result = result || [];
            for (var i = 0; i < world.bodies.length; i++) {
                var b = world.bodies[i];
                if (b.aabbNeedsUpdate) {
                    b.computeAABB();
                }
                // Ugly hack until Body gets aabb
                if (b.aabb.overlaps(aabb)) {
                    result.push(b);
                }
            }
            return result;
        };
        return NaiveBroadphase;
    }(CANNON.Broadphase));
    CANNON.NaiveBroadphase = NaiveBroadphase;
    var tmpAABB = new CANNON.AABB();
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var SAPBroadphase = /** @class */ (function (_super) {
        __extends(SAPBroadphase, _super);
        /**
         * Sweep and prune broadphase along one axis.
         *
         * @param world
         */
        function SAPBroadphase(world) {
            var _this = _super.call(this) || this;
            _this.axisList = [];
            _this.world = null;
            _this.axisIndex = 0;
            var axisList = _this.axisList;
            _this._addBodyHandler = function (e) {
                axisList.push(e.body);
            };
            _this._removeBodyHandler = function (e) {
                var idx = axisList.indexOf(e.body);
                if (idx !== -1) {
                    axisList.splice(idx, 1);
                }
            };
            if (world) {
                _this.setWorld(world);
            }
            return _this;
        }
        /**
         * Change the world
         * @param world
         */
        SAPBroadphase.prototype.setWorld = function (world) {
            // Clear the old axis array
            this.axisList.length = 0;
            // Add all bodies from the new world
            for (var i = 0; i < world.bodies.length; i++) {
                this.axisList.push(world.bodies[i]);
            }
            // Remove old handlers, if any
            world.removeEventListener("addBody", this._addBodyHandler);
            world.removeEventListener("removeBody", this._removeBodyHandler);
            // Add handlers to update the list of bodies.
            world.addEventListener("addBody", this._addBodyHandler);
            world.addEventListener("removeBody", this._removeBodyHandler);
            this.world = world;
            this.dirty = true;
        };
        SAPBroadphase.insertionSortX = function (a) {
            for (var i = 1, l = a.length; i < l; i++) {
                var v = a[i];
                for (var j = i - 1; j >= 0; j--) {
                    if (a[j].aabb.lowerBound.x <= v.aabb.lowerBound.x) {
                        break;
                    }
                    a[j + 1] = a[j];
                }
                a[j + 1] = v;
            }
            return a;
        };
        SAPBroadphase.insertionSortY = function (a) {
            for (var i = 1, l = a.length; i < l; i++) {
                var v = a[i];
                for (var j = i - 1; j >= 0; j--) {
                    if (a[j].aabb.lowerBound.y <= v.aabb.lowerBound.y) {
                        break;
                    }
                    a[j + 1] = a[j];
                }
                a[j + 1] = v;
            }
            return a;
        };
        SAPBroadphase.insertionSortZ = function (a) {
            for (var i = 1, l = a.length; i < l; i++) {
                var v = a[i];
                for (var j = i - 1; j >= 0; j--) {
                    if (a[j].aabb.lowerBound.z <= v.aabb.lowerBound.z) {
                        break;
                    }
                    a[j + 1] = a[j];
                }
                a[j + 1] = v;
            }
            return a;
        };
        /**
         * Collect all collision pairs
         * @param world
         * @param p1
         * @param p2
         */
        SAPBroadphase.prototype.collisionPairs = function (world, p1, p2) {
            var bodies = this.axisList, N = bodies.length, axisIndex = this.axisIndex, i, j;
            if (this.dirty) {
                this.sortList();
                this.dirty = false;
            }
            // Look through the list
            for (i = 0; i !== N; i++) {
                var bi = bodies[i];
                for (j = i + 1; j < N; j++) {
                    var bj = bodies[j];
                    if (!this.needBroadphaseCollision(bi, bj)) {
                        continue;
                    }
                    if (!SAPBroadphase.checkBounds(bi, bj, axisIndex)) {
                        break;
                    }
                    this.intersectionTest(bi, bj, p1, p2);
                }
            }
        };
        SAPBroadphase.prototype.sortList = function () {
            var axisList = this.axisList;
            var axisIndex = this.axisIndex;
            var N = axisList.length;
            // Update AABBs
            for (var i = 0; i !== N; i++) {
                var bi = axisList[i];
                if (bi.aabbNeedsUpdate) {
                    bi.computeAABB();
                }
            }
            // Sort the list
            if (axisIndex === 0) {
                SAPBroadphase.insertionSortX(axisList);
            }
            else if (axisIndex === 1) {
                SAPBroadphase.insertionSortY(axisList);
            }
            else if (axisIndex === 2) {
                SAPBroadphase.insertionSortZ(axisList);
            }
        };
        /**
         * Check if the bounds of two bodies overlap, along the given SAP axis.
         * @param bi
         * @param bj
         * @param axisIndex
         */
        SAPBroadphase.checkBounds = function (bi, bj, axisIndex) {
            var biPos;
            var bjPos;
            if (axisIndex === 0) {
                biPos = bi.position.x;
                bjPos = bj.position.x;
            }
            else if (axisIndex === 1) {
                biPos = bi.position.y;
                bjPos = bj.position.y;
            }
            else if (axisIndex === 2) {
                biPos = bi.position.z;
                bjPos = bj.position.z;
            }
            var ri = bi.boundingRadius, rj = bj.boundingRadius, boundA1 = biPos - ri, boundA2 = biPos + ri, boundB1 = bjPos - rj, boundB2 = bjPos + rj;
            return boundB1 < boundA2;
        };
        /**
         * Computes the variance of the body positions and estimates the best
         * axis to use. Will automatically set property .axisIndex.
         */
        SAPBroadphase.prototype.autoDetectAxis = function () {
            var sumX = 0, sumX2 = 0, sumY = 0, sumY2 = 0, sumZ = 0, sumZ2 = 0, bodies = this.axisList, N = bodies.length, invN = 1 / N;
            for (var i = 0; i !== N; i++) {
                var b = bodies[i];
                var centerX = b.position.x;
                sumX += centerX;
                sumX2 += centerX * centerX;
                var centerY = b.position.y;
                sumY += centerY;
                sumY2 += centerY * centerY;
                var centerZ = b.position.z;
                sumZ += centerZ;
                sumZ2 += centerZ * centerZ;
            }
            var varianceX = sumX2 - sumX * sumX * invN, varianceY = sumY2 - sumY * sumY * invN, varianceZ = sumZ2 - sumZ * sumZ * invN;
            if (varianceX > varianceY) {
                if (varianceX > varianceZ) {
                    this.axisIndex = 0;
                }
                else {
                    this.axisIndex = 2;
                }
            }
            else if (varianceY > varianceZ) {
                this.axisIndex = 1;
            }
            else {
                this.axisIndex = 2;
            }
        };
        /**
         * Returns all the bodies within an AABB.
         * @param world
         * @param aabb
         * @param result An array to store resulting bodies in.
         */
        SAPBroadphase.prototype.aabbQuery = function (world, aabb, result) {
            result = result || [];
            if (this.dirty) {
                this.sortList();
                this.dirty = false;
            }
            var axisIndex = this.axisIndex, axis = 'x';
            if (axisIndex === 1) {
                axis = 'y';
            }
            if (axisIndex === 2) {
                axis = 'z';
            }
            var axisList = this.axisList;
            var lower = aabb.lowerBound[axis];
            var upper = aabb.upperBound[axis];
            for (var i = 0; i < axisList.length; i++) {
                var b = axisList[i];
                if (b.aabbNeedsUpdate) {
                    b.computeAABB();
                }
                if (b.aabb.overlaps(aabb)) {
                    result.push(b);
                }
            }
            return result;
        };
        return SAPBroadphase;
    }(CANNON.Broadphase));
    CANNON.SAPBroadphase = SAPBroadphase;
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var Ray = /** @class */ (function () {
        /**
         * A line in 3D space that intersects bodies and return points.
         * @param from
         * @param to
         */
        function Ray(from, to) {
            this.from = from ? from.clone() : new CANNON.Vec3();
            this.to = to ? to.clone() : new CANNON.Vec3();
            this._direction = new CANNON.Vec3();
            this.precision = 0.0001;
            this.checkCollisionResponse = true;
            this.skipBackfaces = false;
            this.collisionFilterMask = -1;
            this.collisionFilterGroup = -1;
            this.mode = Ray.ANY;
            this.result = new CANNON.RaycastResult();
            this.hasHit = false;
            this.callback = function (result) { };
        }
        /**
         * Do itersection against all bodies in the given World.
         * @param world
         * @param options
         * @return True if the ray hit anything, otherwise false.
         */
        Ray.prototype.intersectWorld = function (world, options) {
            this.mode = options.mode || Ray.ANY;
            this.result = options.result || new CANNON.RaycastResult();
            this.skipBackfaces = !!options.skipBackfaces;
            this.collisionFilterMask = typeof (options.collisionFilterMask) !== 'undefined' ? options.collisionFilterMask : -1;
            this.collisionFilterGroup = typeof (options.collisionFilterGroup) !== 'undefined' ? options.collisionFilterGroup : -1;
            if (options.from) {
                this.from.copy(options.from);
            }
            if (options.to) {
                this.to.copy(options.to);
            }
            this.callback = options.callback || function () { };
            this.hasHit = false;
            this.result.reset();
            this._updateDirection();
            this.getAABB(tmpAABB);
            tmpArray.length = 0;
            world.broadphase.aabbQuery(world, tmpAABB, tmpArray);
            this.intersectBodies(tmpArray);
            return this.hasHit;
        };
        /**
         * Shoot a ray at a body, get back information about the hit.
         * @param body
         * @param result Deprecated - set the result property of the Ray instead.
         */
        Ray.prototype.intersectBody = function (body, result) {
            if (result) {
                this.result = result;
                this._updateDirection();
            }
            var checkCollisionResponse = this.checkCollisionResponse;
            if (checkCollisionResponse && !body.collisionResponse) {
                return;
            }
            if ((this.collisionFilterGroup & body.collisionFilterMask) === 0 || (body.collisionFilterGroup & this.collisionFilterMask) === 0) {
                return;
            }
            var xi = intersectBody_xi;
            var qi = intersectBody_qi;
            for (var i = 0, N = body.shapes.length; i < N; i++) {
                var shape = body.shapes[i];
                if (checkCollisionResponse && !shape.collisionResponse) {
                    continue; // Skip
                }
                body.quaternion.mult(body.shapeOrientations[i], qi);
                body.quaternion.vmult(body.shapeOffsets[i], xi);
                xi.vadd(body.position, xi);
                this.intersectShape(shape, qi, xi, body);
                if (this.result._shouldStop) {
                    break;
                }
            }
        };
        /**
         * @param bodies An array of Body objects.
         * @param result Deprecated
         */
        Ray.prototype.intersectBodies = function (bodies, result) {
            if (result) {
                this.result = result;
                this._updateDirection();
            }
            for (var i = 0, l = bodies.length; !this.result._shouldStop && i < l; i++) {
                this.intersectBody(bodies[i]);
            }
        };
        ;
        /**
         * Updates the _direction vector.
         */
        Ray.prototype._updateDirection = function () {
            this.to.vsub(this.from, this._direction);
            this._direction.normalize();
        };
        ;
        Ray.prototype.intersectShape = function (shape, quat, position, body) {
            var from = this.from;
            // Checking boundingSphere
            var distance = distanceFromIntersection(from, this._direction, position);
            if (distance > shape.boundingSphereRadius) {
                return;
            }
            var intersectMethod = this[shape.type];
            if (intersectMethod) {
                intersectMethod.call(this, shape, quat, position, body, shape);
            }
        };
        Ray.prototype.intersectBox = function (shape, quat, position, body, reportedShape) {
            return this.intersectConvex(shape.convexPolyhedronRepresentation, quat, position, body, reportedShape);
        };
        Ray.prototype.intersectPlane = function (shape, quat, position, body, reportedShape) {
            var from = this.from;
            var to = this.to;
            var direction = this._direction;
            // Get plane normal
            var worldNormal = new CANNON.Vec3().copy(CANNON.World.worldNormal);
            quat.vmult(worldNormal, worldNormal);
            var len = new CANNON.Vec3();
            from.vsub(position, len);
            var planeToFrom = len.dot(worldNormal);
            to.vsub(position, len);
            var planeToTo = len.dot(worldNormal);
            if (planeToFrom * planeToTo > 0) {
                // "from" and "to" are on the same side of the plane... bail out
                return;
            }
            if (from.distanceTo(to) < planeToFrom) {
                return;
            }
            var n_dot_dir = worldNormal.dot(direction);
            if (Math.abs(n_dot_dir) < this.precision) {
                // No intersection
                return;
            }
            var planePointToFrom = new CANNON.Vec3();
            var dir_scaled_with_t = new CANNON.Vec3();
            var hitPointWorld = new CANNON.Vec3();
            from.vsub(position, planePointToFrom);
            var t = -worldNormal.dot(planePointToFrom) / n_dot_dir;
            direction.scale(t, dir_scaled_with_t);
            from.vadd(dir_scaled_with_t, hitPointWorld);
            this.reportIntersection(worldNormal, hitPointWorld, reportedShape, body, -1);
        };
        /**
         * Get the world AABB of the ray.
         */
        Ray.prototype.getAABB = function (result) {
            var to = this.to;
            var from = this.from;
            result.lowerBound.x = Math.min(to.x, from.x);
            result.lowerBound.y = Math.min(to.y, from.y);
            result.lowerBound.z = Math.min(to.z, from.z);
            result.upperBound.x = Math.max(to.x, from.x);
            result.upperBound.y = Math.max(to.y, from.y);
            result.upperBound.z = Math.max(to.z, from.z);
        };
        Ray.prototype.intersectHeightfield = function (shape, quat, position, body, reportedShape) {
            var data = shape.data, w = shape.elementSize;
            // Convert the ray to local heightfield coordinates
            var localRay = intersectHeightfield_localRay; //new Ray(this.from, this.to);
            localRay.from.copy(this.from);
            localRay.to.copy(this.to);
            CANNON.Transform.pointToLocalFrame(position, quat, localRay.from, localRay.from);
            CANNON.Transform.pointToLocalFrame(position, quat, localRay.to, localRay.to);
            localRay._updateDirection();
            // Get the index of the data points to test against
            var index = intersectHeightfield_index;
            var iMinX, iMinY, iMaxX, iMaxY;
            // Set to max
            iMinX = iMinY = 0;
            iMaxX = iMaxY = shape.data.length - 1;
            var aabb = new CANNON.AABB();
            localRay.getAABB(aabb);
            shape.getIndexOfPosition(aabb.lowerBound.x, aabb.lowerBound.y, index, true);
            iMinX = Math.max(iMinX, index[0]);
            iMinY = Math.max(iMinY, index[1]);
            shape.getIndexOfPosition(aabb.upperBound.x, aabb.upperBound.y, index, true);
            iMaxX = Math.min(iMaxX, index[0] + 1);
            iMaxY = Math.min(iMaxY, index[1] + 1);
            for (var i = iMinX; i < iMaxX; i++) {
                for (var j = iMinY; j < iMaxY; j++) {
                    if (this.result._shouldStop) {
                        return;
                    }
                    shape.getAabbAtIndex(i, j, aabb);
                    if (!aabb.overlapsRay(localRay)) {
                        continue;
                    }
                    // Lower triangle
                    shape.getConvexTrianglePillar(i, j, false);
                    CANNON.Transform.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset);
                    this.intersectConvex(shape.pillarConvex, quat, worldPillarOffset, body, reportedShape, intersectConvexOptions);
                    if (this.result._shouldStop) {
                        return;
                    }
                    // Upper triangle
                    shape.getConvexTrianglePillar(i, j, true);
                    CANNON.Transform.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset);
                    this.intersectConvex(shape.pillarConvex, quat, worldPillarOffset, body, reportedShape, intersectConvexOptions);
                }
            }
        };
        Ray.prototype.intersectSphere = function (shape, quat, position, body, reportedShape) {
            var from = this.from, to = this.to, r = shape.radius;
            var a = Math.pow(to.x - from.x, 2) + Math.pow(to.y - from.y, 2) + Math.pow(to.z - from.z, 2);
            var b = 2 * ((to.x - from.x) * (from.x - position.x) + (to.y - from.y) * (from.y - position.y) + (to.z - from.z) * (from.z - position.z));
            var c = Math.pow(from.x - position.x, 2) + Math.pow(from.y - position.y, 2) + Math.pow(from.z - position.z, 2) - Math.pow(r, 2);
            var delta = Math.pow(b, 2) - 4 * a * c;
            var intersectionPoint = Ray_intersectSphere_intersectionPoint;
            var normal = Ray_intersectSphere_normal;
            if (delta < 0) {
                // No intersection
                return;
            }
            else if (delta === 0) {
                // single intersection point
                from.lerp(to, delta, intersectionPoint);
                intersectionPoint.vsub(position, normal);
                normal.normalize();
                this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);
            }
            else {
                var d1 = (-b - Math.sqrt(delta)) / (2 * a);
                var d2 = (-b + Math.sqrt(delta)) / (2 * a);
                if (d1 >= 0 && d1 <= 1) {
                    from.lerp(to, d1, intersectionPoint);
                    intersectionPoint.vsub(position, normal);
                    normal.normalize();
                    this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);
                }
                if (this.result._shouldStop) {
                    return;
                }
                if (d2 >= 0 && d2 <= 1) {
                    from.lerp(to, d2, intersectionPoint);
                    intersectionPoint.vsub(position, normal);
                    normal.normalize();
                    this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);
                }
            }
        };
        Ray.prototype.intersectConvex = function (shape, quat, position, body, reportedShape, options) {
            if (options === void 0) { options = {}; }
            var minDistNormal = intersectConvex_minDistNormal;
            var normal = intersectConvex_normal;
            var vector = intersectConvex_vector;
            var minDistIntersect = intersectConvex_minDistIntersect;
            var faceList = (options && options.faceList) || null;
            // Checking faces
            var faces = shape.faces, vertices = shape.vertices, normals = shape.faceNormals;
            var direction = this._direction;
            var from = this.from;
            var to = this.to;
            var fromToDistance = from.distanceTo(to);
            var minDist = -1;
            var Nfaces = faceList ? faceList.length : faces.length;
            var result = this.result;
            for (var j = 0; !result._shouldStop && j < Nfaces; j++) {
                var fi = faceList ? faceList[j] : j;
                var face = faces[fi];
                var faceNormal = normals[fi];
                var q = quat;
                var x = position;
                // determine if ray intersects the plane of the face
                // note: this works regardless of the direction of the face normal
                // Get plane point in world coordinates...
                vector.copy(vertices[face[0]]);
                q.vmult(vector, vector);
                vector.vadd(x, vector);
                // ...but make it relative to the ray from. We'll fix this later.
                vector.vsub(from, vector);
                // Get plane normal
                q.vmult(faceNormal, normal);
                // If this dot product is negative, we have something interesting
                var dot = direction.dot(normal);
                // Bail out if ray and plane are parallel
                if (Math.abs(dot) < this.precision) {
                    continue;
                }
                // calc distance to plane
                var scalar = normal.dot(vector) / dot;
                // if negative distance, then plane is behind ray
                if (scalar < 0) {
                    continue;
                }
                // if (dot < 0) {
                // Intersection point is from + direction * scalar
                direction.mult(scalar, intersectPoint);
                intersectPoint.vadd(from, intersectPoint);
                // a is the point we compare points b and c with.
                a.copy(vertices[face[0]]);
                q.vmult(a, a);
                x.vadd(a, a);
                for (var i = 1; !result._shouldStop && i < face.length - 1; i++) {
                    // Transform 3 vertices to world coords
                    b.copy(vertices[face[i]]);
                    c.copy(vertices[face[i + 1]]);
                    q.vmult(b, b);
                    q.vmult(c, c);
                    x.vadd(b, b);
                    x.vadd(c, c);
                    var distance = intersectPoint.distanceTo(from);
                    if (!(Ray.pointInTriangle(intersectPoint, a, b, c) || Ray.pointInTriangle(intersectPoint, b, a, c)) || distance > fromToDistance) {
                        continue;
                    }
                    this.reportIntersection(normal, intersectPoint, reportedShape, body, fi);
                }
                // }
            }
        };
        /**
         * @method intersectTrimesh
         * @private
         * @param  {Shape} shape
         * @param  {Quaternion} quat
         * @param  {Vec3} position
         * @param  {Body} body
         * @param {object} [options]
         */
        /**
         *
         * @param mesh
         * @param quat
         * @param position
         * @param body
         * @param reportedShape
         * @param options
         *
         * @todo Optimize by transforming the world to local space first.
         * @todo Use Octree lookup
         */
        Ray.prototype.intersectTrimesh = function (mesh, quat, position, body, reportedShape, options) {
            var normal = intersectTrimesh_normal;
            var triangles = intersectTrimesh_triangles;
            var treeTransform = intersectTrimesh_treeTransform;
            var minDistNormal = intersectConvex_minDistNormal;
            var vector = intersectConvex_vector;
            var minDistIntersect = intersectConvex_minDistIntersect;
            var localAABB = intersectTrimesh_localAABB;
            var localDirection = intersectTrimesh_localDirection;
            var localFrom = intersectTrimesh_localFrom;
            var localTo = intersectTrimesh_localTo;
            var worldIntersectPoint = intersectTrimesh_worldIntersectPoint;
            var worldNormal = intersectTrimesh_worldNormal;
            var faceList = (options && options.faceList) || null;
            // Checking faces
            var indices = mesh.indices, vertices = mesh.vertices, normals = mesh.faceNormals;
            var from = this.from;
            var to = this.to;
            var direction = this._direction;
            var minDist = -1;
            treeTransform.position.copy(position);
            treeTransform.quaternion.copy(quat);
            // Transform ray to local space!
            CANNON.Transform.vectorToLocalFrame(position, quat, direction, localDirection);
            CANNON.Transform.pointToLocalFrame(position, quat, from, localFrom);
            CANNON.Transform.pointToLocalFrame(position, quat, to, localTo);
            localTo.x *= mesh.scale.x;
            localTo.y *= mesh.scale.y;
            localTo.z *= mesh.scale.z;
            localFrom.x *= mesh.scale.x;
            localFrom.y *= mesh.scale.y;
            localFrom.z *= mesh.scale.z;
            localTo.vsub(localFrom, localDirection);
            localDirection.normalize();
            var fromToDistanceSquared = localFrom.distanceSquared(localTo);
            mesh.tree.rayQuery(this, treeTransform, triangles);
            for (var i = 0, N = triangles.length; !this.result._shouldStop && i !== N; i++) {
                var trianglesIndex = triangles[i];
                mesh.getNormal(trianglesIndex, normal);
                // determine if ray intersects the plane of the face
                // note: this works regardless of the direction of the face normal
                // Get plane point in world coordinates...
                mesh.getVertex(indices[trianglesIndex * 3], a);
                // ...but make it relative to the ray from. We'll fix this later.
                a.vsub(localFrom, vector);
                // If this dot product is negative, we have something interesting
                var dot = localDirection.dot(normal);
                // Bail out if ray and plane are parallel
                // if (Math.abs( dot ) < this.precision){
                //     continue;
                // }
                // calc distance to plane
                var scalar = normal.dot(vector) / dot;
                // if negative distance, then plane is behind ray
                if (scalar < 0) {
                    continue;
                }
                // Intersection point is from + direction * scalar
                localDirection.scale(scalar, intersectPoint);
                intersectPoint.vadd(localFrom, intersectPoint);
                // Get triangle vertices
                mesh.getVertex(indices[trianglesIndex * 3 + 1], b);
                mesh.getVertex(indices[trianglesIndex * 3 + 2], c);
                var squaredDistance = intersectPoint.distanceSquared(localFrom);
                if (!(Ray.pointInTriangle(intersectPoint, b, a, c) || Ray.pointInTriangle(intersectPoint, a, b, c)) || squaredDistance > fromToDistanceSquared) {
                    continue;
                }
                // transform intersectpoint and normal to world
                CANNON.Transform.vectorToWorldFrame(quat, normal, worldNormal);
                CANNON.Transform.pointToWorldFrame(position, quat, intersectPoint, worldIntersectPoint);
                this.reportIntersection(worldNormal, worldIntersectPoint, reportedShape, body, trianglesIndex);
            }
            triangles.length = 0;
        };
        Ray.prototype.reportIntersection = function (normal, hitPointWorld, shape, body, hitFaceIndex) {
            var from = this.from;
            var to = this.to;
            var distance = from.distanceTo(hitPointWorld);
            var result = this.result;
            // Skip back faces?
            if (this.skipBackfaces && normal.dot(this._direction) > 0) {
                return;
            }
            result.hitFaceIndex = typeof (hitFaceIndex) !== 'undefined' ? hitFaceIndex : -1;
            switch (this.mode) {
                case Ray.ALL:
                    this.hasHit = true;
                    result.set(from, to, normal, hitPointWorld, shape, body, distance);
                    result.hasHit = true;
                    this.callback(result);
                    break;
                case Ray.CLOSEST:
                    // Store if closer than current closest
                    if (distance < result.distance || !result.hasHit) {
                        this.hasHit = true;
                        result.hasHit = true;
                        result.set(from, to, normal, hitPointWorld, shape, body, distance);
                    }
                    break;
                case Ray.ANY:
                    // Report and stop.
                    this.hasHit = true;
                    result.hasHit = true;
                    result.set(from, to, normal, hitPointWorld, shape, body, distance);
                    result._shouldStop = true;
                    break;
            }
        };
        /*
         * As per "Barycentric Technique" as named here http://www.blackpawn.com/texts/pointinpoly/default.html But without the division
         */
        Ray.pointInTriangle = function (p, a, b, c) {
            c.vsub(a, v0);
            b.vsub(a, v1);
            p.vsub(a, v2);
            var dot00 = v0.dot(v0);
            var dot01 = v0.dot(v1);
            var dot02 = v0.dot(v2);
            var dot11 = v1.dot(v1);
            var dot12 = v1.dot(v2);
            var u, v;
            return ((u = dot11 * dot02 - dot01 * dot12) >= 0) &&
                ((v = dot00 * dot12 - dot01 * dot02) >= 0) &&
                (u + v < (dot00 * dot11 - dot01 * dot01));
        };
        Ray.CLOSEST = 1;
        Ray.ANY = 2;
        Ray.ALL = 4;
        return Ray;
    }());
    CANNON.Ray = Ray;
    var tmpAABB = new CANNON.AABB();
    var tmpArray = [];
    var v1 = new CANNON.Vec3();
    var v2 = new CANNON.Vec3();
    var intersectBody_xi = new CANNON.Vec3();
    var intersectBody_qi = new CANNON.Quaternion();
    var vector = new CANNON.Vec3();
    var normal = new CANNON.Vec3();
    var intersectPoint = new CANNON.Vec3();
    var a = new CANNON.Vec3();
    var b = new CANNON.Vec3();
    var c = new CANNON.Vec3();
    var d = new CANNON.Vec3();
    var tmpRaycastResult = new CANNON.RaycastResult();
    var v0 = new CANNON.Vec3();
    var intersect = new CANNON.Vec3();
    var intersectTrimesh_normal = new CANNON.Vec3();
    var intersectTrimesh_localDirection = new CANNON.Vec3();
    var intersectTrimesh_localFrom = new CANNON.Vec3();
    var intersectTrimesh_localTo = new CANNON.Vec3();
    var intersectTrimesh_worldNormal = new CANNON.Vec3();
    var intersectTrimesh_worldIntersectPoint = new CANNON.Vec3();
    var intersectTrimesh_localAABB = new CANNON.AABB();
    var intersectTrimesh_triangles = [];
    var intersectTrimesh_treeTransform = new CANNON.Transform();
    var intersectConvexOptions = {
        faceList: [0]
    };
    var worldPillarOffset = new CANNON.Vec3();
    var intersectHeightfield_localRay = new Ray();
    var intersectHeightfield_index = [];
    var intersectHeightfield_minMax = [];
    var Ray_intersectSphere_intersectionPoint = new CANNON.Vec3();
    var Ray_intersectSphere_normal = new CANNON.Vec3();
    var intersectConvex_normal = new CANNON.Vec3();
    var intersectConvex_minDistNormal = new CANNON.Vec3();
    var intersectConvex_minDistIntersect = new CANNON.Vec3();
    var intersectConvex_vector = new CANNON.Vec3();
    Ray.prototype[CANNON.Shape.types.BOX] = Ray.prototype["intersectBox"];
    Ray.prototype[CANNON.Shape.types.PLANE] = Ray.prototype["intersectPlane"];
    Ray.prototype[CANNON.Shape.types.HEIGHTFIELD] = Ray.prototype["intersectHeightfield"];
    Ray.prototype[CANNON.Shape.types.SPHERE] = Ray.prototype["intersectSphere"];
    Ray.prototype[CANNON.Shape.types.TRIMESH] = Ray.prototype["intersectTrimesh"];
    Ray.prototype[CANNON.Shape.types.CONVEXPOLYHEDRON] = Ray.prototype["intersectConvex"];
    function distanceFromIntersection(from, direction, position) {
        // v0 is vector from from to position
        position.vsub(from, v0);
        var dot = v0.dot(direction);
        // intersect = direction*dot + from
        direction.mult(dot, intersect);
        intersect.vadd(from, intersect);
        var distance = position.distanceTo(intersect);
        return distance;
    }
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var Material = /** @class */ (function () {
        /**
         * Defines a physics material.
         *
         * @param options
         * @author schteppe
         */
        function Material(options) {
            if (options === void 0) { options = {}; }
            var name = '';
            // Backwards compatibility fix
            if (typeof (options) === 'string') {
                name = options;
                options = {};
            }
            else if (typeof (options) === 'object') {
                name = '';
            }
            this.name = name;
            this.id = Material.idCounter++;
            this.friction = typeof (options.friction) !== 'undefined' ? options.friction : -1;
            this.restitution = typeof (options.restitution) !== 'undefined' ? options.restitution : -1;
        }
        Material.idCounter = 0;
        return Material;
    }());
    CANNON.Material = Material;
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var ContactMaterial = /** @class */ (function () {
        /**
         * Defines what happens when two materials meet.
         *
         * @param m1
         * @param m2
         * @param options
         */
        function ContactMaterial(m1, m2, options) {
            if (options === void 0) { options = {}; }
            options = CANNON.Utils.defaults(options, {
                friction: 0.3,
                restitution: 0.3,
                contactEquationStiffness: 1e7,
                contactEquationRelaxation: 3,
                frictionEquationStiffness: 1e7,
                frictionEquationRelaxation: 3
            });
            this.id = ContactMaterial.idCounter++;
            this.materials = [m1, m2];
            this.friction = options.friction;
            this.restitution = options.restitution;
            this.contactEquationStiffness = options.contactEquationStiffness;
            this.contactEquationRelaxation = options.contactEquationRelaxation;
            this.frictionEquationStiffness = options.frictionEquationStiffness;
            this.frictionEquationRelaxation = options.frictionEquationRelaxation;
        }
        ContactMaterial.idCounter = 0;
        return ContactMaterial;
    }());
    CANNON.ContactMaterial = ContactMaterial;
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var Body = /** @class */ (function (_super) {
        __extends(Body, _super);
        /**
         * Base class for all body types.
         *
         * @param options
         * @param a
         *
         * @example
         *     var body = new Body({
         *         mass: 1
         *     });
         *     var shape = new Sphere(1);
         *     body.addShape(shape);
         *     world.addBody(body);
         */
        function Body(options, a) {
            if (options === void 0) { options = {}; }
            if (a === void 0) { a = undefined; }
            var _this = _super.call(this) || this;
            _this.id = Body.idCounter++;
            _this.world = null;
            _this.preStep = null;
            _this.postStep = null;
            _this.vlambda = new CANNON.Vec3();
            _this.collisionFilterGroup = typeof (options.collisionFilterGroup) === 'number' ? options.collisionFilterGroup : 1;
            _this.collisionFilterMask = typeof (options.collisionFilterMask) === 'number' ? options.collisionFilterMask : -1;
            _this.collisionResponse = true;
            _this.position = new CANNON.Vec3();
            _this.previousPosition = new CANNON.Vec3();
            _this.interpolatedPosition = new CANNON.Vec3();
            _this.initPosition = new CANNON.Vec3();
            if (options.position) {
                _this.position.copy(options.position);
                _this.previousPosition.copy(options.position);
                _this.interpolatedPosition.copy(options.position);
                _this.initPosition.copy(options.position);
            }
            _this.velocity = new CANNON.Vec3();
            if (options.velocity) {
                _this.velocity.copy(options.velocity);
            }
            _this.initVelocity = new CANNON.Vec3();
            _this.force = new CANNON.Vec3();
            var mass = typeof (options.mass) === 'number' ? options.mass : 0;
            _this.mass = mass;
            _this.invMass = mass > 0 ? 1.0 / mass : 0;
            _this.material = options.material || null;
            _this.linearDamping = typeof (options.linearDamping) === 'number' ? options.linearDamping : 0.01;
            _this.type = (mass <= 0.0 ? Body.STATIC : Body.DYNAMIC);
            if (typeof (options.type) === typeof (Body.STATIC)) {
                _this.type = options.type;
            }
            _this.allowSleep = typeof (options.allowSleep) !== 'undefined' ? options.allowSleep : true;
            _this.sleepState = 0;
            _this.sleepSpeedLimit = typeof (options.sleepSpeedLimit) !== 'undefined' ? options.sleepSpeedLimit : 0.1;
            _this.sleepTimeLimit = typeof (options.sleepTimeLimit) !== 'undefined' ? options.sleepTimeLimit : 1;
            _this.timeLastSleepy = 0;
            _this._wakeUpAfterNarrowphase = false;
            _this.torque = new CANNON.Vec3();
            _this.quaternion = new CANNON.Quaternion();
            _this.initQuaternion = new CANNON.Quaternion();
            _this.previousQuaternion = new CANNON.Quaternion();
            _this.interpolatedQuaternion = new CANNON.Quaternion();
            if (options.quaternion) {
                _this.quaternion.copy(options.quaternion);
                _this.initQuaternion.copy(options.quaternion);
                _this.previousQuaternion.copy(options.quaternion);
                _this.interpolatedQuaternion.copy(options.quaternion);
            }
            _this.angularVelocity = new CANNON.Vec3();
            if (options.angularVelocity) {
                _this.angularVelocity.copy(options.angularVelocity);
            }
            _this.initAngularVelocity = new CANNON.Vec3();
            _this.shapes = [];
            _this.shapeOffsets = [];
            _this.shapeOrientations = [];
            _this.inertia = new CANNON.Vec3();
            _this.invInertia = new CANNON.Vec3();
            _this.invInertiaWorld = new CANNON.Mat3();
            _this.invMassSolve = 0;
            _this.invInertiaSolve = new CANNON.Vec3();
            _this.invInertiaWorldSolve = new CANNON.Mat3();
            _this.fixedRotation = typeof (options.fixedRotation) !== "undefined" ? options.fixedRotation : false;
            _this.angularDamping = typeof (options.angularDamping) !== 'undefined' ? options.angularDamping : 0.01;
            _this.linearFactor = new CANNON.Vec3(1, 1, 1);
            if (options.linearFactor) {
                _this.linearFactor.copy(options.linearFactor);
            }
            _this.angularFactor = new CANNON.Vec3(1, 1, 1);
            if (options.angularFactor) {
                _this.angularFactor.copy(options.angularFactor);
            }
            _this.aabb = new CANNON.AABB();
            _this.aabbNeedsUpdate = true;
            _this.boundingRadius = 0;
            _this.wlambda = new CANNON.Vec3();
            if (options.shape) {
                _this.addShape(options.shape);
            }
            _this.updateMassProperties();
            return _this;
        }
        /**
         * Wake the body up.
         */
        Body.prototype.wakeUp = function () {
            var s = this.sleepState;
            this.sleepState = 0;
            this._wakeUpAfterNarrowphase = false;
            if (s === Body.SLEEPING) {
                this.dispatchEvent(Body.wakeupEvent);
            }
        };
        /**
         * Force body sleep
         */
        Body.prototype.sleep = function () {
            this.sleepState = Body.SLEEPING;
            this.velocity.set(0, 0, 0);
            this.angularVelocity.set(0, 0, 0);
            this._wakeUpAfterNarrowphase = false;
        };
        /**
         * Called every timestep to update internal sleep timer and change sleep state if needed.
         */
        Body.prototype.sleepTick = function (time) {
            if (this.allowSleep) {
                var sleepState = this.sleepState;
                var speedSquared = this.velocity.norm2() + this.angularVelocity.norm2();
                var speedLimitSquared = Math.pow(this.sleepSpeedLimit, 2);
                if (sleepState === Body.AWAKE && speedSquared < speedLimitSquared) {
                    this.sleepState = Body.SLEEPY; // Sleepy
                    this.timeLastSleepy = time;
                    this.dispatchEvent(Body.sleepyEvent);
                }
                else if (sleepState === Body.SLEEPY && speedSquared > speedLimitSquared) {
                    this.wakeUp(); // Wake up
                }
                else if (sleepState === Body.SLEEPY && (time - this.timeLastSleepy) > this.sleepTimeLimit) {
                    this.sleep(); // Sleeping
                    this.dispatchEvent(Body.sleepEvent);
                }
            }
        };
        /**
         * If the body is sleeping, it should be immovable / have infinite mass during solve. We solve it by having a separate "solve mass".
         */
        Body.prototype.updateSolveMassProperties = function () {
            if (this.sleepState === Body.SLEEPING || this.type === Body.KINEMATIC) {
                this.invMassSolve = 0;
                this.invInertiaSolve.setZero();
                this.invInertiaWorldSolve.setZero();
            }
            else {
                this.invMassSolve = this.invMass;
                this.invInertiaSolve.copy(this.invInertia);
                this.invInertiaWorldSolve.copy(this.invInertiaWorld);
            }
        };
        /**
         * Convert a world point to local body frame.
         *
         * @param worldPoint
         * @param result
         */
        Body.prototype.pointToLocalFrame = function (worldPoint, result) {
            var result = result || new CANNON.Vec3();
            worldPoint.vsub(this.position, result);
            this.quaternion.conjugate().vmult(result, result);
            return result;
        };
        /**
         * Convert a world vector to local body frame.
         *
         * @param worldPoint
         * @param result
         */
        Body.prototype.vectorToLocalFrame = function (worldVector, result) {
            if (result === void 0) { result = new CANNON.Vec3(); }
            this.quaternion.conjugate().vmult(worldVector, result);
            return result;
        };
        /**
         * Convert a local body point to world frame.
         *
         * @param localPoint
         * @param result
         */
        Body.prototype.pointToWorldFrame = function (localPoint, result) {
            var result = result || new CANNON.Vec3();
            this.quaternion.vmult(localPoint, result);
            result.vadd(this.position, result);
            return result;
        };
        /**
         * Convert a local body point to world frame.
         *
         * @param localVector
         * @param result
         */
        Body.prototype.vectorToWorldFrame = function (localVector, result) {
            var result = result || new CANNON.Vec3();
            this.quaternion.vmult(localVector, result);
            return result;
        };
        /**
         * Add a shape to the body with a local offset and orientation.
         *
         * @param shape
         * @param _offset
         * @param_orientation
         * @return The body object, for chainability.
         */
        Body.prototype.addShape = function (shape, _offset, _orientation) {
            var offset = new CANNON.Vec3();
            var orientation = new CANNON.Quaternion();
            if (_offset) {
                offset.copy(_offset);
            }
            if (_orientation) {
                orientation.copy(_orientation);
            }
            this.shapes.push(shape);
            this.shapeOffsets.push(offset);
            this.shapeOrientations.push(orientation);
            this.updateMassProperties();
            this.updateBoundingRadius();
            this.aabbNeedsUpdate = true;
            shape.body = this;
            return this;
        };
        /**
         * Update the bounding radius of the body. Should be done if any of the shapes are changed.
         */
        Body.prototype.updateBoundingRadius = function () {
            var shapes = this.shapes, shapeOffsets = this.shapeOffsets, N = shapes.length, radius = 0;
            for (var i = 0; i !== N; i++) {
                var shape = shapes[i];
                shape.updateBoundingSphereRadius();
                var offset = shapeOffsets[i].norm(), r = shape.boundingSphereRadius;
                if (offset + r > radius) {
                    radius = offset + r;
                }
            }
            this.boundingRadius = radius;
        };
        /**
         * Updates the .aabb
         *
         * @todo rename to updateAABB()
         */
        Body.prototype.computeAABB = function () {
            var shapes = this.shapes, shapeOffsets = this.shapeOffsets, shapeOrientations = this.shapeOrientations, N = shapes.length, offset = tmpVec, orientation = tmpQuat, bodyQuat = this.quaternion, aabb = this.aabb, shapeAABB = computeAABB_shapeAABB;
            for (var i = 0; i !== N; i++) {
                var shape = shapes[i];
                // Get shape world position
                bodyQuat.vmult(shapeOffsets[i], offset);
                offset.vadd(this.position, offset);
                // Get shape world quaternion
                shapeOrientations[i].mult(bodyQuat, orientation);
                // Get shape AABB
                shape.calculateWorldAABB(offset, orientation, shapeAABB.lowerBound, shapeAABB.upperBound);
                if (i === 0) {
                    aabb.copy(shapeAABB);
                }
                else {
                    aabb.extend(shapeAABB);
                }
            }
            this.aabbNeedsUpdate = false;
        };
        /**
         * Update .inertiaWorld and .invInertiaWorld
         */
        Body.prototype.updateInertiaWorld = function (force) {
            var I = this.invInertia;
            if (I.x === I.y && I.y === I.z && !force) {
                // If inertia M = s*I, where I is identity and s a scalar, then
                //    R*M*R' = R*(s*I)*R' = s*R*I*R' = s*R*R' = s*I = M
                // where R is the rotation matrix.
                // In other words, we don't have to transform the inertia if all
                // inertia diagonal entries are equal.
            }
            else {
                var m1 = uiw_m1, m2 = uiw_m2, m3 = uiw_m3;
                m1.setRotationFromQuaternion(this.quaternion);
                m1.transpose(m2);
                m1.scale(I, m1);
                m1.mmult(m2, this.invInertiaWorld);
            }
        };
        /**
         * Apply force to a world point. This could for example be a point on the Body surface. Applying force this way will add to Body.force and Body.torque.
         *
         * @param force The amount of force to add.
         * @param relativePoint A point relative to the center of mass to apply the force on.
         */
        Body.prototype.applyForce = function (force, relativePoint) {
            if (this.type !== Body.DYNAMIC) { // Needed?
                return;
            }
            // Compute produced rotational force
            var rotForce = Body_applyForce_rotForce;
            relativePoint.cross(force, rotForce);
            // Add linear force
            this.force.vadd(force, this.force);
            // Add rotational force
            this.torque.vadd(rotForce, this.torque);
        };
        /**
         * Apply force to a local point in the body.
         *
         * @param force The force vector to apply, defined locally in the body frame.
         * @param localPoint A local point in the body to apply the force on.
         */
        Body.prototype.applyLocalForce = function (localForce, localPoint) {
            if (this.type !== Body.DYNAMIC) {
                return;
            }
            var worldForce = Body_applyLocalForce_worldForce;
            var relativePointWorld = Body_applyLocalForce_relativePointWorld;
            // Transform the force vector to world space
            this.vectorToWorldFrame(localForce, worldForce);
            this.vectorToWorldFrame(localPoint, relativePointWorld);
            this.applyForce(worldForce, relativePointWorld);
        };
        /**
         * Apply impulse to a world point. This could for example be a point on the Body surface. An impulse is a force added to a body during a short period of time (impulse = force * time). Impulses will be added to Body.velocity and Body.angularVelocity.
         *
         * @param impulse The amount of impulse to add.
         * @param relativePoint A point relative to the center of mass to apply the force on.
         */
        Body.prototype.applyImpulse = function (impulse, relativePoint) {
            if (this.type !== Body.DYNAMIC) {
                return;
            }
            // Compute point position relative to the body center
            var r = relativePoint;
            // Compute produced central impulse velocity
            var velo = Body_applyImpulse_velo;
            velo.copy(impulse);
            velo.mult(this.invMass, velo);
            // Add linear impulse
            this.velocity.vadd(velo, this.velocity);
            // Compute produced rotational impulse velocity
            var rotVelo = Body_applyImpulse_rotVelo;
            r.cross(impulse, rotVelo);
            /*
            rotVelo.x *= this.invInertia.x;
            rotVelo.y *= this.invInertia.y;
            rotVelo.z *= this.invInertia.z;
            */
            this.invInertiaWorld.vmult(rotVelo, rotVelo);
            // Add rotational Impulse
            this.angularVelocity.vadd(rotVelo, this.angularVelocity);
        };
        /**
         * Apply locally-defined impulse to a local point in the body.
         *
         * @param force The force vector to apply, defined locally in the body frame.
         * @param localPoint A local point in the body to apply the force on.
         */
        Body.prototype.applyLocalImpulse = function (localImpulse, localPoint) {
            if (this.type !== Body.DYNAMIC) {
                return;
            }
            var worldImpulse = Body_applyLocalImpulse_worldImpulse;
            var relativePointWorld = Body_applyLocalImpulse_relativePoint;
            // Transform the force vector to world space
            this.vectorToWorldFrame(localImpulse, worldImpulse);
            this.vectorToWorldFrame(localPoint, relativePointWorld);
            this.applyImpulse(worldImpulse, relativePointWorld);
        };
        /**
         * Should be called whenever you change the body shape or mass.
         */
        Body.prototype.updateMassProperties = function () {
            var halfExtents = Body_updateMassProperties_halfExtents;
            this.invMass = this.mass > 0 ? 1.0 / this.mass : 0;
            var I = this.inertia;
            var fixed = this.fixedRotation;
            // Approximate with AABB box
            this.computeAABB();
            halfExtents.set((this.aabb.upperBound.x - this.aabb.lowerBound.x) / 2, (this.aabb.upperBound.y - this.aabb.lowerBound.y) / 2, (this.aabb.upperBound.z - this.aabb.lowerBound.z) / 2);
            CANNON.Box.calculateInertia(halfExtents, this.mass, I);
            this.invInertia.set(I.x > 0 && !fixed ? 1.0 / I.x : 0, I.y > 0 && !fixed ? 1.0 / I.y : 0, I.z > 0 && !fixed ? 1.0 / I.z : 0);
            this.updateInertiaWorld(true);
        };
        /**
         * Get world velocity of a point in the body.
         * @method getVelocityAtWorldPoint
         * @param  {Vec3} worldPoint
         * @param  {Vec3} result
         * @return {Vec3} The result vector.
         */
        Body.prototype.getVelocityAtWorldPoint = function (worldPoint, result) {
            var r = new CANNON.Vec3();
            worldPoint.vsub(this.position, r);
            this.angularVelocity.cross(r, result);
            this.velocity.vadd(result, result);
            return result;
        };
        /**
         * Move the body forward in time.
         * @param dt Time step
         * @param quatNormalize Set to true to normalize the body quaternion
         * @param quatNormalizeFast If the quaternion should be normalized using "fast" quaternion normalization
         */
        Body.prototype.integrate = function (dt, quatNormalize, quatNormalizeFast) {
            // Save previous position
            this.previousPosition.copy(this.position);
            this.previousQuaternion.copy(this.quaternion);
            if (!(this.type === Body.DYNAMIC || this.type === Body.KINEMATIC) || this.sleepState === Body.SLEEPING) { // Only for dynamic
                return;
            }
            var velo = this.velocity, angularVelo = this.angularVelocity, pos = this.position, force = this.force, torque = this.torque, quat = this.quaternion, invMass = this.invMass, invInertia = this.invInertiaWorld, linearFactor = this.linearFactor;
            var iMdt = invMass * dt;
            velo.x += force.x * iMdt * linearFactor.x;
            velo.y += force.y * iMdt * linearFactor.y;
            velo.z += force.z * iMdt * linearFactor.z;
            var e = invInertia.elements;
            var angularFactor = this.angularFactor;
            var tx = torque.x * angularFactor.x;
            var ty = torque.y * angularFactor.y;
            var tz = torque.z * angularFactor.z;
            angularVelo.x += dt * (e[0] * tx + e[1] * ty + e[2] * tz);
            angularVelo.y += dt * (e[3] * tx + e[4] * ty + e[5] * tz);
            angularVelo.z += dt * (e[6] * tx + e[7] * ty + e[8] * tz);
            // Use new velocity  - leap frog
            pos.x += velo.x * dt;
            pos.y += velo.y * dt;
            pos.z += velo.z * dt;
            quat.integrate(this.angularVelocity, dt, this.angularFactor, quat);
            if (quatNormalize) {
                if (quatNormalizeFast) {
                    quat.normalizeFast();
                }
                else {
                    quat.normalize();
                }
            }
            this.aabbNeedsUpdate = true;
            // Update world inertia
            this.updateInertiaWorld();
        };
        Body.COLLIDE_EVENT_NAME = "collide";
        /**
         * A dynamic body is fully simulated. Can be moved manually by the user, but normally they move according to forces. A dynamic body can collide with all body types. A dynamic body always has finite, non-zero mass.
         */
        Body.DYNAMIC = 1;
        /**
         * A static body does not move during simulation and behaves as if it has infinite mass. Static bodies can be moved manually by setting the position of the body. The velocity of a static body is always zero. Static bodies do not collide with other static or kinematic bodies.
         */
        Body.STATIC = 2;
        /**
         * A kinematic body moves under simulation according to its velocity. They do not respond to forces. They can be moved manually, but normally a kinematic body is moved by setting its velocity. A kinematic body behaves as if it has infinite mass. Kinematic bodies do not collide with other static or kinematic bodies.
         */
        Body.KINEMATIC = 4;
        Body.AWAKE = 0;
        Body.SLEEPY = 1;
        Body.SLEEPING = 2;
        Body.idCounter = 0;
        /**
         * Dispatched after a sleeping body has woken up.
         */
        Body.wakeupEvent = {
            type: "wakeup"
        };
        /**
         * Dispatched after a body has gone in to the sleepy state.
         */
        Body.sleepyEvent = {
            type: "sleepy"
        };
        /**
         * Dispatched after a body has fallen asleep.
         * @event sleep
         */
        Body.sleepEvent = {
            type: "sleep"
        };
        return Body;
    }(CANNON.EventTarget));
    CANNON.Body = Body;
    var tmpVec = new CANNON.Vec3();
    var tmpQuat = new CANNON.Quaternion();
    var torque = new CANNON.Vec3();
    var invI_tau_dt = new CANNON.Vec3();
    var w = new CANNON.Quaternion();
    var wq = new CANNON.Quaternion();
    var Body_updateMassProperties_halfExtents = new CANNON.Vec3();
    var Body_applyForce_r = new CANNON.Vec3();
    var Body_applyForce_rotForce = new CANNON.Vec3();
    var Body_applyLocalForce_worldForce = new CANNON.Vec3();
    var Body_applyLocalForce_relativePointWorld = new CANNON.Vec3();
    var Body_applyImpulse_r = new CANNON.Vec3();
    var Body_applyImpulse_velo = new CANNON.Vec3();
    var Body_applyImpulse_rotVelo = new CANNON.Vec3();
    var Body_applyLocalImpulse_worldImpulse = new CANNON.Vec3();
    var Body_applyLocalImpulse_relativePoint = new CANNON.Vec3();
    var uiw_m1 = new CANNON.Mat3();
    var uiw_m2 = new CANNON.Mat3();
    var uiw_m3 = new CANNON.Mat3();
    var computeAABB_shapeAABB = new CANNON.AABB();
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var Spring = /** @class */ (function () {
        /**
         * A spring, connecting two bodies.
         *
         * @param bodyA
         * @param bodyB
         * @param options
         */
        function Spring(bodyA, bodyB, options) {
            if (options === void 0) { options = {}; }
            this.restLength = typeof (options.restLength) === "number" ? options.restLength : 1;
            this.stiffness = options.stiffness || 100;
            this.damping = options.damping || 1;
            this.bodyA = bodyA;
            this.bodyB = bodyB;
            this.localAnchorA = new CANNON.Vec3();
            this.localAnchorB = new CANNON.Vec3();
            if (options.localAnchorA) {
                this.localAnchorA.copy(options.localAnchorA);
            }
            if (options.localAnchorB) {
                this.localAnchorB.copy(options.localAnchorB);
            }
            if (options.worldAnchorA) {
                this.setWorldAnchorA(options.worldAnchorA);
            }
            if (options.worldAnchorB) {
                this.setWorldAnchorB(options.worldAnchorB);
            }
        }
        /**
         * Set the anchor point on body A, using world coordinates.
         * @param worldAnchorA
         */
        Spring.prototype.setWorldAnchorA = function (worldAnchorA) {
            this.bodyA.pointToLocalFrame(worldAnchorA, this.localAnchorA);
        };
        /**
         * Set the anchor point on body B, using world coordinates.
         * @param worldAnchorB
         */
        Spring.prototype.setWorldAnchorB = function (worldAnchorB) {
            this.bodyB.pointToLocalFrame(worldAnchorB, this.localAnchorB);
        };
        /**
         * Get the anchor point on body A, in world coordinates.
         * @param result The vector to store the result in.
         */
        Spring.prototype.getWorldAnchorA = function (result) {
            this.bodyA.pointToWorldFrame(this.localAnchorA, result);
        };
        /**
         * Get the anchor point on body B, in world coordinates.
         * @param result The vector to store the result in.
         */
        Spring.prototype.getWorldAnchorB = function (result) {
            this.bodyB.pointToWorldFrame(this.localAnchorB, result);
        };
        /**
         * Apply the spring force to the connected bodies.
         */
        Spring.prototype.applyForce = function () {
            var k = this.stiffness, d = this.damping, l = this.restLength, bodyA = this.bodyA, bodyB = this.bodyB, r = applyForce_r, r_unit = applyForce_r_unit, u = applyForce_u, f = applyForce_f, tmp = applyForce_tmp;
            var worldAnchorA = applyForce_worldAnchorA, worldAnchorB = applyForce_worldAnchorB, ri = applyForce_ri, rj = applyForce_rj, ri_x_f = applyForce_ri_x_f, rj_x_f = applyForce_rj_x_f;
            // Get world anchors
            this.getWorldAnchorA(worldAnchorA);
            this.getWorldAnchorB(worldAnchorB);
            // Get offset points
            worldAnchorA.vsub(bodyA.position, ri);
            worldAnchorB.vsub(bodyB.position, rj);
            // Compute distance vector between world anchor points
            worldAnchorB.vsub(worldAnchorA, r);
            var rlen = r.norm();
            r_unit.copy(r);
            r_unit.normalize();
            // Compute relative velocity of the anchor points, u
            bodyB.velocity.vsub(bodyA.velocity, u);
            // Add rotational velocity
            bodyB.angularVelocity.cross(rj, tmp);
            u.vadd(tmp, u);
            bodyA.angularVelocity.cross(ri, tmp);
            u.vsub(tmp, u);
            // F = - k * ( x - L ) - D * ( u )
            r_unit.mult(-k * (rlen - l) - d * u.dot(r_unit), f);
            // Add forces to bodies
            bodyA.force.vsub(f, bodyA.force);
            bodyB.force.vadd(f, bodyB.force);
            // Angular force
            ri.cross(f, ri_x_f);
            rj.cross(f, rj_x_f);
            bodyA.torque.vsub(ri_x_f, bodyA.torque);
            bodyB.torque.vadd(rj_x_f, bodyB.torque);
        };
        return Spring;
    }());
    CANNON.Spring = Spring;
    var applyForce_r = new CANNON.Vec3();
    var applyForce_r_unit = new CANNON.Vec3();
    var applyForce_u = new CANNON.Vec3();
    var applyForce_f = new CANNON.Vec3();
    var applyForce_worldAnchorA = new CANNON.Vec3();
    var applyForce_worldAnchorB = new CANNON.Vec3();
    var applyForce_ri = new CANNON.Vec3();
    var applyForce_rj = new CANNON.Vec3();
    var applyForce_ri_x_f = new CANNON.Vec3();
    var applyForce_rj_x_f = new CANNON.Vec3();
    var applyForce_tmp = new CANNON.Vec3();
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var WheelInfo = /** @class */ (function () {
        /**
         *
         * @param options
         */
        function WheelInfo(options) {
            if (options === void 0) { options = {}; }
            options = CANNON.Utils.defaults(options, {
                chassisConnectionPointLocal: new CANNON.Vec3(),
                chassisConnectionPointWorld: new CANNON.Vec3(),
                directionLocal: new CANNON.Vec3(),
                directionWorld: new CANNON.Vec3(),
                axleLocal: new CANNON.Vec3(),
                axleWorld: new CANNON.Vec3(),
                suspensionRestLength: 1,
                suspensionMaxLength: 2,
                radius: 1,
                suspensionStiffness: 100,
                dampingCompression: 10,
                dampingRelaxation: 10,
                frictionSlip: 10000,
                steering: 0,
                rotation: 0,
                deltaRotation: 0,
                rollInfluence: 0.01,
                maxSuspensionForce: Number.MAX_VALUE,
                isFrontWheel: true,
                clippedInvContactDotSuspension: 1,
                suspensionRelativeVelocity: 0,
                suspensionForce: 0,
                skidInfo: 0,
                suspensionLength: 0,
                maxSuspensionTravel: 1,
                useCustomSlidingRotationalSpeed: false,
                customSlidingRotationalSpeed: -0.1
            });
            this.maxSuspensionTravel = options.maxSuspensionTravel;
            this.customSlidingRotationalSpeed = options.customSlidingRotationalSpeed;
            this.useCustomSlidingRotationalSpeed = options.useCustomSlidingRotationalSpeed;
            this.sliding = false;
            this.chassisConnectionPointLocal = options.chassisConnectionPointLocal.clone();
            this.chassisConnectionPointWorld = options.chassisConnectionPointWorld.clone();
            this.directionLocal = options.directionLocal.clone();
            this.directionWorld = options.directionWorld.clone();
            this.axleLocal = options.axleLocal.clone();
            this.axleWorld = options.axleWorld.clone();
            this.suspensionRestLength = options.suspensionRestLength;
            this.suspensionMaxLength = options.suspensionMaxLength;
            this.radius = options.radius;
            this.suspensionStiffness = options.suspensionStiffness;
            this.dampingCompression = options.dampingCompression;
            this.dampingRelaxation = options.dampingRelaxation;
            this.frictionSlip = options.frictionSlip;
            this.steering = 0;
            this.rotation = 0;
            this.deltaRotation = 0;
            this.rollInfluence = options.rollInfluence;
            this.maxSuspensionForce = options.maxSuspensionForce;
            this.engineForce = 0;
            this.brake = 0;
            this.isFrontWheel = options.isFrontWheel;
            this.clippedInvContactDotSuspension = 1;
            this.suspensionRelativeVelocity = 0;
            this.suspensionForce = 0;
            this.skidInfo = 0;
            this.suspensionLength = 0;
            this.sideImpulse = 0;
            this.forwardImpulse = 0;
            this.raycastResult = new CANNON.RaycastResult();
            this.worldTransform = new CANNON.Transform();
            this.isInContact = false;
        }
        WheelInfo.prototype.updateWheel = function (chassis) {
            var raycastResult = this.raycastResult;
            if (this.isInContact) {
                var project = raycastResult.hitNormalWorld.dot(raycastResult.directionWorld);
                raycastResult.hitPointWorld.vsub(chassis.position, relpos);
                chassis.getVelocityAtWorldPoint(relpos, chassis_velocity_at_contactPoint);
                var projVel = raycastResult.hitNormalWorld.dot(chassis_velocity_at_contactPoint);
                if (project >= -0.1) {
                    this.suspensionRelativeVelocity = 0.0;
                    this.clippedInvContactDotSuspension = 1.0 / 0.1;
                }
                else {
                    var inv = -1 / project;
                    this.suspensionRelativeVelocity = projVel * inv;
                    this.clippedInvContactDotSuspension = inv;
                }
            }
            else {
                // Not in contact : position wheel in a nice (rest length) position
                raycastResult.suspensionLength = this.suspensionRestLength;
                this.suspensionRelativeVelocity = 0.0;
                raycastResult.directionWorld.scale(-1, raycastResult.hitNormalWorld);
                this.clippedInvContactDotSuspension = 1.0;
            }
        };
        return WheelInfo;
    }());
    CANNON.WheelInfo = WheelInfo;
    var chassis_velocity_at_contactPoint = new CANNON.Vec3();
    var relpos = new CANNON.Vec3();
    var chassis_velocity_at_contactPoint = new CANNON.Vec3();
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var RaycastVehicle = /** @class */ (function () {
        /**
         * Vehicle helper class that casts rays from the wheel positions towards the ground and applies forces.
         *
         * @param options
         */
        function RaycastVehicle(options) {
            if (options === void 0) { options = {}; }
            this.chassisBody = options.chassisBody;
            this.wheelInfos = [];
            this.sliding = false;
            this.world = null;
            this.indexRightAxis = typeof (options.indexRightAxis) !== 'undefined' ? options.indexRightAxis : 1;
            this.indexForwardAxis = typeof (options.indexForwardAxis) !== 'undefined' ? options.indexForwardAxis : 0;
            this.indexUpAxis = typeof (options.indexUpAxis) !== 'undefined' ? options.indexUpAxis : 2;
        }
        /**
         * Add a wheel. For information about the options, see WheelInfo.
         *
         * @param options
         */
        RaycastVehicle.prototype.addWheel = function (options) {
            if (options === void 0) { options = {}; }
            var info = new CANNON.WheelInfo(options);
            var index = this.wheelInfos.length;
            this.wheelInfos.push(info);
            return index;
        };
        /**
         * Set the steering value of a wheel.
         *
         * @param value
         * @param wheelIndex
         */
        RaycastVehicle.prototype.setSteeringValue = function (value, wheelIndex) {
            var wheel = this.wheelInfos[wheelIndex];
            wheel.steering = value;
        };
        /**
         * Set the wheel force to apply on one of the wheels each time step
         *
         * @param value
         * @param wheelIndex
         */
        RaycastVehicle.prototype.applyEngineForce = function (value, wheelIndex) {
            this.wheelInfos[wheelIndex].engineForce = value;
        };
        /**
         * Set the braking force of a wheel
         *
         * @param brake
         * @param wheelIndex
         */
        RaycastVehicle.prototype.setBrake = function (brake, wheelIndex) {
            this.wheelInfos[wheelIndex].brake = brake;
        };
        /**
         * Add the vehicle including its constraints to the world.
         *
         * @param world
         */
        RaycastVehicle.prototype.addToWorld = function (world) {
            var constraints = this.constraints;
            world.addBody(this.chassisBody);
            var that = this;
            this.preStepCallback = function () {
                that.updateVehicle(world.dt);
            };
            world.addEventListener('preStep', this.preStepCallback);
            this.world = world;
        };
        /**
         * Get one of the wheel axles, world-oriented.
         * @param axisIndex
         * @param result
         */
        RaycastVehicle.prototype.getVehicleAxisWorld = function (axisIndex, result) {
            result.set(axisIndex === 0 ? 1 : 0, axisIndex === 1 ? 1 : 0, axisIndex === 2 ? 1 : 0);
            this.chassisBody.vectorToWorldFrame(result, result);
        };
        RaycastVehicle.prototype.updateVehicle = function (timeStep) {
            var wheelInfos = this.wheelInfos;
            var numWheels = wheelInfos.length;
            var chassisBody = this.chassisBody;
            for (var i = 0; i < numWheels; i++) {
                this.updateWheelTransform(i);
            }
            this.currentVehicleSpeedKmHour = 3.6 * chassisBody.velocity.norm();
            var forwardWorld = new CANNON.Vec3();
            this.getVehicleAxisWorld(this.indexForwardAxis, forwardWorld);
            if (forwardWorld.dot(chassisBody.velocity) < 0) {
                this.currentVehicleSpeedKmHour *= -1;
            }
            // simulate suspension
            for (var i = 0; i < numWheels; i++) {
                this.castRay(wheelInfos[i]);
            }
            this.updateSuspension(timeStep);
            var impulse = new CANNON.Vec3();
            var relpos = new CANNON.Vec3();
            for (var i = 0; i < numWheels; i++) {
                //apply suspension force
                var wheel = wheelInfos[i];
                var suspensionForce = wheel.suspensionForce;
                if (suspensionForce > wheel.maxSuspensionForce) {
                    suspensionForce = wheel.maxSuspensionForce;
                }
                wheel.raycastResult.hitNormalWorld.scale(suspensionForce * timeStep, impulse);
                wheel.raycastResult.hitPointWorld.vsub(chassisBody.position, relpos);
                chassisBody.applyImpulse(impulse, relpos);
            }
            this.updateFriction(timeStep);
            var hitNormalWorldScaledWithProj = new CANNON.Vec3();
            var fwd = new CANNON.Vec3();
            var vel = new CANNON.Vec3();
            for (i = 0; i < numWheels; i++) {
                var wheel = wheelInfos[i];
                //var relpos = new Vec3();
                //wheel.chassisConnectionPointWorld.vsub(chassisBody.position, relpos);
                chassisBody.getVelocityAtWorldPoint(wheel.chassisConnectionPointWorld, vel);
                // Hack to get the rotation in the correct direction
                var m = 1;
                switch (this.indexUpAxis) {
                    case 1:
                        m = -1;
                        break;
                }
                if (wheel.isInContact) {
                    this.getVehicleAxisWorld(this.indexForwardAxis, fwd);
                    var proj = fwd.dot(wheel.raycastResult.hitNormalWorld);
                    wheel.raycastResult.hitNormalWorld.scale(proj, hitNormalWorldScaledWithProj);
                    fwd.vsub(hitNormalWorldScaledWithProj, fwd);
                    var proj2 = fwd.dot(vel);
                    wheel.deltaRotation = m * proj2 * timeStep / wheel.radius;
                }
                if ((wheel.sliding || !wheel.isInContact) && wheel.engineForce !== 0 && wheel.useCustomSlidingRotationalSpeed) {
                    // Apply custom rotation when accelerating and sliding
                    wheel.deltaRotation = (wheel.engineForce > 0 ? 1 : -1) * wheel.customSlidingRotationalSpeed * timeStep;
                }
                // Lock wheels
                if (Math.abs(wheel.brake) > Math.abs(wheel.engineForce)) {
                    wheel.deltaRotation = 0;
                }
                wheel.rotation += wheel.deltaRotation; // Use the old value
                wheel.deltaRotation *= 0.99; // damping of rotation when not in contact
            }
        };
        RaycastVehicle.prototype.updateSuspension = function (deltaTime) {
            var chassisBody = this.chassisBody;
            var chassisMass = chassisBody.mass;
            var wheelInfos = this.wheelInfos;
            var numWheels = wheelInfos.length;
            for (var w_it = 0; w_it < numWheels; w_it++) {
                var wheel = wheelInfos[w_it];
                if (wheel.isInContact) {
                    var force;
                    // Spring
                    var susp_length = wheel.suspensionRestLength;
                    var current_length = wheel.suspensionLength;
                    var length_diff = (susp_length - current_length);
                    force = wheel.suspensionStiffness * length_diff * wheel.clippedInvContactDotSuspension;
                    // Damper
                    var projected_rel_vel = wheel.suspensionRelativeVelocity;
                    var susp_damping;
                    if (projected_rel_vel < 0) {
                        susp_damping = wheel.dampingCompression;
                    }
                    else {
                        susp_damping = wheel.dampingRelaxation;
                    }
                    force -= susp_damping * projected_rel_vel;
                    wheel.suspensionForce = force * chassisMass;
                    if (wheel.suspensionForce < 0) {
                        wheel.suspensionForce = 0;
                    }
                }
                else {
                    wheel.suspensionForce = 0;
                }
            }
        };
        /**
         * Remove the vehicle including its constraints from the world.
         *
         * @param world
         */
        RaycastVehicle.prototype.removeFromWorld = function (world) {
            var constraints = this.constraints;
            world.remove(this.chassisBody);
            world.removeEventListener('preStep', this.preStepCallback);
            this.world = null;
        };
        RaycastVehicle.prototype.castRay = function (wheel) {
            var rayvector = castRay_rayvector;
            var target = castRay_target;
            this.updateWheelTransformWorld(wheel);
            var chassisBody = this.chassisBody;
            var depth = -1;
            var raylen = wheel.suspensionRestLength + wheel.radius;
            wheel.directionWorld.scale(raylen, rayvector);
            var source = wheel.chassisConnectionPointWorld;
            source.vadd(rayvector, target);
            var raycastResult = wheel.raycastResult;
            var param = 0;
            raycastResult.reset();
            // Turn off ray collision with the chassis temporarily
            var oldState = chassisBody.collisionResponse;
            chassisBody.collisionResponse = false;
            // Cast ray against world
            this.world.rayTest(source, target, raycastResult);
            chassisBody.collisionResponse = oldState;
            var object = raycastResult.body;
            wheel.raycastResult.groundObject = 0; //?
            if (object) {
                depth = raycastResult.distance;
                wheel.raycastResult.hitNormalWorld = raycastResult.hitNormalWorld;
                wheel.isInContact = true;
                var hitDistance = raycastResult.distance;
                wheel.suspensionLength = hitDistance - wheel.radius;
                // clamp on max suspension travel
                var minSuspensionLength = wheel.suspensionRestLength - wheel.maxSuspensionTravel;
                var maxSuspensionLength = wheel.suspensionRestLength + wheel.maxSuspensionTravel;
                if (wheel.suspensionLength < minSuspensionLength) {
                    wheel.suspensionLength = minSuspensionLength;
                }
                if (wheel.suspensionLength > maxSuspensionLength) {
                    wheel.suspensionLength = maxSuspensionLength;
                    wheel.raycastResult.reset();
                }
                var denominator = wheel.raycastResult.hitNormalWorld.dot(wheel.directionWorld);
                var chassis_velocity_at_contactPoint = new CANNON.Vec3();
                chassisBody.getVelocityAtWorldPoint(wheel.raycastResult.hitPointWorld, chassis_velocity_at_contactPoint);
                var projVel = wheel.raycastResult.hitNormalWorld.dot(chassis_velocity_at_contactPoint);
                if (denominator >= -0.1) {
                    wheel.suspensionRelativeVelocity = 0;
                    wheel.clippedInvContactDotSuspension = 1 / 0.1;
                }
                else {
                    var inv = -1 / denominator;
                    wheel.suspensionRelativeVelocity = projVel * inv;
                    wheel.clippedInvContactDotSuspension = inv;
                }
            }
            else {
                //put wheel info as in rest position
                wheel.suspensionLength = wheel.suspensionRestLength + 0 * wheel.maxSuspensionTravel;
                wheel.suspensionRelativeVelocity = 0.0;
                wheel.directionWorld.scale(-1, wheel.raycastResult.hitNormalWorld);
                wheel.clippedInvContactDotSuspension = 1.0;
            }
            return depth;
        };
        RaycastVehicle.prototype.updateWheelTransformWorld = function (wheel) {
            wheel.isInContact = false;
            var chassisBody = this.chassisBody;
            chassisBody.pointToWorldFrame(wheel.chassisConnectionPointLocal, wheel.chassisConnectionPointWorld);
            chassisBody.vectorToWorldFrame(wheel.directionLocal, wheel.directionWorld);
            chassisBody.vectorToWorldFrame(wheel.axleLocal, wheel.axleWorld);
        };
        /**
         * Update one of the wheel transform.
         * Note when rendering wheels: during each step, wheel transforms are updated BEFORE the chassis; ie. their position becomes invalid after the step. Thus when you render wheels, you must update wheel transforms before rendering them. See raycastVehicle demo for an example.
         *
         * @param wheelIndex The wheel index to update.
         */
        RaycastVehicle.prototype.updateWheelTransform = function (wheelIndex) {
            var up = tmpVec4;
            var right = tmpVec5;
            var fwd = tmpVec6;
            var wheel = this.wheelInfos[wheelIndex];
            this.updateWheelTransformWorld(wheel);
            wheel.directionLocal.scale(-1, up);
            right.copy(wheel.axleLocal);
            up.cross(right, fwd);
            fwd.normalize();
            right.normalize();
            // Rotate around steering over the wheelAxle
            var steering = wheel.steering;
            var steeringOrn = new CANNON.Quaternion();
            steeringOrn.setFromAxisAngle(up, steering);
            var rotatingOrn = new CANNON.Quaternion();
            rotatingOrn.setFromAxisAngle(right, wheel.rotation);
            // World rotation of the wheel
            var q = wheel.worldTransform.quaternion;
            this.chassisBody.quaternion.mult(steeringOrn, q);
            q.mult(rotatingOrn, q);
            q.normalize();
            // world position of the wheel
            var p = wheel.worldTransform.position;
            p.copy(wheel.directionWorld);
            p.scale(wheel.suspensionLength, p);
            p.vadd(wheel.chassisConnectionPointWorld, p);
        };
        /**
         * Get the world transform of one of the wheels
         *
         * @param wheelIndex
         */
        RaycastVehicle.prototype.getWheelTransformWorld = function (wheelIndex) {
            return this.wheelInfos[wheelIndex].worldTransform;
        };
        RaycastVehicle.prototype.updateFriction = function (timeStep) {
            var surfNormalWS_scaled_proj = updateFriction_surfNormalWS_scaled_proj;
            //calculate the impulse, so that the wheels don't move sidewards
            var wheelInfos = this.wheelInfos;
            var numWheels = wheelInfos.length;
            var chassisBody = this.chassisBody;
            var forwardWS = updateFriction_forwardWS;
            var axle = updateFriction_axle;
            var numWheelsOnGround = 0;
            for (var i = 0; i < numWheels; i++) {
                var wheel = wheelInfos[i];
                var groundObject = wheel.raycastResult.body;
                if (groundObject) {
                    numWheelsOnGround++;
                }
                wheel.sideImpulse = 0;
                wheel.forwardImpulse = 0;
                if (!forwardWS[i]) {
                    forwardWS[i] = new CANNON.Vec3();
                }
                if (!axle[i]) {
                    axle[i] = new CANNON.Vec3();
                }
            }
            for (var i = 0; i < numWheels; i++) {
                var wheel = wheelInfos[i];
                var groundObject = wheel.raycastResult.body;
                if (groundObject) {
                    var axlei = axle[i];
                    var wheelTrans = this.getWheelTransformWorld(i);
                    // Get world axle
                    wheelTrans.vectorToWorldFrame(directions[this.indexRightAxis], axlei);
                    var surfNormalWS = wheel.raycastResult.hitNormalWorld;
                    var proj = axlei.dot(surfNormalWS);
                    surfNormalWS.scale(proj, surfNormalWS_scaled_proj);
                    axlei.vsub(surfNormalWS_scaled_proj, axlei);
                    axlei.normalize();
                    surfNormalWS.cross(axlei, forwardWS[i]);
                    forwardWS[i].normalize();
                    wheel.sideImpulse = resolveSingleBilateral(chassisBody, wheel.raycastResult.hitPointWorld, groundObject, wheel.raycastResult.hitPointWorld, axlei);
                    wheel.sideImpulse *= sideFrictionStiffness2;
                }
            }
            var sideFactor = 1;
            var fwdFactor = 0.5;
            this.sliding = false;
            for (var i = 0; i < numWheels; i++) {
                var wheel = wheelInfos[i];
                var groundObject = wheel.raycastResult.body;
                var rollingFriction = 0;
                wheel.slipInfo = 1;
                if (groundObject) {
                    var defaultRollingFrictionImpulse = 0;
                    var maxImpulse = wheel.brake ? wheel.brake : defaultRollingFrictionImpulse;
                    // btWheelContactPoint contactPt(chassisBody,groundObject,wheelInfraycastInfo.hitPointWorld,forwardWS[wheel],maxImpulse);
                    // rollingFriction = calcRollingFriction(contactPt);
                    rollingFriction = calcRollingFriction(chassisBody, groundObject, wheel.raycastResult.hitPointWorld, forwardWS[i], maxImpulse);
                    rollingFriction += wheel.engineForce * timeStep;
                    // rollingFriction = 0;
                    var factor = maxImpulse / rollingFriction;
                    wheel.slipInfo *= factor;
                }
                //switch between active rolling (throttle), braking and non-active rolling friction (nthrottle/break)
                wheel.forwardImpulse = 0;
                wheel.skidInfo = 1;
                if (groundObject) {
                    wheel.skidInfo = 1;
                    var maximp = wheel.suspensionForce * timeStep * wheel.frictionSlip;
                    var maximpSide = maximp;
                    var maximpSquared = maximp * maximpSide;
                    wheel.forwardImpulse = rollingFriction; //wheelInfo.engineForce* timeStep;
                    var x = wheel.forwardImpulse * fwdFactor;
                    var y = wheel.sideImpulse * sideFactor;
                    var impulseSquared = x * x + y * y;
                    wheel.sliding = false;
                    if (impulseSquared > maximpSquared) {
                        this.sliding = true;
                        wheel.sliding = true;
                        var factor = maximp / Math.sqrt(impulseSquared);
                        wheel.skidInfo *= factor;
                    }
                }
            }
            if (this.sliding) {
                for (var i = 0; i < numWheels; i++) {
                    var wheel = wheelInfos[i];
                    if (wheel.sideImpulse !== 0) {
                        if (wheel.skidInfo < 1) {
                            wheel.forwardImpulse *= wheel.skidInfo;
                            wheel.sideImpulse *= wheel.skidInfo;
                        }
                    }
                }
            }
            // apply the impulses
            for (var i = 0; i < numWheels; i++) {
                var wheel = wheelInfos[i];
                var rel_pos = new CANNON.Vec3();
                wheel.raycastResult.hitPointWorld.vsub(chassisBody.position, rel_pos);
                // cannons applyimpulse is using world coord for the position
                //rel_pos.copy(wheel.raycastResult.hitPointWorld);
                if (wheel.forwardImpulse !== 0) {
                    var impulse = new CANNON.Vec3();
                    forwardWS[i].scale(wheel.forwardImpulse, impulse);
                    chassisBody.applyImpulse(impulse, rel_pos);
                }
                if (wheel.sideImpulse !== 0) {
                    var groundObject = wheel.raycastResult.body;
                    var rel_pos2 = new CANNON.Vec3();
                    wheel.raycastResult.hitPointWorld.vsub(groundObject.position, rel_pos2);
                    //rel_pos2.copy(wheel.raycastResult.hitPointWorld);
                    var sideImp = new CANNON.Vec3();
                    axle[i].scale(wheel.sideImpulse, sideImp);
                    // Scale the relative position in the up direction with rollInfluence.
                    // If rollInfluence is 1, the impulse will be applied on the hitPoint (easy to roll over), if it is zero it will be applied in the same plane as the center of mass (not easy to roll over).
                    chassisBody.vectorToLocalFrame(rel_pos, rel_pos);
                    rel_pos['xyz'[this.indexUpAxis]] *= wheel.rollInfluence;
                    chassisBody.vectorToWorldFrame(rel_pos, rel_pos);
                    chassisBody.applyImpulse(sideImp, rel_pos);
                    //apply friction impulse on the ground
                    sideImp.scale(-1, sideImp);
                    groundObject.applyImpulse(sideImp, rel_pos2);
                }
            }
        };
        return RaycastVehicle;
    }());
    CANNON.RaycastVehicle = RaycastVehicle;
    var tmpVec1 = new CANNON.Vec3();
    var tmpVec2 = new CANNON.Vec3();
    var tmpVec3 = new CANNON.Vec3();
    var tmpVec4 = new CANNON.Vec3();
    var tmpVec5 = new CANNON.Vec3();
    var tmpVec6 = new CANNON.Vec3();
    var tmpRay = new CANNON.Ray();
    var torque = new CANNON.Vec3();
    var castRay_rayvector = new CANNON.Vec3();
    var castRay_target = new CANNON.Vec3();
    var directions = [
        new CANNON.Vec3(1, 0, 0),
        new CANNON.Vec3(0, 1, 0),
        new CANNON.Vec3(0, 0, 1)
    ];
    var updateFriction_surfNormalWS_scaled_proj = new CANNON.Vec3();
    var updateFriction_axle = [];
    var updateFriction_forwardWS = [];
    var sideFrictionStiffness2 = 1;
    var calcRollingFriction_vel1 = new CANNON.Vec3();
    var calcRollingFriction_vel2 = new CANNON.Vec3();
    var calcRollingFriction_vel = new CANNON.Vec3();
    function calcRollingFriction(body0, body1, frictionPosWorld, frictionDirectionWorld, maxImpulse) {
        var j1 = 0;
        var contactPosWorld = frictionPosWorld;
        // var rel_pos1 = new Vec3();
        // var rel_pos2 = new Vec3();
        var vel1 = calcRollingFriction_vel1;
        var vel2 = calcRollingFriction_vel2;
        var vel = calcRollingFriction_vel;
        // contactPosWorld.vsub(body0.position, rel_pos1);
        // contactPosWorld.vsub(body1.position, rel_pos2);
        body0.getVelocityAtWorldPoint(contactPosWorld, vel1);
        body1.getVelocityAtWorldPoint(contactPosWorld, vel2);
        vel1.vsub(vel2, vel);
        var vrel = frictionDirectionWorld.dot(vel);
        var denom0 = computeImpulseDenominator(body0, frictionPosWorld, frictionDirectionWorld);
        var denom1 = computeImpulseDenominator(body1, frictionPosWorld, frictionDirectionWorld);
        var relaxation = 1;
        var jacDiagABInv = relaxation / (denom0 + denom1);
        // calculate j that moves us to zero relative velocity
        j1 = -vrel * jacDiagABInv;
        if (maxImpulse < j1) {
            j1 = maxImpulse;
        }
        if (j1 < -maxImpulse) {
            j1 = -maxImpulse;
        }
        return j1;
    }
    var computeImpulseDenominator_r0 = new CANNON.Vec3();
    var computeImpulseDenominator_c0 = new CANNON.Vec3();
    var computeImpulseDenominator_vec = new CANNON.Vec3();
    var computeImpulseDenominator_m = new CANNON.Vec3();
    function computeImpulseDenominator(body, pos, normal) {
        var r0 = computeImpulseDenominator_r0;
        var c0 = computeImpulseDenominator_c0;
        var vec = computeImpulseDenominator_vec;
        var m = computeImpulseDenominator_m;
        pos.vsub(body.position, r0);
        r0.cross(normal, c0);
        body.invInertiaWorld.vmult(c0, m);
        m.cross(r0, vec);
        return body.invMass + normal.dot(vec);
    }
    var resolveSingleBilateral_vel1 = new CANNON.Vec3();
    var resolveSingleBilateral_vel2 = new CANNON.Vec3();
    var resolveSingleBilateral_vel = new CANNON.Vec3();
    //bilateral constraint between two dynamic objects
    function resolveSingleBilateral(body1, pos1, body2, pos2, normal) {
        var normalLenSqr = normal.norm2();
        if (normalLenSqr > 1.1) {
            return 0; // no impulse
        }
        // var rel_pos1 = new Vec3();
        // var rel_pos2 = new Vec3();
        // pos1.vsub(body1.position, rel_pos1);
        // pos2.vsub(body2.position, rel_pos2);
        var vel1 = resolveSingleBilateral_vel1;
        var vel2 = resolveSingleBilateral_vel2;
        var vel = resolveSingleBilateral_vel;
        body1.getVelocityAtWorldPoint(pos1, vel1);
        body2.getVelocityAtWorldPoint(pos2, vel2);
        vel1.vsub(vel2, vel);
        var rel_vel = normal.dot(vel);
        var contactDamping = 0.2;
        var massTerm = 1 / (body1.invMass + body2.invMass);
        var impulse = -contactDamping * rel_vel * massTerm;
        return impulse;
    }
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var RigidVehicle = /** @class */ (function () {
        /**
         * Simple vehicle helper class with spherical rigid body wheels.
         *
         * @param options
         */
        function RigidVehicle(options) {
            if (options === void 0) { options = {}; }
            this.wheelBodies = [];
            this.coordinateSystem = typeof (options.coordinateSystem) === 'undefined' ? new CANNON.Vec3(1, 2, 3) : options.coordinateSystem.clone();
            this.chassisBody = options.chassisBody;
            if (!this.chassisBody) {
                // No chassis body given. Create it!
                var chassisShape = new CANNON.Box(new CANNON.Vec3(5, 2, 0.5));
                throw "下一行代码有问题？！";
                // this.chassisBody = new Body(1, chassisShape);
            }
            this.constraints = [];
            this.wheelAxes = [];
            this.wheelForces = [];
        }
        /**
         * Add a wheelraycastClosest(
         *
         * @param options
         */
        RigidVehicle.prototype.addWheel = function (options) {
            if (options === void 0) { options = {}; }
            var wheelBody = options.body;
            if (!wheelBody) {
                throw "下一行代码有问题？！";
                // wheelBody = new Body(1, new Sphere(1.2));
            }
            this.wheelBodies.push(wheelBody);
            this.wheelForces.push(0);
            // Position constrain wheels
            var zero = new CANNON.Vec3();
            var position = typeof (options.position) !== 'undefined' ? options.position.clone() : new CANNON.Vec3();
            // Set position locally to the chassis
            var worldPosition = new CANNON.Vec3();
            this.chassisBody.pointToWorldFrame(position, worldPosition);
            wheelBody.position.set(worldPosition.x, worldPosition.y, worldPosition.z);
            // Constrain wheel
            var axis = typeof (options.axis) !== 'undefined' ? options.axis.clone() : new CANNON.Vec3(0, 1, 0);
            this.wheelAxes.push(axis);
            var hingeConstraint = new CANNON.HingeConstraint(this.chassisBody, wheelBody, {
                pivotA: position,
                axisA: axis,
                pivotB: CANNON.Vec3.ZERO,
                axisB: axis,
                collideConnected: false
            });
            this.constraints.push(hingeConstraint);
            return this.wheelBodies.length - 1;
        };
        /**
         * Set the steering value of a wheel.
         *
         * @param value
         * @param wheelIndex
         *
         * @todo check coordinateSystem
         */
        RigidVehicle.prototype.setSteeringValue = function (value, wheelIndex) {
            // Set angle of the hinge axis
            var axis = this.wheelAxes[wheelIndex];
            var c = Math.cos(value), s = Math.sin(value), x = axis.x, y = axis.y;
            this.constraints[wheelIndex].axisA.set(c * x - s * y, s * x + c * y, 0);
        };
        /**
         * Set the target rotational speed of the hinge constraint.
         *
         * @param value
         * @param wheelIndex
         */
        RigidVehicle.prototype.setMotorSpeed = function (value, wheelIndex) {
            var hingeConstraint = this.constraints[wheelIndex];
            hingeConstraint.enableMotor();
            hingeConstraint.motorTargetVelocity = value;
        };
        /**
         * Set the target rotational speed of the hinge constraint.
         *
         * @param wheelIndex
         */
        RigidVehicle.prototype.disableMotor = function (wheelIndex) {
            var hingeConstraint = this.constraints[wheelIndex];
            hingeConstraint.disableMotor();
        };
        /**
         * Set the wheel force to apply on one of the wheels each time step
         *
         * @param value
         * @param wheelIndex
         */
        RigidVehicle.prototype.setWheelForce = function (value, wheelIndex) {
            this.wheelForces[wheelIndex] = value;
        };
        /**
         * Apply a torque on one of the wheels.
         *
         * @param value
         * @param wheelIndex
         */
        RigidVehicle.prototype.applyWheelForce = function (value, wheelIndex) {
            var axis = this.wheelAxes[wheelIndex];
            var wheelBody = this.wheelBodies[wheelIndex];
            var bodyTorque = wheelBody.torque;
            axis.scale(value, torque);
            wheelBody.vectorToWorldFrame(torque, torque);
            bodyTorque.vadd(torque, bodyTorque);
        };
        /**
         * Add the vehicle including its constraints to the world.
         *
         * @param world
         */
        RigidVehicle.prototype.addToWorld = function (world) {
            var constraints = this.constraints;
            var bodies = this.wheelBodies.concat([this.chassisBody]);
            for (var i = 0; i < bodies.length; i++) {
                world.addBody(bodies[i]);
            }
            for (var i = 0; i < constraints.length; i++) {
                world.addConstraint(constraints[i]);
            }
            world.addEventListener('preStep', this._update.bind(this));
        };
        RigidVehicle.prototype._update = function () {
            var wheelForces = this.wheelForces;
            for (var i = 0; i < wheelForces.length; i++) {
                this.applyWheelForce(wheelForces[i], i);
            }
        };
        /**
         * Remove the vehicle including its constraints from the world.
         * @param world
         */
        RigidVehicle.prototype.removeFromWorld = function (world) {
            var constraints = this.constraints;
            var bodies = this.wheelBodies.concat([this.chassisBody]);
            for (var i = 0; i < bodies.length; i++) {
                world.remove(bodies[i]);
            }
            for (var i = 0; i < constraints.length; i++) {
                world.removeConstraint(constraints[i]);
            }
        };
        /**
         * Get current rotational velocity of a wheel
         *
         * @param wheelIndex
         */
        RigidVehicle.prototype.getWheelSpeed = function (wheelIndex) {
            var axis = this.wheelAxes[wheelIndex];
            var wheelBody = this.wheelBodies[wheelIndex];
            var w = wheelBody.angularVelocity;
            this.chassisBody.vectorToWorldFrame(axis, worldAxis);
            return w.dot(worldAxis);
        };
        return RigidVehicle;
    }());
    CANNON.RigidVehicle = RigidVehicle;
    var torque = new CANNON.Vec3();
    var worldAxis = new CANNON.Vec3();
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var SPHSystem = /** @class */ (function () {
        /**
         * Smoothed-particle hydrodynamics system
         */
        function SPHSystem() {
            this.particles = [];
            this.density = 1;
            this.smoothingRadius = 1;
            this.speedOfSound = 1;
            this.viscosity = 0.01;
            this.eps = 0.000001;
            // Stuff Computed per particle
            this.pressures = [];
            this.densities = [];
            this.neighbors = [];
        }
        /**
         * Add a particle to the system.
         *
         * @param particle
         */
        SPHSystem.prototype.add = function (particle) {
            this.particles.push(particle);
            if (this.neighbors.length < this.particles.length) {
                this.neighbors.push([]);
            }
        };
        /**
         * Remove a particle from the system.
         *
         * @param particle
         */
        SPHSystem.prototype.remove = function (particle) {
            var idx = this.particles.indexOf(particle);
            if (idx !== -1) {
                this.particles.splice(idx, 1);
                if (this.neighbors.length > this.particles.length) {
                    this.neighbors.pop();
                }
            }
        };
        /**
         * Get neighbors within smoothing volume, save in the array neighbors
         *
         * @param particle
         * @param neighbors
         */
        SPHSystem.prototype.getNeighbors = function (particle, neighbors) {
            var N = this.particles.length, id = particle.id, R2 = this.smoothingRadius * this.smoothingRadius, dist = SPHSystem_getNeighbors_dist;
            for (var i = 0; i !== N; i++) {
                var p = this.particles[i];
                p.position.vsub(particle.position, dist);
                if (id !== p.id && dist.norm2() < R2) {
                    neighbors.push(p);
                }
            }
        };
        SPHSystem.prototype.update = function () {
            var N = this.particles.length, dist = SPHSystem_update_dist, cs = this.speedOfSound, eps = this.eps;
            for (var i = 0; i !== N; i++) {
                var p = this.particles[i]; // Current particle
                var neighbors = this.neighbors[i];
                // Get neighbors
                neighbors.length = 0;
                this.getNeighbors(p, neighbors);
                neighbors.push(this.particles[i]); // Add current too
                var numNeighbors = neighbors.length;
                // Accumulate density for the particle
                var sum = 0.0;
                for (var j = 0; j !== numNeighbors; j++) {
                    //printf("Current particle has position %f %f %f\n",objects[id].pos.x(),objects[id].pos.y(),objects[id].pos.z());
                    p.position.vsub(neighbors[j].position, dist);
                    var len = dist.norm();
                    var weight = this.w(len);
                    sum += neighbors[j].mass * weight;
                }
                // Save
                this.densities[i] = sum;
                this.pressures[i] = cs * cs * (this.densities[i] - this.density);
            }
            // Add forces
            // Sum to these accelerations
            var a_pressure = SPHSystem_update_a_pressure;
            var a_visc = SPHSystem_update_a_visc;
            var gradW = SPHSystem_update_gradW;
            var r_vec = SPHSystem_update_r_vec;
            var u = SPHSystem_update_u;
            for (var i = 0; i !== N; i++) {
                var particle = this.particles[i];
                a_pressure.set(0, 0, 0);
                a_visc.set(0, 0, 0);
                // Init vars
                var Pij;
                var nabla;
                var Vij;
                // Sum up for all other neighbors
                var neighbors = this.neighbors[i];
                var numNeighbors = neighbors.length;
                //printf("Neighbors: ");
                for (var j = 0; j !== numNeighbors; j++) {
                    var neighbor = neighbors[j];
                    //printf("%d ",nj);
                    // Get r once for all..
                    particle.position.vsub(neighbor.position, r_vec);
                    var r = r_vec.norm();
                    // Pressure contribution
                    Pij = -neighbor.mass * (this.pressures[i] / (this.densities[i] * this.densities[i] + eps) + this.pressures[j] / (this.densities[j] * this.densities[j] + eps));
                    this.gradw(r_vec, gradW);
                    // Add to pressure acceleration
                    gradW.mult(Pij, gradW);
                    a_pressure.vadd(gradW, a_pressure);
                    // Viscosity contribution
                    neighbor.velocity.vsub(particle.velocity, u);
                    u.mult(1.0 / (0.0001 + this.densities[i] * this.densities[j]) * this.viscosity * neighbor.mass, u);
                    nabla = this.nablaw(r);
                    u.mult(nabla, u);
                    // Add to viscosity acceleration
                    a_visc.vadd(u, a_visc);
                }
                // Calculate force
                a_visc.mult(particle.mass, a_visc);
                a_pressure.mult(particle.mass, a_pressure);
                // Add force to particles
                particle.force.vadd(a_visc, particle.force);
                particle.force.vadd(a_pressure, particle.force);
            }
        };
        // Calculate the weight using the W(r) weightfunction
        SPHSystem.prototype.w = function (r) {
            // 315
            var h = this.smoothingRadius;
            return 315.0 / (64.0 * Math.PI * Math.pow(h, 9)) * Math.pow(h * h - r * r, 3);
        };
        // calculate gradient of the weight function
        SPHSystem.prototype.gradw = function (rVec, resultVec) {
            var r = rVec.norm(), h = this.smoothingRadius;
            rVec.mult(945.0 / (32.0 * Math.PI * Math.pow(h, 9)) * Math.pow((h * h - r * r), 2), resultVec);
        };
        // Calculate nabla(W)
        SPHSystem.prototype.nablaw = function (r) {
            var h = this.smoothingRadius;
            var nabla = 945.0 / (32.0 * Math.PI * Math.pow(h, 9)) * (h * h - r * r) * (7 * r * r - 3 * h * h);
            return nabla;
        };
        return SPHSystem;
    }());
    CANNON.SPHSystem = SPHSystem;
    var SPHSystem_getNeighbors_dist = new CANNON.Vec3();
    var SPHSystem_update_dist = new CANNON.Vec3();
    var SPHSystem_update_a_pressure = new CANNON.Vec3();
    var SPHSystem_update_a_visc = new CANNON.Vec3();
    var SPHSystem_update_gradW = new CANNON.Vec3();
    var SPHSystem_update_r_vec = new CANNON.Vec3();
    var SPHSystem_update_u = new CANNON.Vec3(); // Relative velocity
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var Equation = /** @class */ (function () {
        /**
         * Equation base class
         * @class Equation
         * @constructor
         * @author schteppe
         * @param {Body} bi
         * @param {Body} bj
         * @param {Number} minForce Minimum (read: negative max) force to be applied by the constraint.
         * @param {Number} maxForce Maximum (read: positive max) force to be applied by the constraint.
         */
        function Equation(bi, bj, minForce, maxForce) {
            this.id = Equation.id++;
            this.minForce = typeof (minForce) === "undefined" ? -1e6 : minForce;
            this.maxForce = typeof (maxForce) === "undefined" ? 1e6 : maxForce;
            this.bi = bi;
            this.bj = bj;
            this.a = 0.0;
            this.b = 0.0;
            this.eps = 0.0;
            this.jacobianElementA = new CANNON.JacobianElement();
            this.jacobianElementB = new CANNON.JacobianElement();
            this.enabled = true;
            this.multiplier = 0;
            // Set typical spook params
            this.setSpookParams(1e7, 4, 1 / 60);
        }
        /**
         * Recalculates a,b,eps.
         */
        Equation.prototype.setSpookParams = function (stiffness, relaxation, timeStep) {
            var d = relaxation, k = stiffness, h = timeStep;
            this.a = 4.0 / (h * (1 + 4 * d));
            this.b = (4.0 * d) / (1 + 4 * d);
            this.eps = 4.0 / (h * h * k * (1 + 4 * d));
        };
        /**
         * Computes the RHS of the SPOOK equation
         */
        Equation.prototype.computeB = function (a, b, h) {
            var GW = this.computeGW(), Gq = this.computeGq(), GiMf = this.computeGiMf();
            return -Gq * a - GW * b - GiMf * h;
        };
        /**
         * Computes G*q, where q are the generalized body coordinates
         */
        Equation.prototype.computeGq = function () {
            var GA = this.jacobianElementA, GB = this.jacobianElementB, bi = this.bi, bj = this.bj, xi = bi.position, xj = bj.position;
            return GA.spatial.dot(xi) + GB.spatial.dot(xj);
        };
        /**
         * Computes G*W, where W are the body velocities
         */
        Equation.prototype.computeGW = function () {
            var GA = this.jacobianElementA, GB = this.jacobianElementB, bi = this.bi, bj = this.bj, vi = bi.velocity, vj = bj.velocity, wi = bi.angularVelocity, wj = bj.angularVelocity;
            return GA.multiplyVectors(vi, wi) + GB.multiplyVectors(vj, wj);
        };
        /**
         * Computes G*Wlambda, where W are the body velocities
         */
        Equation.prototype.computeGWlambda = function () {
            var GA = this.jacobianElementA, GB = this.jacobianElementB, bi = this.bi, bj = this.bj, vi = bi.vlambda, vj = bj.vlambda, wi = bi.wlambda, wj = bj.wlambda;
            return GA.multiplyVectors(vi, wi) + GB.multiplyVectors(vj, wj);
        };
        /**
         * Computes G*inv(M)*f, where M is the mass matrix with diagonal blocks for each body, and f are the forces on the bodies.
         */
        Equation.prototype.computeGiMf = function () {
            var GA = this.jacobianElementA, GB = this.jacobianElementB, bi = this.bi, bj = this.bj, fi = bi.force, ti = bi.torque, fj = bj.force, tj = bj.torque, invMassi = bi.invMassSolve, invMassj = bj.invMassSolve;
            fi.scale(invMassi, iMfi);
            fj.scale(invMassj, iMfj);
            bi.invInertiaWorldSolve.vmult(ti, invIi_vmult_taui);
            bj.invInertiaWorldSolve.vmult(tj, invIj_vmult_tauj);
            return GA.multiplyVectors(iMfi, invIi_vmult_taui) + GB.multiplyVectors(iMfj, invIj_vmult_tauj);
        };
        /**
         * Computes G*inv(M)*G'
         */
        Equation.prototype.computeGiMGt = function () {
            var GA = this.jacobianElementA, GB = this.jacobianElementB, bi = this.bi, bj = this.bj, invMassi = bi.invMassSolve, invMassj = bj.invMassSolve, invIi = bi.invInertiaWorldSolve, invIj = bj.invInertiaWorldSolve, result = invMassi + invMassj;
            invIi.vmult(GA.rotational, tmp);
            result += tmp.dot(GA.rotational);
            invIj.vmult(GB.rotational, tmp);
            result += tmp.dot(GB.rotational);
            return result;
        };
        /**
         * Add constraint velocity to the bodies.
         */
        Equation.prototype.addToWlambda = function (deltalambda) {
            var GA = this.jacobianElementA, GB = this.jacobianElementB, bi = this.bi, bj = this.bj, temp = addToWlambda_temp;
            // Add to linear velocity
            // v_lambda += inv(M) * delta_lamba * G
            bi.vlambda.addScaledVector(bi.invMassSolve * deltalambda, GA.spatial, bi.vlambda);
            bj.vlambda.addScaledVector(bj.invMassSolve * deltalambda, GB.spatial, bj.vlambda);
            // Add to angular velocity
            bi.invInertiaWorldSolve.vmult(GA.rotational, temp);
            bi.wlambda.addScaledVector(deltalambda, temp, bi.wlambda);
            bj.invInertiaWorldSolve.vmult(GB.rotational, temp);
            bj.wlambda.addScaledVector(deltalambda, temp, bj.wlambda);
        };
        /**
         * Compute the denominator part of the SPOOK equation: C = G*inv(M)*G' + eps
         */
        Equation.prototype.computeC = function () {
            return this.computeGiMGt() + this.eps;
        };
        Equation.id = 0;
        return Equation;
    }());
    CANNON.Equation = Equation;
    var zero = new CANNON.Vec3();
    var iMfi = new CANNON.Vec3();
    var iMfj = new CANNON.Vec3();
    var invIi_vmult_taui = new CANNON.Vec3();
    var invIj_vmult_tauj = new CANNON.Vec3();
    var tmp = new CANNON.Vec3();
    var addToWlambda_temp = new CANNON.Vec3();
    var addToWlambda_Gi = new CANNON.Vec3();
    var addToWlambda_Gj = new CANNON.Vec3();
    var addToWlambda_ri = new CANNON.Vec3();
    var addToWlambda_rj = new CANNON.Vec3();
    var addToWlambda_Mdiag = new CANNON.Vec3();
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var ConeEquation = /** @class */ (function (_super) {
        __extends(ConeEquation, _super);
        /**
         * Cone equation. Works to keep the given body world vectors aligned, or tilted within a given angle from each other.
         *
         * @param bodyA
         * @param bodyB
         * @param options
         *
         * @author schteppe
         */
        function ConeEquation(bodyA, bodyB, options) {
            if (options === void 0) { options = {}; }
            var _this = _super.call(this, bodyA, bodyB, -(typeof (options.maxForce) !== 'undefined' ? options.maxForce : 1e6), typeof (options.maxForce) !== 'undefined' ? options.maxForce : 1e6) || this;
            _this.axisA = options.axisA ? options.axisA.clone() : new CANNON.Vec3(1, 0, 0);
            _this.axisB = options.axisB ? options.axisB.clone() : new CANNON.Vec3(0, 1, 0);
            _this.angle = typeof (options.angle) !== 'undefined' ? options.angle : 0;
            return _this;
        }
        ConeEquation.prototype.computeB = function (h) {
            var a = this.a, b = this.b, ni = this.axisA, nj = this.axisB, nixnj = tmpVec1, njxni = tmpVec2, GA = this.jacobianElementA, GB = this.jacobianElementB;
            // Caluclate cross products
            ni.cross(nj, nixnj);
            nj.cross(ni, njxni);
            // The angle between two vector is:
            // cos(theta) = a * b / (length(a) * length(b) = { len(a) = len(b) = 1 } = a * b
            // g = a * b
            // gdot = (b x a) * wi + (a x b) * wj
            // G = [0 bxa 0 axb]
            // W = [vi wi vj wj]
            GA.rotational.copy(njxni);
            GB.rotational.copy(nixnj);
            var g = Math.cos(this.angle) - ni.dot(nj), GW = this.computeGW(), GiMf = this.computeGiMf();
            var B = -g * a - GW * b - h * GiMf;
            return B;
        };
        return ConeEquation;
    }(CANNON.Equation));
    CANNON.ConeEquation = ConeEquation;
    var tmpVec1 = new CANNON.Vec3();
    var tmpVec2 = new CANNON.Vec3();
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var ContactEquation = /** @class */ (function (_super) {
        __extends(ContactEquation, _super);
        /**
         * Contact/non-penetration constraint equation
         *
         * @param bodyA
         * @param bodyB
         *
         * @author schteppe
         */
        function ContactEquation(bodyA, bodyB, maxForce) {
            var _this = _super.call(this, bodyA, bodyB, 0, typeof (maxForce) !== 'undefined' ? maxForce : 1e6) || this;
            _this.restitution = 0.0; // "bounciness": u1 = -e*u0
            _this.ri = new CANNON.Vec3();
            _this.rj = new CANNON.Vec3();
            _this.ni = new CANNON.Vec3();
            return _this;
        }
        ContactEquation.prototype.computeB = function (h) {
            var a = this.a, b = this.b, bi = this.bi, bj = this.bj, ri = this.ri, rj = this.rj, rixn = ContactEquation_computeB_temp1, rjxn = ContactEquation_computeB_temp2, vi = bi.velocity, wi = bi.angularVelocity, fi = bi.force, taui = bi.torque, vj = bj.velocity, wj = bj.angularVelocity, fj = bj.force, tauj = bj.torque, penetrationVec = ContactEquation_computeB_temp3, GA = this.jacobianElementA, GB = this.jacobianElementB, n = this.ni;
            // Caluclate cross products
            ri.cross(n, rixn);
            rj.cross(n, rjxn);
            // g = xj+rj -(xi+ri)
            // G = [ -ni  -rixn  ni  rjxn ]
            n.negate(GA.spatial);
            rixn.negate(GA.rotational);
            GB.spatial.copy(n);
            GB.rotational.copy(rjxn);
            // Calculate the penetration vector
            penetrationVec.copy(bj.position);
            penetrationVec.vadd(rj, penetrationVec);
            penetrationVec.vsub(bi.position, penetrationVec);
            penetrationVec.vsub(ri, penetrationVec);
            var g = n.dot(penetrationVec);
            // Compute iteration
            var ePlusOne = this.restitution + 1;
            var GW = ePlusOne * vj.dot(n) - ePlusOne * vi.dot(n) + wj.dot(rjxn) - wi.dot(rixn);
            var GiMf = this.computeGiMf();
            var B = -g * a - GW * b - h * GiMf;
            return B;
        };
        /**
         * Get the current relative velocity in the contact point.
         */
        ContactEquation.prototype.getImpactVelocityAlongNormal = function () {
            var vi = ContactEquation_getImpactVelocityAlongNormal_vi;
            var vj = ContactEquation_getImpactVelocityAlongNormal_vj;
            var xi = ContactEquation_getImpactVelocityAlongNormal_xi;
            var xj = ContactEquation_getImpactVelocityAlongNormal_xj;
            var relVel = ContactEquation_getImpactVelocityAlongNormal_relVel;
            this.bi.position.vadd(this.ri, xi);
            this.bj.position.vadd(this.rj, xj);
            this.bi.getVelocityAtWorldPoint(xi, vi);
            this.bj.getVelocityAtWorldPoint(xj, vj);
            vi.vsub(vj, relVel);
            return this.ni.dot(relVel);
        };
        return ContactEquation;
    }(CANNON.Equation));
    CANNON.ContactEquation = ContactEquation;
    var ContactEquation_computeB_temp1 = new CANNON.Vec3(); // Temp vectors
    var ContactEquation_computeB_temp2 = new CANNON.Vec3();
    var ContactEquation_computeB_temp3 = new CANNON.Vec3();
    var ContactEquation_getImpactVelocityAlongNormal_vi = new CANNON.Vec3();
    var ContactEquation_getImpactVelocityAlongNormal_vj = new CANNON.Vec3();
    var ContactEquation_getImpactVelocityAlongNormal_xi = new CANNON.Vec3();
    var ContactEquation_getImpactVelocityAlongNormal_xj = new CANNON.Vec3();
    var ContactEquation_getImpactVelocityAlongNormal_relVel = new CANNON.Vec3();
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var FrictionEquation = /** @class */ (function (_super) {
        __extends(FrictionEquation, _super);
        /**
         * Constrains the slipping in a contact along a tangent
         * @class FrictionEquation
         * @constructor
         * @author schteppe
         * @param {Body} bodyA
         * @param {Body} bodyB
         * @param {Number} slipForce should be +-F_friction = +-mu * F_normal = +-mu * m * g
         * @extends Equation
         */
        function FrictionEquation(bodyA, bodyB, slipForce) {
            var _this = _super.call(this, bodyA, bodyB, -slipForce, slipForce) || this;
            _this.ri = new CANNON.Vec3();
            _this.rj = new CANNON.Vec3();
            _this.t = new CANNON.Vec3(); // tangent
            return _this;
        }
        FrictionEquation.prototype.computeB = function (h) {
            var a = this.a, b = this.b, bi = this.bi, bj = this.bj, ri = this.ri, rj = this.rj, rixt = FrictionEquation_computeB_temp1, rjxt = FrictionEquation_computeB_temp2, t = this.t;
            // Caluclate cross products
            ri.cross(t, rixt);
            rj.cross(t, rjxt);
            // G = [-t -rixt t rjxt]
            // And remember, this is a pure velocity constraint, g is always zero!
            var GA = this.jacobianElementA, GB = this.jacobianElementB;
            t.negate(GA.spatial);
            rixt.negate(GA.rotational);
            GB.spatial.copy(t);
            GB.rotational.copy(rjxt);
            var GW = this.computeGW();
            var GiMf = this.computeGiMf();
            var B = -GW * b - h * GiMf;
            return B;
        };
        return FrictionEquation;
    }(CANNON.Equation));
    CANNON.FrictionEquation = FrictionEquation;
    var FrictionEquation_computeB_temp1 = new CANNON.Vec3();
    var FrictionEquation_computeB_temp2 = new CANNON.Vec3();
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var RotationalEquation = /** @class */ (function (_super) {
        __extends(RotationalEquation, _super);
        /**
         * Rotational constraint. Works to keep the local vectors orthogonal to each other in world space.
         *
         * @param bodyA
         * @param bodyB
         * @param options
         *
         * @author schteppe
         */
        function RotationalEquation(bodyA, bodyB, options) {
            if (options === void 0) { options = {}; }
            var _this = _super.call(this, bodyA, bodyB, -(typeof (options.maxForce) !== 'undefined' ? options.maxForce : 1e6), typeof (options.maxForce) !== 'undefined' ? options.maxForce : 1e6) || this;
            _this.axisA = options.axisA ? options.axisA.clone() : new CANNON.Vec3(1, 0, 0);
            _this.axisB = options.axisB ? options.axisB.clone() : new CANNON.Vec3(0, 1, 0);
            _this.maxAngle = Math.PI / 2;
            return _this;
        }
        RotationalEquation.prototype.computeB = function (h) {
            var a = this.a, b = this.b, ni = this.axisA, nj = this.axisB, nixnj = tmpVec1, njxni = tmpVec2, GA = this.jacobianElementA, GB = this.jacobianElementB;
            // Caluclate cross products
            ni.cross(nj, nixnj);
            nj.cross(ni, njxni);
            // g = ni * nj
            // gdot = (nj x ni) * wi + (ni x nj) * wj
            // G = [0 njxni 0 nixnj]
            // W = [vi wi vj wj]
            GA.rotational.copy(njxni);
            GB.rotational.copy(nixnj);
            var g = Math.cos(this.maxAngle) - ni.dot(nj), GW = this.computeGW(), GiMf = this.computeGiMf();
            var B = -g * a - GW * b - h * GiMf;
            return B;
        };
        return RotationalEquation;
    }(CANNON.Equation));
    CANNON.RotationalEquation = RotationalEquation;
    var tmpVec1 = new CANNON.Vec3();
    var tmpVec2 = new CANNON.Vec3();
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var RotationalMotorEquation = /** @class */ (function (_super) {
        __extends(RotationalMotorEquation, _super);
        /**
         * Rotational motor constraint. Tries to keep the relative angular velocity of the bodies to a given value.
         *
         * @param bodyA
         * @param bodyB
         * @param maxForce
         *
         * @author schteppe
         */
        function RotationalMotorEquation(bodyA, bodyB, maxForce) {
            var _this = _super.call(this, bodyA, bodyB, -(typeof (maxForce) !== 'undefined' ? maxForce : 1e6), typeof (maxForce) !== 'undefined' ? maxForce : 1e6) || this;
            _this.axisA = new CANNON.Vec3();
            _this.axisB = new CANNON.Vec3(); // World oriented rotational axis
            _this.targetVelocity = 0;
            return _this;
        }
        RotationalMotorEquation.prototype.computeB = function (h) {
            var a = this.a, b = this.b, bi = this.bi, bj = this.bj, axisA = this.axisA, axisB = this.axisB, GA = this.jacobianElementA, GB = this.jacobianElementB;
            // g = 0
            // gdot = axisA * wi - axisB * wj
            // gdot = G * W = G * [vi wi vj wj]
            // =>
            // G = [0 axisA 0 -axisB]
            GA.rotational.copy(axisA);
            axisB.negate(GB.rotational);
            var GW = this.computeGW() - this.targetVelocity, GiMf = this.computeGiMf();
            var B = -GW * b - h * GiMf;
            return B;
        };
        return RotationalMotorEquation;
    }(CANNON.Equation));
    CANNON.RotationalMotorEquation = RotationalMotorEquation;
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var Solver = /** @class */ (function () {
        /**
         * Constraint equation solver base class.
         * @author schteppe / https://github.com/schteppe
         */
        function Solver() {
            this.equations = [];
        }
        /**
         * Should be implemented in subclasses!
         * @param dt
         * @param world
         */
        Solver.prototype.solve = function (dt, world) {
            // Should return the number of iterations done!
            return 0;
        };
        /**
         * Add an equation
         * @param eq
         */
        Solver.prototype.addEquation = function (eq) {
            if (eq.enabled) {
                this.equations.push(eq);
            }
        };
        /**
         * Remove an equation
         * @param eq
         */
        Solver.prototype.removeEquation = function (eq) {
            var eqs = this.equations;
            var i = eqs.indexOf(eq);
            if (i !== -1) {
                eqs.splice(i, 1);
            }
        };
        /**
         * Add all equations
         */
        Solver.prototype.removeAllEquations = function () {
            this.equations.length = 0;
        };
        return Solver;
    }());
    CANNON.Solver = Solver;
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var GSSolver = /** @class */ (function (_super) {
        __extends(GSSolver, _super);
        /**
         * Constraint equation Gauss-Seidel solver.
         * @todo The spook parameters should be specified for each constraint, not globally.
         * @author schteppe / https://github.com/schteppe
         * @see https://www8.cs.umu.se/kurser/5DV058/VT09/lectures/spooknotes.pdf
         */
        function GSSolver() {
            var _this = _super.call(this) || this;
            _this.iterations = 10;
            _this.tolerance = 1e-7;
            return _this;
        }
        GSSolver.prototype.solve = function (dt, world) {
            var iter = 0, maxIter = this.iterations, tolSquared = this.tolerance * this.tolerance, equations = this.equations, Neq = equations.length, bodies = world.bodies, Nbodies = bodies.length, h = dt, q, B, invC, deltalambda, deltalambdaTot, GWlambda, lambdaj;
            // Update solve mass
            if (Neq !== 0) {
                for (var i = 0; i !== Nbodies; i++) {
                    bodies[i].updateSolveMassProperties();
                }
            }
            // Things that does not change during iteration can be computed once
            var invCs = GSSolver_solve_invCs, Bs = GSSolver_solve_Bs, lambda = GSSolver_solve_lambda;
            invCs.length = Neq;
            Bs.length = Neq;
            lambda.length = Neq;
            for (var i = 0; i !== Neq; i++) {
                var c = equations[i];
                lambda[i] = 0.0;
                Bs[i] = c.computeB(h, 0, 0);
                invCs[i] = 1.0 / c.computeC();
            }
            if (Neq !== 0) {
                // Reset vlambda
                for (var i = 0; i !== Nbodies; i++) {
                    var b = bodies[i], vlambda = b.vlambda, wlambda = b.wlambda;
                    vlambda.set(0, 0, 0);
                    wlambda.set(0, 0, 0);
                }
                // Iterate over equations
                for (iter = 0; iter !== maxIter; iter++) {
                    // Accumulate the total error for each iteration.
                    deltalambdaTot = 0.0;
                    for (var j = 0; j !== Neq; j++) {
                        var c = equations[j];
                        // Compute iteration
                        B = Bs[j];
                        invC = invCs[j];
                        lambdaj = lambda[j];
                        GWlambda = c.computeGWlambda();
                        deltalambda = invC * (B - GWlambda - c.eps * lambdaj);
                        // Clamp if we are not within the min/max interval
                        if (lambdaj + deltalambda < c.minForce) {
                            deltalambda = c.minForce - lambdaj;
                        }
                        else if (lambdaj + deltalambda > c.maxForce) {
                            deltalambda = c.maxForce - lambdaj;
                        }
                        lambda[j] += deltalambda;
                        deltalambdaTot += deltalambda > 0.0 ? deltalambda : -deltalambda; // abs(deltalambda)
                        c.addToWlambda(deltalambda);
                    }
                    // If the total error is small enough - stop iterate
                    if (deltalambdaTot * deltalambdaTot < tolSquared) {
                        break;
                    }
                }
                // Add result to velocity
                for (var i = 0; i !== Nbodies; i++) {
                    var b = bodies[i], v = b.velocity, w = b.angularVelocity;
                    b.vlambda.vmul(b.linearFactor, b.vlambda);
                    v.vadd(b.vlambda, v);
                    b.wlambda.vmul(b.angularFactor, b.wlambda);
                    w.vadd(b.wlambda, w);
                }
                // Set the .multiplier property of each equation
                var l = equations.length;
                var invDt = 1 / h;
                while (l--) {
                    equations[l].multiplier = lambda[l] * invDt;
                }
            }
            return iter;
        };
        return GSSolver;
    }(CANNON.Solver));
    CANNON.GSSolver = GSSolver;
    var GSSolver_solve_lambda = []; // Just temporary number holders that we want to reuse each solve.
    var GSSolver_solve_invCs = [];
    var GSSolver_solve_Bs = [];
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var SplitSolver = /** @class */ (function (_super) {
        __extends(SplitSolver, _super);
        /**
         * Splits the equations into islands and solves them independently. Can improve performance.
         *
         * @param subsolver
         */
        function SplitSolver(subsolver) {
            var _this = _super.call(this) || this;
            _this.iterations = 10;
            _this.tolerance = 1e-7;
            _this.subsolver = subsolver;
            _this.nodes = [];
            _this.nodePool = [];
            // Create needed nodes, reuse if possible
            while (_this.nodePool.length < 128) {
                _this.nodePool.push(_this.createNode());
            }
            return _this;
        }
        SplitSolver.prototype.createNode = function () {
            return { body: null, children: [], eqs: [], visited: false };
        };
        /**
         * Solve the subsystems
         * @method solve
         * @param  {Number} dt
         * @param  {World} world
         */
        SplitSolver.prototype.solve = function (dt, world) {
            var nodes = SplitSolver_solve_nodes, nodePool = this.nodePool, bodies = world.bodies, equations = this.equations, Neq = equations.length, Nbodies = bodies.length, subsolver = this.subsolver;
            // Create needed nodes, reuse if possible
            while (nodePool.length < Nbodies) {
                nodePool.push(this.createNode());
            }
            nodes.length = Nbodies;
            for (var i = 0; i < Nbodies; i++) {
                nodes[i] = nodePool[i];
            }
            // Reset node values
            for (var i = 0; i !== Nbodies; i++) {
                var node = nodes[i];
                node.body = bodies[i];
                node.children.length = 0;
                node.eqs.length = 0;
                node.visited = false;
            }
            for (var k = 0; k !== Neq; k++) {
                var eq = equations[k], i0 = bodies.indexOf(eq.bi), j = bodies.indexOf(eq.bj), ni = nodes[i0], nj = nodes[j];
                ni.children.push(nj);
                ni.eqs.push(eq);
                nj.children.push(ni);
                nj.eqs.push(eq);
            }
            var child, n = 0, eqs = SplitSolver_solve_eqs;
            subsolver.tolerance = this.tolerance;
            subsolver.iterations = this.iterations;
            var dummyWorld = SplitSolver_solve_dummyWorld;
            while ((child = getUnvisitedNode(nodes))) {
                eqs.length = 0;
                dummyWorld.bodies.length = 0;
                bfs(child, visitFunc, dummyWorld.bodies, eqs);
                var Neqs = eqs.length;
                eqs = eqs.sort(sortById);
                for (var i = 0; i !== Neqs; i++) {
                    subsolver.addEquation(eqs[i]);
                }
                var iter = subsolver.solve(dt, dummyWorld);
                subsolver.removeAllEquations();
                n++;
            }
            return n;
        };
        return SplitSolver;
    }(CANNON.Solver));
    CANNON.SplitSolver = SplitSolver;
    // Returns the number of subsystems
    var SplitSolver_solve_nodes = []; // All allocated node objects
    var SplitSolver_solve_nodePool = []; // All allocated node objects
    var SplitSolver_solve_eqs = []; // Temp array
    var SplitSolver_solve_bds = []; // Temp array
    var SplitSolver_solve_dummyWorld = { bodies: [] }; // Temp object
    var STATIC = CANNON.Body.STATIC;
    function getUnvisitedNode(nodes) {
        var Nnodes = nodes.length;
        for (var i = 0; i !== Nnodes; i++) {
            var node = nodes[i];
            if (!node.visited && !(node.body.type & STATIC)) {
                return node;
            }
        }
        return false;
    }
    var queue = [];
    function bfs(root, visitFunc, bds, eqs) {
        queue.push(root);
        root.visited = true;
        visitFunc(root, bds, eqs);
        while (queue.length) {
            var node = queue.pop();
            // Loop over unvisited child nodes
            var child;
            while ((child = getUnvisitedNode(node.children))) {
                child.visited = true;
                visitFunc(child, bds, eqs);
                queue.push(child);
            }
        }
    }
    function visitFunc(node, bds, eqs) {
        bds.push(node.body);
        var Neqs = node.eqs.length;
        for (var i = 0; i !== Neqs; i++) {
            var eq = node.eqs[i];
            if (eqs.indexOf(eq) === -1) {
                eqs.push(eq);
            }
        }
    }
    function sortById(a, b) {
        return b.id - a.id;
    }
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var World = /** @class */ (function (_super) {
        __extends(World, _super);
        /**
         * The physics world
         * @param options
         */
        function World(options) {
            if (options === void 0) { options = {}; }
            var _this = _super.call(this) || this;
            _this.profile = {
                solve: 0,
                makeContactConstraints: 0,
                broadphase: 0,
                integrate: 0,
                narrowphase: 0,
            };
            /**
             * Dispatched after a body has been added to the world.
             */
            _this.addBodyEvent = {
                type: "addBody",
                body: null
            };
            /**
             * Dispatched after a body has been removed from the world.
             */
            _this.removeBodyEvent = {
                type: "removeBody",
                body: null
            };
            _this.idToBodyMap = {};
            _this.emitContactEvents = (function () {
                var additions = [];
                var removals = [];
                var beginContactEvent = {
                    type: 'beginContact',
                    bodyA: null,
                    bodyB: null
                };
                var endContactEvent = {
                    type: 'endContact',
                    bodyA: null,
                    bodyB: null
                };
                var beginShapeContactEvent = {
                    type: 'beginShapeContact',
                    bodyA: null,
                    bodyB: null,
                    shapeA: null,
                    shapeB: null
                };
                var endShapeContactEvent = {
                    type: 'endShapeContact',
                    bodyA: null,
                    bodyB: null,
                    shapeA: null,
                    shapeB: null
                };
                return function () {
                    var hasBeginContact = this.hasAnyEventListener('beginContact');
                    var hasEndContact = this.hasAnyEventListener('endContact');
                    if (hasBeginContact || hasEndContact) {
                        this.bodyOverlapKeeper.getDiff(additions, removals);
                    }
                    if (hasBeginContact) {
                        for (var i = 0, l = additions.length; i < l; i += 2) {
                            beginContactEvent.bodyA = this.getBodyById(additions[i]);
                            beginContactEvent.bodyB = this.getBodyById(additions[i + 1]);
                            this.dispatchEvent(beginContactEvent);
                        }
                        beginContactEvent.bodyA = beginContactEvent.bodyB = null;
                    }
                    if (hasEndContact) {
                        for (var i = 0, l = removals.length; i < l; i += 2) {
                            endContactEvent.bodyA = this.getBodyById(removals[i]);
                            endContactEvent.bodyB = this.getBodyById(removals[i + 1]);
                            this.dispatchEvent(endContactEvent);
                        }
                        endContactEvent.bodyA = endContactEvent.bodyB = null;
                    }
                    additions.length = removals.length = 0;
                    var hasBeginShapeContact = this.hasAnyEventListener('beginShapeContact');
                    var hasEndShapeContact = this.hasAnyEventListener('endShapeContact');
                    if (hasBeginShapeContact || hasEndShapeContact) {
                        this.shapeOverlapKeeper.getDiff(additions, removals);
                    }
                    if (hasBeginShapeContact) {
                        for (var i = 0, l = additions.length; i < l; i += 2) {
                            var shapeA = this.getShapeById(additions[i]);
                            var shapeB = this.getShapeById(additions[i + 1]);
                            beginShapeContactEvent.shapeA = shapeA;
                            beginShapeContactEvent.shapeB = shapeB;
                            beginShapeContactEvent.bodyA = shapeA.body;
                            beginShapeContactEvent.bodyB = shapeB.body;
                            this.dispatchEvent(beginShapeContactEvent);
                        }
                        beginShapeContactEvent.bodyA = beginShapeContactEvent.bodyB = beginShapeContactEvent.shapeA = beginShapeContactEvent.shapeB = null;
                    }
                    if (hasEndShapeContact) {
                        for (var i = 0, l = removals.length; i < l; i += 2) {
                            var shapeA = this.getShapeById(removals[i]);
                            var shapeB = this.getShapeById(removals[i + 1]);
                            endShapeContactEvent.shapeA = shapeA;
                            endShapeContactEvent.shapeB = shapeB;
                            endShapeContactEvent.bodyA = shapeA.body;
                            endShapeContactEvent.bodyB = shapeB.body;
                            this.dispatchEvent(endShapeContactEvent);
                        }
                        endShapeContactEvent.bodyA = endShapeContactEvent.bodyB = endShapeContactEvent.shapeA = endShapeContactEvent.shapeB = null;
                    }
                };
            })();
            _this.dt = -1;
            _this.allowSleep = !!options.allowSleep;
            _this.contacts = [];
            _this.frictionEquations = [];
            _this.quatNormalizeSkip = options.quatNormalizeSkip !== undefined ? options.quatNormalizeSkip : 0;
            _this.quatNormalizeFast = options.quatNormalizeFast !== undefined ? options.quatNormalizeFast : false;
            _this.time = 0.0;
            _this.stepnumber = 0;
            _this.default_dt = 1 / 60;
            _this.nextId = 0;
            _this.gravity = new CANNON.Vec3();
            if (options.gravity) {
                _this.gravity.copy(options.gravity);
            }
            _this.broadphase = options.broadphase !== undefined ? options.broadphase : new CANNON.NaiveBroadphase();
            _this.bodies = [];
            _this.solver = options.solver !== undefined ? options.solver : new CANNON.GSSolver();
            _this.constraints = [];
            _this.narrowphase = new CANNON.Narrowphase(_this);
            _this.collisionMatrix = new CANNON.ArrayCollisionMatrix();
            _this.collisionMatrixPrevious = new CANNON.ArrayCollisionMatrix();
            _this.bodyOverlapKeeper = new CANNON.OverlapKeeper();
            _this.shapeOverlapKeeper = new CANNON.OverlapKeeper();
            _this.materials = [];
            _this.contactmaterials = [];
            _this.contactMaterialTable = new CANNON.TupleDictionary();
            _this.defaultMaterial = new CANNON.Material("default");
            _this.defaultContactMaterial = new CANNON.ContactMaterial(_this.defaultMaterial, _this.defaultMaterial, { friction: 0.3, restitution: 0.0 });
            _this.doProfiling = false;
            _this.profile = {
                solve: 0,
                makeContactConstraints: 0,
                broadphase: 0,
                integrate: 0,
                narrowphase: 0,
            };
            _this.accumulator = 0;
            _this.subsystems = [];
            _this.addBodyEvent = {
                type: "addBody",
                body: null
            };
            _this.removeBodyEvent = {
                type: "removeBody",
                body: null
            };
            _this.idToBodyMap = {};
            _this.broadphase.setWorld(_this);
            return _this;
        }
        /**
         * Get the contact material between materials m1 and m2
         * @param m1
         * @param m2
         * @return  The contact material if it was found.
         */
        World.prototype.getContactMaterial = function (m1, m2) {
            return this.contactMaterialTable.get(m1.id, m2.id); //this.contactmaterials[this.mats2cmat[i+j*this.materials.length]];
        };
        /**
         * Get number of objects in the world.
         * @deprecated
         */
        World.prototype.numObjects = function () {
            return this.bodies.length;
        };
        /**
         * Store old collision state info
         */
        World.prototype.collisionMatrixTick = function () {
            var temp = this.collisionMatrixPrevious;
            this.collisionMatrixPrevious = this.collisionMatrix;
            this.collisionMatrix = temp;
            this.collisionMatrix.reset();
            this.bodyOverlapKeeper.tick();
            this.shapeOverlapKeeper.tick();
        };
        /**
         * Add a rigid body to the simulation.
         * @param body
         *
         * @todo If the simulation has not yet started, why recrete and copy arrays for each body? Accumulate in dynamic arrays in this case.
         * @todo Adding an array of bodies should be possible. This would save some loops too
         * @deprecated Use .addBody instead
         */
        World.prototype.add = function (body) {
            if (this.bodies.indexOf(body) !== -1) {
                return;
            }
            body.index = this.bodies.length;
            this.bodies.push(body);
            body.world = this;
            body.initPosition.copy(body.position);
            body.initVelocity.copy(body.velocity);
            body.timeLastSleepy = this.time;
            if (body instanceof CANNON.Body) {
                body.initAngularVelocity.copy(body.angularVelocity);
                body.initQuaternion.copy(body.quaternion);
            }
            this.collisionMatrix.setNumObjects(this.bodies.length);
            this.addBodyEvent.body = body;
            this.idToBodyMap[body.id] = body;
            this.dispatchEvent(this.addBodyEvent);
        };
        /**
         * Add a rigid body to the simulation.
         * @method add
         * @param {Body} body
         * @todo If the simulation has not yet started, why recrete and copy arrays for each body? Accumulate in dynamic arrays in this case.
         * @todo Adding an array of bodies should be possible. This would save some loops too
         * @deprecated Use .addBody instead
         */
        World.prototype.addBody = function (body) {
            if (this.bodies.indexOf(body) !== -1) {
                return;
            }
            body.index = this.bodies.length;
            this.bodies.push(body);
            body.world = this;
            body.initPosition.copy(body.position);
            body.initVelocity.copy(body.velocity);
            body.timeLastSleepy = this.time;
            if (body instanceof CANNON.Body) {
                body.initAngularVelocity.copy(body.angularVelocity);
                body.initQuaternion.copy(body.quaternion);
            }
            this.collisionMatrix.setNumObjects(this.bodies.length);
            this.addBodyEvent.body = body;
            this.idToBodyMap[body.id] = body;
            this.dispatchEvent(this.addBodyEvent);
        };
        /**
         * Add a constraint to the simulation.
         * @param c
         */
        World.prototype.addConstraint = function (c) {
            this.constraints.push(c);
        };
        /**
         * Removes a constraint
         * @param c
         */
        World.prototype.removeConstraint = function (c) {
            var idx = this.constraints.indexOf(c);
            if (idx !== -1) {
                this.constraints.splice(idx, 1);
            }
        };
        /**
         * Raycast test
         * @param from
         * @param to
         * @param result
         * @deprecated Use .raycastAll, .raycastClosest or .raycastAny instead.
         */
        World.prototype.rayTest = function (from, to, result) {
            if (result instanceof CANNON.RaycastResult) {
                // Do raycastclosest
                this.raycastClosest(from, to, {
                    skipBackfaces: true
                }, result);
            }
            else {
                // Do raycastAll
                this.raycastAll(from, to, {
                    skipBackfaces: true
                }, result);
            }
        };
        /**
         * Ray cast against all bodies. The provided callback will be executed for each hit with a RaycastResult as single argument.
         * @param from
         * @param to
         * @param options
         * @param callback
         * @return True if any body was hit.
         */
        World.prototype.raycastAll = function (from, to, options, callback) {
            if (options === void 0) { options = {}; }
            options.mode = CANNON.Ray.ALL;
            options.from = from;
            options.to = to;
            options.callback = callback;
            return tmpRay.intersectWorld(this, options);
        };
        /**
         * Ray cast, and stop at the first result. Note that the order is random - but the method is fast.
         *
         * @param from
         * @param to
         * @param options
         * @param result
         *
         * @return True if any body was hit.
         */
        World.prototype.raycastAny = function (from, to, options, result) {
            options.mode = CANNON.Ray.ANY;
            options.from = from;
            options.to = to;
            options.result = result;
            return tmpRay.intersectWorld(this, options);
        };
        /**
         * Ray cast, and return information of the closest hit.
         *
         * @param from
         * @param to
         * @param options
         * @param result
         *
         * @return True if any body was hit.
         */
        World.prototype.raycastClosest = function (from, to, options, result) {
            options.mode = CANNON.Ray.CLOSEST;
            options.from = from;
            options.to = to;
            options.result = result;
            return tmpRay.intersectWorld(this, options);
        };
        /**
         * Remove a rigid body from the simulation.
         * @param body
         * @deprecated Use .removeBody instead
         */
        World.prototype.remove = function (body) {
            body.world = null;
            var n = this.bodies.length - 1, bodies = this.bodies, idx = bodies.indexOf(body);
            if (idx !== -1) {
                bodies.splice(idx, 1); // Todo: should use a garbage free method
                // Recompute index
                for (var i = 0; i !== bodies.length; i++) {
                    bodies[i].index = i;
                }
                this.collisionMatrix.setNumObjects(n);
                this.removeBodyEvent.body = body;
                delete this.idToBodyMap[body.id];
                this.dispatchEvent(this.removeBodyEvent);
            }
        };
        /**
         * Remove a rigid body from the simulation.
         * @param body
         */
        World.prototype.removeBody = function (body) {
            body.world = null;
            var n = this.bodies.length - 1, bodies = this.bodies, idx = bodies.indexOf(body);
            if (idx !== -1) {
                bodies.splice(idx, 1); // Todo: should use a garbage free method
                // Recompute index
                for (var i = 0; i !== bodies.length; i++) {
                    bodies[i].index = i;
                }
                this.collisionMatrix.setNumObjects(n);
                this.removeBodyEvent.body = body;
                delete this.idToBodyMap[body.id];
                this.dispatchEvent(this.removeBodyEvent);
            }
        };
        World.prototype.getBodyById = function (id) {
            return this.idToBodyMap[id];
        };
        // TODO Make a faster map
        World.prototype.getShapeById = function (id) {
            var bodies = this.bodies;
            for (var i = 0, bl = bodies.length; i < bl; i++) {
                var shapes = bodies[i].shapes;
                for (var j = 0, sl = shapes.length; j < sl; j++) {
                    var shape = shapes[j];
                    if (shape.id === id) {
                        return shape;
                    }
                }
            }
        };
        /**
         * Adds a material to the World.
         * @param m
         * @todo Necessary?
         */
        World.prototype.addMaterial = function (m) {
            this.materials.push(m);
        };
        /**
         * Adds a contact material to the World
         * @param cmat
         */
        World.prototype.addContactMaterial = function (cmat) {
            // Add contact material
            this.contactmaterials.push(cmat);
            // Add current contact material to the material table
            this.contactMaterialTable.set(cmat.materials[0].id, cmat.materials[1].id, cmat);
        };
        /**
         * Step the physics world forward in time.
         *
         * There are two modes. The simple mode is fixed timestepping without interpolation. In this case you only use the first argument. The second case uses interpolation. In that you also provide the time since the function was last used, as well as the maximum fixed timesteps to take.
         *
         * @param dt                       The fixed time step size to use.
         * @param timeSinceLastCalled    The time elapsed since the function was last called.
         * @param maxSubSteps         Maximum number of fixed steps to take per function call.
         *
         * @example
         *     // fixed timestepping without interpolation
         *     world.step(1/60);
         *
         * @see http://bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World
         */
        World.prototype.step = function (dt, timeSinceLastCalled, maxSubSteps) {
            maxSubSteps = maxSubSteps || 10;
            timeSinceLastCalled = timeSinceLastCalled || 0;
            if (timeSinceLastCalled === 0) { // Fixed, simple stepping
                this.internalStep(dt);
                // Increment time
                this.time += dt;
            }
            else {
                this.accumulator += timeSinceLastCalled;
                var substeps = 0;
                while (this.accumulator >= dt && substeps < maxSubSteps) {
                    // Do fixed steps to catch up
                    this.internalStep(dt);
                    this.accumulator -= dt;
                    substeps++;
                }
                var t = (this.accumulator % dt) / dt;
                for (var j = 0; j !== this.bodies.length; j++) {
                    var b = this.bodies[j];
                    b.previousPosition.lerp(b.position, t, b.interpolatedPosition);
                    b.previousQuaternion.slerp(b.quaternion, t, b.interpolatedQuaternion);
                    b.previousQuaternion.normalize();
                }
                this.time += timeSinceLastCalled;
            }
        };
        World.prototype.internalStep = function (dt) {
            this.dt = dt;
            var world = this, that = this, contacts = this.contacts, p1 = World_step_p1, p2 = World_step_p2, N = this.numObjects(), bodies = this.bodies, solver = this.solver, gravity = this.gravity, doProfiling = this.doProfiling, profile = this.profile, DYNAMIC = CANNON.Body.DYNAMIC, profilingStart, constraints = this.constraints, frictionEquationPool = World_step_frictionEquationPool, gnorm = gravity.norm(), gx = gravity.x, gy = gravity.y, gz = gravity.z, i = 0;
            if (doProfiling) {
                profilingStart = performance.now();
            }
            // Add gravity to all objects
            for (i = 0; i !== N; i++) {
                var bi = bodies[i];
                if (bi.type === DYNAMIC) { // Only for dynamic bodies
                    var f = bi.force, m = bi.mass;
                    f.x += m * gx;
                    f.y += m * gy;
                    f.z += m * gz;
                }
            }
            // Update subsystems
            for (var i = 0, Nsubsystems = this.subsystems.length; i !== Nsubsystems; i++) {
                this.subsystems[i].update();
            }
            // Collision detection
            if (doProfiling) {
                profilingStart = performance.now();
            }
            p1.length = 0; // Clean up pair arrays from last step
            p2.length = 0;
            this.broadphase.collisionPairs(this, p1, p2);
            if (doProfiling) {
                profile.broadphase = performance.now() - profilingStart;
            }
            // Remove constrained pairs with collideConnected == false
            var Nconstraints = constraints.length;
            for (i = 0; i !== Nconstraints; i++) {
                var c = constraints[i];
                if (!c.collideConnected) {
                    for (var j = p1.length - 1; j >= 0; j -= 1) {
                        if ((c.bodyA === p1[j] && c.bodyB === p2[j]) ||
                            (c.bodyB === p1[j] && c.bodyA === p2[j])) {
                            p1.splice(j, 1);
                            p2.splice(j, 1);
                        }
                    }
                }
            }
            this.collisionMatrixTick();
            // Generate contacts
            if (doProfiling) {
                profilingStart = performance.now();
            }
            var oldcontacts = World_step_oldContacts;
            var NoldContacts = contacts.length;
            for (i = 0; i !== NoldContacts; i++) {
                oldcontacts.push(contacts[i]);
            }
            contacts.length = 0;
            // Transfer FrictionEquation from current list to the pool for reuse
            var NoldFrictionEquations = this.frictionEquations.length;
            for (i = 0; i !== NoldFrictionEquations; i++) {
                frictionEquationPool.push(this.frictionEquations[i]);
            }
            this.frictionEquations.length = 0;
            this.narrowphase.getContacts(p1, p2, this, contacts, oldcontacts, // To be reused
            this.frictionEquations, frictionEquationPool);
            if (doProfiling) {
                profile.narrowphase = performance.now() - profilingStart;
            }
            // Loop over all collisions
            if (doProfiling) {
                profilingStart = performance.now();
            }
            // Add all friction eqs
            for (var i = 0; i < this.frictionEquations.length; i++) {
                solver.addEquation(this.frictionEquations[i]);
            }
            var ncontacts = contacts.length;
            for (var k = 0; k !== ncontacts; k++) {
                // Current contact
                var c = contacts[k];
                // Get current collision indeces
                var bi = c.bi, bj = c.bj, si = c.si, sj = c.sj;
                // Get collision properties
                var cm;
                if (bi.material && bj.material) {
                    cm = this.getContactMaterial(bi.material, bj.material) || this.defaultContactMaterial;
                }
                else {
                    cm = this.defaultContactMaterial;
                }
                // c.enabled = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;
                var mu = cm.friction;
                // c.restitution = cm.restitution;
                // If friction or restitution were specified in the material, use them
                if (bi.material && bj.material) {
                    if (bi.material.friction >= 0 && bj.material.friction >= 0) {
                        mu = bi.material.friction * bj.material.friction;
                    }
                    if (bi.material.restitution >= 0 && bj.material.restitution >= 0) {
                        c.restitution = bi.material.restitution * bj.material.restitution;
                    }
                }
                // c.setSpookParams(
                //           cm.contactEquationStiffness,
                //           cm.contactEquationRelaxation,
                //           dt
                //       );
                solver.addEquation(c);
                // // Add friction constraint equation
                // if(mu > 0){
                // 	// Create 2 tangent equations
                // 	var mug = mu * gnorm;
                // 	var reducedMass = (bi.invMass + bj.invMass);
                // 	if(reducedMass > 0){
                // 		reducedMass = 1/reducedMass;
                // 	}
                // 	var pool = frictionEquationPool;
                // 	var c1 = pool.length ? pool.pop() : new FrictionEquation(bi,bj,mug*reducedMass);
                // 	var c2 = pool.length ? pool.pop() : new FrictionEquation(bi,bj,mug*reducedMass);
                // 	this.frictionEquations.push(c1, c2);
                // 	c1.bi = c2.bi = bi;
                // 	c1.bj = c2.bj = bj;
                // 	c1.minForce = c2.minForce = -mug*reducedMass;
                // 	c1.maxForce = c2.maxForce = mug*reducedMass;
                // 	// Copy over the relative vectors
                // 	c1.ri.copy(c.ri);
                // 	c1.rj.copy(c.rj);
                // 	c2.ri.copy(c.ri);
                // 	c2.rj.copy(c.rj);
                // 	// Construct tangents
                // 	c.ni.tangents(c1.t, c2.t);
                //           // Set spook params
                //           c1.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, dt);
                //           c2.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, dt);
                //           c1.enabled = c2.enabled = c.enabled;
                // 	// Add equations to solver
                // 	solver.addEquation(c1);
                // 	solver.addEquation(c2);
                // }
                if (bi.allowSleep &&
                    bi.type === CANNON.Body.DYNAMIC &&
                    bi.sleepState === CANNON.Body.SLEEPING &&
                    bj.sleepState === CANNON.Body.AWAKE &&
                    bj.type !== CANNON.Body.STATIC) {
                    var speedSquaredB = bj.velocity.norm2() + bj.angularVelocity.norm2();
                    var speedLimitSquaredB = Math.pow(bj.sleepSpeedLimit, 2);
                    if (speedSquaredB >= speedLimitSquaredB * 2) {
                        bi._wakeUpAfterNarrowphase = true;
                    }
                }
                if (bj.allowSleep &&
                    bj.type === CANNON.Body.DYNAMIC &&
                    bj.sleepState === CANNON.Body.SLEEPING &&
                    bi.sleepState === CANNON.Body.AWAKE &&
                    bi.type !== CANNON.Body.STATIC) {
                    var speedSquaredA = bi.velocity.norm2() + bi.angularVelocity.norm2();
                    var speedLimitSquaredA = Math.pow(bi.sleepSpeedLimit, 2);
                    if (speedSquaredA >= speedLimitSquaredA * 2) {
                        bj._wakeUpAfterNarrowphase = true;
                    }
                }
                // Now we know that i and j are in contact. Set collision matrix state
                this.collisionMatrix.set(bi, bj, true);
                if (!this.collisionMatrixPrevious.get(bi, bj)) {
                    // First contact!
                    // We reuse the collideEvent object, otherwise we will end up creating new objects for each new contact, even if there's no event listener attached.
                    World_step_collideEvent.body = bj;
                    World_step_collideEvent.contact = c;
                    bi.dispatchEvent(World_step_collideEvent);
                    World_step_collideEvent.body = bi;
                    bj.dispatchEvent(World_step_collideEvent);
                }
                this.bodyOverlapKeeper.set(bi.id, bj.id);
                this.shapeOverlapKeeper.set(si.id, sj.id);
            }
            this.emitContactEvents();
            if (doProfiling) {
                profile.makeContactConstraints = performance.now() - profilingStart;
                profilingStart = performance.now();
            }
            // Wake up bodies
            for (i = 0; i !== N; i++) {
                var bi = bodies[i];
                if (bi._wakeUpAfterNarrowphase) {
                    bi.wakeUp();
                    bi._wakeUpAfterNarrowphase = false;
                }
            }
            // Add user-added constraints
            var Nconstraints = constraints.length;
            for (i = 0; i !== Nconstraints; i++) {
                var c = constraints[i];
                c.update();
                for (var j = 0, Neq = c.equations.length; j !== Neq; j++) {
                    var eq = c.equations[j];
                    solver.addEquation(eq);
                }
            }
            // Solve the constrained system
            solver.solve(dt, this);
            if (doProfiling) {
                profile.solve = performance.now() - profilingStart;
            }
            // Remove all contacts from solver
            solver.removeAllEquations();
            // Apply damping, see http://code.google.com/p/bullet/issues/detail?id=74 for details
            var pow = Math.pow;
            for (i = 0; i !== N; i++) {
                var bi = bodies[i];
                if (bi.type & DYNAMIC) { // Only for dynamic bodies
                    var ld = pow(1.0 - bi.linearDamping, dt);
                    var v = bi.velocity;
                    v.mult(ld, v);
                    var av = bi.angularVelocity;
                    if (av) {
                        var ad = pow(1.0 - bi.angularDamping, dt);
                        av.mult(ad, av);
                    }
                }
            }
            this.dispatchEvent(World_step_preStepEvent);
            // Invoke pre-step callbacks
            for (i = 0; i !== N; i++) {
                var bi = bodies[i];
                if (bi.preStep) {
                    bi.preStep.call(bi);
                }
            }
            // Leap frog
            // vnew = v + h*f/m
            // xnew = x + h*vnew
            if (doProfiling) {
                profilingStart = performance.now();
            }
            var stepnumber = this.stepnumber;
            var quatNormalize = stepnumber % (this.quatNormalizeSkip + 1) === 0;
            var quatNormalizeFast = this.quatNormalizeFast;
            for (i = 0; i !== N; i++) {
                bodies[i].integrate(dt, quatNormalize, quatNormalizeFast);
            }
            this.clearForces();
            this.broadphase.dirty = true;
            if (doProfiling) {
                profile.integrate = performance.now() - profilingStart;
            }
            // Update world time
            this.time += dt;
            this.stepnumber += 1;
            this.dispatchEvent(World_step_postStepEvent);
            // Invoke post-step callbacks
            for (i = 0; i !== N; i++) {
                var bi = bodies[i];
                var postStep = bi.postStep;
                if (postStep) {
                    postStep.call(bi);
                }
            }
            // Sleeping update
            if (this.allowSleep) {
                for (i = 0; i !== N; i++) {
                    bodies[i].sleepTick(this.time);
                }
            }
        };
        /**
         * Sets all body forces in the world to zero.
         * @method clearForces
         */
        World.prototype.clearForces = function () {
            var bodies = this.bodies;
            var N = bodies.length;
            for (var i = 0; i !== N; i++) {
                var b = bodies[i], force = b.force, tau = b.torque;
                b.force.set(0, 0, 0);
                b.torque.set(0, 0, 0);
            }
        };
        World.worldNormal = new CANNON.Vec3(0, 0, 1);
        return World;
    }(CANNON.EventTarget));
    CANNON.World = World;
    // Temp stuff
    var tmpAABB1 = new CANNON.AABB();
    var tmpArray1 = [];
    var tmpRay = new CANNON.Ray();
    // performance.now()
    if (typeof performance === 'undefined') {
        throw "performance";
        // performance = {};
    }
    if (!performance.now) {
        var nowOffset = Date.now();
        if (performance.timing && performance.timing.navigationStart) {
            nowOffset = performance.timing.navigationStart;
        }
        performance.now = function () {
            return Date.now() - nowOffset;
        };
    }
    var step_tmp1 = new CANNON.Vec3();
    /**
     * Dispatched after the world has stepped forward in time.
     */
    var World_step_postStepEvent = { type: "postStep" }; // Reusable event objects to save memory
    /**
     * Dispatched before the world steps forward in time.
     */
    var World_step_preStepEvent = { type: "preStep" };
    var World_step_collideEvent = { type: CANNON.Body.COLLIDE_EVENT_NAME, body: null, contact: null };
    var World_step_oldContacts = []; // Pools for unused objects
    var World_step_frictionEquationPool = [];
    var World_step_p1 = []; // Reusable arrays for collision pairs
    var World_step_p2 = [];
    var World_step_gvec = new CANNON.Vec3(); // Temporary vectors and quats
    var World_step_vi = new CANNON.Vec3();
    var World_step_vj = new CANNON.Vec3();
    var World_step_wi = new CANNON.Vec3();
    var World_step_wj = new CANNON.Vec3();
    var World_step_t1 = new CANNON.Vec3();
    var World_step_t2 = new CANNON.Vec3();
    var World_step_rixn = new CANNON.Vec3();
    var World_step_rjxn = new CANNON.Vec3();
    var World_step_step_q = new CANNON.Quaternion();
    var World_step_step_w = new CANNON.Quaternion();
    var World_step_step_wq = new CANNON.Quaternion();
    var invI_tau_dt = new CANNON.Vec3();
})(CANNON || (CANNON = {}));
var CANNON;
(function (CANNON) {
    var Narrowphase = /** @class */ (function () {
        /**
         * Helper class for the World. Generates ContactEquations.
         * @class Narrowphase
         * @constructor
         * @todo Sphere-ConvexPolyhedron contacts
         * @todo Contact reduction
         * @todo  should move methods to prototype
         */
        function Narrowphase(world) {
            this.contactPointPool = [];
            this.frictionEquationPool = [];
            this.result = [];
            this.frictionResult = [];
            this.v3pool = new CANNON.Vec3Pool();
            this.world = world;
            this.currentContactMaterial = null;
            this.enableFrictionReduction = false;
        }
        /**
         * Make a contact object, by using the internal pool or creating a new one.
         *
         * @param bi
         * @param bj
         * @param si
         * @param sj
         * @param overrideShapeA
         * @param overrideShapeB
         */
        Narrowphase.prototype.createContactEquation = function (bi, bj, si, sj, overrideShapeA, overrideShapeB) {
            var c;
            if (this.contactPointPool.length) {
                c = this.contactPointPool.pop();
                c.bi = bi;
                c.bj = bj;
            }
            else {
                c = new CANNON.ContactEquation(bi, bj);
            }
            c.enabled = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;
            var cm = this.currentContactMaterial;
            c.restitution = cm.restitution;
            c.setSpookParams(cm.contactEquationStiffness, cm.contactEquationRelaxation, this.world.dt);
            var matA = si.material || bi.material;
            var matB = sj.material || bj.material;
            if (matA && matB && matA.restitution >= 0 && matB.restitution >= 0) {
                c.restitution = matA.restitution * matB.restitution;
            }
            c.si = overrideShapeA || si;
            c.sj = overrideShapeB || sj;
            return c;
        };
        ;
        Narrowphase.prototype.createFrictionEquationsFromContact = function (contactEquation, outArray) {
            var bodyA = contactEquation.bi;
            var bodyB = contactEquation.bj;
            var shapeA = contactEquation.si;
            var shapeB = contactEquation.sj;
            var world = this.world;
            var cm = this.currentContactMaterial;
            // If friction or restitution were specified in the material, use them
            var friction = cm.friction;
            var matA = shapeA.material || bodyA.material;
            var matB = shapeB.material || bodyB.material;
            if (matA && matB && matA.friction >= 0 && matB.friction >= 0) {
                friction = matA.friction * matB.friction;
            }
            if (friction > 0) {
                // Create 2 tangent equations
                var mug = friction * world.gravity.length();
                var reducedMass = (bodyA.invMass + bodyB.invMass);
                if (reducedMass > 0) {
                    reducedMass = 1 / reducedMass;
                }
                var pool = this.frictionEquationPool;
                var c1 = pool.length ? pool.pop() : new CANNON.FrictionEquation(bodyA, bodyB, mug * reducedMass);
                var c2 = pool.length ? pool.pop() : new CANNON.FrictionEquation(bodyA, bodyB, mug * reducedMass);
                c1.bi = c2.bi = bodyA;
                c1.bj = c2.bj = bodyB;
                c1.minForce = c2.minForce = -mug * reducedMass;
                c1.maxForce = c2.maxForce = mug * reducedMass;
                // Copy over the relative vectors
                c1.ri.copy(contactEquation.ri);
                c1.rj.copy(contactEquation.rj);
                c2.ri.copy(contactEquation.ri);
                c2.rj.copy(contactEquation.rj);
                // Construct tangents
                contactEquation.ni.tangents(c1.t, c2.t);
                // Set spook params
                c1.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, world.dt);
                c2.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, world.dt);
                c1.enabled = c2.enabled = contactEquation.enabled;
                outArray.push(c1, c2);
                return true;
            }
            return false;
        };
        // Take the average N latest contact point on the plane.
        Narrowphase.prototype.createFrictionFromAverage = function (numContacts) {
            // The last contactEquation
            var c = this.result[this.result.length - 1];
            // Create the result: two "average" friction equations
            if (!this.createFrictionEquationsFromContact(c, this.frictionResult) || numContacts === 1) {
                return;
            }
            var f1 = this.frictionResult[this.frictionResult.length - 2];
            var f2 = this.frictionResult[this.frictionResult.length - 1];
            averageNormal.setZero();
            averageContactPointA.setZero();
            averageContactPointB.setZero();
            var bodyA = c.bi;
            var bodyB = c.bj;
            for (var i = 0; i !== numContacts; i++) {
                c = this.result[this.result.length - 1 - i];
                if (c.bodyA !== bodyA) {
                    averageNormal.vadd(c.ni, averageNormal);
                    averageContactPointA.vadd(c.ri, averageContactPointA);
                    averageContactPointB.vadd(c.rj, averageContactPointB);
                }
                else {
                    averageNormal.vsub(c.ni, averageNormal);
                    averageContactPointA.vadd(c.rj, averageContactPointA);
                    averageContactPointB.vadd(c.ri, averageContactPointB);
                }
            }
            var invNumContacts = 1 / numContacts;
            averageContactPointA.scale(invNumContacts, f1.ri);
            averageContactPointB.scale(invNumContacts, f1.rj);
            f2.ri.copy(f1.ri); // Should be the same
            f2.rj.copy(f1.rj);
            averageNormal.normalize();
            averageNormal.tangents(f1.t, f2.t);
            // return eq;
        };
        /**
         * Generate all contacts between a list of body pairs
         * @method getContacts
         * @param {array} p1 Array of body indices
         * @param {array} p2 Array of body indices
         * @param {World} world
         * @param {array} result Array to store generated contacts
         * @param {array} oldcontacts Optional. Array of reusable contact objects
         */
        Narrowphase.prototype.getContacts = function (p1, p2, world, result, oldcontacts, frictionResult, frictionPool) {
            // Save old contact objects
            this.contactPointPool = oldcontacts;
            this.frictionEquationPool = frictionPool;
            this.result = result;
            this.frictionResult = frictionResult;
            var qi = tmpQuat1;
            var qj = tmpQuat2;
            var xi = tmpVec1;
            var xj = tmpVec2;
            for (var k = 0, N = p1.length; k !== N; k++) {
                // Get current collision bodies
                var bi = p1[k], bj = p2[k];
                // Get contact material
                var bodyContactMaterial = null;
                if (bi.material && bj.material) {
                    bodyContactMaterial = world.getContactMaterial(bi.material, bj.material) || null;
                }
                var justTest = (((bi.type & CANNON.Body.KINEMATIC) && (bj.type & CANNON.Body.STATIC)) || ((bi.type & CANNON.Body.STATIC) && (bj.type & CANNON.Body.KINEMATIC)) || ((bi.type & CANNON.Body.KINEMATIC) && (bj.type & CANNON.Body.KINEMATIC)));
                for (var i = 0; i < bi.shapes.length; i++) {
                    bi.quaternion.mult(bi.shapeOrientations[i], qi);
                    bi.quaternion.vmult(bi.shapeOffsets[i], xi);
                    xi.vadd(bi.position, xi);
                    var si = bi.shapes[i];
                    for (var j = 0; j < bj.shapes.length; j++) {
                        // Compute world transform of shapes
                        bj.quaternion.mult(bj.shapeOrientations[j], qj);
                        bj.quaternion.vmult(bj.shapeOffsets[j], xj);
                        xj.vadd(bj.position, xj);
                        var sj = bj.shapes[j];
                        if (!((si.collisionFilterMask & sj.collisionFilterGroup) && (sj.collisionFilterMask & si.collisionFilterGroup))) {
                            continue;
                        }
                        if (xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius) {
                            continue;
                        }
                        // Get collision material
                        var shapeContactMaterial = null;
                        if (si.material && sj.material) {
                            shapeContactMaterial = world.getContactMaterial(si.material, sj.material) || null;
                        }
                        this.currentContactMaterial = shapeContactMaterial || bodyContactMaterial || world.defaultContactMaterial;
                        // Get contacts
                        var resolver = this[si.type | sj.type];
                        if (resolver) {
                            var retval = false;
                            if (si.type < sj.type) {
                                retval = resolver.call(this, si, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest);
                            }
                            else {
                                retval = resolver.call(this, sj, si, xj, xi, qj, qi, bj, bi, si, sj, justTest);
                            }
                            if (retval && justTest) {
                                // Register overlap
                                world.shapeOverlapKeeper.set(si.id, sj.id);
                                world.bodyOverlapKeeper.set(bi.id, bj.id);
                            }
                        }
                    }
                }
            }
        };
        Narrowphase.prototype.boxBox = function (si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
            si.convexPolyhedronRepresentation.material = si.material;
            sj.convexPolyhedronRepresentation.material = sj.material;
            si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
            sj.convexPolyhedronRepresentation.collisionResponse = sj.collisionResponse;
            return this.convexConvex(si.convexPolyhedronRepresentation, sj.convexPolyhedronRepresentation, xi, xj, qi, qj, bi, bj, si, sj, justTest);
        };
        Narrowphase.prototype.boxConvex = function (si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
            si.convexPolyhedronRepresentation.material = si.material;
            si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
            return this.convexConvex(si.convexPolyhedronRepresentation, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest);
        };
        Narrowphase.prototype.boxParticle = function (si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
            si.convexPolyhedronRepresentation.material = si.material;
            si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
            return this.convexParticle(si.convexPolyhedronRepresentation, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest);
        };
        Narrowphase.prototype.sphereSphere = function (si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
            if (justTest) {
                return xi.distanceSquared(xj) < Math.pow(si.radius + sj.radius, 2);
            }
            // We will have only one contact in this case
            var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
            // Contact normal
            xj.vsub(xi, r.ni);
            r.ni.normalize();
            // Contact point locations
            r.ri.copy(r.ni);
            r.rj.copy(r.ni);
            r.ri.mult(si.radius, r.ri);
            r.rj.mult(-sj.radius, r.rj);
            r.ri.vadd(xi, r.ri);
            r.ri.vsub(bi.position, r.ri);
            r.rj.vadd(xj, r.rj);
            r.rj.vsub(bj.position, r.rj);
            this.result.push(r);
            this.createFrictionEquationsFromContact(r, this.frictionResult);
        };
        ;
        /**
         * @method planeTrimesh
         * @param  {Shape}      si
         * @param  {Shape}      sj
         * @param  {Vec3}       xi
         * @param  {Vec3}       xj
         * @param  {Quaternion} qi
         * @param  {Quaternion} qj
         * @param  {Body}       bi
         * @param  {Body}       bj
         */
        Narrowphase.prototype.planeTrimesh = function (planeShape, trimeshShape, planePos, trimeshPos, planeQuat, trimeshQuat, planeBody, trimeshBody, rsi, rsj, justTest) {
            // Make contacts!
            var v = new CANNON.Vec3();
            var normal = planeTrimesh_normal;
            normal.copy(CANNON.World.worldNormal);
            planeQuat.vmult(normal, normal); // Turn normal according to plane
            for (var i = 0; i < trimeshShape.vertices.length / 3; i++) {
                // Get world vertex from trimesh
                trimeshShape.getVertex(i, v);
                // Safe up
                var v2 = new CANNON.Vec3();
                v2.copy(v);
                CANNON.Transform.pointToWorldFrame(trimeshPos, trimeshQuat, v2, v);
                // Check plane side
                var relpos = planeTrimesh_relpos;
                v.vsub(planePos, relpos);
                var dot = normal.dot(relpos);
                if (dot <= 0.0) {
                    if (justTest) {
                        return true;
                    }
                    var r = this.createContactEquation(planeBody, trimeshBody, planeShape, trimeshShape, rsi, rsj);
                    r.ni.copy(normal); // Contact normal is the plane normal
                    // Get vertex position projected on plane
                    var projected = planeTrimesh_projected;
                    normal.scale(relpos.dot(normal), projected);
                    v.vsub(projected, projected);
                    // ri is the projected world position minus plane position
                    r.ri.copy(projected);
                    r.ri.vsub(planeBody.position, r.ri);
                    r.rj.copy(v);
                    r.rj.vsub(trimeshBody.position, r.rj);
                    // Store result
                    this.result.push(r);
                    this.createFrictionEquationsFromContact(r, this.frictionResult);
                }
            }
        };
        Narrowphase.prototype.sphereTrimesh = function (sphereShape, trimeshShape, spherePos, trimeshPos, sphereQuat, trimeshQuat, sphereBody, trimeshBody, rsi, rsj, justTest) {
            var edgeVertexA = sphereTrimesh_edgeVertexA;
            var edgeVertexB = sphereTrimesh_edgeVertexB;
            var edgeVector = sphereTrimesh_edgeVector;
            var edgeVectorUnit = sphereTrimesh_edgeVectorUnit;
            var localSpherePos = sphereTrimesh_localSpherePos;
            var tmp = sphereTrimesh_tmp;
            var localSphereAABB = sphereTrimesh_localSphereAABB;
            var v2 = sphereTrimesh_v2;
            var relpos = sphereTrimesh_relpos;
            var triangles = sphereTrimesh_triangles;
            // Convert sphere position to local in the trimesh
            CANNON.Transform.pointToLocalFrame(trimeshPos, trimeshQuat, spherePos, localSpherePos);
            // Get the aabb of the sphere locally in the trimesh
            var sphereRadius = sphereShape.radius;
            localSphereAABB.lowerBound.set(localSpherePos.x - sphereRadius, localSpherePos.y - sphereRadius, localSpherePos.z - sphereRadius);
            localSphereAABB.upperBound.set(localSpherePos.x + sphereRadius, localSpherePos.y + sphereRadius, localSpherePos.z + sphereRadius);
            trimeshShape.getTrianglesInAABB(localSphereAABB, triangles);
            //for (var i = 0; i < trimeshShape.indices.length / 3; i++) triangles.push(i); // All
            // Vertices
            var v = sphereTrimesh_v;
            var radiusSquared = sphereShape.radius * sphereShape.radius;
            for (var i = 0; i < triangles.length; i++) {
                for (var j = 0; j < 3; j++) {
                    trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + j], v);
                    // Check vertex overlap in sphere
                    v.vsub(localSpherePos, relpos);
                    if (relpos.norm2() <= radiusSquared) {
                        // Safe up
                        v2.copy(v);
                        CANNON.Transform.pointToWorldFrame(trimeshPos, trimeshQuat, v2, v);
                        v.vsub(spherePos, relpos);
                        if (justTest) {
                            return true;
                        }
                        var r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape, rsi, rsj);
                        r.ni.copy(relpos);
                        r.ni.normalize();
                        // ri is the vector from sphere center to the sphere surface
                        r.ri.copy(r.ni);
                        r.ri.scale(sphereShape.radius, r.ri);
                        r.ri.vadd(spherePos, r.ri);
                        r.ri.vsub(sphereBody.position, r.ri);
                        r.rj.copy(v);
                        r.rj.vsub(trimeshBody.position, r.rj);
                        // Store result
                        this.result.push(r);
                        this.createFrictionEquationsFromContact(r, this.frictionResult);
                    }
                }
            }
            // Check all edges
            for (var i = 0; i < triangles.length; i++) {
                for (var j = 0; j < 3; j++) {
                    trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + j], edgeVertexA);
                    trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + ((j + 1) % 3)], edgeVertexB);
                    edgeVertexB.vsub(edgeVertexA, edgeVector);
                    // Project sphere position to the edge
                    localSpherePos.vsub(edgeVertexB, tmp);
                    var positionAlongEdgeB = tmp.dot(edgeVector);
                    localSpherePos.vsub(edgeVertexA, tmp);
                    var positionAlongEdgeA = tmp.dot(edgeVector);
                    if (positionAlongEdgeA > 0 && positionAlongEdgeB < 0) {
                        // Now check the orthogonal distance from edge to sphere center
                        localSpherePos.vsub(edgeVertexA, tmp);
                        edgeVectorUnit.copy(edgeVector);
                        edgeVectorUnit.normalize();
                        positionAlongEdgeA = tmp.dot(edgeVectorUnit);
                        edgeVectorUnit.scale(positionAlongEdgeA, tmp);
                        tmp.vadd(edgeVertexA, tmp);
                        // tmp is now the sphere center position projected to the edge, defined locally in the trimesh frame
                        var dist = tmp.distanceTo(localSpherePos);
                        if (dist < sphereShape.radius) {
                            if (justTest) {
                                return true;
                            }
                            var r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape, rsi, rsj);
                            tmp.vsub(localSpherePos, r.ni);
                            r.ni.normalize();
                            r.ni.scale(sphereShape.radius, r.ri);
                            CANNON.Transform.pointToWorldFrame(trimeshPos, trimeshQuat, tmp, tmp);
                            tmp.vsub(trimeshBody.position, r.rj);
                            CANNON.Transform.vectorToWorldFrame(trimeshQuat, r.ni, r.ni);
                            CANNON.Transform.vectorToWorldFrame(trimeshQuat, r.ri, r.ri);
                            this.result.push(r);
                            this.createFrictionEquationsFromContact(r, this.frictionResult);
                        }
                    }
                }
            }
            // Triangle faces
            var va = sphereTrimesh_va;
            var vb = sphereTrimesh_vb;
            var vc = sphereTrimesh_vc;
            var normal = sphereTrimesh_normal;
            for (var i = 0, N = triangles.length; i !== N; i++) {
                trimeshShape.getTriangleVertices(triangles[i], va, vb, vc);
                trimeshShape.getNormal(triangles[i], normal);
                localSpherePos.vsub(va, tmp);
                var dist = tmp.dot(normal);
                normal.scale(dist, tmp);
                localSpherePos.vsub(tmp, tmp);
                // tmp is now the sphere position projected to the triangle plane
                dist = tmp.distanceTo(localSpherePos);
                if (CANNON.Ray.pointInTriangle(tmp, va, vb, vc) && dist < sphereShape.radius) {
                    if (justTest) {
                        return true;
                    }
                    var r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape, rsi, rsj);
                    tmp.vsub(localSpherePos, r.ni);
                    r.ni.normalize();
                    r.ni.scale(sphereShape.radius, r.ri);
                    CANNON.Transform.pointToWorldFrame(trimeshPos, trimeshQuat, tmp, tmp);
                    tmp.vsub(trimeshBody.position, r.rj);
                    CANNON.Transform.vectorToWorldFrame(trimeshQuat, r.ni, r.ni);
                    CANNON.Transform.vectorToWorldFrame(trimeshQuat, r.ri, r.ri);
                    this.result.push(r);
                    this.createFrictionEquationsFromContact(r, this.frictionResult);
                }
            }
            triangles.length = 0;
        };
        Narrowphase.prototype.spherePlane = function (si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
            // We will have one contact in this case
            var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
            // Contact normal
            r.ni.copy(CANNON.World.worldNormal);
            qj.vmult(r.ni, r.ni);
            r.ni.negate(r.ni); // body i is the sphere, flip normal
            r.ni.normalize(); // Needed?
            // Vector from sphere center to contact point
            r.ni.mult(si.radius, r.ri);
            // Project down sphere on plane
            xi.vsub(xj, point_on_plane_to_sphere);
            r.ni.mult(r.ni.dot(point_on_plane_to_sphere), plane_to_sphere_ortho);
            point_on_plane_to_sphere.vsub(plane_to_sphere_ortho, r.rj); // The sphere position projected to plane
            if (-point_on_plane_to_sphere.dot(r.ni) <= si.radius) {
                if (justTest) {
                    return true;
                }
                // Make it relative to the body
                var ri = r.ri;
                var rj = r.rj;
                ri.vadd(xi, ri);
                ri.vsub(bi.position, ri);
                rj.vadd(xj, rj);
                rj.vsub(bj.position, rj);
                this.result.push(r);
                this.createFrictionEquationsFromContact(r, this.frictionResult);
            }
        };
        Narrowphase.prototype.sphereBox = function (si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
            var v3pool = this.v3pool;
            // we refer to the box as body j
            var sides = sphereBox_sides;
            xi.vsub(xj, box_to_sphere);
            sj.getSideNormals(sides, qj);
            var R = si.radius;
            var penetrating_sides = [];
            // Check side (plane) intersections
            var found = false;
            // Store the resulting side penetration info
            var side_ns = sphereBox_side_ns;
            var side_ns1 = sphereBox_side_ns1;
            var side_ns2 = sphereBox_side_ns2;
            var side_h = null;
            var side_penetrations = 0;
            var side_dot1 = 0;
            var side_dot2 = 0;
            var side_distance = null;
            for (var idx = 0, nsides = sides.length; idx !== nsides && found === false; idx++) {
                // Get the plane side normal (ns)
                var ns = sphereBox_ns;
                ns.copy(sides[idx]);
                var h = ns.norm();
                ns.normalize();
                // The normal/distance dot product tells which side of the plane we are
                var dot = box_to_sphere.dot(ns);
                if (dot < h + R && dot > 0) {
                    // Intersects plane. Now check the other two dimensions
                    var ns1 = sphereBox_ns1;
                    var ns2 = sphereBox_ns2;
                    ns1.copy(sides[(idx + 1) % 3]);
                    ns2.copy(sides[(idx + 2) % 3]);
                    var h1 = ns1.norm();
                    var h2 = ns2.norm();
                    ns1.normalize();
                    ns2.normalize();
                    var dot1 = box_to_sphere.dot(ns1);
                    var dot2 = box_to_sphere.dot(ns2);
                    if (dot1 < h1 && dot1 > -h1 && dot2 < h2 && dot2 > -h2) {
                        var dist = Math.abs(dot - h - R);
                        if (side_distance === null || dist < side_distance) {
                            side_distance = dist;
                            side_dot1 = dot1;
                            side_dot2 = dot2;
                            side_h = h;
                            side_ns.copy(ns);
                            side_ns1.copy(ns1);
                            side_ns2.copy(ns2);
                            side_penetrations++;
                            if (justTest) {
                                return true;
                            }
                        }
                    }
                }
            }
            if (side_penetrations) {
                found = true;
                var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
                side_ns.mult(-R, r.ri); // Sphere r
                r.ni.copy(side_ns);
                r.ni.negate(r.ni); // Normal should be out of sphere
                side_ns.mult(side_h, side_ns);
                side_ns1.mult(side_dot1, side_ns1);
                side_ns.vadd(side_ns1, side_ns);
                side_ns2.mult(side_dot2, side_ns2);
                side_ns.vadd(side_ns2, r.rj);
                // Make relative to bodies
                r.ri.vadd(xi, r.ri);
                r.ri.vsub(bi.position, r.ri);
                r.rj.vadd(xj, r.rj);
                r.rj.vsub(bj.position, r.rj);
                this.result.push(r);
                this.createFrictionEquationsFromContact(r, this.frictionResult);
            }
            // Check corners
            var rj = v3pool.get();
            var sphere_to_corner = sphereBox_sphere_to_corner;
            for (var j = 0; j !== 2 && !found; j++) {
                for (var k = 0; k !== 2 && !found; k++) {
                    for (var l = 0; l !== 2 && !found; l++) {
                        rj.set(0, 0, 0);
                        if (j) {
                            rj.vadd(sides[0], rj);
                        }
                        else {
                            rj.vsub(sides[0], rj);
                        }
                        if (k) {
                            rj.vadd(sides[1], rj);
                        }
                        else {
                            rj.vsub(sides[1], rj);
                        }
                        if (l) {
                            rj.vadd(sides[2], rj);
                        }
                        else {
                            rj.vsub(sides[2], rj);
                        }
                        // World position of corner
                        xj.vadd(rj, sphere_to_corner);
                        sphere_to_corner.vsub(xi, sphere_to_corner);
                        if (sphere_to_corner.norm2() < R * R) {
                            if (justTest) {
                                return true;
                            }
                            found = true;
                            var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
                            r.ri.copy(sphere_to_corner);
                            r.ri.normalize();
                            r.ni.copy(r.ri);
                            r.ri.mult(R, r.ri);
                            r.rj.copy(rj);
                            // Make relative to bodies
                            r.ri.vadd(xi, r.ri);
                            r.ri.vsub(bi.position, r.ri);
                            r.rj.vadd(xj, r.rj);
                            r.rj.vsub(bj.position, r.rj);
                            this.result.push(r);
                            this.createFrictionEquationsFromContact(r, this.frictionResult);
                        }
                    }
                }
            }
            v3pool.release(rj);
            rj = null;
            // Check edges
            var edgeTangent = v3pool.get();
            var edgeCenter = v3pool.get();
            var r = v3pool.get(); // r = edge center to sphere center
            var orthogonal = v3pool.get();
            var dist1 = v3pool.get();
            var Nsides = sides.length;
            for (var j = 0; j !== Nsides && !found; j++) {
                for (var k = 0; k !== Nsides && !found; k++) {
                    if (j % 3 !== k % 3) {
                        // Get edge tangent
                        sides[k].cross(sides[j], edgeTangent);
                        edgeTangent.normalize();
                        sides[j].vadd(sides[k], edgeCenter);
                        r.copy(xi);
                        r.vsub(edgeCenter, r);
                        r.vsub(xj, r);
                        var orthonorm = r.dot(edgeTangent); // distance from edge center to sphere center in the tangent direction
                        edgeTangent.mult(orthonorm, orthogonal); // Vector from edge center to sphere center in the tangent direction
                        // Find the third side orthogonal to this one
                        var l = 0;
                        while (l === j % 3 || l === k % 3) {
                            l++;
                        }
                        // vec from edge center to sphere projected to the plane orthogonal to the edge tangent
                        dist1.copy(xi);
                        dist1.vsub(orthogonal, dist1);
                        dist1.vsub(edgeCenter, dist1);
                        dist1.vsub(xj, dist1);
                        // Distances in tangent direction and distance in the plane orthogonal to it
                        var tdist = Math.abs(orthonorm);
                        var ndist = dist1.norm();
                        if (tdist < sides[l].norm() && ndist < R) {
                            if (justTest) {
                                return true;
                            }
                            found = true;
                            var res = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
                            edgeCenter.vadd(orthogonal, res.rj); // box rj
                            res.rj.copy(res.rj);
                            dist1.negate(res.ni);
                            res.ni.normalize();
                            res.ri.copy(res.rj);
                            res.ri.vadd(xj, res.ri);
                            res.ri.vsub(xi, res.ri);
                            res.ri.normalize();
                            res.ri.mult(R, res.ri);
                            // Make relative to bodies
                            res.ri.vadd(xi, res.ri);
                            res.ri.vsub(bi.position, res.ri);
                            res.rj.vadd(xj, res.rj);
                            res.rj.vsub(bj.position, res.rj);
                            this.result.push(res);
                            this.createFrictionEquationsFromContact(res, this.frictionResult);
                        }
                    }
                }
            }
            v3pool.release(edgeTangent, edgeCenter, r, orthogonal, dist1);
        };
        Narrowphase.prototype.sphereConvex = function (si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
            var v3pool = this.v3pool;
            xi.vsub(xj, convex_to_sphere);
            var normals = sj.faceNormals;
            var faces = sj.faces;
            var verts = sj.vertices;
            var R = si.radius;
            var penetrating_sides = [];
            // if(convex_to_sphere.norm2() > si.boundingSphereRadius + sj.boundingSphereRadius){
            //     return;
            // }
            // Check corners
            for (var i = 0; i !== verts.length; i++) {
                var v = verts[i];
                // World position of corner
                var worldCorner = sphereConvex_worldCorner;
                qj.vmult(v, worldCorner);
                xj.vadd(worldCorner, worldCorner);
                var sphere_to_corner = sphereConvex_sphereToCorner;
                worldCorner.vsub(xi, sphere_to_corner);
                if (sphere_to_corner.norm2() < R * R) {
                    if (justTest) {
                        return true;
                    }
                    found = true;
                    var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
                    r.ri.copy(sphere_to_corner);
                    r.ri.normalize();
                    r.ni.copy(r.ri);
                    r.ri.mult(R, r.ri);
                    worldCorner.vsub(xj, r.rj);
                    // Should be relative to the body.
                    r.ri.vadd(xi, r.ri);
                    r.ri.vsub(bi.position, r.ri);
                    // Should be relative to the body.
                    r.rj.vadd(xj, r.rj);
                    r.rj.vsub(bj.position, r.rj);
                    this.result.push(r);
                    this.createFrictionEquationsFromContact(r, this.frictionResult);
                    return;
                }
            }
            // Check side (plane) intersections
            var found = false;
            for (var i = 0, nfaces = faces.length; i !== nfaces && found === false; i++) {
                var normal = normals[i];
                var face = faces[i];
                // Get world-transformed normal of the face
                var worldNormal = sphereConvex_worldNormal;
                qj.vmult(normal, worldNormal);
                // Get a world vertex from the face
                var worldPoint = sphereConvex_worldPoint;
                qj.vmult(verts[face[0]], worldPoint);
                worldPoint.vadd(xj, worldPoint);
                // Get a point on the sphere, closest to the face normal
                var worldSpherePointClosestToPlane = sphereConvex_worldSpherePointClosestToPlane;
                worldNormal.mult(-R, worldSpherePointClosestToPlane);
                xi.vadd(worldSpherePointClosestToPlane, worldSpherePointClosestToPlane);
                // Vector from a face point to the closest point on the sphere
                var penetrationVec = sphereConvex_penetrationVec;
                worldSpherePointClosestToPlane.vsub(worldPoint, penetrationVec);
                // The penetration. Negative value means overlap.
                var penetration = penetrationVec.dot(worldNormal);
                var worldPointToSphere = sphereConvex_sphereToWorldPoint;
                xi.vsub(worldPoint, worldPointToSphere);
                if (penetration < 0 && worldPointToSphere.dot(worldNormal) > 0) {
                    // Intersects plane. Now check if the sphere is inside the face polygon
                    var faceVerts = []; // Face vertices, in world coords
                    for (var j = 0, Nverts = face.length; j !== Nverts; j++) {
                        var worldVertex = v3pool.get();
                        qj.vmult(verts[face[j]], worldVertex);
                        xj.vadd(worldVertex, worldVertex);
                        faceVerts.push(worldVertex);
                    }
                    if (pointInPolygon(faceVerts, worldNormal, xi)) { // Is the sphere center in the face polygon?
                        if (justTest) {
                            return true;
                        }
                        found = true;
                        var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
                        worldNormal.mult(-R, r.ri); // Contact offset, from sphere center to contact
                        worldNormal.negate(r.ni); // Normal pointing out of sphere
                        var penetrationVec2 = v3pool.get();
                        worldNormal.mult(-penetration, penetrationVec2);
                        var penetrationSpherePoint = v3pool.get();
                        worldNormal.mult(-R, penetrationSpherePoint);
                        //xi.vsub(xj).vadd(penetrationSpherePoint).vadd(penetrationVec2 , r.rj);
                        xi.vsub(xj, r.rj);
                        r.rj.vadd(penetrationSpherePoint, r.rj);
                        r.rj.vadd(penetrationVec2, r.rj);
                        // Should be relative to the body.
                        r.rj.vadd(xj, r.rj);
                        r.rj.vsub(bj.position, r.rj);
                        // Should be relative to the body.
                        r.ri.vadd(xi, r.ri);
                        r.ri.vsub(bi.position, r.ri);
                        v3pool.release(penetrationVec2);
                        v3pool.release(penetrationSpherePoint);
                        this.result.push(r);
                        this.createFrictionEquationsFromContact(r, this.frictionResult);
                        // Release world vertices
                        for (var j = 0, Nfaceverts = faceVerts.length; j !== Nfaceverts; j++) {
                            v3pool.release(faceVerts[j]);
                        }
                        return; // We only expect *one* face contact
                    }
                    else {
                        // Edge?
                        for (var j = 0; j !== face.length; j++) {
                            // Get two world transformed vertices
                            var v1 = v3pool.get();
                            var v2 = v3pool.get();
                            qj.vmult(verts[face[(j + 1) % face.length]], v1);
                            qj.vmult(verts[face[(j + 2) % face.length]], v2);
                            xj.vadd(v1, v1);
                            xj.vadd(v2, v2);
                            // Construct edge vector
                            var edge = sphereConvex_edge;
                            v2.vsub(v1, edge);
                            // Construct the same vector, but normalized
                            var edgeUnit = sphereConvex_edgeUnit;
                            edge.unit(edgeUnit);
                            // p is xi projected onto the edge
                            var p = v3pool.get();
                            var v1_to_xi = v3pool.get();
                            xi.vsub(v1, v1_to_xi);
                            var dot = v1_to_xi.dot(edgeUnit);
                            edgeUnit.mult(dot, p);
                            p.vadd(v1, p);
                            // Compute a vector from p to the center of the sphere
                            var xi_to_p = v3pool.get();
                            p.vsub(xi, xi_to_p);
                            // Collision if the edge-sphere distance is less than the radius
                            // AND if p is in between v1 and v2
                            if (dot > 0 && dot * dot < edge.norm2() && xi_to_p.norm2() < R * R) { // Collision if the edge-sphere distance is less than the radius
                                // Edge contact!
                                if (justTest) {
                                    return true;
                                }
                                var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
                                p.vsub(xj, r.rj);
                                p.vsub(xi, r.ni);
                                r.ni.normalize();
                                r.ni.mult(R, r.ri);
                                // Should be relative to the body.
                                r.rj.vadd(xj, r.rj);
                                r.rj.vsub(bj.position, r.rj);
                                // Should be relative to the body.
                                r.ri.vadd(xi, r.ri);
                                r.ri.vsub(bi.position, r.ri);
                                this.result.push(r);
                                this.createFrictionEquationsFromContact(r, this.frictionResult);
                                // Release world vertices
                                for (var j = 0, Nfaceverts = faceVerts.length; j !== Nfaceverts; j++) {
                                    v3pool.release(faceVerts[j]);
                                }
                                v3pool.release(v1);
                                v3pool.release(v2);
                                v3pool.release(p);
                                v3pool.release(xi_to_p);
                                v3pool.release(v1_to_xi);
                                return;
                            }
                            v3pool.release(v1);
                            v3pool.release(v2);
                            v3pool.release(p);
                            v3pool.release(xi_to_p);
                            v3pool.release(v1_to_xi);
                        }
                    }
                    // Release world vertices
                    for (var j = 0, Nfaceverts = faceVerts.length; j !== Nfaceverts; j++) {
                        v3pool.release(faceVerts[j]);
                    }
                }
            }
        };
        Narrowphase.prototype.planeBox = function (si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
            sj.convexPolyhedronRepresentation.material = sj.material;
            sj.convexPolyhedronRepresentation.collisionResponse = sj.collisionResponse;
            sj.convexPolyhedronRepresentation.id = sj.id;
            return this.planeConvex(si, sj.convexPolyhedronRepresentation, xi, xj, qi, qj, bi, bj, si, sj, justTest);
        };
        Narrowphase.prototype.planeConvex = function (planeShape, convexShape, planePosition, convexPosition, planeQuat, convexQuat, planeBody, convexBody, si, sj, justTest) {
            // Simply return the points behind the plane.
            var worldVertex = planeConvex_v, worldNormal = planeConvex_normal;
            worldNormal.copy(CANNON.World.worldNormal);
            planeQuat.vmult(worldNormal, worldNormal); // Turn normal according to plane orientation
            var numContacts = 0;
            var relpos = planeConvex_relpos;
            for (var i = 0; i !== convexShape.vertices.length; i++) {
                // Get world convex vertex
                worldVertex.copy(convexShape.vertices[i]);
                convexQuat.vmult(worldVertex, worldVertex);
                convexPosition.vadd(worldVertex, worldVertex);
                worldVertex.vsub(planePosition, relpos);
                var dot = worldNormal.dot(relpos);
                if (dot <= 0.0) {
                    if (justTest) {
                        return true;
                    }
                    var r = this.createContactEquation(planeBody, convexBody, planeShape, convexShape, si, sj);
                    // Get vertex position projected on plane
                    var projected = planeConvex_projected;
                    worldNormal.mult(worldNormal.dot(relpos), projected);
                    worldVertex.vsub(projected, projected);
                    projected.vsub(planePosition, r.ri); // From plane to vertex projected on plane
                    r.ni.copy(worldNormal); // Contact normal is the plane normal out from plane
                    // rj is now just the vector from the convex center to the vertex
                    worldVertex.vsub(convexPosition, r.rj);
                    // Make it relative to the body
                    r.ri.vadd(planePosition, r.ri);
                    r.ri.vsub(planeBody.position, r.ri);
                    r.rj.vadd(convexPosition, r.rj);
                    r.rj.vsub(convexBody.position, r.rj);
                    this.result.push(r);
                    numContacts++;
                    if (!this.enableFrictionReduction) {
                        this.createFrictionEquationsFromContact(r, this.frictionResult);
                    }
                }
            }
            if (this.enableFrictionReduction && numContacts) {
                this.createFrictionFromAverage(numContacts);
            }
        };
        Narrowphase.prototype.convexConvex = function (si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest, faceListA, faceListB) {
            var sepAxis = convexConvex_sepAxis;
            if (xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius) {
                return;
            }
            if (si.findSeparatingAxis(sj, xi, qi, xj, qj, sepAxis, faceListA, faceListB)) {
                var res = [];
                var q = convexConvex_q;
                si.clipAgainstHull(xi, qi, sj, xj, qj, sepAxis, -100, 100, res);
                var numContacts = 0;
                for (var j = 0; j !== res.length; j++) {
                    if (justTest) {
                        return true;
                    }
                    var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj), ri = r.ri, rj = r.rj;
                    sepAxis.negate(r.ni);
                    res[j].normal.negate(q);
                    q.mult(res[j].depth, q);
                    res[j].point.vadd(q, ri);
                    rj.copy(res[j].point);
                    // Contact points are in world coordinates. Transform back to relative
                    ri.vsub(xi, ri);
                    rj.vsub(xj, rj);
                    // Make relative to bodies
                    ri.vadd(xi, ri);
                    ri.vsub(bi.position, ri);
                    rj.vadd(xj, rj);
                    rj.vsub(bj.position, rj);
                    this.result.push(r);
                    numContacts++;
                    if (!this.enableFrictionReduction) {
                        this.createFrictionEquationsFromContact(r, this.frictionResult);
                    }
                }
                if (this.enableFrictionReduction && numContacts) {
                    this.createFrictionFromAverage(numContacts);
                }
            }
        };
        /**
         * @method convexTrimesh
         * @param  {Array}      result
         * @param  {Shape}      si
         * @param  {Shape}      sj
         * @param  {Vec3}       xi
         * @param  {Vec3}       xj
         * @param  {Quaternion} qi
         * @param  {Quaternion} qj
         * @param  {Body}       bi
         * @param  {Body}       bj
         */
        // Narrowphase.prototype[Shape.types.CONVEXPOLYHEDRON | Shape.types.TRIMESH] =
        // Narrowphase.prototype.convexTrimesh = function(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,faceListA,faceListB){
        //     var sepAxis = convexConvex_sepAxis;
        //     if(xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius){
        //         return;
        //     }
        //     // Construct a temp hull for each triangle
        //     var hullB = new ConvexPolyhedron();
        //     hullB.faces = [[0,1,2]];
        //     var va = new Vec3();
        //     var vb = new Vec3();
        //     var vc = new Vec3();
        //     hullB.vertices = [
        //         va,
        //         vb,
        //         vc
        //     ];
        //     for (var i = 0; i < sj.indices.length / 3; i++) {
        //         var triangleNormal = new Vec3();
        //         sj.getNormal(i, triangleNormal);
        //         hullB.faceNormals = [triangleNormal];
        //         sj.getTriangleVertices(i, va, vb, vc);
        //         var d = si.testSepAxis(triangleNormal, hullB, xi, qi, xj, qj);
        //         if(!d){
        //             triangleNormal.scale(-1, triangleNormal);
        //             d = si.testSepAxis(triangleNormal, hullB, xi, qi, xj, qj);
        //             if(!d){
        //                 continue;
        //             }
        //         }
        //         var res = [];
        //         var q = convexConvex_q;
        //         si.clipAgainstHull(xi,qi,hullB,xj,qj,triangleNormal,-100,100,res);
        //         for(var j = 0; j !== res.length; j++){
        //             var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj),
        //                 ri = r.ri,
        //                 rj = r.rj;
        //             r.ni.copy(triangleNormal);
        //             r.ni.negate(r.ni);
        //             res[j].normal.negate(q);
        //             q.mult(res[j].depth, q);
        //             res[j].point.vadd(q, ri);
        //             rj.copy(res[j].point);
        //             // Contact points are in world coordinates. Transform back to relative
        //             ri.vsub(xi,ri);
        //             rj.vsub(xj,rj);
        //             // Make relative to bodies
        //             ri.vadd(xi, ri);
        //             ri.vsub(bi.position, ri);
        //             rj.vadd(xj, rj);
        //             rj.vsub(bj.position, rj);
        //             result.push(r);
        //         }
        //     }
        // };
        Narrowphase.prototype.planeParticle = function (sj, si, xj, xi, qj, qi, bj, bi, rsi, rsj, justTest) {
            var normal = particlePlane_normal;
            normal.copy(CANNON.World.worldNormal);
            bj.quaternion.vmult(normal, normal); // Turn normal according to plane orientation
            var relpos = particlePlane_relpos;
            xi.vsub(bj.position, relpos);
            var dot = normal.dot(relpos);
            if (dot <= 0.0) {
                if (justTest) {
                    return true;
                }
                var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
                r.ni.copy(normal); // Contact normal is the plane normal
                r.ni.negate(r.ni);
                r.ri.set(0, 0, 0); // Center of particle
                // Get particle position projected on plane
                var projected = particlePlane_projected;
                normal.mult(normal.dot(xi), projected);
                xi.vsub(projected, projected);
                //projected.vadd(bj.position,projected);
                // rj is now the projected world position minus plane position
                r.rj.copy(projected);
                this.result.push(r);
                this.createFrictionEquationsFromContact(r, this.frictionResult);
            }
        };
        Narrowphase.prototype.sphereParticle = function (sj, si, xj, xi, qj, qi, bj, bi, rsi, rsj, justTest) {
            // The normal is the unit vector from sphere center to particle center
            var normal = particleSphere_normal;
            normal.copy(CANNON.World.worldNormal);
            xi.vsub(xj, normal);
            var lengthSquared = normal.norm2();
            if (lengthSquared <= sj.radius * sj.radius) {
                if (justTest) {
                    return true;
                }
                var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
                normal.normalize();
                r.rj.copy(normal);
                r.rj.mult(sj.radius, r.rj);
                r.ni.copy(normal); // Contact normal
                r.ni.negate(r.ni);
                r.ri.set(0, 0, 0); // Center of particle
                this.result.push(r);
                this.createFrictionEquationsFromContact(r, this.frictionResult);
            }
        };
        Narrowphase.prototype.convexParticle = function (sj, si, xj, xi, qj, qi, bj, bi, rsi, rsj, justTest) {
            var penetratedFaceIndex = -1;
            var penetratedFaceNormal = convexParticle_penetratedFaceNormal;
            var worldPenetrationVec = convexParticle_worldPenetrationVec;
            var minPenetration = null;
            var numDetectedFaces = 0;
            // Convert particle position xi to local coords in the convex
            var local = convexParticle_local;
            local.copy(xi);
            local.vsub(xj, local); // Convert position to relative the convex origin
            qj.conjugate(cqj);
            cqj.vmult(local, local);
            if (sj.pointIsInside(local)) {
                if (sj.worldVerticesNeedsUpdate) {
                    sj.computeWorldVertices(xj, qj);
                }
                if (sj.worldFaceNormalsNeedsUpdate) {
                    sj.computeWorldFaceNormals(qj);
                }
                // For each world polygon in the polyhedra
                for (var i = 0, nfaces = sj.faces.length; i !== nfaces; i++) {
                    // Construct world face vertices
                    var verts = [sj.worldVertices[sj.faces[i][0]]];
                    var normal = sj.worldFaceNormals[i];
                    // Check how much the particle penetrates the polygon plane.
                    xi.vsub(verts[0], convexParticle_vertexToParticle);
                    var penetration = -normal.dot(convexParticle_vertexToParticle);
                    if (minPenetration === null || Math.abs(penetration) < Math.abs(minPenetration)) {
                        if (justTest) {
                            return true;
                        }
                        minPenetration = penetration;
                        penetratedFaceIndex = i;
                        penetratedFaceNormal.copy(normal);
                        numDetectedFaces++;
                    }
                }
                if (penetratedFaceIndex !== -1) {
                    // Setup contact
                    var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
                    penetratedFaceNormal.mult(minPenetration, worldPenetrationVec);
                    // rj is the particle position projected to the face
                    worldPenetrationVec.vadd(xi, worldPenetrationVec);
                    worldPenetrationVec.vsub(xj, worldPenetrationVec);
                    r.rj.copy(worldPenetrationVec);
                    //var projectedToFace = xi.vsub(xj).vadd(worldPenetrationVec);
                    //projectedToFace.copy(r.rj);
                    //qj.vmult(r.rj,r.rj);
                    penetratedFaceNormal.negate(r.ni); // Contact normal
                    r.ri.set(0, 0, 0); // Center of particle
                    var ri = r.ri, rj = r.rj;
                    // Make relative to bodies
                    ri.vadd(xi, ri);
                    ri.vsub(bi.position, ri);
                    rj.vadd(xj, rj);
                    rj.vsub(bj.position, rj);
                    this.result.push(r);
                    this.createFrictionEquationsFromContact(r, this.frictionResult);
                }
                else {
                    console.warn("Point found inside convex, but did not find penetrating face!");
                }
            }
        };
        Narrowphase.prototype.boxHeightfield = function (si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
            si.convexPolyhedronRepresentation.material = si.material;
            si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
            return this.convexHeightfield(si.convexPolyhedronRepresentation, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest);
        };
        Narrowphase.prototype.convexHeightfield = function (convexShape, hfShape, convexPos, hfPos, convexQuat, hfQuat, convexBody, hfBody, rsi, rsj, justTest) {
            var data = hfShape.data, w = hfShape.elementSize, radius = convexShape.boundingSphereRadius, worldPillarOffset = convexHeightfield_tmp2, faceList = convexHeightfield_faceList;
            // Get sphere position to heightfield local!
            var localConvexPos = convexHeightfield_tmp1;
            CANNON.Transform.pointToLocalFrame(hfPos, hfQuat, convexPos, localConvexPos);
            // Get the index of the data points to test against
            var iMinX = Math.floor((localConvexPos.x - radius) / w) - 1, iMaxX = Math.ceil((localConvexPos.x + radius) / w) + 1, iMinY = Math.floor((localConvexPos.y - radius) / w) - 1, iMaxY = Math.ceil((localConvexPos.y + radius) / w) + 1;
            // Bail out if we are out of the terrain
            if (iMaxX < 0 || iMaxY < 0 || iMinX > data.length || iMinY > data[0].length) {
                return;
            }
            // Clamp index to edges
            if (iMinX < 0) {
                iMinX = 0;
            }
            if (iMaxX < 0) {
                iMaxX = 0;
            }
            if (iMinY < 0) {
                iMinY = 0;
            }
            if (iMaxY < 0) {
                iMaxY = 0;
            }
            if (iMinX >= data.length) {
                iMinX = data.length - 1;
            }
            if (iMaxX >= data.length) {
                iMaxX = data.length - 1;
            }
            if (iMaxY >= data[0].length) {
                iMaxY = data[0].length - 1;
            }
            if (iMinY >= data[0].length) {
                iMinY = data[0].length - 1;
            }
            var minMax = [];
            hfShape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);
            var min = minMax[0];
            var max = minMax[1];
            // Bail out if we're cant touch the bounding height box
            if (localConvexPos.z - radius > max || localConvexPos.z + radius < min) {
                return;
            }
            for (var i = iMinX; i < iMaxX; i++) {
                for (var j = iMinY; j < iMaxY; j++) {
                    var intersecting = false;
                    // Lower triangle
                    hfShape.getConvexTrianglePillar(i, j, false);
                    CANNON.Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);
                    if (convexPos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + convexShape.boundingSphereRadius) {
                        intersecting = this.convexConvex(convexShape, hfShape.pillarConvex, convexPos, worldPillarOffset, convexQuat, hfQuat, convexBody, hfBody, null, null, justTest, faceList, null);
                    }
                    if (justTest && intersecting) {
                        return true;
                    }
                    // Upper triangle
                    hfShape.getConvexTrianglePillar(i, j, true);
                    CANNON.Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);
                    if (convexPos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + convexShape.boundingSphereRadius) {
                        intersecting = this.convexConvex(convexShape, hfShape.pillarConvex, convexPos, worldPillarOffset, convexQuat, hfQuat, convexBody, hfBody, null, null, justTest, faceList, null);
                    }
                    if (justTest && intersecting) {
                        return true;
                    }
                }
            }
        };
        ;
        Narrowphase.prototype.sphereHeightfield = function (sphereShape, hfShape, spherePos, hfPos, sphereQuat, hfQuat, sphereBody, hfBody, rsi, rsj, justTest) {
            var data = hfShape.data, radius = sphereShape.radius, w = hfShape.elementSize, worldPillarOffset = sphereHeightfield_tmp2;
            // Get sphere position to heightfield local!
            var localSpherePos = sphereHeightfield_tmp1;
            CANNON.Transform.pointToLocalFrame(hfPos, hfQuat, spherePos, localSpherePos);
            // Get the index of the data points to test against
            var iMinX = Math.floor((localSpherePos.x - radius) / w) - 1, iMaxX = Math.ceil((localSpherePos.x + radius) / w) + 1, iMinY = Math.floor((localSpherePos.y - radius) / w) - 1, iMaxY = Math.ceil((localSpherePos.y + radius) / w) + 1;
            // Bail out if we are out of the terrain
            if (iMaxX < 0 || iMaxY < 0 || iMinX > data.length || iMaxY > data[0].length) {
                return;
            }
            // Clamp index to edges
            if (iMinX < 0) {
                iMinX = 0;
            }
            if (iMaxX < 0) {
                iMaxX = 0;
            }
            if (iMinY < 0) {
                iMinY = 0;
            }
            if (iMaxY < 0) {
                iMaxY = 0;
            }
            if (iMinX >= data.length) {
                iMinX = data.length - 1;
            }
            if (iMaxX >= data.length) {
                iMaxX = data.length - 1;
            }
            if (iMaxY >= data[0].length) {
                iMaxY = data[0].length - 1;
            }
            if (iMinY >= data[0].length) {
                iMinY = data[0].length - 1;
            }
            var minMax = [];
            hfShape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);
            var min = minMax[0];
            var max = minMax[1];
            // Bail out if we're cant touch the bounding height box
            if (localSpherePos.z - radius > max || localSpherePos.z + radius < min) {
                return;
            }
            var result = this.result;
            for (var i = iMinX; i < iMaxX; i++) {
                for (var j = iMinY; j < iMaxY; j++) {
                    var numContactsBefore = result.length;
                    var intersecting = false;
                    // Lower triangle
                    hfShape.getConvexTrianglePillar(i, j, false);
                    CANNON.Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);
                    if (spherePos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + sphereShape.boundingSphereRadius) {
                        intersecting = this.sphereConvex(sphereShape, hfShape.pillarConvex, spherePos, worldPillarOffset, sphereQuat, hfQuat, sphereBody, hfBody, sphereShape, hfShape, justTest);
                    }
                    if (justTest && intersecting) {
                        return true;
                    }
                    // Upper triangle
                    hfShape.getConvexTrianglePillar(i, j, true);
                    CANNON.Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);
                    if (spherePos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + sphereShape.boundingSphereRadius) {
                        intersecting = this.sphereConvex(sphereShape, hfShape.pillarConvex, spherePos, worldPillarOffset, sphereQuat, hfQuat, sphereBody, hfBody, sphereShape, hfShape, justTest);
                    }
                    if (justTest && intersecting) {
                        return true;
                    }
                    var numContacts = result.length - numContactsBefore;
                    if (numContacts > 2) {
                        return;
                    }
                    /*
                    // Skip all but 1
                    for (var k = 0; k < numContacts - 1; k++) {
                        result.pop();
                    }
                    */
                }
            }
        };
        return Narrowphase;
    }());
    CANNON.Narrowphase = Narrowphase;
    var averageNormal = new CANNON.Vec3();
    var averageContactPointA = new CANNON.Vec3();
    var averageContactPointB = new CANNON.Vec3();
    var tmpVec1 = new CANNON.Vec3();
    var tmpVec2 = new CANNON.Vec3();
    var tmpQuat1 = new CANNON.Quaternion();
    var tmpQuat2 = new CANNON.Quaternion();
    var numWarnings = 0;
    var maxWarnings = 10;
    function warn(msg) {
        if (numWarnings > maxWarnings) {
            return;
        }
        numWarnings++;
        console.warn(msg);
    }
    var planeTrimesh_normal = new CANNON.Vec3();
    var planeTrimesh_relpos = new CANNON.Vec3();
    var planeTrimesh_projected = new CANNON.Vec3();
    var sphereTrimesh_normal = new CANNON.Vec3();
    var sphereTrimesh_relpos = new CANNON.Vec3();
    var sphereTrimesh_projected = new CANNON.Vec3();
    var sphereTrimesh_v = new CANNON.Vec3();
    var sphereTrimesh_v2 = new CANNON.Vec3();
    var sphereTrimesh_edgeVertexA = new CANNON.Vec3();
    var sphereTrimesh_edgeVertexB = new CANNON.Vec3();
    var sphereTrimesh_edgeVector = new CANNON.Vec3();
    var sphereTrimesh_edgeVectorUnit = new CANNON.Vec3();
    var sphereTrimesh_localSpherePos = new CANNON.Vec3();
    var sphereTrimesh_tmp = new CANNON.Vec3();
    var sphereTrimesh_va = new CANNON.Vec3();
    var sphereTrimesh_vb = new CANNON.Vec3();
    var sphereTrimesh_vc = new CANNON.Vec3();
    var sphereTrimesh_localSphereAABB = new CANNON.AABB();
    var sphereTrimesh_triangles = [];
    var point_on_plane_to_sphere = new CANNON.Vec3();
    var plane_to_sphere_ortho = new CANNON.Vec3();
    // See http://bulletphysics.com/Bullet/BulletFull/SphereTriangleDetector_8cpp_source.html
    var pointInPolygon_edge = new CANNON.Vec3();
    var pointInPolygon_edge_x_normal = new CANNON.Vec3();
    var pointInPolygon_vtp = new CANNON.Vec3();
    function pointInPolygon(verts, normal, p) {
        var positiveResult = null;
        var N = verts.length;
        for (var i = 0; i !== N; i++) {
            var v = verts[i];
            // Get edge to the next vertex
            var edge = pointInPolygon_edge;
            verts[(i + 1) % (N)].vsub(v, edge);
            // Get cross product between polygon normal and the edge
            var edge_x_normal = pointInPolygon_edge_x_normal;
            //var edge_x_normal = new Vec3();
            edge.cross(normal, edge_x_normal);
            // Get vector between point and current vertex
            var vertex_to_p = pointInPolygon_vtp;
            p.vsub(v, vertex_to_p);
            // This dot product determines which side of the edge the point is
            var r = edge_x_normal.dot(vertex_to_p);
            // If all such dot products have same sign, we are inside the polygon.
            if (positiveResult === null || (r > 0 && positiveResult === true) || (r <= 0 && positiveResult === false)) {
                if (positiveResult === null) {
                    positiveResult = r > 0;
                }
                continue;
            }
            else {
                return false; // Encountered some other sign. Exit.
            }
        }
        // If we got here, all dot products were of the same sign.
        return true;
    }
    var box_to_sphere = new CANNON.Vec3();
    var sphereBox_ns = new CANNON.Vec3();
    var sphereBox_ns1 = new CANNON.Vec3();
    var sphereBox_ns2 = new CANNON.Vec3();
    var sphereBox_sides = [new CANNON.Vec3(), new CANNON.Vec3(), new CANNON.Vec3(), new CANNON.Vec3(), new CANNON.Vec3(), new CANNON.Vec3()];
    var sphereBox_sphere_to_corner = new CANNON.Vec3();
    var sphereBox_side_ns = new CANNON.Vec3();
    var sphereBox_side_ns1 = new CANNON.Vec3();
    var sphereBox_side_ns2 = new CANNON.Vec3();
    var convex_to_sphere = new CANNON.Vec3();
    var sphereConvex_edge = new CANNON.Vec3();
    var sphereConvex_edgeUnit = new CANNON.Vec3();
    var sphereConvex_sphereToCorner = new CANNON.Vec3();
    var sphereConvex_worldCorner = new CANNON.Vec3();
    var sphereConvex_worldNormal = new CANNON.Vec3();
    var sphereConvex_worldPoint = new CANNON.Vec3();
    var sphereConvex_worldSpherePointClosestToPlane = new CANNON.Vec3();
    var sphereConvex_penetrationVec = new CANNON.Vec3();
    var sphereConvex_sphereToWorldPoint = new CANNON.Vec3();
    var planeBox_normal = new CANNON.Vec3();
    var plane_to_corner = new CANNON.Vec3();
    var planeConvex_v = new CANNON.Vec3();
    var planeConvex_normal = new CANNON.Vec3();
    var planeConvex_relpos = new CANNON.Vec3();
    var planeConvex_projected = new CANNON.Vec3();
    var convexConvex_sepAxis = new CANNON.Vec3();
    var convexConvex_q = new CANNON.Vec3();
    var particlePlane_normal = new CANNON.Vec3();
    var particlePlane_relpos = new CANNON.Vec3();
    var particlePlane_projected = new CANNON.Vec3();
    var particleSphere_normal = new CANNON.Vec3();
    // WIP
    var cqj = new CANNON.Quaternion();
    var convexParticle_local = new CANNON.Vec3();
    var convexParticle_normal = new CANNON.Vec3();
    var convexParticle_penetratedFaceNormal = new CANNON.Vec3();
    var convexParticle_vertexToParticle = new CANNON.Vec3();
    var convexParticle_worldPenetrationVec = new CANNON.Vec3();
    var convexHeightfield_tmp1 = new CANNON.Vec3();
    var convexHeightfield_tmp2 = new CANNON.Vec3();
    var convexHeightfield_faceList = [0];
    var sphereHeightfield_tmp1 = new CANNON.Vec3();
    var sphereHeightfield_tmp2 = new CANNON.Vec3();
    Narrowphase.prototype[CANNON.Shape.types.BOX | CANNON.Shape.types.BOX] = Narrowphase.prototype.boxBox;
    Narrowphase.prototype[CANNON.Shape.types.BOX | CANNON.Shape.types.CONVEXPOLYHEDRON] = Narrowphase.prototype.boxConvex;
    Narrowphase.prototype[CANNON.Shape.types.BOX | CANNON.Shape.types.PARTICLE] = Narrowphase.prototype.boxParticle;
    Narrowphase.prototype[CANNON.Shape.types.SPHERE] = Narrowphase.prototype.sphereSphere;
    Narrowphase.prototype[CANNON.Shape.types.PLANE | CANNON.Shape.types.TRIMESH] = Narrowphase.prototype.planeTrimesh;
    Narrowphase.prototype[CANNON.Shape.types.SPHERE | CANNON.Shape.types.TRIMESH] = Narrowphase.prototype.sphereTrimesh;
    Narrowphase.prototype[CANNON.Shape.types.SPHERE | CANNON.Shape.types.PLANE] = Narrowphase.prototype.spherePlane;
    Narrowphase.prototype[CANNON.Shape.types.SPHERE | CANNON.Shape.types.BOX] = Narrowphase.prototype.sphereBox;
    Narrowphase.prototype[CANNON.Shape.types.SPHERE | CANNON.Shape.types.CONVEXPOLYHEDRON] = Narrowphase.prototype.sphereConvex;
    Narrowphase.prototype[CANNON.Shape.types.PLANE | CANNON.Shape.types.BOX] = Narrowphase.prototype.planeBox;
    Narrowphase.prototype[CANNON.Shape.types.PLANE | CANNON.Shape.types.CONVEXPOLYHEDRON] = Narrowphase.prototype.planeConvex;
    Narrowphase.prototype[CANNON.Shape.types.CONVEXPOLYHEDRON] = Narrowphase.prototype.convexConvex;
    Narrowphase.prototype[CANNON.Shape.types.PLANE | CANNON.Shape.types.PARTICLE] = Narrowphase.prototype.planeParticle;
    Narrowphase.prototype[CANNON.Shape.types.PARTICLE | CANNON.Shape.types.SPHERE] = Narrowphase.prototype.sphereParticle;
    Narrowphase.prototype[CANNON.Shape.types.PARTICLE | CANNON.Shape.types.CONVEXPOLYHEDRON] = Narrowphase.prototype.convexParticle;
    Narrowphase.prototype[CANNON.Shape.types.BOX | CANNON.Shape.types.HEIGHTFIELD] = Narrowphase.prototype.boxHeightfield;
    Narrowphase.prototype[CANNON.Shape.types.SPHERE | CANNON.Shape.types.HEIGHTFIELD] = Narrowphase.prototype.sphereHeightfield;
    Narrowphase.prototype[CANNON.Shape.types.CONVEXPOLYHEDRON | CANNON.Shape.types.HEIGHTFIELD] = Narrowphase.prototype.convexHeightfield;
})(CANNON || (CANNON = {}));
// /* global CANNON,THREE,Detector */
// namespace CANNON
// {
//     export class Demo extends EventTarget
//     {
//         addScene: (title: any, initfunc: any) => void;
//         restartCurrentScene: () => void;
//         changeScene: (n: any) => void;
//         start: () => void;
//         settings
//         bodies: any[];
//         visuals: any[];
//         world: World;
//         currentMaterial: any;
//         scene: any;
//         particleGeo: any;
//         particleMaterial: any;
//         /**
//          * Demo framework class. If you want to learn how to connect Cannon.js with Three.js, please look at the examples/ instead.
//          * @class Demo
//          * @constructor
//          * @param {Object} options
//          */
//         constructor(options)
//         {
//             super();
//             var that = this;
//             // API
//             this.addScene = addScene;
//             this.restartCurrentScene = restartCurrentScene;
//             this.changeScene = changeScene;
//             this.start = start;
//             var sceneFolder;
//             // Global settings
//             var settings = this.settings = {
//                 stepFrequency: 60,
//                 quatNormalizeSkip: 2,
//                 quatNormalizeFast: true,
//                 gx: 0,
//                 gy: 0,
//                 gz: 0,
//                 iterations: 3,
//                 tolerance: 0.0001,
//                 k: 1e6,
//                 d: 3,
//                 scene: 0,
//                 paused: false,
//                 rendermode: "solid",
//                 constraints: false,
//                 contacts: false,  // Contact points
//                 cm2contact: false, // center of mass to contact points
//                 normals: false, // contact normals
//                 axes: false, // "local" frame axes
//                 particleSize: 0.1,
//                 shadows: false,
//                 aabbs: false,
//                 profiling: false,
//                 maxSubSteps: 3
//             };
//             // Extend settings with options
//             options = options || {};
//             for (var key in options)
//             {
//                 if (key in settings)
//                 {
//                     settings[key] = options[key];
//                 }
//             }
//             if (settings.stepFrequency % 60 !== 0)
//             {
//                 throw new Error("stepFrequency must be a multiple of 60.");
//             }
//             var bodies = this.bodies = [];
//             var visuals = this.visuals = [];
//             var scenes = [];
//             var gui = null;
//             var smoothie = null;
//             var smoothieCanvas = null;
//             var scenePicker = {};
//             var three_contactpoint_geo = new feng3d.SphereGeometry();
//             three_contactpoint_geo.radius = 0.1;
//             three_contactpoint_geo.segmentsW = 6;
//             three_contactpoint_geo.segmentsH = 6;
//             var particleGeo = this.particleGeo = new feng3d.SphereGeometry();
//             particleGeo.radius = 1;
//             particleGeo.segmentsW = 16;
//             particleGeo.segmentsH = 8;
//             // Material
//             var materialColor = 0xdddddd;
//             var solidMaterial = new feng3d.Material();
//             (<feng3d.StandardUniforms>solidMaterial.uniforms).u_diffuse = new feng3d.Color4().fromUnit(materialColor);
//             //THREE.ColorUtils.adjustHSV( solidMaterial.color, 0, 0, 0.9 );
//             // var wireframeMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff, wireframe: true });
//             var wireframeMaterial = new feng3d.Material();
//             (<feng3d.StandardUniforms>wireframeMaterial.uniforms).u_diffuse = new feng3d.Color4().fromUnit(0xffffff);
//             wireframeMaterial.renderParams.renderMode = feng3d.RenderMode.LINES;
//             this.currentMaterial = solidMaterial;
//             var contactDotMaterial = new feng3d.Material();
//             (<feng3d.StandardUniforms>contactDotMaterial.uniforms).u_diffuse = new feng3d.Color4().fromUnit(0xff0000);
//             var particleMaterial = this.particleMaterial = new feng3d.Material();
//             (<feng3d.StandardUniforms>particleMaterial.uniforms).u_diffuse = new feng3d.Color4().fromUnit(0xff0000);
//             // Geometry caches
//             var contactMeshCache = new GeometryCache(function ()
//             {
//                 var go = new feng3d.GameObject();
//                 var mm = go.addComponent(feng3d.MeshModel);
//                 mm.geometry = three_contactpoint_geo;
//                 mm.material = contactDotMaterial;
//                 return go;
//             });
//             var cm2contactMeshCache = new GeometryCache(function ()
//             {
//                 var sg = new feng3d.SegmentGeometry();
//                 sg.segments = [{ start: new feng3d.Vector3(0, 0, 0), end: new feng3d.Vector3(1, 1, 1) }];
//                 var mat = new feng3d.Material();
//                 (<feng3d.StandardUniforms>mat.uniforms).u_diffuse = new feng3d.Color4().fromUnit(0xff0000);
//                 var go = new feng3d.GameObject();
//                 var mm = go.addComponent(feng3d.MeshModel);
//                 mm.geometry = sg;
//                 mm.material = mat;
//                 return go;
//             });
//             var bboxGeometry = new feng3d.CubeGeometry();
//             bboxGeometry.width = bboxGeometry.height = bboxGeometry.depth = 1;
//             var bboxMaterial = new feng3d.Material();
//             (<feng3d.StandardUniforms>bboxMaterial.uniforms).u_diffuse = new feng3d.Color4().fromUnit(materialColor);
//             bboxMaterial.renderParams.renderMode = feng3d.RenderMode.LINES;
//             var bboxMeshCache = new GeometryCache(function ()
//             {
//                 var go = new feng3d.GameObject();
//                 var mm = go.addComponent(feng3d.MeshModel);
//                 mm.geometry = bboxGeometry;
//                 mm.material = bboxMaterial;
//                 return go;
//             });
//             var distanceConstraintMeshCache = new GeometryCache(function ()
//             {
//                 var sg = new feng3d.SegmentGeometry();
//                 sg.segments = [{ start: new feng3d.Vector3(0, 0, 0), end: new feng3d.Vector3(1, 1, 1) }];
//                 var mat = new feng3d.Material();
//                 (<feng3d.StandardUniforms>mat.uniforms).u_diffuse = new feng3d.Color4().fromUnit(0xff0000);
//                 var go = new feng3d.GameObject();
//                 var mm = go.addComponent(feng3d.MeshModel);
//                 mm.geometry = sg;
//                 mm.material = mat;
//                 return go;
//             });
//             var p2pConstraintMeshCache = new GeometryCache(function ()
//             {
//                 var sg = new feng3d.SegmentGeometry();
//                 sg.segments = [{ start: new feng3d.Vector3(0, 0, 0), end: new feng3d.Vector3(1, 1, 1) }];
//                 var mat = new feng3d.Material();
//                 (<feng3d.StandardUniforms>mat.uniforms).u_diffuse = new feng3d.Color4().fromUnit(0xff0000);
//                 var go = new feng3d.GameObject();
//                 var mm = go.addComponent(feng3d.MeshModel);
//                 mm.geometry = sg;
//                 mm.material = mat;
//                 return go;
//             });
//             var normalMeshCache = new GeometryCache(function ()
//             {
//                 var sg = new feng3d.SegmentGeometry();
//                 sg.segments = [{ start: new feng3d.Vector3(0, 0, 0), end: new feng3d.Vector3(1, 1, 1) }];
//                 var mat = new feng3d.Material();
//                 (<feng3d.StandardUniforms>mat.uniforms).u_diffuse = new feng3d.Color4().fromUnit(0x00ff00);
//                 var go = new feng3d.GameObject();
//                 var mm = go.addComponent(feng3d.MeshModel);
//                 mm.geometry = sg;
//                 mm.material = mat;
//                 return go;
//             });
//             var axesMeshCache = new GeometryCache(function ()
//             {
//                 var vecs = [new feng3d.Vector3(1, 0, 0), new feng3d.Vector3(0, 1, 0), new feng3d.Vector3(0, 0, 1)]
//                 var colors = [0xff0000, 0x00ff00, 0x0000ff];
//                 var mesh = new feng3d.GameObject();
//                 for (let i = 0; i < vecs.length; i++)
//                 {
//                     var sg = new feng3d.SegmentGeometry();
//                     sg.segments = [{ start: new feng3d.Vector3(0, 0, 0), end: vecs[i] }];
//                     var mat = new feng3d.Material();
//                     (<feng3d.StandardUniforms>mat.uniforms).u_diffuse = new feng3d.Color4().fromUnit(colors[i]);
//                     var go = new feng3d.GameObject();
//                     var mm = go.addComponent(feng3d.MeshModel);
//                     mm.geometry = sg;
//                     mm.material = mat;
//                     mesh.addChild(go);
//                 }
//                 return mesh;
//             });
//             function restartGeometryCaches()
//             {
//                 contactMeshCache.restart();
//                 contactMeshCache.hideCached();
//                 cm2contactMeshCache.restart();
//                 cm2contactMeshCache.hideCached();
//                 distanceConstraintMeshCache.restart();
//                 distanceConstraintMeshCache.hideCached();
//                 normalMeshCache.restart();
//                 normalMeshCache.hideCached();
//             }
//             // Create physics world
//             var world = this.world = new CANNON.World();
//             world.broadphase = new CANNON.NaiveBroadphase();
//             var renderModes = ["solid", "wireframe"];
//             function updategui()
//             {
//                 if (gui)
//                 {
//                     // First level
//                     var c = gui.__controllers;
//                     Object.keys(c).forEach(i =>
//                     {
//                         c[i].updateDisplay();
//                     });
//                     // Second level
//                     for (var f in gui.__folders)
//                     {
//                         var c = gui.__folders[f].__controllers;
//                         Object.keys(c).forEach(i =>
//                         {
//                             c[i].updateDisplay();
//                         });
//                     }
//                 }
//             }
//             var light, scene, ambient, stats, info;
//             function setRenderMode(mode)
//             {
//                 if (renderModes.indexOf(mode) === -1)
//                 {
//                     throw new Error("Render mode " + mode + " not found!");
//                 }
//                 switch (mode)
//                 {
//                     case "solid":
//                         that.currentMaterial = solidMaterial;
//                         light.intensity = 1;
//                         ambient.color.setHex(0x222222);
//                         break;
//                     case "wireframe":
//                         that.currentMaterial = wireframeMaterial;
//                         light.intensity = 0;
//                         ambient.color.setHex(0xffffff);
//                         break;
//                 }
//                 function setMaterial(node, mat)
//                 {
//                     if (node.material)
//                     {
//                         node.material = mat;
//                     }
//                     for (var i = 0; i < node.children.length; i++)
//                     {
//                         setMaterial(node.children[i], mat);
//                     }
//                 }
//                 for (var i = 0; i < visuals.length; i++)
//                 {
//                     setMaterial(visuals[i], that.currentMaterial);
//                 }
//                 settings.rendermode = mode;
//             }
//             /**
//              * Add a scene to the demo app
//              * @method addScene
//              * @param {String} title Title of the scene
//              * @param {Function} initfunc A function that takes one argument, app, and initializes a physics scene. The function runs app.setWorld(body), app.addVisual(body), app.removeVisual(body) etc.
//              */
//             function addScene(title, initfunc)
//             {
//                 if (typeof (title) !== "string")
//                 {
//                     throw new Error("1st argument of Demo.addScene(title,initfunc) must be a string!");
//                 }
//                 if (typeof (initfunc) !== "function")
//                 {
//                     throw new Error("2nd argument of Demo.addScene(title,initfunc) must be a function!");
//                 }
//                 scenes.push(initfunc);
//                 var idx = scenes.length - 1;
//                 scenePicker[title] = function ()
//                 {
//                     changeScene(idx);
//                 };
//                 sceneFolder.add(scenePicker, title);
//             }
//             /**
//              * Restarts the current scene
//              * @method restartCurrentScene
//              */
//             function restartCurrentScene()
//             {
//                 var N = bodies.length;
//                 for (var i = 0; i < N; i++)
//                 {
//                     var b = bodies[i];
//                     b.position.copy(b.initPosition);
//                     b.velocity.copy(b.initVelocity);
//                     if (b.initAngularVelocity)
//                     {
//                         b.angularVelocity.copy(b.initAngularVelocity);
//                         b.quaternion.copy(b.initQuaternion);
//                     }
//                 }
//             }
//             function makeSureNotZero(vec)
//             {
//                 if (vec.x === 0.0)
//                 {
//                     vec.x = 1e-6;
//                 }
//                 if (vec.y === 0.0)
//                 {
//                     vec.y = 1e-6;
//                 }
//                 if (vec.z === 0.0)
//                 {
//                     vec.z = 1e-6;
//                 }
//             }
//             function updateVisuals()
//             {
//                 var N = bodies.length;
//                 // Read position data into visuals
//                 for (var i = 0; i < N; i++)
//                 {
//                     var b = bodies[i], visual = visuals[i];
//                     visual.position.copy(b.position);
//                     if (b.quaternion)
//                     {
//                         visual.quaternion.copy(b.quaternion);
//                     }
//                 }
//                 // Render contacts
//                 contactMeshCache.restart();
//                 if (settings.contacts)
//                 {
//                     // if ci is even - use body i, else j
//                     for (var ci = 0; ci < world.contacts.length; ci++)
//                     {
//                         for (var ij = 0; ij < 2; ij++)
//                         {
//                             var mesh = contactMeshCache.request(),
//                                 c = world.contacts[ci],
//                                 b = ij === 0 ? c.bi : c.bj,
//                                 r = ij === 0 ? c.ri : c.rj;
//                             mesh.position.set(b.position.x + r.x, b.position.y + r.y, b.position.z + r.z);
//                         }
//                     }
//                 }
//                 contactMeshCache.hideCached();
//                 // Lines from center of mass to contact point
//                 cm2contactMeshCache.restart();
//                 if (settings.cm2contact)
//                 {
//                     for (var ci = 0; ci < world.contacts.length; ci++)
//                     {
//                         for (var ij = 0; ij < 2; ij++)
//                         {
//                             var line = cm2contactMeshCache.request(),
//                                 c = world.contacts[ci],
//                                 b = ij === 0 ? c.bi : c.bj,
//                                 r = ij === 0 ? c.ri : c.rj;
//                             line.scale.set(r.x, r.y, r.z);
//                             makeSureNotZero(line.scale);
//                             line.position.copy(b.position);
//                         }
//                     }
//                 }
//                 cm2contactMeshCache.hideCached();
//                 distanceConstraintMeshCache.restart();
//                 p2pConstraintMeshCache.restart();
//                 if (settings.constraints)
//                 {
//                     // Lines for distance constraints
//                     for (var ci = 0; ci < world.constraints.length; ci++)
//                     {
//                         var c = world.constraints[ci];
//                         if (!(c instanceof CANNON.DistanceConstraint))
//                         {
//                             continue;
//                         }
//                         var nc = c.equations.normal;
//                         var bi = nc.bi, bj = nc.bj, line = distanceConstraintMeshCache.request();
//                         var i = bi.id, j = bj.id;
//                         // Remember, bj is either a Vec3 or a Body.
//                         var v;
//                         if (bj.position)
//                         {
//                             v = bj.position;
//                         } else
//                         {
//                             v = bj;
//                         }
//                         line.scale.set(v.x - bi.position.x,
//                             v.y - bi.position.y,
//                             v.z - bi.position.z);
//                         makeSureNotZero(line.scale);
//                         line.position.copy(bi.position);
//                     }
//                     // Lines for distance constraints
//                     for (var ci = 0; ci < world.constraints.length; ci++)
//                     {
//                         var c = world.constraints[ci];
//                         if (!(c instanceof CANNON.PointToPointConstraint))
//                         {
//                             continue;
//                         }
//                         var n = c.equations.normal;
//                         var bi = n.bi, bj = n.bj, relLine1 = p2pConstraintMeshCache.request(), relLine2 = p2pConstraintMeshCache.request(), diffLine = p2pConstraintMeshCache.request();
//                         var i = bi.id, j = bj.id;
//                         relLine1.scale.set(n.ri.x, n.ri.y, n.ri.z);
//                         relLine2.scale.set(n.rj.x, n.rj.y, n.rj.z);
//                         diffLine.scale.set(-n.penetrationVec.x, -n.penetrationVec.y, -n.penetrationVec.z);
//                         makeSureNotZero(relLine1.scale);
//                         makeSureNotZero(relLine2.scale);
//                         makeSureNotZero(diffLine.scale);
//                         relLine1.position.copy(bi.position);
//                         relLine2.position.copy(bj.position);
//                         n.bj.position.vadd(n.rj, diffLine.position);
//                     }
//                 }
//                 p2pConstraintMeshCache.hideCached();
//                 distanceConstraintMeshCache.hideCached();
//                 // Normal lines
//                 normalMeshCache.restart();
//                 if (settings.normals)
//                 {
//                     for (var ci = 0; ci < world.contacts.length; ci++)
//                     {
//                         var c = world.contacts[ci];
//                         var bi = c.bi, bj = c.bj, line = normalMeshCache.request();
//                         var i = bi.id, j = bj.id;
//                         var n = c.ni;
//                         var b = bi;
//                         line.scale.set(n.x, n.y, n.z);
//                         makeSureNotZero(line.scale);
//                         line.position.copy(b.position);
//                         c.ri.vadd(line.position, line.position);
//                     }
//                 }
//                 normalMeshCache.hideCached();
//                 // Frame axes for each body
//                 axesMeshCache.restart();
//                 if (settings.axes)
//                 {
//                     for (var bi = 0; bi < bodies.length; bi++)
//                     {
//                         var b = bodies[bi], mesh = axesMeshCache.request();
//                         mesh.position.copy(b.position);
//                         if (b.quaternion)
//                         {
//                             mesh.quaternion.copy(b.quaternion);
//                         }
//                     }
//                 }
//                 axesMeshCache.hideCached();
//                 // AABBs
//                 bboxMeshCache.restart();
//                 if (settings.aabbs)
//                 {
//                     for (var i = 0; i < bodies.length; i++)
//                     {
//                         var b = bodies[i];
//                         if (b.computeAABB)
//                         {
//                             if (b.aabbNeedsUpdate)
//                             {
//                                 b.computeAABB();
//                             }
//                             // Todo: cap the infinite AABB to scene AABB, for now just dont render
//                             if (isFinite(b.aabb.lowerBound.x) &&
//                                 isFinite(b.aabb.lowerBound.y) &&
//                                 isFinite(b.aabb.lowerBound.z) &&
//                                 isFinite(b.aabb.upperBound.x) &&
//                                 isFinite(b.aabb.upperBound.y) &&
//                                 isFinite(b.aabb.upperBound.z) &&
//                                 b.aabb.lowerBound.x - b.aabb.upperBound.x != 0 &&
//                                 b.aabb.lowerBound.y - b.aabb.upperBound.y != 0 &&
//                                 b.aabb.lowerBound.z - b.aabb.upperBound.z != 0)
//                             {
//                                 var mesh = bboxMeshCache.request();
//                                 mesh.scale.set(b.aabb.lowerBound.x - b.aabb.upperBound.x,
//                                     b.aabb.lowerBound.y - b.aabb.upperBound.y,
//                                     b.aabb.lowerBound.z - b.aabb.upperBound.z);
//                                 mesh.position.set((b.aabb.lowerBound.x + b.aabb.upperBound.x) * 0.5,
//                                     (b.aabb.lowerBound.y + b.aabb.upperBound.y) * 0.5,
//                                     (b.aabb.lowerBound.z + b.aabb.upperBound.z) * 0.5);
//                             }
//                         }
//                     }
//                 }
//                 bboxMeshCache.hideCached();
//             }
//             if (!Detector.webgl)
//             {
//                 Detector.addGetWebGLMessage();
//             }
//             var SHADOW_MAP_WIDTH = 512;
//             var SHADOW_MAP_HEIGHT = 512;
//             var MARGIN = 0;
//             var SCREEN_WIDTH = window.innerWidth;
//             var SCREEN_HEIGHT = window.innerHeight - 2 * MARGIN;
//             var camera, controls, renderer;
//             var container;
//             var NEAR = 5, FAR = 2000;
//             var sceneHUD, cameraOrtho, hudMaterial;
//             var mouseX = 0, mouseY = 0;
//             var windowHalfX = window.innerWidth / 2;
//             var windowHalfY = window.innerHeight / 2;
//             init();
//             animate();
//             function init()
//             {
//                 container = document.createElement('div');
//                 document.body.appendChild(container);
//                 // Camera
//                 camera = new THREE.PerspectiveCamera(24, SCREEN_WIDTH / SCREEN_HEIGHT, NEAR, FAR);
//                 camera.up.set(0, 0, 1);
//                 camera.position.set(0, 30, 20);
//                 // SCENE
//                 scene = that.scene = new THREE.Scene();
//                 scene.fog = new THREE.Fog(0x222222, 1000, FAR);
//                 // LIGHTS
//                 ambient = new THREE.AmbientLight(0x222222);
//                 scene.add(ambient);
//                 light = new THREE.SpotLight(0xffffff);
//                 light.position.set(30, 30, 40);
//                 light.target.position.set(0, 0, 0);
//                 light.castShadow = true;
//                 light.shadow.camera.near = 10;
//                 light.shadow.camera.near = 100;//camera.far;
//                 light.shadow.camera.fov = 30;
//                 light.shadowMapBias = 0.0039;
//                 light.shadowMapDarkness = 0.5;
//                 light.shadow.mapSize.width = SHADOW_MAP_WIDTH;
//                 light.shadow.mapSize.height = SHADOW_MAP_HEIGHT;
//                 //light.shadowCameraVisible = true;
//                 scene.add(light);
//                 scene.add(camera);
//                 // RENDERER
//                 renderer = new THREE.WebGLRenderer({ clearColor: 0x000000, clearAlpha: 1, antialias: false });
//                 renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
//                 renderer.domElement.style.position = "relative";
//                 renderer.domElement.style.top = MARGIN + 'px';
//                 container.appendChild(renderer.domElement);
//                 // Add info
//                 info = document.createElement('div');
//                 info.style.position = 'absolute';
//                 info.style.top = '10px';
//                 info.style.width = '100%';
//                 info.style.textAlign = 'center';
//                 info.innerHTML = '<a href="http://github.com/schteppe/cannon.js">cannon.js</a> - javascript 3d physics';
//                 container.appendChild(info);
//                 document.addEventListener('mousemove', onDocumentMouseMove);
//                 window.addEventListener('resize', onWindowResize);
//                 renderer.setClearColor(scene.fog.color, 1);
//                 renderer.autoClear = false;
//                 renderer.shadowMap.enabled = true;
//                 renderer.shadowMapSoft = true;
//                 // Smoothie
//                 smoothieCanvas = document.createElement("canvas");
//                 smoothieCanvas.width = SCREEN_WIDTH;
//                 smoothieCanvas.height = SCREEN_HEIGHT;
//                 smoothieCanvas.style.opacity = 0.5;
//                 smoothieCanvas.style.position = 'absolute';
//                 smoothieCanvas.style.top = '0px';
//                 smoothieCanvas.style.zIndex = 90;
//                 container.appendChild(smoothieCanvas);
//                 smoothie = new SmoothieChart({
//                     labelOffsetY: 50,
//                     maxDataSetLength: 100,
//                     millisPerPixel: 2,
//                     grid: {
//                         strokeStyle: 'none',
//                         fillStyle: 'none',
//                         lineWidth: 1,
//                         millisPerLine: 250,
//                         verticalSections: 6
//                     },
//                     labels: {
//                         fillStyle: 'rgb(180, 180, 180)'
//                     }
//                 });
//                 smoothie.streamTo(smoothieCanvas);
//                 // Create time series for each profile label
//                 var lines = {};
//                 var colors = [[255, 0, 0], [0, 255, 0], [0, 0, 255], [255, 255, 0], [255, 0, 255], [0, 255, 255]];
//                 var i = 0;
//                 for (var label in world.profile)
//                 {
//                     var c = colors[i % colors.length];
//                     lines[label] = new TimeSeries({
//                         label: label,
//                         fillStyle: "rgb(" + c[0] + "," + c[1] + "," + c[2] + ")",
//                         maxDataLength: 500,
//                     });
//                     i++;
//                 }
//                 // Add a random value to each line every second
//                 world.addEventListener("postStep", function (evt)
//                 {
//                     for (var label in world.profile)
//                         lines[label].append(world.time * 1000, world.profile[label]);
//                 });
//                 // Add to SmoothieChart
//                 var i = 0;
//                 for (var label in world.profile)
//                 {
//                     var c = colors[i % colors.length];
//                     smoothie.addTimeSeries(lines[label], {
//                         strokeStyle: "rgb(" + c[0] + "," + c[1] + "," + c[2] + ")",
//                         //fillStyle:"rgba("+c[0]+","+c[1]+","+c[2]+",0.3)",
//                         lineWidth: 2
//                     });
//                     i++;
//                 }
//                 world.doProfiling = false;
//                 smoothie.stop();
//                 smoothieCanvas.style.display = "none";
//                 // STATS
//                 stats = new Stats();
//                 stats.domElement.style.position = 'absolute';
//                 stats.domElement.style.top = '0px';
//                 stats.domElement.style.zIndex = 100;
//                 container.appendChild(stats.domElement);
//                 if (window.dat != undefined)
//                 {
//                     gui = new dat.GUI();
//                     gui.domElement.parentNode.style.zIndex = 120;
//                     // Render mode
//                     var rf = gui.addFolder('Rendering');
//                     rf.add(settings, 'rendermode', { Solid: "solid", Wireframe: "wireframe" }).onChange(function (mode)
//                     {
//                         setRenderMode(mode);
//                     });
//                     rf.add(settings, 'contacts');
//                     rf.add(settings, 'cm2contact');
//                     rf.add(settings, 'normals');
//                     rf.add(settings, 'constraints');
//                     rf.add(settings, 'axes');
//                     rf.add(settings, 'particleSize').min(0).max(1).onChange(function (size)
//                     {
//                         for (var i = 0; i < visuals.length; i++)
//                         {
//                             if (bodies[i] instanceof CANNON.Particle)
//                                 visuals[i].scale.set(size, size, size);
//                         }
//                     });
//                     rf.add(settings, 'shadows').onChange(function (shadows)
//                     {
//                         if (shadows)
//                         {
//                             renderer.shadowMapAutoUpdate = true;
//                         } else
//                         {
//                             renderer.shadowMapAutoUpdate = false;
//                             renderer.clearTarget(light.shadowMap);
//                         }
//                     });
//                     rf.add(settings, 'aabbs');
//                     rf.add(settings, 'profiling').onChange(function (profiling)
//                     {
//                         if (profiling)
//                         {
//                             world.doProfiling = true;
//                             smoothie.start();
//                             smoothieCanvas.style.display = "block";
//                         } else
//                         {
//                             world.doProfiling = false;
//                             smoothie.stop();
//                             smoothieCanvas.style.display = "none";
//                         }
//                     });
//                     // World folder
//                     var wf = gui.addFolder('World');
//                     // Pause
//                     wf.add(settings, 'paused').onChange(function (p)
//                     {
//                         /*if(p){
//                             smoothie.stop();
//                         } else {
//                             smoothie.start();
//                         }*/
//                     });
//                     wf.add(settings, 'stepFrequency', 60, 60 * 10).step(60);
//                     var maxg = 100;
//                     wf.add(settings, 'gx', -maxg, maxg).onChange(function (gx)
//                     {
//                         if (!isNaN(gx))
//                         {
//                             world.gravity.set(gx, settings.gy, settings.gz);
//                         }
//                     });
//                     wf.add(settings, 'gy', -maxg, maxg).onChange(function (gy)
//                     {
//                         if (!isNaN(gy))
//                             world.gravity.set(settings.gx, gy, settings.gz);
//                     });
//                     wf.add(settings, 'gz', -maxg, maxg).onChange(function (gz)
//                     {
//                         if (!isNaN(gz))
//                             world.gravity.set(settings.gx, settings.gy, gz);
//                     });
//                     wf.add(settings, 'quatNormalizeSkip', 0, 50).step(1).onChange(function (skip)
//                     {
//                         if (!isNaN(skip))
//                         {
//                             world.quatNormalizeSkip = skip;
//                         }
//                     });
//                     wf.add(settings, 'quatNormalizeFast').onChange(function (fast)
//                     {
//                         world.quatNormalizeFast = !!fast;
//                     });
//                     // Solver folder
//                     var sf = gui.addFolder('Solver');
//                     sf.add(settings, 'iterations', 1, 50).step(1).onChange(function (it)
//                     {
//                         world.solver.iterations = it;
//                     });
//                     sf.add(settings, 'k', 10, 10000000).onChange(function (k)
//                     {
//                         that.setGlobalSpookParams(settings.k, settings.d, 1 / settings.stepFrequency);
//                     });
//                     sf.add(settings, 'd', 0, 20).step(0.1).onChange(function (d)
//                     {
//                         that.setGlobalSpookParams(settings.k, settings.d, 1 / settings.stepFrequency);
//                     });
//                     sf.add(settings, 'tolerance', 0.0, 10.0).step(0.01).onChange(function (t)
//                     {
//                         world.solver.tolerance = t;
//                     });
//                     // Scene picker
//                     sceneFolder = gui.addFolder('Scenes');
//                     sceneFolder.open();
//                 }
//                 // Trackball controls
//                 controls = new THREE.TrackballControls(camera, renderer.domElement);
//                 controls.rotateSpeed = 1.0;
//                 controls.zoomSpeed = 1.2;
//                 controls.panSpeed = 0.2;
//                 controls.noZoom = false;
//                 controls.noPan = false;
//                 controls.staticMoving = false;
//                 controls.dynamicDampingFactor = 0.3;
//                 var radius = 100;
//                 controls.minDistance = 0.0;
//                 controls.maxDistance = radius * 1000;
//                 //controls.keys = [ 65, 83, 68 ]; // [ rotateKey, zoomKey, panKey ]
//                 controls.screen.width = SCREEN_WIDTH;
//                 controls.screen.height = SCREEN_HEIGHT;
//             }
//             var t = 0, newTime, delta;
//             function animate()
//             {
//                 requestAnimationFrame(animate);
//                 if (!settings.paused)
//                 {
//                     updateVisuals();
//                     updatePhysics();
//                 }
//                 render();
//                 stats.update();
//             }
//             var lastCallTime = 0;
//             function updatePhysics()
//             {
//                 // Step world
//                 var timeStep = 1 / settings.stepFrequency;
//                 var now = Date.now() / 1000;
//                 if (!lastCallTime)
//                 {
//                     // last call time not saved, cant guess elapsed time. Take a simple step.
//                     world.step(timeStep);
//                     lastCallTime = now;
//                     return;
//                 }
//                 var timeSinceLastCall = now - lastCallTime;
//                 world.step(timeStep, timeSinceLastCall, settings.maxSubSteps);
//                 lastCallTime = now;
//             }
//             function onDocumentMouseMove(event)
//             {
//                 mouseX = (event.clientX - windowHalfX);
//                 mouseY = (event.clientY - windowHalfY);
//             }
//             function onWindowResize(event)
//             {
//                 SCREEN_WIDTH = window.innerWidth;
//                 SCREEN_HEIGHT = window.innerHeight;
//                 renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
//                 camera.aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
//                 camera.updateProjectionMatrix();
//                 controls.screen.width = SCREEN_WIDTH;
//                 controls.screen.height = SCREEN_HEIGHT;
//                 camera.radius = (SCREEN_WIDTH + SCREEN_HEIGHT) / 4;
//             }
//             function render()
//             {
//                 controls.update();
//                 renderer.clear();
//                 renderer.render(that.scene, camera);
//             }
//             document.addEventListener('keypress', function (e)
//             {
//                 if (e.keyCode)
//                 {
//                     switch (e.keyCode)
//                     {
//                         case 32: // Space - restart
//                             restartCurrentScene();
//                             break;
//                         case 104: // h - toggle widgets
//                             if (stats.domElement.style.display == "none")
//                             {
//                                 stats.domElement.style.display = "block";
//                                 info.style.display = "block";
//                             } else
//                             {
//                                 stats.domElement.style.display = "none";
//                                 info.style.display = "none";
//                             }
//                             break;
//                         case 97: // a - AABBs
//                             settings.aabbs = !settings.aabbs;
//                             updategui();
//                             break;
//                         case 99: // c - constraints
//                             settings.constraints = !settings.constraints;
//                             updategui();
//                             break;
//                         case 112: // p
//                             settings.paused = !settings.paused;
//                             updategui();
//                             break;
//                         case 115: // s
//                             var timeStep = 1 / settings.stepFrequency;
//                             world.step(timeStep);
//                             updateVisuals();
//                             break;
//                         case 109: // m - toggle materials
//                             var idx = renderModes.indexOf(settings.rendermode);
//                             idx++;
//                             idx = idx % renderModes.length; // begin at 0 if we exceeded number of modes
//                             setRenderMode(renderModes[idx]);
//                             updategui();
//                             break;
//                         case 49:
//                         case 50:
//                         case 51:
//                         case 52:
//                         case 53:
//                         case 54:
//                         case 55:
//                         case 56:
//                         case 57:
//                             // Change scene
//                             // Only for numbers 1-9 and if no input field is active
//                             if (scenes.length > e.keyCode - 49 && !document.activeElement.localName.match(/input/))
//                             {
//                                 changeScene(e.keyCode - 49);
//                             }
//                             break;
//                     }
//                 }
//             });
//             function changeScene(n)
//             {
//                 that.dispatchEvent({ type: 'destroy' });
//                 settings.paused = false;
//                 updategui();
//                 buildScene(n);
//             }
//             function start()
//             {
//                 buildScene(0);
//             }
//             function buildScene(n)
//             {
//                 // Remove current bodies and visuals
//                 var num = visuals.length;
//                 for (var i = 0; i < num; i++)
//                 {
//                     world.remove(bodies.pop());
//                     var mesh = visuals.pop();
//                     that.scene.remove(mesh);
//                 }
//                 // Remove all constraints
//                 while (world.constraints.length)
//                 {
//                     world.removeConstraint(world.constraints[0]);
//                 }
//                 // Run the user defined "build scene" function
//                 scenes[n]();
//                 // Read the newly set data to the gui
//                 settings.iterations = world.solver.iterations;
//                 settings.gx = world.gravity.x + 0.0;
//                 settings.gy = world.gravity.y + 0.0;
//                 settings.gz = world.gravity.z + 0.0;
//                 settings.quatNormalizeSkip = world.quatNormalizeSkip;
//                 settings.quatNormalizeFast = world.quatNormalizeFast;
//                 updategui();
//                 restartGeometryCaches();
//             }
//             function GeometryCache(createFunc)
//             {
//                 var that = this, geometries = [], gone = [];
//                 this.request = function ()
//                 {
//                     if (geometries.length)
//                     {
//                         geo = geometries.pop();
//                     } else
//                     {
//                         geo = createFunc();
//                     }
//                     scene.add(geo);
//                     gone.push(geo);
//                     return geo;
//                 };
//                 this.restart = function ()
//                 {
//                     while (gone.length)
//                     {
//                         geometries.push(gone.pop());
//                     }
//                 };
//                 this.hideCached = function ()
//                 {
//                     for (var i = 0; i < geometries.length; i++)
//                     {
//                         scene.remove(geometries[i]);
//                     }
//                 };
//             }
//         }
//         setGlobalSpookParams(k, d, h)
//         {
//             var world = this.world;
//             // Set for all constraints
//             for (var i = 0; i < world.constraints.length; i++)
//             {
//                 var c = world.constraints[i];
//                 for (var j = 0; j < c.equations.length; j++)
//                 {
//                     var eq = c.equations[j];
//                     eq.setSpookParams(k, d, h);
//                 }
//             }
//             // Set for all contact materals
//             for (var i = 0; i < world.contactmaterials.length; i++)
//             {
//                 var cm = world.contactmaterials[i];
//                 cm.contactEquationStiffness = k;
//                 cm.frictionEquationStiffness = k;
//                 cm.contactEquationRelaxation = d;
//                 cm.frictionEquationRelaxation = d;
//             }
//             world.defaultContactMaterial.contactEquationStiffness = k;
//             world.defaultContactMaterial.frictionEquationStiffness = k;
//             world.defaultContactMaterial.contactEquationRelaxation = d;
//             world.defaultContactMaterial.frictionEquationRelaxation = d;
//         }
//         getWorld()
//         {
//             return this.world;
//         }
//         addVisual(body)
//         {
//             var s = this.settings;
//             // What geometry should be used?
//             var mesh;
//             if (body instanceof CANNON.Body)
//             {
//                 mesh = this.shape2mesh(body);
//             }
//             if (mesh)
//             {
//                 // Add body
//                 this.bodies.push(body);
//                 this.visuals.push(mesh);
//                 body.visualref = mesh;
//                 body.visualref.visualId = this.bodies.length - 1;
//                 //mesh.useQuaternion = true;
//                 this.scene.add(mesh);
//             }
//         }
//         addVisuals(bodies)
//         {
//             for (var i = 0; i < bodies.length; i++)
//             {
//                 this.addVisual(bodies[i]);
//             }
//         }
//         removeVisual(body)
//         {
//             if (body.visualref)
//             {
//                 var bodies = this.bodies,
//                     visuals = this.visuals,
//                     old_b = [],
//                     old_v = [],
//                     n = bodies.length;
//                 for (var i = 0; i < n; i++)
//                 {
//                     old_b.unshift(bodies.pop());
//                     old_v.unshift(visuals.pop());
//                 }
//                 var id = body.visualref.visualId;
//                 for (var j = 0; j < old_b.length; j++)
//                 {
//                     if (j !== id)
//                     {
//                         var i = j > id ? j - 1 : j;
//                         bodies[i] = old_b[j];
//                         visuals[i] = old_v[j];
//                         bodies[i].visualref = old_b[j].visualref;
//                         bodies[i].visualref.visualId = i;
//                     }
//                 }
//                 body.visualref.visualId = null;
//                 this.scene.remove(body.visualref);
//                 body.visualref = null;
//             }
//         }
//         removeAllVisuals()
//         {
//             while (this.bodies.length)
//             {
//                 this.removeVisual(this.bodies[0]);
//             }
//         }
//         shape2mesh(body)
//         {
//             var wireframe = this.settings.renderMode === "wireframe";
//             var obj = new THREE.Object3D();
//             for (var l = 0; l < body.shapes.length; l++)
//             {
//                 var shape = body.shapes[l];
//                 var mesh;
//                 switch (shape.type)
//                 {
//                     case CANNON.Shape.types.SPHERE:
//                         var sphere_geometry = new THREE.SphereGeometry(shape.radius, 8, 8);
//                         mesh = new THREE.Mesh(sphere_geometry, this.currentMaterial);
//                         break;
//                     case CANNON.Shape.types.PARTICLE:
//                         mesh = new THREE.Mesh(this.particleGeo, this.particleMaterial);
//                         var s = this.settings;
//                         mesh.scale.set(s.particleSize, s.particleSize, s.particleSize);
//                         break;
//                     case CANNON.Shape.types.PLANE:
//                         var geometry = new THREE.PlaneGeometry(10, 10, 4, 4);
//                         mesh = new THREE.Object3D();
//                         var submesh = new THREE.Object3D();
//                         var ground = new THREE.Mesh(geometry, this.currentMaterial);
//                         ground.scale.set(100, 100, 100);
//                         submesh.add(ground);
//                         ground.castShadow = true;
//                         ground.receiveShadow = true;
//                         mesh.add(submesh);
//                         break;
//                     case CANNON.Shape.types.BOX:
//                         var box_geometry = new THREE.BoxGeometry(shape.halfExtents.x * 2,
//                             shape.halfExtents.y * 2,
//                             shape.halfExtents.z * 2);
//                         mesh = new THREE.Mesh(box_geometry, this.currentMaterial);
//                         break;
//                     case CANNON.Shape.types.CONVEXPOLYHEDRON:
//                         var geo = new THREE.Geometry();
//                         // Add vertices
//                         for (var i = 0; i < shape.vertices.length; i++)
//                         {
//                             var v = shape.vertices[i];
//                             geo.vertices.push(new THREE.Vector3(v.x, v.y, v.z));
//                         }
//                         for (var i = 0; i < shape.faces.length; i++)
//                         {
//                             var face = shape.faces[i];
//                             // add triangles
//                             var a = face[0];
//                             for (var j = 1; j < face.length - 1; j++)
//                             {
//                                 var b = face[j];
//                                 var c = face[j + 1];
//                                 geo.faces.push(new THREE.Face3(a, b, c));
//                             }
//                         }
//                         geo.computeBoundingSphere();
//                         geo.computeFaceNormals();
//                         mesh = new THREE.Mesh(geo, this.currentMaterial);
//                         break;
//                     case CANNON.Shape.types.HEIGHTFIELD:
//                         var geometry = new THREE.Geometry();
//                         var v0 = new CANNON.Vec3();
//                         var v1 = new CANNON.Vec3();
//                         var v2 = new CANNON.Vec3();
//                         for (var xi = 0; xi < shape.data.length - 1; xi++)
//                         {
//                             for (var yi = 0; yi < shape.data[xi].length - 1; yi++)
//                             {
//                                 for (var k = 0; k < 2; k++)
//                                 {
//                                     shape.getConvexTrianglePillar(xi, yi, k === 0);
//                                     v0.copy(shape.pillarConvex.vertices[0]);
//                                     v1.copy(shape.pillarConvex.vertices[1]);
//                                     v2.copy(shape.pillarConvex.vertices[2]);
//                                     v0.vadd(shape.pillarOffset, v0);
//                                     v1.vadd(shape.pillarOffset, v1);
//                                     v2.vadd(shape.pillarOffset, v2);
//                                     geometry.vertices.push(
//                                         new THREE.Vector3(v0.x, v0.y, v0.z),
//                                         new THREE.Vector3(v1.x, v1.y, v1.z),
//                                         new THREE.Vector3(v2.x, v2.y, v2.z)
//                                     );
//                                     var i = geometry.vertices.length - 3;
//                                     geometry.faces.push(new THREE.Face3(i, i + 1, i + 2));
//                                 }
//                             }
//                         }
//                         geometry.computeBoundingSphere();
//                         geometry.computeFaceNormals();
//                         mesh = new THREE.Mesh(geometry, this.currentMaterial);
//                         break;
//                     case CANNON.Shape.types.TRIMESH:
//                         var geometry = new THREE.Geometry();
//                         var v0 = new CANNON.Vec3();
//                         var v1 = new CANNON.Vec3();
//                         var v2 = new CANNON.Vec3();
//                         for (var i = 0; i < shape.indices.length / 3; i++)
//                         {
//                             shape.getTriangleVertices(i, v0, v1, v2);
//                             geometry.vertices.push(
//                                 new THREE.Vector3(v0.x, v0.y, v0.z),
//                                 new THREE.Vector3(v1.x, v1.y, v1.z),
//                                 new THREE.Vector3(v2.x, v2.y, v2.z)
//                             );
//                             var j = geometry.vertices.length - 3;
//                             geometry.faces.push(new THREE.Face3(j, j + 1, j + 2));
//                         }
//                         geometry.computeBoundingSphere();
//                         geometry.computeFaceNormals();
//                         mesh = new THREE.Mesh(geometry, this.currentMaterial);
//                         break;
//                     default:
//                         throw "Visual type not recognized: " + shape.type;
//                 }
//                 mesh.receiveShadow = true;
//                 mesh.castShadow = true;
//                 if (mesh.children)
//                 {
//                     for (var i = 0; i < mesh.children.length; i++)
//                     {
//                         mesh.children[i].castShadow = true;
//                         mesh.children[i].receiveShadow = true;
//                         if (mesh.children[i])
//                         {
//                             for (var j = 0; j < mesh.children[i].length; j++)
//                             {
//                                 mesh.children[i].children[j].castShadow = true;
//                                 mesh.children[i].children[j].receiveShadow = true;
//                             }
//                         }
//                     }
//                 }
//                 var o = body.shapeOffsets[l];
//                 var q = body.shapeOrientations[l];
//                 mesh.position.set(o.x, o.y, o.z);
//                 mesh.quaternion.set(q.x, q.y, q.z, q.w);
//                 obj.add(mesh);
//             }
//             return obj;
//         }
//     }
// }
var feng3d;
(function (feng3d) {
    /**
     * 刚体
     */
    var Rigidbody = /** @class */ (function (_super) {
        __extends(Rigidbody, _super);
        function Rigidbody() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.__class__ = "feng3d.Rigidbody";
            _this.runEnvironment = feng3d.RunEnvironment.feng3d;
            _this.mass = 0;
            return _this;
        }
        Rigidbody.prototype.init = function () {
            var _this = this;
            this.body = new CANNON.Body({ mass: this.mass });
            this.body.position = new CANNON.Vec3(this.transform.x, this.transform.y, this.transform.z);
            var colliders = this.gameObject.getComponents(feng3d.Collider);
            colliders.forEach(function (element) {
                _this.body.addShape(element.shape);
            });
        };
        /**
         * 每帧执行
         */
        Rigidbody.prototype.update = function (interval) {
            var scene3D = this.getComponentsInParents(feng3d.Scene3D)[0];
            if (scene3D) {
                this.transform.position = new feng3d.Vector3(this.body.position.x, this.body.position.y, this.body.position.z);
            }
        };
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], Rigidbody.prototype, "mass", void 0);
        return Rigidbody;
    }(feng3d.Behaviour));
    feng3d.Rigidbody = Rigidbody;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 碰撞体
     */
    var Collider = /** @class */ (function (_super) {
        __extends(Collider, _super);
        function Collider() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(Collider.prototype, "shape", {
            get: function () {
                return this._shape;
            },
            enumerable: true,
            configurable: true
        });
        return Collider;
    }(feng3d.Component));
    feng3d.Collider = Collider;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 长方体碰撞体
     */
    var BoxCollider = /** @class */ (function (_super) {
        __extends(BoxCollider, _super);
        function BoxCollider() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 宽度
             */
            _this.width = 1;
            /**
             * 高度
             */
            _this.height = 1;
            /**
             * 深度
             */
            _this.depth = 1;
            return _this;
        }
        BoxCollider.prototype.init = function () {
            var halfExtents = new CANNON.Vec3(this.width / 2, this.height / 2, this.depth / 2);
            this._shape = new CANNON.Box(halfExtents);
        };
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], BoxCollider.prototype, "width", void 0);
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], BoxCollider.prototype, "height", void 0);
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], BoxCollider.prototype, "depth", void 0);
        return BoxCollider;
    }(feng3d.Collider));
    feng3d.BoxCollider = BoxCollider;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 球形碰撞体
     */
    var SphereCollider = /** @class */ (function (_super) {
        __extends(SphereCollider, _super);
        function SphereCollider() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._radius = 0.5;
            return _this;
        }
        Object.defineProperty(SphereCollider.prototype, "radius", {
            /**
             * 半径
             */
            get: function () {
                return this._radius;
            },
            set: function (v) {
                this._radius = v;
                if (this._shape)
                    this._shape.radius = v;
            },
            enumerable: true,
            configurable: true
        });
        SphereCollider.prototype.init = function () {
            this._shape = new CANNON.Sphere(this._radius);
        };
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], SphereCollider.prototype, "radius", null);
        return SphereCollider;
    }(feng3d.Collider));
    feng3d.SphereCollider = SphereCollider;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 圆柱体碰撞体
     */
    var CylinderCollider = /** @class */ (function (_super) {
        __extends(CylinderCollider, _super);
        function CylinderCollider() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 顶部半径
             */
            _this.topRadius = 0.5;
            /**
             * 底部半径
             */
            _this.bottomRadius = 0.5;
            /**
             * 高度
             */
            _this.height = 2;
            /**
             * 横向分割数
             */
            _this.segmentsW = 16;
            return _this;
        }
        CylinderCollider.prototype.init = function () {
            var g = new feng3d.CylinderGeometry();
            g.topRadius = this.topRadius;
            g.bottomRadius = this.bottomRadius;
            g.height = this.height;
            g.segmentsW = this.segmentsW;
            g.updateGrometry();
            this._shape = new CANNON.Trimesh(g.positions, g.indices);
        };
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], CylinderCollider.prototype, "topRadius", void 0);
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], CylinderCollider.prototype, "bottomRadius", void 0);
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], CylinderCollider.prototype, "height", void 0);
        __decorate([
            feng3d.oav(),
            feng3d.serialize
        ], CylinderCollider.prototype, "segmentsW", void 0);
        return CylinderCollider;
    }(feng3d.Collider));
    feng3d.CylinderCollider = CylinderCollider;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 胶囊体碰撞体
     */
    var CapsuleCollider = /** @class */ (function (_super) {
        __extends(CapsuleCollider, _super);
        function CapsuleCollider() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._radius = 0.5;
            _this._height = 1;
            _this._segmentsW = 16;
            _this._segmentsH = 15;
            _this._yUp = true;
            return _this;
        }
        Object.defineProperty(CapsuleCollider.prototype, "radius", {
            /**
             * 胶囊体半径
             */
            get: function () {
                return this._radius;
            },
            set: function (v) {
                if (this._radius == v)
                    return;
                this._radius = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CapsuleCollider.prototype, "height", {
            /**
             * 胶囊体高度
             */
            get: function () {
                return this._height;
            },
            set: function (v) {
                if (this._height == v)
                    return;
                this._height = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CapsuleCollider.prototype, "segmentsW", {
            /**
             * 横向分割数
             */
            get: function () {
                return this._segmentsW;
            },
            set: function (v) {
                if (this._segmentsW == v)
                    return;
                this._segmentsW = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CapsuleCollider.prototype, "segmentsH", {
            /**
             * 纵向分割数
             */
            get: function () {
                return this._segmentsH;
            },
            set: function (v) {
                if (this._segmentsH == v)
                    return;
                this._segmentsH = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CapsuleCollider.prototype, "yUp", {
            /**
             * 正面朝向 true:Y+ false:Z+
             */
            get: function () {
                return this._yUp;
            },
            set: function (v) {
                if (this._yUp == v)
                    return;
                this._yUp = v;
                this.invalidateGeometry();
            },
            enumerable: true,
            configurable: true
        });
        CapsuleCollider.prototype.init = function () {
            this.invalidateGeometry();
        };
        CapsuleCollider.prototype.invalidateGeometry = function () {
            var g = new feng3d.CapsuleGeometry();
            g.radius = this._radius;
            g.height = this._height;
            g.segmentsW = this._segmentsW;
            g.segmentsH = this._segmentsH;
            g.yUp = this._yUp;
            g.updateGrometry();
            this._shape = new CANNON.Trimesh(g.positions, g.indices);
        };
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], CapsuleCollider.prototype, "radius", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], CapsuleCollider.prototype, "height", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], CapsuleCollider.prototype, "segmentsW", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], CapsuleCollider.prototype, "segmentsH", null);
        __decorate([
            feng3d.serialize,
            feng3d.oav()
        ], CapsuleCollider.prototype, "yUp", null);
        return CapsuleCollider;
    }(feng3d.Collider));
    feng3d.CapsuleCollider = CapsuleCollider;
})(feng3d || (feng3d = {}));
var feng3d;
(function (feng3d) {
    /**
     * 平面碰撞体
     */
    var PlaneCollider = /** @class */ (function (_super) {
        __extends(PlaneCollider, _super);
        function PlaneCollider() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        PlaneCollider.prototype.init = function () {
            this._shape = new CANNON.Plane();
        };
        return PlaneCollider;
    }(feng3d.Collider));
    feng3d.PlaneCollider = PlaneCollider;
})(feng3d || (feng3d = {}));
//# sourceMappingURL=feng3d.js.map
console.log("feng3d-0.1.3");
(function universalModuleDefinition(root, factory)
{
    if (typeof exports === 'object' && typeof module === 'object')
        module.exports = factory();
    else if (typeof define === 'function' && define.amd)
        define([], factory);
    else if (typeof exports === 'object')
        exports["feng3d"] = factory();
    else
        root["feng3d"] = factory();
    
    var globalObject = (typeof global !== 'undefined') ? global : ((typeof window !== 'undefined') ? window : this);
    globalObject["feng3d"] = factory();
})(this, function ()
{
    return feng3d;
});
